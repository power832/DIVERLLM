[
  {
    "instruction": "Check the following code for security issues.",
    "input": "void Document::ClearAXObjectCache() {\n  DCHECK_EQ(&AXObjectCacheOwner(), this);\n  if (ax_object_cache_)\n    ax_object_cache_->Dispose();\n  ax_object_cache_.Clear();\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "BGD_DECLARE(void) gdImagePolygon (gdImagePtr im, gdPointPtr p, int n, int c)\n{\n  if (!n)\n    {\n      return;\n    }\n\n\n  gdImageLine (im, p->x, p->y, p[n - 1].x, p[n - 1].y, c);\n  gdImageOpenPolygon (im, p, n, c);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool WebContentsImpl::PreHandleWheelEvent(\n    const WebKit::WebMouseWheelEvent& event) {\n#if !defined(OS_MACOSX)\n  if (delegate_ &&\n      event.wheelTicksY &&\n      (event.modifiers & WebKit::WebInputEvent::ControlKey)) {\n    delegate_->ContentsZoomChange(event.wheelTicksY > 0);\n    return true;\n  }\n#endif\n\n  return false;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void Document::NotifyLayoutTreeOfSubtreeChanges() {\n  if (!GetLayoutView()->WasNotifiedOfSubtreeChange())\n    return;\n\n  lifecycle_.AdvanceTo(DocumentLifecycle::kInLayoutSubtreeChange);\n\n  GetLayoutView()->HandleSubtreeModifications();\n  DCHECK(!GetLayoutView()->WasNotifiedOfSubtreeChange());\n\n  lifecycle_.AdvanceTo(DocumentLifecycle::kLayoutSubtreeChangeClean);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline int validate_convert_profile(struct btrfs_balance_args *bctl_arg,\n\t\tu64 allowed)\n{\n\treturn ((bctl_arg->flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t(!alloc_profile_is_valid(bctl_arg->target, 1) ||\n\t\t (bctl_arg->target & ~allowed)));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void * calloc(size_t n, size_t lb)\n{\n    if (lb && n > GC_SIZE_MAX / lb)\n      return NULL;\n#   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n        /* libpthread allocated some memory that is only pointed to by  */\n        /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "includeFile(FileInfo *nested, CharsString *includedFile,\n\t\tCharacterClass **characterClasses,\n\t\tTranslationTableCharacterAttributes *characterClassAttribute,\n\t\tshort opcodeLengths[], TranslationTableOffset *newRuleOffset,\n\t\tTranslationTableRule **newRule, RuleName **ruleNames,\n\t\tTranslationTableHeader **table) {\n\tint k;\n\tchar includeThis[MAXSTRING];\n\tchar **tableFiles;\n\tint rv;\n\tfor (k = 0; k < includedFile->length; k++)\n\t\tincludeThis[k] = (char)includedFile->chars[k];\n\tincludeThis[k] = 0;\n\ttableFiles = _lou_resolveTable(includeThis, nested->fileName);\n\tif (tableFiles == NULL) {\n\t\terrorCount++;\n\t\treturn 0;\n\t}\n\tif (tableFiles[1] != NULL) {\n\t\terrorCount++;\n\t\tfree_tablefiles(tableFiles);\n\t\t_lou_logMessage(LOG_ERROR,\n\t\t\t\t\"Table list not supported in include statement: 'include %s'\",\n\t\t\t\tincludeThis);\n\t\treturn 0;\n\t}\n\trv = compileFile(*tableFiles, characterClasses, characterClassAttribute,\n\t\t\topcodeLengths, newRuleOffset, newRule, ruleNames, table);\n\tfree_tablefiles(tableFiles);\n\treturn rv;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static struct table_device *find_table_device(struct list_head *l, dev_t dev,\n\t\t\t\t\t      fmode_t mode) {\n\tstruct table_device *td;\n\n\tlist_for_each_entry(td, l, list)\n\t\tif (td->dm_dev.bdev->bd_dev == dev && td->dm_dev.mode == mode)\n\t\t\treturn td;\n\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "CodecHandler::CodecHandler(AMediaCodec *codec) {\n    mCodec = codec;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int yurex_release(struct inode *inode, struct file *file)\n{\n\tstruct usb_yurex *dev;\n\n\tdev = file->private_data;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\t/* decrement the count on our device */\n\tkref_put(&dev->kref, yurex_delete);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "uint8_t smb2cli_session_security_mode(struct smbXcli_session *session)\n{\n\tstruct smbXcli_conn *conn = session->conn;\n\tuint8_t security_mode = 0;\n\n\tif (conn == NULL) {\n\t\treturn security_mode;\n\t}\n\n\tsecurity_mode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n        if (conn->mandatory_signing) {\n                security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n        }\n       if (session->smb2->should_sign) {\n               security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n       }\n \n        return security_mode;\n }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "char *imap_hcache_get_uid_seqset (IMAP_DATA *idata)\n{\n  char *hc_seqset, *seqset;\n\n  if (!idata->hcache)\n    return NULL;\n\n  hc_seqset = mutt_hcache_fetch_raw (idata->hcache, \"/UIDSEQSET\",\n                                     imap_hcache_keylen);\n  seqset = safe_strdup (hc_seqset);\n  mutt_hcache_free ((void **)&hc_seqset);\n  dprint (5, (debugfile, \"Retrieved /UIDSEQSET %s\\n\", NONULL (seqset)));\n\n  return seqset;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "CWD_API int virtual_chmod(const char *filename, mode_t mode TSRMLS_DC) /* {{{ */\n{\n\tcwd_state new_state;\n\tint ret;\n\n\tCWD_STATE_COPY(&new_state, &CWDG(cwd));\n\tif (virtual_file_ex(&new_state, filename, NULL, CWD_REALPATH TSRMLS_CC)) {\n\t\tCWD_STATE_FREE(&new_state);\n\t\treturn -1;\n\t}\n\n\tret = chmod(new_state.cwd, mode);\n\n\tCWD_STATE_FREE(&new_state);\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,\n                const xmlChar *URI, int line, int nsNr, int tlen) {\n    const xmlChar *name;\n\n    GROW;\n    if ((RAW != '<') || (NXT(1) != '/')) {\n\txmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);\n\treturn;\n    }\n    SKIP(2);\n\n    if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {\n        if (ctxt->input->cur[tlen] == '>') {\n\t    ctxt->input->cur += tlen + 1;\n\t    ctxt->input->col += tlen + 1;\n\t    goto done;\n\t}\n\tctxt->input->cur += tlen;\n\tctxt->input->col += tlen;\n\tname = (xmlChar*)1;\n    } else {\n\tif (prefix == NULL)\n\t    name = xmlParseNameAndCompare(ctxt, ctxt->name);\n\telse\n\t    name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);\n    }\n\n    /*\n     * We should definitely be at the ending \"S? '>'\" part\n     */\n    GROW;\n    if (ctxt->instate == XML_PARSER_EOF)\n        return;\n    SKIP_BLANKS;\n    if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {\n\txmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n    } else\n\tNEXT1;\n\n    /*\n     * [ WFC: Element Type Match ]\n     * The Name in an element's end-tag must match the element type in the\n     * start-tag.\n     *\n     */\n    if (name != (xmlChar*)1) {\n        if (name == NULL) name = BAD_CAST \"unparseable\";\n        if ((line == 0) && (ctxt->node != NULL))\n            line = ctxt->node->line;\n        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,\n\t\t     \"Opening and ending tag mismatch: %s line %d and %s\\n\",\n\t\t                ctxt->name, line, name);\n    }\n\n    /*\n     * SAX: End of Tag\n     */\ndone:\n    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&\n\t(!ctxt->disableSAX))\n\tctxt->sax->endElementNs(ctxt->userData, ctxt->name, prefix, URI);\n\n    spacePop(ctxt);\n    if (nsNr != 0)\n\tnsPop(ctxt, nsNr);\n    return;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int Item_copy_int::save_in_field(Field *field, bool no_conversions)\n{\n  return save_int_value_in_field(field, cached_value, \n                                 null_value, unsigned_flag);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "uintptr_t stack_limit() const { return stack_limit_; }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int pkey_gost_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                      size_t *key_len, const unsigned char *in, size_t in_len)\n{\n    struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx);\n    switch (gctx->cipher_nid)\n    {\n        case NID_id_Gost28147_89:\n        case NID_undef: /* FIXME */\n            return pkey_GOST_ECcp_decrypt(pctx, key, key_len, in, in_len);\n        case NID_kuznyechik_ctr:\n        case NID_magma_ctr:\n            return pkey_gost2018_decrypt(pctx, key, key_len, in, in_len);\n        default:\n      GOSTerr(GOST_F_PKEY_GOST_DECRYPT, ERR_R_INTERNAL_ERROR);\n      return -1;\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "Curves16Data* CurvesAlloc(cmsContext ContextID, int nCurves, int nElements, cmsToneCurve** G)\n{\n    int i, j;\n    Curves16Data* c16;\n\n    c16 = _cmsMallocZero(ContextID, sizeof(Curves16Data));\n    if (c16 == NULL) return NULL;\n\n    c16 ->nCurves = nCurves;\n    c16 ->nElements = nElements;\n\n    c16 ->Curves = _cmsCalloc(ContextID, nCurves, sizeof(cmsUInt16Number*));\n    if (c16 ->Curves == NULL) return NULL;\n\n    for (i=0; i < nCurves; i++) {\n \n         c16->Curves[i] = _cmsCalloc(ContextID, nElements, sizeof(cmsUInt16Number));\n \n         if (nElements == 256) {\n \n             for (j=0; j < nElements; j++) {\n\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], FROM_8_TO_16(j));\n            }\n        }\n        else {\n\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], (cmsUInt16Number) j);\n            }\n        }\n    }\n\n    return c16;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "DLLEXPORT unsigned long tjBufSizeYUV2(int width, int pad, int height,\n                                      int subsamp)\n{\n  int retval = 0, nc, i;\n\n  if (subsamp < 0 || subsamp >= NUMSUBOPT)\n    THROWG(\"tjBufSizeYUV2(): Invalid argument\");\n\n  nc = (subsamp == TJSAMP_GRAY ? 1 : 3);\n  for (i = 0; i < nc; i++) {\n    int pw = tjPlaneWidth(i, width, subsamp);\n    int stride = PAD(pw, pad);\n    int ph = tjPlaneHeight(i, height, subsamp);\n\n    if (pw < 0 || ph < 0) return -1;\n    else retval += stride * ph;\n  }\n\nbailout:\n  return retval;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "apr_status_t ap_cleanup_scoreboard(void *d)\n{\n    if (ap_scoreboard_image == NULL) {\n        return APR_SUCCESS;\n    }\n    if (scoreboard_type == SB_SHARED) {\n        ap_cleanup_shared_mem(NULL);\n    }\n    else {\n        free(ap_scoreboard_image->global);\n        free(ap_scoreboard_image);\n        ap_scoreboard_image = NULL;\n    }\n    return APR_SUCCESS;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n{\n \tstruct task_io_accounting acct = task->ioac;\n \tunsigned long flags;\n \n \tif (whole && lock_task_sighand(task, &flags)) {\n \t\tstruct task_struct *t = task;\n \n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\treturn sprintf(buffer,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void RenderView::OnFindReplyAck() {\n  if (queued_find_reply_message_.get()) {\n    Send(queued_find_reply_message_.release());\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "ModuleExport size_t RegisterARTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"ART\",\"ART\",\"PFS: 1st Publisher Clip Art\");\n  entry->decoder=(DecodeImageHandler *) ReadARTImage;\n  entry->encoder=(EncodeImageHandler *) WriteARTImage;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "Local<Array> CreateHeaders() {\n    // num_values_ is either -1 or the entry # of the last header\n    // so num_values_ == 0 means there's a single header\n    Local<Array> headers = Array::New(2 * num_values_);\n\n    for (int i = 0; i < num_values_; ++i) {\n      headers->Set(2 * i, fields_[i].ToString());\n      headers->Set(2 * i + 1, values_[i].ToString());\n    }\n\n    return headers;\n  }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void mg_ws_mask(struct mg_connection *c, size_t len) {\n  if (c->is_client && c->send.buf != NULL) {\n    size_t i;\n    uint8_t *p = c->send.buf + c->send.len - len, *mask = p - 4;\n    for (i = 0; i < len; i++) p[i] ^= mask[i & 3];\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static xmlNodePtr to_xml_gyear(encodeTypePtr type, zval *data, int style, xmlNodePtr parent TSRMLS_DC)\n{\n\treturn to_xml_datetime_ex(type, data, \"%Y\", style, parent TSRMLS_CC);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp_item_list(RList *cp_list, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\trvalue: RBinJavaObj *\n\t*/\n\tRBinJavaCPTypeObj *item = NULL;\n\tif (cp_list == NULL) {\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);\n\treturn item;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "nfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{ }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "HTMLFormElement* HTMLFormControlElement::formOwner() const {\n  return ListedElement::Form();\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void jas_matrix_asl(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\trowstep = jas_matrix_rowstep(matrix);\n\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t  rowstart += rowstep) {\n\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t  ++data) {\n\t\t\t*data <<= n;\n\t\t}\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int qemu_strtoll(const char *nptr, const char **endptr, int base,\n\n                 int64_t *result)\n\n{\n\n    char *p;\n\n    int err = 0;\n\n    if (!nptr) {\n\n        if (endptr) {\n\n            *endptr = nptr;\n\n        }\n\n        err = -EINVAL;\n\n    } else {\n\n        errno = 0;\n\n        *result = strtoll(nptr, &p, base);\n\n        err = check_strtox_error(endptr, p, errno);\n\n    }\n\n    return err;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void __destroy_context(int context_id)\n{\n\tida_free(&mmu_context_ida, context_id);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void sqlite3FreeCodecArg(void *pCodecArg) {\n  codec_ctx *ctx = (codec_ctx *) pCodecArg;\n  if(pCodecArg == NULL) return;\n  sqlcipher_codec_ctx_free(&ctx); /* wipe and free allocated memory for the context */\n  sqlcipher_deactivate(); /* cleanup related structures, OpenSSL etc, when codec is detatched */\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "gs_manager_destroy_windows (GSManager *manager)\n{\n        GdkDisplay  *display;\n        GSList      *l;\n        int          n_screens;\n        int          i;\n\n        g_return_if_fail (manager != NULL);\n        g_return_if_fail (GS_IS_MANAGER (manager));\n\n        if (manager->priv->windows == NULL) {\n                return;\n        }\n\n        display = gdk_display_get_default ();\n\n        n_screens = gdk_display_get_n_screens (display);\n\n        for (i = 0; i < n_screens; i++) {\n                g_signal_handlers_disconnect_by_func (gdk_display_get_screen (display, i),\n                                                      on_screen_monitors_changed,\n                                                      manager);\n        }\n\n        for (l = manager->priv->windows; l; l = l->next) {\n                gs_window_destroy (l->data);\n        }\n        g_slist_free (manager->priv->windows);\n        manager->priv->windows = NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void* StubGLMapBuffer(GLenum target, GLenum access) {\n  return glMapBuffer(target, access);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "look_for_existing_users_sync (GdmDisplay *self)\n{\n        GdmDisplayPrivate *priv;\n        GError *error = NULL;\n        GVariant *call_result;\n        GVariant *user_list;\n\n        priv = gdm_display_get_instance_private (self);\n        priv->accountsservice_proxy = g_dbus_proxy_new_sync (priv->connection,\n                                                             0, NULL,\n                                                             \"org.freedesktop.Accounts\",\n                                                             \"/org/freedesktop/Accounts\",\n                                                             \"org.freedesktop.Accounts\",\n                                                             NULL,\n                                                             &error);\n\n        if (!priv->accountsservice_proxy) {\n                g_critical (\"Failed to contact accountsservice: %s\", error->message);\n                goto out;\n        }\n\n        call_result = g_dbus_proxy_call_sync (priv->accountsservice_proxy,\n                                              \"ListCachedUsers\",\n                                              NULL,\n                                              0,\n                                              -1,\n                                              NULL,\n                                              &error);\n\n        if (!call_result) {\n                g_critical (\"Failed to list cached users: %s\", error->message);\n                goto out;\n        }\n\n        g_variant_get (call_result, \"(@ao)\", &user_list);\n        priv->have_existing_user_accounts = g_variant_n_children (user_list) > 0;\n        g_variant_unref (user_list);\n        g_variant_unref (call_result);\nout:\n        g_clear_error (&error);\n        return priv->accountsservice_proxy != NULL && call_result != NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void pciej_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    BusState *bus = opaque;\n\n    DeviceState *qdev, *next;\n\n    PCIDevice *dev;\n\n    int slot = ffs(val) - 1;\n\n\n\n    QLIST_FOREACH_SAFE(qdev, &bus->children, sibling, next) {\n\n        dev = DO_UPCAST(PCIDevice, qdev, qdev);\n\n        if (PCI_SLOT(dev->devfn) == slot) {\n\n            qdev_free(qdev);\n\n        }\n\n    }\n\n\n\n\n\n    PIIX4_DPRINTF(\"pciej write %x <== %d\\n\", addr, val);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "rd_contents_init(struct archive_read *a, enum enctype encoding,\n    int a_sum_alg, int e_sum_alg)\n{\n\tint r;\n\n\t/* Init decompress library. */\n\tif ((r = decompression_init(a, encoding)) != ARCHIVE_OK)\n\t\treturn (r);\n\t/* Init checksum library. */\n\tchecksum_init(a, a_sum_alg, e_sum_alg);\n\treturn (ARCHIVE_OK);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void cmd_mechanism_status(IDEState *s, uint8_t* buf)\n{\n    int max_len = ube16_to_cpu(buf + 8);\n\n    cpu_to_ube16(buf, 0);\n    /* no current LBA */\n    buf[2] = 0;\n    buf[3] = 0;\n    buf[4] = 0;\n    buf[5] = 1;\n    cpu_to_ube16(buf + 6, 0);\n    ide_atapi_cmd_reply(s, 8, max_len);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void strip_prefix(int prefix_length, const char **namep, const char **otherp)\n{\n\t/* Strip the prefix but do not molest /dev/null and absolute paths */\n\tif (*namep && **namep != '/')\n\t\t*namep += prefix_length;\n\tif (*otherp && **otherp != '/')\n\t\t*otherp += prefix_length;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "inline std::shared_ptr<Ope> oom(const std::shared_ptr<Ope> &ope) {\n  return Repetition::oom(ope);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int tclass_notify(struct sk_buff *oskb, struct nlmsghdr *n,\n\t\t\t  struct Qdisc *q, unsigned long cl, int event)\n{\n\tstruct sk_buff *skb;\n\tu32 pid = oskb ? NETLINK_CB(oskb).pid : 0;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (tc_fill_tclass(skb, q, cl, pid, n->nlmsg_seq, 0, event) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rtnetlink_send(skb, &init_net, pid, RTNLGRP_TC, n->nlmsg_flags&NLM_F_ECHO);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void FillRectangle(rfbClient* client, int x, int y, int w, int h, uint32_t colour) {\n  int i,j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n#define FILL_RECT(BPP) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n\n  switch(client->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "startParsing(XML_Parser parser)\n{\n    /* hash functions must be initialized before setContext() is called */\n    if (hash_secret_salt == 0)\n      hash_secret_salt = generate_hash_secret_salt();\n    if (ns) {\n      /* implicit context only set for root parser, since child\n         parsers (i.e. external entity parsers) will inherit it\n      */\n      return setContext(parser, implicitContext);\n    }\n    return XML_TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void TDStretch::setChannels(int numChannels)\r\n{\r\n    assert(numChannels > 0);\r\n    if (channels == numChannels) return;\r\n//    assert(numChannels == 1 || numChannels == 2);\r\n\r\n    channels = numChannels;\r\n    inputBuffer.setChannels(channels);\r\n    outputBuffer.setChannels(channels);\r\n\r\n    // re-init overlap/buffer\r\n    overlapLength=0;\r\n    setParameters(sampleRate);\r\n}\r",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (!count)\n\t\treturn 0;\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (s[count-1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int compat_sock_common_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t\t  char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk->sk_prot->compat_setsockopt != NULL)\n\t\treturn sk->sk_prot->compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t      optval, optlen);\n\treturn sk->sk_prot->setsockopt(sk, level, optname, optval, optlen);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "TIFFFlushData1(TIFF* tif)\n{\n\tif (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {\n\t\tif (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&\n\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\tTIFFReverseBits((uint8*)tif->tif_rawdata,\n\t\t\t    tif->tif_rawcc);\n \t\tif (!TIFFAppendToStrip(tif,\n \t\t    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,\n \t\t    tif->tif_rawdata, tif->tif_rawcc))\n \t\t\treturn (0);\n \t\ttif->tif_rawcc = 0;\n \t\ttif->tif_rawcp = tif->tif_rawdata;\n \t}\n\treturn (1);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int tun_peek_len(struct socket *sock)\n{\n\tstruct tun_file *tfile = container_of(sock, struct tun_file, socket);\n\tstruct tun_struct *tun;\n\tint ret = 0;\n\n\ttun = __tun_get(tfile);\n\tif (!tun)\n\t\treturn 0;\n\n\tret = skb_array_peek_len(&tfile->tx_array);\n\ttun_put(tun);\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "GF_Err fiin_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs, fiin_AddBox);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void __tg3_set_coalesce(struct tg3 *tp, struct ethtool_coalesce *ec)\n{\n\ttg3_coal_tx_init(tp, ec);\n\ttg3_coal_rx_init(tp, ec);\n\n\tif (!tg3_flag(tp, 5705_PLUS)) {\n\t\tu32 val = ec->stats_block_coalesce_usecs;\n\n\t\ttw32(HOSTCC_RXCOAL_TICK_INT, ec->rx_coalesce_usecs_irq);\n\t\ttw32(HOSTCC_TXCOAL_TICK_INT, ec->tx_coalesce_usecs_irq);\n\n\t\tif (!tp->link_up)\n\t\t\tval = 0;\n\n\t\ttw32(HOSTCC_STAT_COAL_TICKS, val);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "BGD_DECLARE(void *) gdImageBmpPtr(gdImagePtr im, int *size, int compression)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageBmpCtx(im, out, compression);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\t/* Allocate skb here so that firmware can DMA data from it */\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "rel_time_to_secs_str(wmem_allocator_t *scope, const nstime_t *rel_time)\n{\n\tgchar *buf;\n\n\tbuf=(gchar *)wmem_alloc(scope, REL_TIME_SECS_LEN);\n\n\tdisplay_signed_time(buf, REL_TIME_SECS_LEN, (gint64) rel_time->secs,\n\t\t\trel_time->nsecs, TO_STR_TIME_RES_T_NSECS);\n\treturn buf;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void CSoundFile::ResetMidiCfg()\n{\n\tmemset(&m_MidiCfg, 0, sizeof(m_MidiCfg));\n\tlstrcpy(&m_MidiCfg.szMidiGlb[MIDIOUT_START*32], \"FF\");\n\tlstrcpy(&m_MidiCfg.szMidiGlb[MIDIOUT_STOP*32], \"FC\");\n\tlstrcpy(&m_MidiCfg.szMidiGlb[MIDIOUT_NOTEON*32], \"9c n v\");\n\tlstrcpy(&m_MidiCfg.szMidiGlb[MIDIOUT_NOTEOFF*32], \"9c n 0\");\n\tlstrcpy(&m_MidiCfg.szMidiGlb[MIDIOUT_PROGRAM*32], \"Cc p\");\n\tlstrcpy(&m_MidiCfg.szMidiSFXExt[0], \"F0F000z\");\n\tfor (int iz=0; iz<16; iz++) wsprintf(&m_MidiCfg.szMidiZXXExt[iz*32], \"F0F001%02X\", iz*8);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "JPEGImageDecoder* decoder() { return m_decoder; }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)\n{\n  unsigned long int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  /* The symbols being reduced.  */\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                                              );\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "Item *Item_ref::get_tmp_table_item(THD *thd)\n{\n  if (!result_field)\n    return (*ref)->get_tmp_table_item(thd);\n\n  Item_field *item= new Item_field(result_field);\n  if (item)\n  {\n    item->table_name= table_name;\n    item->db_name= db_name;\n  }\n  return item;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void qemu_get_guest_memory_mapping(MemoryMappingList *list, Error **errp)\n\n{\n\n    CPUState *cpu, *first_paging_enabled_cpu;\n\n    RAMBlock *block;\n\n    ram_addr_t offset, length;\n\n\n\n    first_paging_enabled_cpu = find_paging_enabled_cpu(first_cpu);\n\n    if (first_paging_enabled_cpu) {\n\n        for (cpu = first_paging_enabled_cpu; cpu != NULL; cpu = cpu->next_cpu) {\n\n            Error *err = NULL;\n\n            cpu_get_memory_mapping(cpu, list, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n        }\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * If the guest doesn't use paging, the virtual address is equal to physical\n\n     * address.\n\n     */\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        offset = block->offset;\n\n        length = block->length;\n\n        create_new_memory_mapping(list, offset, offset, length);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "HandleCopySelection(Widget w,\n\t\t    XEvent *event,\n\t\t    String *params,\t/* list of targets */\n\t\t    Cardinal *num_params)\n{\n    XtermWidget xw;\n\n    if ((xw = getXtermWidget(w)) != 0) {\n\tTRACE_EVENT(\"HandleCopySelection\", event, params, num_params);\n\tSelectSet(xw, event, params, *num_params);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "inline internal::Arg BasicFormatter<Char, AF>::parse_arg_index(const Char *&s) {\n  const char *error = FMT_NULL;\n  internal::Arg arg = *s < '0' || *s > '9' ?\n        next_arg(error) : get_arg(internal::parse_nonnegative_int(s), error);\n  if (error) {\n    FMT_THROW(FormatError(\n                *s != '}' && *s != ':' ? \"invalid format string\" : error));\n  }\n  return arg;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "compat_do_ip6t_set_ctl(struct sock *sk, int cmd, void __user *user,\n\t\t       unsigned int len)\n{\n\tint ret;\n\n\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase IP6T_SO_SET_REPLACE:\n\t\tret = compat_do_replace(sock_net(sk), user, len);\n\t\tbreak;\n\n\tcase IP6T_SO_SET_ADD_COUNTERS:\n\t\tret = do_add_counters(sock_net(sk), user, len, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int lock_fb_info(struct fb_info *info)\n{\n\tmutex_lock(&info->lock);\n\tif (!info->fbops) {\n\t\tmutex_unlock(&info->lock);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int uio_fasync(int fd, struct file *filep, int on)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\n\treturn fasync_helper(fd, filep, on, &idev->async_queue);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void cache_insert(PageCache *cache, uint64_t addr, uint8_t *pdata)\n{\n    CacheItem *it = NULL;\n    g_assert(cache);\n    g_assert(cache->page_cache);\n    /* actual update of entry */\n    it = cache_get_by_addr(cache, addr);\n    if (!it->it_data) {\n        cache->num_items++;\n    }\n    it->it_data = pdata;\n    it->it_age = ++cache->max_item_age;\n    it->it_addr = addr;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "template<typename t>\n    CImg<T>& operator*=(const t value) {\n      if (is_empty()) return *this;\n      cimg_openmp_for(*this,*ptr * value,262144);\n      return *this;",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool HaarEvaluator::Feature :: read( const FileNode& node )\n{\n    FileNode rnode = node[CC_RECTS];\n    FileNodeIterator it = rnode.begin(), it_end = rnode.end();\n\n    int ri;\n    for( ri = 0; ri < RECT_NUM; ri++ )\n    {\n        rect[ri].r = Rect();\n        rect[ri].weight = 0.f;\n    }\n\n    for(ri = 0; it != it_end; ++it, ri++)\n    {\n        FileNodeIterator it2 = (*it).begin();\n        it2 >> rect[ri].r.x >> rect[ri].r.y >>\n            rect[ri].r.width >> rect[ri].r.height >> rect[ri].weight;\n    }\n\n    tilted = (int)node[CC_TILTED] != 0;\n    return true;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int sony_init_ff(struct sony_sc *sc)\n{\n\tstruct hid_input *hidinput = list_entry(sc->hdev->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *input_dev = hidinput->input;\n\n\tinput_set_capability(input_dev, EV_FF, FF_RUMBLE);\n\treturn input_ff_create_memless(input_dev, NULL, sony_play_effect);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "Image::AutoPtr ImageFactory::open(const byte* data, long size)\n    {\n        BasicIo::AutoPtr io(new MemIo(data, size));\n        Image::AutoPtr image = open(io); // may throw\n        if (image.get() == 0) throw Error(12);\n        return image;\n    }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "bool SVGElement::HasSVGParent() const {\n  return ParentOrShadowHostElement() &&\n         ParentOrShadowHostElement()->IsSVGElement();\n }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void pcmcia_socket_unregister(PCMCIASocket *socket)\n\n{\n\n    struct pcmcia_socket_entry_s *entry, **ptr;\n\n\n\n    ptr = &pcmcia_sockets;\n\n    for (entry = *ptr; entry; ptr = &entry->next, entry = *ptr)\n\n        if (entry->socket == socket) {\n\n            *ptr = entry->next;\n\n            g_free(entry);\n\n        }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void openrisc_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    OpenRISCCPU *cpu = OPENRISC_CPU(dev);\n\n    OpenRISCCPUClass *occ = OPENRISC_CPU_GET_CLASS(dev);\n\n\n\n    cpu_reset(CPU(cpu));\n\n\n\n    occ->parent_realize(dev, errp);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void Shell::OnLoginStateChanged(user::LoginStatus status) {\n  FOR_EACH_OBSERVER(ShellObserver, observers_, OnLoginStateChanged(status));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static PHP_GINIT_FUNCTION(libxml)\n{\n        libxml_globals->stream_context = NULL;\n        libxml_globals->error_buffer.c = NULL;\n        libxml_globals->error_list = NULL;\n }",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void InterstitialPage::InterstitialPageRVHViewDelegate::ShowContextMenu(\n    const ContextMenuParams& params) {\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static size_t phar_dir_write(php_stream *stream, const char *buf, size_t count TSRMLS_DC) /* {{{ */\n{\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "kick_buried_job(tube t)\n{\n    int r;\n    job j;\n    size_t z;\n\n    if (!buried_job_p(t)) return 0;\n    j = remove_buried_job(t->buried.next);\n\n    z = binlog_reserve_space_update(j);\n    if (!z) return pq_give(&t->delay, j), 0; /* put it back */\n    j->reserved_binlog_space += z;\n\n    j->kick_ct++;\n    r = enqueue_job(j, 0, 1);\n    if (r == 1) return 1;\n\n    /* ready queue is full, so bury it */\n    bury_job(j, 0);\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n \t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n \t\t\tu64 redir_content;\n \n\t\t\tASSERT(redir_index < IOAPIC_NUM_PINS);\n \n\t\t\tredir_content = ioapic->redirtbl[redir_index].bits;\n \t\t\tresult = (ioapic->ioregsel & 0x1) ?\n \t\t\t    (redir_content >> 32) & 0xffffffff :\n \t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "Eina_Bool ewk_view_setting_auto_load_images_set(Evas_Object* ewkView, Eina_Bool automatic)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    automatic = !!automatic;\n    if (priv->settings.autoLoadImages != automatic) {\n        priv->pageSettings->setLoadsImagesAutomatically(automatic);\n        priv->settings.autoLoadImages = automatic;\n    }\n    return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "**/\n    CImg<T>& load_png(const char *const filename, unsigned int *const bits_per_pixel=0) {\n      return _load_png(0,filename,bits_per_pixel);",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void XMLRPC_SetValueBoolean(XMLRPC_VALUE value, int val) {\n   if(value) {\n      value->type = xmlrpc_boolean;\n      value->i = val ? 1 : 0;\n   }\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "PHP_FUNCTION( msgfmt_parse_message )\n{\n\tUChar      *spattern = NULL;\n\tint         spattern_len = 0;\n\tchar       *pattern = NULL;\n\tsize_t      pattern_len = 0;\n\tconst char *slocale = NULL;\n\tsize_t      slocale_len = 0;\n\tchar       *source = NULL;\n\tsize_t      src_len = 0;\n\tMessageFormatter_object mf;\n\tMessageFormatter_object *mfo = &mf;\n\n\t/* Parse parameters. */\n\tif( zend_parse_parameters( ZEND_NUM_ARGS(), \"sss\",\n\t\t  &slocale, &slocale_len, &pattern, &pattern_len, &source, &src_len ) == FAILURE )\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\"msgfmt_parse_message: unable to parse input params\", 0 );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tmemset(mfo, 0, sizeof(*mfo));\n\tmsgformat_data_init(&mfo->mf_data);\n\n\tif(pattern && pattern_len) {\n\t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n\t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n\t\t{\n\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\"msgfmt_parse_message: error converting pattern to UTF-16\", 0 );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tspattern_len = 0;\n\t\tspattern = NULL;\n\t}\n\n\tif(slocale_len == 0) {\n\t\tslocale = intl_locale_get_default();\n\t}\n\n#ifdef MSG_FORMAT_QUOTE_APOS\n\tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n\t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n\t\t\t\"msgfmt_parse_message: error converting pattern to quote-friendly format\", 0 );\n\t\tRETURN_FALSE;\n\t}\n#endif\n\n\t/* Create an ICU message formatter. */\n\tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n\tif(spattern && spattern_len) {\n\t\tefree(spattern);\n\t}\n\tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n\n\tmsgfmt_do_parse(mfo, source, src_len, return_value);\n\n\t/* drop the temporary formatter */\n\tmsgformat_data_free(&mfo->mf_data);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "unix_peeraddr(VALUE sock)\n{\n    rb_io_t *fptr;\n    struct sockaddr_un addr;\n    socklen_t len = (socklen_t)sizeof addr;\n    socklen_t len0 = len;\n\n    GetOpenFile(sock, fptr);\n\n    if (getpeername(fptr->fd, (struct sockaddr*)&addr, &len) < 0)\n        rsock_sys_fail_path(\"getpeername(2)\", fptr->pathv);\n    if (len0 < len) len = len0;\n    return rsock_unixaddr(&addr, len);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void prune_one(struct audit_tree *victim)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct node *p;\n\t\tstruct audit_chunk *chunk;\n\n\t\tp = list_entry(victim->chunks.next, struct node, list);\n\t\tchunk = find_chunk(p);\n\t\tget_inotify_watch(&chunk->watch);\n\t\tspin_unlock(&hash_lock);\n\n\t\tuntag_chunk(chunk, p);\n\n\t\tput_inotify_watch(&chunk->watch);\n\t\tspin_lock(&hash_lock);\n\t}\n\tspin_unlock(&hash_lock);\n\tput_tree(victim);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "  v8::Local<v8::Promise> Invoke(v8::Isolate* isolate,\n                                gin_helper::ErrorThrower thrower,\n                                bool internal,\n                                const std::string& channel,\n                                v8::Local<v8::Value> arguments) {\n    if (!electron_browser_remote_) {\n      thrower.ThrowError(kIPCMethodCalledAfterContextReleasedError);\n      return v8::Local<v8::Promise>();\n    }\n    blink::CloneableMessage message;\n    if (!electron::SerializeV8Value(isolate, arguments, &message)) {\n      return v8::Local<v8::Promise>();\n    }\n    gin_helper::Promise<blink::CloneableMessage> p(isolate);\n    auto handle = p.GetHandle();\n\n    electron_browser_remote_->Invoke(\n        internal, channel, std::move(message),\n        base::BindOnce(\n            [](gin_helper::Promise<blink::CloneableMessage> p,\n               blink::CloneableMessage result) { p.Resolve(result); },\n            std::move(p)));\n\n    return handle;\n  }",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void BookmarksIOFunction::ShowSelectFileDialog(\n     ui::SelectFileDialog::Type type,\n     const base::FilePath& default_path) {\n   AddRef();\n\n  WebContents* web_contents = dispatcher()->delegate()->\n      GetAssociatedWebContents();\n\n  select_file_dialog_ = ui::SelectFileDialog::Create(\n      this, new ChromeSelectFilePolicy(web_contents));\n  ui::SelectFileDialog::FileTypeInfo file_type_info;\n  file_type_info.extensions.resize(1);\n  file_type_info.extensions[0].push_back(FILE_PATH_LITERAL(\"html\"));\n  if (type == ui::SelectFileDialog::SELECT_OPEN_FILE)\n    file_type_info.support_drive = true;\n  select_file_dialog_->SelectFile(type,\n                                  string16(),\n                                  default_path,\n                                  &file_type_info,\n                                  0,\n                                  FILE_PATH_LITERAL(\"\"),\n                                  NULL,\n                                  NULL);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "version(void)\n{\n\tfprintf(stderr, \"Version: %s\\n\\n\", VERSION);\n\tfprintf(stderr, \"Compiled in settings:\\n\");\n\tfprintf(stderr, \"  default config file\t\t\\\"%s\\\"\\n\", PATH_RADVD_CONF);\n\tfprintf(stderr, \"  default pidfile\t\t\\\"%s\\\"\\n\", PATH_RADVD_PID);\n\tfprintf(stderr, \"  default logfile\t\t\\\"%s\\\"\\n\", PATH_RADVD_LOG);\n\tfprintf(stderr, \"  default syslog facility\t%d\\n\", LOG_FACILITY);\n\tfprintf(stderr, \"Please send bug reports or suggestions to %s.\\n\",\n\t\tCONTACT_EMAIL);\n\n\texit(1);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static char *get_eow(char *s, char *e)\n{\n\twhile ((s < e) && *s && !isblank(*s) && (*s != '\\n'))\n\t\ts++;\n\treturn s;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void copy_video_props(AVFilterBufferRefVideoProps *dst, AVFilterBufferRefVideoProps *src) {\n\n    *dst = *src;\n\n    if (src->qp_table) {\n\n        int qsize = src->qp_table_size;\n\n        dst->qp_table = av_malloc(qsize);\n\n        memcpy(dst->qp_table, src->qp_table, qsize);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "short ByteVector::toShort(bool mostSignificantByteFirst) const\n{\n  return toNumber<unsigned short>(d->data, mostSignificantByteFirst);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void AffiliationFetcher::SetFactoryForTesting(\n    TestAffiliationFetcherFactory* factory) {\n  g_testing_factory = factory;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static uint64_t cg3_reg_read(void *opaque, hwaddr addr, unsigned size)\n\n{\n\n    CG3State *s = opaque;\n\n    int val;\n\n\n\n    switch (addr) {\n\n    case CG3_REG_BT458_ADDR:\n\n    case CG3_REG_BT458_COLMAP:\n\n        val = 0;\n\n        break;\n\n    case CG3_REG_FBC_CTRL:\n\n        val = s->regs[0];\n\n        break;\n\n    case CG3_REG_FBC_STATUS:\n\n        /* monitor ID 6, board type = 1 (color) */\n\n        val = s->regs[1] | CG3_SR_1152_900_76_B | CG3_SR_ID_COLOR;\n\n        break;\n\n    case CG3_REG_FBC_CURSTART ... CG3_REG_SIZE:\n\n        val = s->regs[addr - 0x10];\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_UNIMP,\n\n                  \"cg3: Unimplemented register read \"\n\n                  \"reg 0x%\" HWADDR_PRIx \" size 0x%x\\n\",\n\n                  addr, size);\n\n        val = 0;\n\n        break;\n\n    }\n\n    DPRINTF(\"read %02x from reg %\" HWADDR_PRIx \"\\n\", val, addr);\n\n    return val;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "ftp_putcmd(ftpbuf_t *ftp, const char *cmd, const char *args)\n{\n\tint\t\tsize;\n\tchar\t\t*data;\n\n\tif (strpbrk(cmd, \"\\r\\n\")) {\n\t\treturn 0;\n\t} \n\t/* build the output buffer */\n\tif (args && args[0]) {\n\t\t/* \"cmd args\\r\\n\\0\" */\n\t\tif (strlen(cmd) + strlen(args) + 4 > FTP_BUFSIZE) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (strpbrk(args, \"\\r\\n\")) {\n\t\t\treturn 0;\n\t\t}\n\t\tsize = slprintf(ftp->outbuf, sizeof(ftp->outbuf), \"%s %s\\r\\n\", cmd, args);\n\t} else {\n\t\t/* \"cmd\\r\\n\\0\" */\n\t\tif (strlen(cmd) + 3 > FTP_BUFSIZE) {\n\t\t\treturn 0;\n\t\t}\n\t\tsize = slprintf(ftp->outbuf, sizeof(ftp->outbuf), \"%s\\r\\n\", cmd);\n\t}\n\n\tdata = ftp->outbuf;\n\n\t/* Clear the extra-lines buffer */\n\tftp->extra = NULL;\n\n\tif (my_send(ftp, ftp->fd, data, size) != size) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void clearLoader() {\n    m_loader = nullptr;\n    m_scriptState.clear();\n  }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static av_cold int ulti_decode_init(AVCodecContext *avctx)\n\n{\n\n    UltimotionDecodeContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    s->width = avctx->width;\n\n    s->height = avctx->height;\n\n    s->blocks = (s->width / 8) * (s->height / 8);\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV410P;\n\n    s->ulti_codebook = ulti_codebook;\n\n\n\n    s->frame = av_frame_alloc();\n\n    if (!s->frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    return 0;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "GC_API void * GC_CALL GC_generic_malloc(size_t lb, int k)\n{\n    void * result;\n    DCL_LOCK_STATE;\n\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    if (SMALL_OBJ(lb)) {\n        LOCK();\n        result = GC_generic_malloc_inner((word)lb, k);\n        UNLOCK();\n    } else {\n        size_t lg;\n        size_t lb_rounded;\n        word n_blocks;\n         GC_bool init;\n         lg = ROUNDED_UP_GRANULES(lb);\n         lb_rounded = GRANULES_TO_BYTES(lg);\n         n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n         init = GC_obj_kinds[k].ok_init;\n         LOCK();\n        result = (ptr_t)GC_alloc_large(lb_rounded, k, 0);\n        if (0 != result) {\n          if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n          } else {\n#           ifdef THREADS\n              /* Clear any memory that might be used for GC descriptors */\n              /* before we release the lock.                            */\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n          }\n        }\n        GC_bytes_allocd += lb_rounded;\n        UNLOCK();\n        if (init && !GC_debugging_started && 0 != result) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n    }\n    if (0 == result) {\n        return((*GC_get_oom_fn())(lb));\n    } else {\n        return(result);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static MagickBooleanType IsVIPS(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n\n  if (memcmp(magick,\"\\010\\362\\246\\266\",4) == 0)\n    return(MagickTrue);\n\n  if (memcmp(magick,\"\\266\\246\\362\\010\",4) == 0)\n    return(MagickTrue);\n\n  return(MagickFalse);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int32_t IPCThreadState::getLastTransactionBinderFlags() const\n{\n return mLastTransactionBinderFlags;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int any_slab_objects(struct kmem_cache *s)\n{\n\tint node;\n\n\tfor_each_online_node(node) {\n\t\tstruct kmem_cache_node *n = get_node(s, node);\n\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tif (atomic_read(&n->total_objects))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void rtc_periodic_timer(void *opaque)\n\n{\n\n    RTCState *s = opaque;\n\n\n\n    rtc_timer_update(s, s->next_periodic_time);\n\n#ifdef TARGET_I386\n\n    if ((s->cmos_data[RTC_REG_C] & 0xc0) && rtc_td_hack) {\n\n        s->irq_coalesced++;\n\n        return;\n\n    }\n\n#endif\n\n    if (s->cmos_data[RTC_REG_B] & REG_B_PIE) {\n\n        s->cmos_data[RTC_REG_C] |= 0xc0;\n\n        rtc_irq_raise(s->irq);\n\n    }\n\n    if (s->cmos_data[RTC_REG_B] & REG_B_SQWE) {\n\n        /* Not square wave at all but we don't want 2048Hz interrupts!\n\n           Must be seen as a pulse.  */\n\n        qemu_irq_raise(s->sqw_irq);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int skcipher_decrypt_blkcipher(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tstruct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);\n\tstruct blkcipher_alg *alg = &tfm->__crt_alg->cra_blkcipher;\n\n\treturn skcipher_crypt_blkcipher(req, alg->decrypt);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int AVI_set_video_position(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif (frame < 0 ) frame = 0;\n\tAVI->video_pos = frame;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "svx_type_find (GstTypeFind * tf, gpointer unused)\n{\n  const guint8 *data = gst_type_find_peek (tf, 0, 4);\n\n  if (data && memcmp (data, \"FORM\", 4) == 0) {\n    data += 8;\n    if (memcmp (data, \"8SVX\", 4) == 0 || memcmp (data, \"16SV\", 4) == 0)\n      gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SVX_CAPS);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n {\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n }",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void atalk_register_sysctl(void)\n{\n\tatalk_table_header = register_net_sysctl(&init_net, \"net/appletalk\", atalk_table);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void WebContentsImpl::RenderViewForInterstitialPageCreated(\n    RenderViewHost* render_view_host) {\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    RenderViewForInterstitialPageCreated(render_view_host));\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "read_cc_bcc (compose_env_t *env)\n{\n  if (mailvar_is_true (mailvar_name_askcc))\n    compose_header_set (env, MU_HEADER_CC,\n\t\t\tml_readline_with_intr (\"Cc: \"), COMPOSE_REPLACE);\n  if (mailvar_is_true (mailvar_name_askbcc))\n    compose_header_set (env, MU_HEADER_BCC,\n\t\t\tml_readline_with_intr (\"Bcc: \"), COMPOSE_REPLACE);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "LZWStream::LZWStream(Stream *strA, int predictor, int columns, int colors,\n\t\t     int bits, int earlyA):\n    FilterStream(strA) {\n  if (predictor != 1) {\n    pred = new StreamPredictor(this, predictor, columns, colors, bits);\n    if (!pred->isOk()) {\n      delete pred;\n      pred = NULL;\n    }\n  } else {\n    pred = NULL;\n  }\n  early = earlyA;\n  eof = gFalse;\n  inputBits = 0;\n  clearTable();\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void* rfx_decoder_tile_new(void* val)\n{\n\tRFX_TILE* tile = NULL;\n\tWINPR_UNUSED(val);\n\n\tif (!(tile = (RFX_TILE*)calloc(1, sizeof(RFX_TILE))))\n\t\treturn NULL;\n\n\tif (!(tile->data = (BYTE*)_aligned_malloc(4 * 64 * 64, 16)))\n\t{\n\t\tfree(tile);\n\t\treturn NULL;\n\t}\n\n\ttile->allocated = TRUE;\n\treturn tile;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "  void SetZoomLevel(v8::Isolate* isolate, double level) {\n    content::RenderFrame* render_frame;\n    if (!MaybeGetRenderFrame(isolate, \"setZoomLevel\", &render_frame))\n      return;\n\n    mojo::AssociatedRemote<mojom::ElectronBrowser> browser_remote;\n    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(\n        &browser_remote);\n    browser_remote->SetTemporaryZoomLevel(level);\n  }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "pvscsi_reset_adapter(PVSCSIState *s)\n{\n    s->resetting++;\n    qbus_reset_all_fn(&s->bus);\n    s->resetting--;\n    pvscsi_process_completion_queue(s);\n    assert(QTAILQ_EMPTY(&s->pending_queue));\n    pvscsi_reset_state(s);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void set_up_watchdog (m48t59_t *NVRAM, uint8_t value)\n\n{\n\n    uint64_t interval; /* in 1/16 seconds */\n\n\n\n    if (NVRAM->wd_timer != NULL) {\n\n        qemu_del_timer(NVRAM->wd_timer);\n\n\tNVRAM->wd_timer = NULL;\n\n    }\n\n    NVRAM->buffer[0x1FF0] &= ~0x80;\n\n    if (value != 0) {\n\n\tinterval = (1 << (2 * (value & 0x03))) * ((value >> 2) & 0x1F);\n\n\tqemu_mod_timer(NVRAM->wd_timer, ((uint64_t)time(NULL) * 1000) +\n\n\t\t       ((interval * 1000) >> 4));\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void cJSON_InitHooks(cJSON_Hooks* hooks)\nstatic char* cJSON_strdup(const char* str)\n {",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void netlink_mm_close(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct socket *sock = file->private_data;\n\tstruct sock *sk = sock->sk;\n\n\tif (sk)\n\t\tatomic_dec(&nlk_sk(sk)->mapped);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,\n\n                              uint16_t index, uint16_t num)\n\n{\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);\n\n\n\n    if (index > VIRTIO_PCI_QUEUE_MAX) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Current code in virtio.c relies on 4K alignment. */\n\n    if (addr && (align != 4096)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!vdev) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    virtio_queue_set_addr(vdev, index, addr);\n\n    if (!addr) {\n\n        virtio_queue_set_vector(vdev, index, 0);\n\n    } else {\n\n        /* Fail if we don't have a big enough queue. */\n\n        /* TODO: Add interface to handle vring.num changing */\n\n        if (virtio_queue_get_num(vdev, index) > num) {\n\n            return -EINVAL;\n\n        }\n\n        virtio_queue_set_vector(vdev, index, index);\n\n    }\n\n    /* tell notify handler in case of config change */\n\n    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void __fastcall TSCPFileSystem::HomeDirectory()\r\n{\r\n  ExecCommand(fsHomeDirectory);\r\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "BGD_DECLARE(void) gdImageArc (gdImagePtr im, int cx, int cy, int w, int h, int s, int e,\n\t\t\t\t\t\t\t  int color)\n{\n\tgdImageFilledArc (im, cx, cy, w, h, s, e, color, gdNoFill);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void set_orig_addr(struct msghdr *m, struct tipc_msg *msg)\n{\n\tstruct sockaddr_tipc *addr = (struct sockaddr_tipc *)m->msg_name;\n\n\tif (addr) {\n\t\taddr->family = AF_TIPC;\n\t\taddr->addrtype = TIPC_ADDR_ID;\n\t\taddr->addr.id.ref = msg_origport(msg);\n\t\taddr->addr.id.node = msg_orignode(msg);\n\t\taddr->addr.name.domain = 0;\t/* could leave uninitialized */\n\t\taddr->scope = 0;\t\t/* could leave uninitialized */\n\t\tm->msg_namelen = sizeof(struct sockaddr_tipc);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "valid_entryname(const char *name)\n{\n    bool result = TRUE;\n    int ch;\n    while ((ch = UChar(*name++)) != '\\0') {\n\tif (ch <= ' ' || ch > '~' || ch == '/') {\n\t    result = FALSE;\n\t    break;\n\t}\n    }\n    return result;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "rsvg_node_path_free (RsvgNode * self)\n{\n    RsvgNodePath *path = (RsvgNodePath *) self;\n    if (path->path)\n        rsvg_cairo_path_destroy (path->path);\n    _rsvg_node_finalize (&path->super);\n    g_free (path);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "char *re_eprint(int err)\n{\n  static char epbuf[100];\n  size_t len __attribute__((unused))=\n          my_regerror(REG_ITOA|err, (my_regex_t *)NULL, epbuf, sizeof(epbuf));\n  assert(len <= sizeof(epbuf));\n  return(epbuf);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void uhci_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    UHCIPCIDeviceClass *u = container_of(k, UHCIPCIDeviceClass, parent_class);\n\n    UHCIInfo *info = data;\n\n\n\n    k->init = info->initfn ? info->initfn : usb_uhci_common_initfn;\n\n    k->exit = info->unplug ? usb_uhci_exit : NULL;\n\n    k->vendor_id = info->vendor_id;\n\n    k->device_id = info->device_id;\n\n    k->revision  = info->revision;\n\n    k->class_id  = PCI_CLASS_SERIAL_USB;\n\n\n    dc->vmsd = &vmstate_uhci;\n\n    dc->props = uhci_properties;\n\n    u->info = *info;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "CharCodeToUnicode::~CharCodeToUnicode() {\n  if (tag) {\n    delete tag;\n  }\n  gfree(map);\n  if (sMap) {\n    gfree(sMap);\n  }\n#if MULTITHREADED\n  gDestroyMutex(&mutex);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void virtio_blk_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n    dc->exit = virtio_blk_device_exit;\n\n    dc->props = virtio_blk_properties;\n\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n\n    vdc->init = virtio_blk_device_init;\n\n    vdc->get_config = virtio_blk_update_config;\n\n    vdc->set_config = virtio_blk_set_config;\n\n    vdc->get_features = virtio_blk_get_features;\n\n    vdc->set_status = virtio_blk_set_status;\n\n    vdc->reset = virtio_blk_reset;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int ASN1_template_d2i(ASN1_VALUE **pval,\n                      const unsigned char **in, long len,\n                      const ASN1_TEMPLATE *tt)\n{\n    ASN1_TLC c;\n    asn1_tlc_clear_nc(&c);\n    return asn1_template_ex_d2i(pval, in, len, tt, 0, &c);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void OmniboxViewViews::SetFocus() {\n  std::unique_ptr<ImmersiveRevealedLock> focus_reveal_lock;\n  if (location_bar_view_) {\n    focus_reveal_lock.reset(\n        BrowserView::GetBrowserViewForBrowser(location_bar_view_->browser())\n            ->immersive_mode_controller()\n            ->GetRevealedLock(ImmersiveModeController::ANIMATE_REVEAL_YES));\n  }\n\n  RequestFocus();\n  model()->SetCaretVisibility(true);\n  model()->ConsumeCtrlKey();\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "unsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (len < 5)\n\t\treturn len;\t/* call too long for patch site */\n\n\tb->opcode = 0xe9;\t/* jmp */\n\tb->delta = delta;\n\n\treturn 5;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n{\n    return core->mac[r->dh] == core->mac[r->dt];\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int fsmReadLink(const char *path,\n\t\t       char *buf, size_t bufsize, size_t *linklen)\n{\n    ssize_t llen = readlink(path, buf, bufsize - 1);\n    int rc = RPMERR_READLINK_FAILED;\n\n    if (_fsm_debug) {\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, buf, %d) %s\\n\",\n\t       __func__,\n               path, (int)(bufsize -1), (llen < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (llen >= 0) {\n\tbuf[llen] = '\\0';\n\trc = 0;\n\t*linklen = llen;\n    }\n    return rc;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int ebml_read_ascii(AVIOContext *pb, int size, char **str)\n\n{\n\n    av_free(*str);\n\n    /* EBML strings are usually not 0-terminated, so we allocate one\n\n     * byte more, read the string and NULL-terminate it ourselves. */\n\n    if (!(*str = av_malloc(size + 1)))\n\n        return AVERROR(ENOMEM);\n\n    if (avio_read(pb, (uint8_t *) *str, size) != size) {\n\n        av_freep(str);\n\n        return AVERROR(EIO);\n\n    }\n\n    (*str)[size] = '\\0';\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "xbstream_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *mystat)\n{\n\tds_file_t\t\t*file;\n\tds_stream_file_t\t*stream_file;\n\tds_stream_ctxt_t\t*stream_ctxt;\n\tds_ctxt_t\t\t*dest_ctxt;\n\txb_wstream_t\t\t*xbstream;\n\txb_wstream_file_t\t*xbstream_file;\n\n\n\txb_ad(ctxt->pipe_ctxt != NULL);\n\tdest_ctxt = ctxt->pipe_ctxt;\n\n\tstream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;\n\n\tpthread_mutex_lock(&stream_ctxt->mutex);\n\tif (stream_ctxt->dest_file == NULL) {\n\t\tstream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat);\n\t\tif (stream_ctxt->dest_file == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&stream_ctxt->mutex);\n\n\tfile = (ds_file_t *) my_malloc(sizeof(ds_file_t) +\n\t\t\t\t       sizeof(ds_stream_file_t),\n\t\t\t\t       MYF(MY_FAE));\n\tstream_file = (ds_stream_file_t *) (file + 1);\n\n\txbstream = stream_ctxt->xbstream;\n\n\txbstream_file = xb_stream_write_open(xbstream, path, mystat,\n\t\t                             stream_ctxt,\n\t\t\t\t\t     my_xbstream_write_callback);\n\n\tif (xbstream_file == NULL) {\n\t\tmsg(\"xb_stream_write_open() failed.\");\n\t\tgoto err;\n\t}\n\n\tstream_file->xbstream_file = xbstream_file;\n\tstream_file->stream_ctxt = stream_ctxt;\n\tfile->ptr = stream_file;\n\tfile->path = stream_ctxt->dest_file->path;\n\n\treturn file;\n\nerr:\n\tif (stream_ctxt->dest_file) {\n\t\tds_close(stream_ctxt->dest_file);\n\t\tstream_ctxt->dest_file = NULL;\n\t}\n\tmy_free(file);\n\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "process_cmd_authhash(const char *line)\n{\n  const char *hash_name;\n  int new_hash_id;\n\n  assert(auth_hash_id >= 0);\n  hash_name = line;\n\n  if (!*hash_name) {\n    fprintf(stderr, \"Could not parse hash name\\n\");\n    return 0;\n  }\n\n  new_hash_id = HSH_GetHashId(hash_name);\n  if (new_hash_id < 0) {\n    fprintf(stderr, \"Unknown hash name: %s\\n\", hash_name);\n    return 0;\n  }\n\n  auth_hash_id = new_hash_id;\n\n  return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* overflow check */\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n \tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n \t\treturn -ENOMEM;\n \n \tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n \tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n \tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "sysfs_get_uint64 (const char *dir,\n                  const char *attribute)\n{\n  guint64 result;\n  char *contents;\n  char *filename;\n\n  result = 0;\n  filename = g_build_filename (dir, attribute, NULL);\n  if (g_file_get_contents (filename, &contents, NULL, NULL))\n    {\n      result = strtoll (contents, NULL, 0);\n      g_free (contents);\n    }\n  g_free (filename);\n\n  return result;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline void __hrtimer_peek_ahead_timers(void) { }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void pmcraid_shutdown(struct pci_dev *pdev)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\tpmcraid_reset_bringdown(pinstance);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "sh4_change_fpscr(int off, int on)\n{\n\tint b = sh4_get_fpscr();\n\toff = ~off;\n\toff |=   0x00180000;\n\ton  &= ~ 0x00180000;\n\tb &= off;\n\tb |= on;\n\tsh4_put_fpscr(b);\n\t__fpscr_values[0] &= off;\n\t__fpscr_values[0] |= on;\n\t__fpscr_values[1] &= off;\n\t__fpscr_values[1] |= on;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static long vhost_set_vring_endian(struct vhost_virtqueue *vq, int __user *argp)\n{\n\tstruct vhost_vring_state s;\n\n\tif (vq->private_data)\n\t\treturn -EBUSY;\n\n\tif (copy_from_user(&s, argp, sizeof(s)))\n\t\treturn -EFAULT;\n\n\tif (s.num != VHOST_VRING_LITTLE_ENDIAN &&\n\t    s.num != VHOST_VRING_BIG_ENDIAN)\n\t\treturn -EINVAL;\n\n\tvq->user_be = s.num;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "update_bar_address(struct vmctx *ctx, struct pci_vdev *dev, uint64_t addr,\n\tint idx, int type, bool ignore_reg_unreg)\n{\n\tbool decode = false;\n\tuint64_t orig_addr = dev->bar[idx].addr;\n\n\tif (!ignore_reg_unreg) {\n\t\tif (dev->bar[idx].type == PCIBAR_IO)\n\t\t\tdecode = porten(dev);\n\t\telse\n\t\t\tdecode = memen(dev);\n\t}\n\n\tif (decode)\n\t\tunregister_bar(dev, idx);\n\n\tswitch (type) {\n\tcase PCIBAR_IO:\n\tcase PCIBAR_MEM32:\n\t\tdev->bar[idx].addr = addr;\n\t\tbreak;\n\tcase PCIBAR_MEM64:\n\t\tdev->bar[idx].addr &= ~0xffffffffUL;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\n\tif (decode)\n\t\tregister_bar(dev, idx);\n\n\t/* update bar mapping */\n\tif (dev->dev_ops->vdev_update_bar_map && decode)\n\t\tdev->dev_ops->vdev_update_bar_map(ctx, dev, idx, orig_addr);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void usb_uas_unrealize(USBDevice *dev, Error **errp)\n{\n    UASDevice *uas = USB_UAS(dev);\n    qemu_bh_delete(uas->status_bh);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int rb_check_list(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t struct list_head *list)\n{\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->prev) != list->prev))\n\t\treturn 1;\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->next) != list->next))\n\t\treturn 1;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int snd_timer_global_register(struct snd_timer *timer)\n{\n\tstruct snd_device dev;\n\n\tmemset(&dev, 0, sizeof(dev));\n\tdev.device_data = timer;\n\treturn snd_timer_dev_register(&dev);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFDirEntry* direntry, double* value)\n{\n\tUInt64Aligned_t m;\n\n\tassert(sizeof(double)==8);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(uint32)==4);\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tenum TIFFReadDirEntryErr err;\n\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&offset);\n\t\terr=TIFFReadDirEntryData(tif,offset,8,m.i);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\treturn(err);\n\t}\n\telse\n\t\tm.l = direntry->tdir_offset.toff_long8;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong(m.i,2);\n\tif (m.i[0]==0)\n\t\t*value=0.0;\n\telse\n\t\t*value=(double)m.i[0]/(double)m.i[1];\n\treturn(TIFFReadDirEntryErrOk);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "dequeue_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tsub_positive(&cfs_rq->avg.load_avg, se->avg.load_avg);\n\tsub_positive(&cfs_rq->avg.load_sum, se_weight(se) * se->avg.load_sum);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "short CCITTFaxStream::lookBits(int n) {\n  int c;\n\n  while (inputBits < n) {\n    if ((c = str->getChar()) == EOF) {\n      if (inputBits == 0) {\n\treturn EOF;\n      }\n      return (inputBuf << (n - inputBits)) & (0xffffffff >> (32 - n));\n    }\n    inputBuf = (inputBuf << 8) + c;\n    inputBits += 8;\n  }\n  return (inputBuf >> (inputBits - n)) & (0xffffffff >> (32 - n));\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool client_skip_line(struct imap_client *client)\n{\n\tconst unsigned char *data;\n\tsize_t i, data_size;\n\n\tdata = i_stream_get_data(client->common.input, &data_size);\n\n\tfor (i = 0; i < data_size; i++) {\n\t\tif (data[i] == '\\n') {\n\t\t\ti_stream_skip(client->common.input, i+1);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "inline double ror(const long double a, const unsigned int n=1) {\n      return (double)ror((cimg_long)a,n);",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n{\n\tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n\treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t\tgdImageSaveAlpha(dst, 1);\n\t} else {\n\t\tdst = gdImageCreate(crop->width, crop->height);\n\t\tgdImagePaletteCopy(dst, src);\n\t}\n\tdst->transparent = src->transparent;\n\n\tif (src->sx < (crop->x + crop->width -1)) {\n\t\tcrop->width = src->sx - crop->x + 1;\n\t}\n\tif (src->sy < (crop->y + crop->height -1)) {\n\t\tcrop->height = src->sy - crop->y + 1;\n\t}\n#if 0\nprintf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n#endif\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tint y = crop->y;\n\t\tif (src->trueColor) {\n\t\t\tunsigned int dst_y = 0;\n\t\t\twhile (y < (crop->y + (crop->height - 1))) {\n\t\t\t\t/* TODO: replace 4 w/byte per channel||pitch once available */\n\t\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tint x;\n\t\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n\t\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n\t\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dst;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int indexedrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)\n{\n    ref hival;\n    int code;\n\n    code = array_get(imemory, space, 2, &hival);\n    if (code < 0)\n        return code;\n    ptr[0] = 0;\n    ptr[1] = (float)hival.value.intval;\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n {\n     struct inflate_state FAR *state;\n \n    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n     state = (struct inflate_state FAR *)strm->state;\n    return ((long)(state->back) << 16) +\n         (state->mode == COPY ? state->length :\n             (state->mode == MATCH ? state->was - state->length : 0));\n }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "schemeNumToName(int scheme)\n{\n    int i;\n\n    for (i = 0; schemetable[i].cmdname != NULL; i++) {\n\tif (schemetable[i].cmd == scheme)\n\t    return schemetable[i].cmdname;\n    }\n    return NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n \t\treturn -ENOMEM;\n \t*rcmd = ptr;\n \tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n \tptr->next = NULL;\n \tptr->buffer_length = 0;\n \tparam += sizeof(struct floppy_raw_cmd);\n \tif (ptr->cmd_count > 33)\n \t\t\t/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t * such as RESTORE, which takes ... 17 command\n\t\t\t * bytes. Murphy's law #137: When you reserve\n\t\t\t * 16 bytes for a structure, you'll one day\n\t\t\t * discover that you really need 17...\n\t\t\t */\n\t\treturn -EINVAL;\n\n \tfor (i = 0; i < 16; i++)\n \t\tptr->reply[i] = 0;\n \tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n \n \tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n \t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "String DumpFragmentTree(Element* element) {\n    auto fragment = RunBlockLayoutAlgorithm(element);\n    return DumpFragmentTree(fragment.get());\n  }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)\n{\n   int len=0;\n   char c = '\\0';\n\n   c = (char) stbi__get8(z);\n\n   while (!stbi__at_eof(z) && c != '\\n') {\n      buffer[len++] = c;\n      if (len == STBI__HDR_BUFLEN-1) {\n         // flush to end of line\n         while (!stbi__at_eof(z) && stbi__get8(z) != '\\n')\n            ;\n         break;\n      }\n      c = (char) stbi__get8(z);\n   }\n\n   buffer[len] = 0;\n   return buffer;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int collect_syscall(struct task_struct *target, struct syscall_info *info)\n{\n\tstruct pt_regs *regs;\n\n\tif (!try_get_task_stack(target)) {\n\t\t/* Task has no stack, so the task isn't in a syscall. */\n\t\tmemset(info, 0, sizeof(*info));\n\t\tinfo->data.nr = -1;\n\t\treturn 0;\n\t}\n\n\tregs = task_pt_regs(target);\n\tif (unlikely(!regs)) {\n\t\tput_task_stack(target);\n\t\treturn -EAGAIN;\n\t}\n\n\tinfo->sp = user_stack_pointer(regs);\n\tinfo->data.instruction_pointer = instruction_pointer(regs);\n\n\tinfo->data.nr = syscall_get_nr(target, regs);\n\tif (info->data.nr != -1L)\n\t\tsyscall_get_arguments(target, regs,\n\t\t\t\t      (unsigned long *)&info->data.args[0]);\n\n\tput_task_stack(target);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int r_cmd_java_handle_replace_cp_value_double (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {\n\tdouble value = cmd && *cmd ? strtod (cmd, NULL) : 0.0;\n\tint res = false;\n\tres = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 8);\n\treturn res;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int decode_extradata(AVFormatContext *s, ADTSContext *adts, uint8_t *buf, int size)\n\n{\n\n    GetBitContext gb;\n\n\n\n    init_get_bits(&gb, buf, size * 8);\n\n    adts->objecttype = get_bits(&gb, 5) - 1;\n\n    adts->sample_rate_index = get_bits(&gb, 4);\n\n    adts->channel_conf = get_bits(&gb, 4);\n\n\n\n    if (adts->objecttype > 3) {\n\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype);\n\n        return -1;\n\n    }\n\n    if (adts->sample_rate_index == 15) {\n\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n\n        return -1;\n\n    }\n\n    if (adts->channel_conf == 0) {\n\n        ff_log_missing_feature(s, \"PCE based channel configuration\", 0);\n\n        return -1;\n\n    }\n\n\n\n    adts->write_adts = 1;\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\n\t*_request = NULL;\n\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "SCTP_STATIC void sctp_shutdown(struct sock *sk, int how)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *asoc;\n\n\tif (!sctp_style(sk, TCP))\n\t\treturn;\n\n\tif (how & SEND_SHUTDOWN) {\n\t\tep = sctp_sk(sk)->ep;\n\t\tif (!list_empty(&ep->asocs)) {\n\t\t\tasoc = list_entry(ep->asocs.next,\n\t\t\t\t\t  struct sctp_association, asocs);\n\t\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t\t}\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void adb_kbd_initfn(Object *obj)\n\n{\n\n    ADBDevice *d = ADB_DEVICE(obj);\n\n\n\n    d->devaddr = ADB_DEVID_KEYBOARD;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void pageCacheLog(const String& prefix, const String& message)\n{\n    LOG(PageCache, \"%s%s\", prefix.utf8().data(), message.utf8().data());\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "WebContents* DownloadItemImpl::GetWebContents() const {\n  if (job_)\n    return job_->GetWebContents();\n  return nullptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int get_uint32_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint32_t *v = pv;\n\n    uint32_t v2;\n\n    qemu_get_be32s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void WebContentsImpl::OnFrameAttached(\n    int64 parent_frame_id,\n    int64 frame_id,\n    const std::string& frame_name) {\n  FrameTreeNode* parent = FindFrameTreeNodeByID(parent_frame_id);\n  if (!parent)\n    return;\n\n  FrameTreeNode* node = new FrameTreeNode(frame_id, frame_name);\n  parent->AddChild(node);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void GetVersion(int32* major, int32* minor, int32* build, int32* revision) {\n  *major = 0;\n  *minor = 2;\n  *build = 1;\n  *revision = 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "unsigned long ring_buffer_entries_cpu(struct ring_buffer *buffer, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn 0;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\n\treturn rb_num_of_entries(cpu_buffer);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int stv06xx_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tmin_packet_size = sd->sensor->min_packet_size[gspca_dev->curr_mode];\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tgspca_err(gspca_dev, \"set alt 1 err %d\\n\", ret);\n\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static __init int hardware_setup(void)\n{\n\tif (setup_vmcs_config(&vmcs_config) < 0)\n\t\treturn -EIO;\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\treturn alloc_kvm_area();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void add_error(Scanner *s, char *error)\n{\n\ts->errors->error_count++;\n\ts->errors->error_messages = realloc(s->errors->error_messages, s->errors->error_count * sizeof(timelib_error_message));\n\ts->errors->error_messages[s->errors->error_count - 1].position = s->tok ? s->tok - s->str : 0;\n\ts->errors->error_messages[s->errors->error_count - 1].character = s->tok ? *s->tok : 0;\n\ts->errors->error_messages[s->errors->error_count - 1].message = strdup(error);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void OmniboxViewWin::SetFocus() {\n  ::SetFocus(m_hWnd);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void qpci_io_writeb(QPCIDevice *dev, void *data, uint8_t value)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    if (addr < QPCI_PIO_LIMIT) {\n\n        dev->bus->pio_writeb(dev->bus, addr, value);\n\n    } else {\n\n        dev->bus->memwrite(dev->bus, addr, &value, sizeof(value));\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "Extension::PermissionMessage::MessageId GetPermissionMessageId(\n      const std::string& permission) {\n    return Extension::kPermissions[permission_map_[permission]].message_id;\n  }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "parse_buildchar( T1_Face    face,\n                   T1_Loader  loader )\n  {\n    face->len_buildchar = T1_ToFixedArray( &loader->parser, 0, NULL, 0 );\n\n    return;\n  }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "JVM_CurrentTimeMillis(JNIEnv *env, jint unused1)\n{\n\tjlong result;\n\n\tif (env != NULL) {\n\t\tPORT_ACCESS_FROM_ENV(env);\n\n\t\tTrc_SC_CurrentTimeMillis_Entry(env, unused1);\n\n\t\tresult = (jlong) j9time_current_time_millis();\n\n\t\tTrc_SC_CurrentTimeMillis_Exit(env, result);\n\t} else {\n\t\tPORT_ACCESS_FROM_JAVAVM(BFUjavaVM);\n\n\t\tresult = (jlong) j9time_current_time_millis();\n\t}\n\n\treturn result;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "uc_err uc_context_reg_write_batch(uc_context *ctx, int *ids, void *const *vals,\n                                  int count)\n{\n    int ret = UC_ERR_OK;\n    context_reg_rw_t rw;\n\n    find_context_reg_rw_function(ctx->arch, ctx->mode, &rw);\n    if (rw.context_reg_write) {\n        ret = rw.context_reg_write(ctx, (unsigned int *)ids, vals, count);\n    } else {\n        return UC_ERR_HANDLE;\n    }\n\n    return ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n\tint retval = 0;\n\tstruct file_handle f_handle;\n\tstruct file_handle *handle = NULL;\n\n\t/*\n\t * With handle we don't look at the execute bit on the\n\t * the directory. Ideally we would like CAP_DAC_SEARCH.\n\t * But we don't have that\n\t */\n\tif (!capable(CAP_DAC_READ_SEARCH)) {\n\t\tretval = -EPERM;\n\t\tgoto out_err;\n\t}\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle))) {\n\t\tretval = -EFAULT;\n\t\tgoto out_err;\n\t}\n\tif ((f_handle.handle_bytes > MAX_HANDLE_SZ) ||\n\t    (f_handle.handle_bytes == 0)) {\n\t\tretval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\t/* copy the full handle */\n\tif (copy_from_user(handle, ufh,\n\t\t\t   sizeof(struct file_handle) +\n\t\t\t   f_handle.handle_bytes)) {\n\t\tretval = -EFAULT;\n\t\tgoto out_handle;\n\t}\n\n\tretval = do_handle_to_path(mountdirfd, handle, path);\n\nout_handle:\n\tkfree(handle);\nout_err:\n\treturn retval;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int add_shorts_metadata(int count, const char *name,\n\n                               const char *sep, TiffContext *s)\n\n{\n\n    char *ap;\n\n    int i;\n\n    int16_t *sp;\n\n\n\n    if (count >= INT_MAX / sizeof(int16_t) || count <= 0)\n\n        return AVERROR_INVALIDDATA;\n\n    if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int16_t))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    sp = av_malloc(count * sizeof(int16_t));\n\n    if (!sp)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < count; i++)\n\n        sp[i] = tget_short(&s->gb, s->le);\n\n    ap = shorts2str(sp, count, sep);\n\n    av_freep(&sp);\n\n    if (!ap)\n\n        return AVERROR(ENOMEM);\n\n    av_dict_set(avpriv_frame_get_metadatap(&s->picture), name, ap, AV_DICT_DONT_STRDUP_VAL);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "DRMSource::~DRMSource() {\n Mutex::Autolock autoLock(mDRMLock);\n    mDrmManagerClient->finalizeDecryptUnit(mDecryptHandle, mTrackId);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void jas_matrix_asl(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t//*data <<= n;\n\t\t\t\t*data = jas_seqent_asl(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void __attribute__((constructor)) init(void)\n{\n\tg_test_add_func(\"/utils/parse_bool\", test_parse_bool);\n\tg_test_add_func(\"/utils/die\", test_die);\n\tg_test_add_func(\"/utils/die_with_errno\", test_die_with_errno);\n\tg_test_add_func(\"/utils/sc_nonfatal_mkpath/relative\",\n\t\t\ttest_sc_nonfatal_mkpath__relative);\n\tg_test_add_func(\"/utils/sc_nonfatal_mkpath/absolute\",\n\t\t\ttest_sc_nonfatal_mkpath__absolute);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "URational getURational(const byte* buf, ByteOrder byteOrder)\n    {\n        uint32_t nominator = getULong(buf, byteOrder);\n        uint32_t denominator = getULong(buf + 4, byteOrder);\n        return std::make_pair(nominator, denominator);\n    }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "vte_sequence_handler_next_line (VteTerminal *terminal, GValueArray *params)\n{\n\tterminal->pvt->screen->cursor_current.col = 0;\n\tvte_sequence_handler_DO (terminal, params);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "isdn_net_addphone(isdn_net_ioctl_phone *phone)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tisdn_net_phone *n;\n\n\tif (p) {\n\t\tif (!(n = kmalloc(sizeof(isdn_net_phone), GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\tstrlcpy(n->num, phone->phone, sizeof(n->num));\n\t\tn->next = p->local->phone[phone->outgoing & 1];\n\t\tp->local->phone[phone->outgoing & 1] = n;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tif (buf_offset + 8 > sz) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.annotation_array.num_annotations; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void dec_modu(DisasContext *dc)\n\n{\n\n    int l1;\n\n\n\n    LOG_DIS(\"modu r%d, r%d, %d\\n\", dc->r2, dc->r0, dc->r1);\n\n\n\n    if (!(dc->env->features & LM32_FEATURE_DIVIDE)) {\n\n        cpu_abort(dc->env, \"hardware divider is not available\\n\");\n\n    }\n\n\n\n    l1 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);\n\n    tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);\n\n    gen_set_label(l1);\n\n    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int sd_snapshot_delete(BlockDriverState *bs, const char *snapshot_id)\n\n{\n\n    /* FIXME: Delete specified snapshot id.  */\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "xfs_file_open(\n\tstruct inode\t*inode,\n\tstruct file\t*file)\n{\n\tif (!(file->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EFBIG;\n\tif (XFS_FORCED_SHUTDOWN(XFS_M(inode->i_sb)))\n\t\treturn -EIO;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "mail_parser_run (EMailParser *parser,\n                 EMailPartList *part_list,\n                 GCancellable *cancellable)\n{\n\tEMailExtensionRegistry *reg;\n\tCamelMimeMessage *message;\n\tEMailPart *mail_part;\n\tGQueue *parsers;\n\tGQueue mail_part_queue = G_QUEUE_INIT;\n\tGList *iter;\n\tGString *part_id;\n\n\tif (cancellable)\n\t\tg_object_ref (cancellable);\n\telse\n\t\tcancellable = g_cancellable_new ();\n\n\tg_mutex_lock (&parser->priv->mutex);\n\tg_hash_table_insert (parser->priv->ongoing_part_lists, cancellable, part_list);\n\tg_mutex_unlock (&parser->priv->mutex);\n\n\tmessage = e_mail_part_list_get_message (part_list);\n\n\treg = e_mail_parser_get_extension_registry (parser);\n\n\tparsers = e_mail_extension_registry_get_for_mime_type (\n\t\treg, \"application/vnd.evolution.message\");\n\n\tif (parsers == NULL)\n\t\tparsers = e_mail_extension_registry_get_for_mime_type (\n\t\t\treg, \"message/*\");\n\n\t/* No parsers means the internal Evolution parser\n\t * extensions were not loaded. Something is terribly wrong! */\n\tg_return_if_fail (parsers != NULL);\n\n\tpart_id = g_string_new (\".message\");\n\n\tmail_part = e_mail_part_new (CAMEL_MIME_PART (message), \".message\");\n\te_mail_part_list_add_part (part_list, mail_part);\n\tg_object_unref (mail_part);\n\n\tfor (iter = parsers->head; iter; iter = iter->next) {\n\t\tEMailParserExtension *extension;\n\t\tgboolean message_handled;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\textension = iter->data;\n\t\tif (!extension)\n\t\t\tcontinue;\n\n\t\tmessage_handled = e_mail_parser_extension_parse (\n\t\t\textension, parser,\n\t\t\tCAMEL_MIME_PART (message),\n\t\t\tpart_id, cancellable, &mail_part_queue);\n\n\t\tif (message_handled)\n\t\t\tbreak;\n\t}\n\n\twhile (!g_queue_is_empty (&mail_part_queue)) {\n\t\tmail_part = g_queue_pop_head (&mail_part_queue);\n\t\te_mail_part_list_add_part (part_list, mail_part);\n\t\tg_object_unref (mail_part);\n\t}\n\n\tg_mutex_lock (&parser->priv->mutex);\n\tg_hash_table_remove (parser->priv->ongoing_part_lists, cancellable);\n\tg_mutex_unlock (&parser->priv->mutex);\n\n\tg_clear_object (&cancellable);\n\tg_string_free (part_id, TRUE);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void ib_destroy_cm_id(struct ib_cm_id *cm_id)\n{\n\tcm_destroy_id(cm_id, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static unsigned int count_acl_entries(connection_struct *conn, SMB_ACL_T posix_acl)\n{\n\tunsigned int ace_count = 0;\n\tint entry_id = SMB_ACL_FIRST_ENTRY;\n\tSMB_ACL_ENTRY_T entry;\n\n\twhile ( posix_acl && (sys_acl_get_entry(posix_acl, entry_id, &entry) == 1)) {\n\t\t/* get_next... */\n\t\tif (entry_id == SMB_ACL_FIRST_ENTRY) {\n\t\t\tentry_id = SMB_ACL_NEXT_ENTRY;\n\t\t}\n\t\tace_count++;\n\t}\n\treturn ace_count;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "double Item_cache_real::val_real()\n{\n  DBUG_ASSERT(fixed == 1);\n  if (!has_value())\n    return 0.0;\n  return value;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "inline const TfLiteTensor* GetIntermediates(TfLiteContext* context,\n                                            const TfLiteNode* node, int index) {\n  return &context->tensors[node->intermediates->data[index]];\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static struct inode *minix_alloc_inode(struct super_block *sb)\n{\n\tstruct minix_inode_info *ei;\n\tei = (struct minix_inode_info *)kmem_cache_alloc(minix_inode_cachep, SLAB_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int hid_debug_events_release(struct inode *inode, struct file *file)\n{\n\tstruct hid_debug_list *list = file->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&list->hdev->debug_list_lock, flags);\n\tlist_del(&list->node);\n\tspin_unlock_irqrestore(&list->hdev->debug_list_lock, flags);\n\tkfree(list->hid_debug_buf);\n\tkfree(list);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "sec_dist_func11 (xd3_stream *stream, xd3_output *data)\n{\n  int sum0 = 0;\n  int sum1 = 1;\n  int i, j, ret;\n  for (i = 0; i < 33; ++i)\n    {\n      for (j = 0; j < (sum0 + sum1); ++j)\n\t{\n\t  if ((ret = xd3_emit_byte (stream, & data, i))) { return ret; }\n\t}\n      sum0 = sum1;\n      sum1 = j;\n    }\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n                        void *value, size_t vsize)\n{\n    ssize_t size = 0;\n    void *ovalue = value;\n    XattrOperations *xops;\n    char *orig_value, *orig_value_start;\n    ssize_t xattr_len, parsed_len = 0, attr_len;\n    char *dirpath, *name;\n    int dirfd;\n\n    /* Get the actual len */\n    dirpath = g_path_get_dirname(path);\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    g_free(dirpath);\n    if (dirfd == -1) {\n        return -1;\n    }\n\n    name = g_path_get_basename(path);\n    xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);\n    if (xattr_len <= 0) {\n        g_free(name);\n        close_preserve_errno(dirfd);\n        return xattr_len;\n    }\n\n    /* Now fetch the xattr and find the actual size */\n    orig_value = g_malloc(xattr_len);\n    xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);\n    g_free(name);\n    close_preserve_errno(dirfd);\n    if (xattr_len < 0) {\n        return -1;\n    }\n\n    /* store the orig pointer */\n    orig_value_start = orig_value;\n    while (xattr_len > parsed_len) {\n        xops = get_xattr_operations(ctx->xops, orig_value);\n        if (!xops) {\n            goto next_entry;\n        }\n\n        if (!value) {\n            size += xops->listxattr(ctx, path, orig_value, value, vsize);\n        } else {\n            size = xops->listxattr(ctx, path, orig_value, value, vsize);\n            if (size < 0) {\n                goto err_out;\n            }\n            value += size;\n            vsize -= size;\n        }\nnext_entry:\n        /* Got the next entry */\n        attr_len = strlen(orig_value) + 1;\n        parsed_len += attr_len;\n        orig_value += attr_len;\n    }\n    if (value) {\n        size = value - ovalue;\n    }\n\nerr_out:\n    g_free(orig_value_start);\n    return size;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static unsigned long atalk_sum_partial(const unsigned char *data,\n\t\t\t\t       int len, unsigned long sum)\n{\n\t/* This ought to be unwrapped neatly. I'll trust gcc for now */\n\twhile (len--) {\n\t\tsum += *data++;\n\t\tsum = rol16(sum, 1);\n\t}\n\treturn sum;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "hstorePairs(Pairs *pairs, int32 pcount, int32 buflen)\n{\n\tHStore\t   *out;\n\tHEntry\t   *entry;\n\tchar\t   *ptr;\n\tchar\t   *buf;\n\tint32\t\tlen;\n\tint32\t\ti;\n\n\tlen = CALCDATASIZE(pcount, buflen);\n\tout = palloc(len);\n\tSET_VARSIZE(out, len);\n\tHS_SETCOUNT(out, pcount);\n\n\tif (pcount == 0)\n\t\treturn out;\n\n\tentry = ARRPTR(out);\n\tbuf = ptr = STRPTR(out);\n\n\tfor (i = 0; i < pcount; i++)\n\t\tHS_ADDITEM(entry, buf, ptr, pairs[i]);\n\n\tHS_FINALIZE(out, pcount, buf, ptr);\n\n\treturn out;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tif (fault_in_pages_writeable(iov->iov_base, this_len))\n\t\t\tbreak;\n\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n\n\treturn len;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void PPB_URLLoader_Impl::UpdateStatus() {\n  if (status_callback_ &&\n      (RecordDownloadProgress() || RecordUploadProgress())) {\n    status_callback_(\n        pp_instance(), pp_resource(),\n        RecordUploadProgress() ? bytes_sent_ : -1,\n        RecordUploadProgress() ?  total_bytes_to_be_sent_ : -1,\n        RecordDownloadProgress() ? bytes_received_ : -1,\n        RecordDownloadProgress() ? total_bytes_to_be_received_ : -1);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "\nstatic void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t */\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t */\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void do_adde (void)\n\n{\n\n    T2 = T0;\n\n    T0 += T1 + xer_ca;\n\n    if (likely(!(T0 < T2 || (xer_ca == 1 && T0 == T2)))) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static uint16_t qvirtio_pci_config_readw(QVirtioDevice *d, uint64_t off)\n\n{\n\n    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;\n\n    uint16_t value;\n\n\n\n    value = qpci_io_readw(dev->pdev, CONFIG_BASE(dev) + off);\n\n    if (qvirtio_is_big_endian(d)) {\n\n        value = bswap16(value);\n\n    }\n\n    return value;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void add_pid_to_pmt(MpegTSContext *ts, unsigned int programid,\n\n                           unsigned int pid)\n\n{\n\n    struct Program *p = get_program(ts, programid);\n\n    int i;\n\n    if (!p)\n\n        return;\n\n\n\n    if (p->nb_pids >= MAX_PIDS_PER_PROGRAM)\n\n        return;\n\n\n\n    for (i = 0; i < MAX_PIDS_PER_PROGRAM; i++)\n\n        if (p->pids[i] == pid)\n\n            return;\n\n\n\n    p->pids[p->nb_pids++] = pid;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n      return;\n   }\n\n   ctx_params.shared = true;\n   ctx_params.major_ver = VREND_GL_VER_MAJOR;\n   ctx_params.minor_ver = VREND_GL_VER_MINOR;\n   blit_ctx->gl_context = vrend_clicbs->create_gl_context(0, &ctx_params);\n\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; /*v.w*/\n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void i40e_handle_reset_warning(struct i40e_pf *pf, bool lock_acquired)\n{\n\ti40e_prep_for_reset(pf, lock_acquired);\n\ti40e_reset_and_rebuild(pf, false, lock_acquired);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "GuestFileWrite *qmp_guest_file_write(int64_t handle, const char *buf_b64,\n                                     bool has_count, int64_t count,\n                                     Error **errp)\n{\n    GuestFileWrite *write_data = NULL;\n    guchar *buf;\n    gsize buf_len;\n    int write_count;\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n    FILE *fh;\n    if (!gfh) {\n    fh = gfh->fh;\n    buf = g_base64_decode(buf_b64, &buf_len);\n    if (!has_count) {\n        count = buf_len;\n    } else if (count < 0 || count > buf_len) {\n        error_setg(errp, \"value '%\" PRId64 \"' is invalid for argument count\",\n                   count);\n        g_free(buf);\n    write_count = fwrite(buf, 1, count, fh);\n    if (ferror(fh)) {\n        error_setg_errno(errp, errno, \"failed to write to file\");\n        slog(\"guest-file-write failed, handle: %\" PRId64, handle);\n    } else {\n        write_data = g_new0(GuestFileWrite, 1);\n        write_data->count = write_count;\n        write_data->eof = feof(fh);\n        gfh->state = RW_STATE_WRITING;\n    g_free(buf);\n    clearerr(fh);\n    return write_data;",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "sanitize_filename (const char *file_name)\n{\n\tsize_t      prefix_len;\n\tchar const *p;\n\n\tif (file_name == NULL)\n\t\treturn NULL;\n\n\tprefix_len = 0;\n\tfor (p = file_name; *p; ) {\n\t\tif (ISDOT (p[0]) && ISDOT (p[1]) && (ISSLASH (p[2]) || !p[2]))\n\t\t\treturn NULL;\n\n\t\tdo {\n\t\t\tchar c = *p++;\n\t\t\tif (ISSLASH (c))\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (*p);\n\t}\n\n\tp = file_name + prefix_len;\n\twhile (ISSLASH (*p))\n\t\tp++;\n\n\treturn p;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "virtual UnicodeString& format(const Formattable& , UnicodeString& appendTo, FieldPosition& , UErrorCode& ) const {\n        return appendTo;\n    }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void mce_register_decode_chain(struct notifier_block *nb)\n{\n\tif (WARN_ON(nb->priority > MCE_PRIO_MCELOG && nb->priority < MCE_PRIO_EDAC))\n\t\treturn;\n\n\tatomic_inc(&num_notifiers);\n\n\tblocking_notifier_chain_register(&x86_mce_decoder_chain, nb);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void cleanup_one_si(struct smi_info *smi_info)\n{\n\tif (!smi_info)\n\t\treturn;\n\n\tlist_del(&smi_info->link);\n\n\tif (smi_info->intf)\n\t\tipmi_unregister_smi(smi_info->intf);\n\n\tif (smi_info->pdev) {\n\t\tif (smi_info->pdev_registered)\n\t\t\tplatform_device_unregister(smi_info->pdev);\n\t\telse\n\t\t\tplatform_device_put(smi_info->pdev);\n\t}\n\n\tkfree(smi_info);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "AutoFillManager::~AutoFillManager() {\n  download_manager_.SetObserver(NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "Round_Up_To_Grid( EXEC_OP_ FT_F26Dot6  distance,\n                             FT_F26Dot6  compensation )\n  {\n    FT_F26Dot6  val;\n\n    FT_UNUSED_EXEC;\n\n\n    if ( distance >= 0 )\n    {\n      val = distance + compensation + 63;\n      if ( distance && val > 0 )\n        val &= ~63;\n      else\n        val = 0;\n    }\n    else\n    {\n      val = - FT_PIX_CEIL( compensation - distance );\n      if ( val > 0 )\n        val = 0;\n    }\n\n    return val;\n  }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void kvm_io_ioeventfd_add(MemoryListener *listener,\n\n                                 MemoryRegionSection *section,\n\n                                 bool match_data, uint64_t data,\n\n                                 EventNotifier *e)\n\n{\n\n    int fd = event_notifier_get_fd(e);\n\n    int r;\n\n\n\n    r = kvm_set_ioeventfd_pio(fd, section->offset_within_address_space,\n\n                              data, true, int128_get64(section->size),\n\n                              match_data);\n\n    if (r < 0) {\n\n\n\n        abort();\n\n    }\n\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n \t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n \t\t\t.tcpv_minrtt = ca->base_rtt,\n \t\t};\n \n\t\tif (info.tcpv_rttcnt > 0) {\n\t\t\tu64 t = ca->sum_rtt;\n \n\t\t\tdo_div(t, info.tcpv_rttcnt);\n\t\t\tinfo.tcpv_rtt = t;\n\t\t}\n \t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n \t}\n }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void ToUpperCase(\n\t/*! Input string to be converted. */\n\tchar *s)\n{\n\twhile (*s) {\n\t\t*s = (char)toupper(*s);\n\t\t++s;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "uint32_t nand_getio(DeviceState *dev)\n\n{\n\n    int offset;\n\n    uint32_t x = 0;\n\n    NANDFlashState *s = (NANDFlashState *) dev;\n\n\n\n    /* Allow sequential reading */\n\n    if (!s->iolen && s->cmd == NAND_CMD_READ0) {\n\n        offset = (int) (s->addr & ((1 << s->addr_shift) - 1)) + s->offset;\n\n        s->offset = 0;\n\n\n\n        s->blk_load(s, s->addr, offset);\n\n        if (s->gnd)\n\n            s->iolen = (1 << s->page_shift) - offset;\n\n        else\n\n            s->iolen = (1 << s->page_shift) + (1 << s->oob_shift) - offset;\n\n    }\n\n\n\n    if (s->ce || s->iolen <= 0)\n\n        return 0;\n\n\n\n    for (offset = s->buswidth; offset--;) {\n\n        x |= s->ioaddr[offset] << (offset << 3);\n\n    }\n\n    /* after receiving READ STATUS command all subsequent reads will\n\n     * return the status register value until another command is issued\n\n     */\n\n    if (s->cmd != NAND_CMD_READSTATUS) {\n\n        s->addr   += s->buswidth;\n\n        s->ioaddr += s->buswidth;\n\n        s->iolen  -= s->buswidth;\n\n    }\n\n    return x;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static ImageEventSender& loadEventSender() {\n  DEFINE_STATIC_LOCAL(ImageEventSender, sender,\n                      (ImageEventSender::create(EventTypeNames::load)));\n  return sender;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void clearbykeys (global_State *g, GCObject *l) {\n  for (; l; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *limit = gnodelast(h);\n    Node *n;\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (iscleared(g, gckeyN(n)))  /* unmarked key? */\n        setempty(gval(n));  /* remove entry */\n      if (isempty(gval(n)))  /* is entry empty? */\n        clearkey(n);  /* clear its key */\n    }\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "plan_a (char const *filename)\n{\n  char const *s;\n  char const *lim;\n  char const **ptr;\n  char *buffer;\n  lin iline;\n  size_t size = instat.st_size;\n\n  /* Fail if the file size doesn't fit in a size_t,\n     or if storage isn't available.  */\n  if (! (size == instat.st_size\n\t && (buffer = malloc (size ? size : (size_t) 1))))\n    return false;\n\n  /* Read the input file, but don't bother reading it if it's empty.\n     When creating files, the files do not actually exist.  */\n  if (size)\n     {\n       if (S_ISREG (instat.st_mode))\n         {\n\t  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);\n \t  size_t buffered = 0, n;\n \t  if (ifd < 0)\n \t    pfatal (\"can't open file %s\", quotearg (filename));\n \n\t\t  /* Some non-POSIX hosts exaggerate st_size in text mode;\n\t\t     or the file may have shrunk!  */\n\t\t  size = buffered;\n\t\t  break;\n\t\t}\n\t      if (n == (size_t) -1)\n\t\t{\n\t\t  /* Perhaps size is too large for this host.  */\n\t\t  close (ifd);\n\t\t  free (buffer);\n\t\t  return false;\n\t\t}\n\t      buffered += n;\n\t    }\n\n\t  if (close (ifd) != 0)\n\t    read_fatal ();\n\t}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void vnc_flush(VncState *vs)\n\n{\n\n    if (vs->output.offset)\n\n        vnc_client_write(vs);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void h2_session_ev_data_read(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_IDLE:\n        case H2_SESSION_ST_WAIT:\n            transit(session, \"data read\", H2_SESSION_ST_BUSY);\n            break;\n        default:\n            /* nop */\n            break;\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int ast_probe(AVProbeData *p)\n\n{\n\n    if (AV_RL32(p->buf) == MKTAG('S','T','R','M') &&\n\n        AV_RB16(p->buf + 10) &&\n\n        AV_RB16(p->buf + 12) &&\n\n        AV_RB32(p->buf + 16))\n\n        return AVPROBE_SCORE_MAX / 3 * 2;\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int tg3_phy_auxctl_write(struct tg3 *tp, int reg, u32 set)\n{\n\tif (reg == MII_TG3_AUXCTL_SHDWSEL_MISC)\n\t\tset |= MII_TG3_AUXCTL_MISC_WREN;\n\n\treturn tg3_writephy(tp, MII_TG3_AUX_CTRL, set | reg);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "u_undo_end(\n    int\t\tdid_undo,\t// just did an undo\n    int\t\tabsolute)\t// used \":undo N\"\n{\n    char\t*msgstr;\n    u_header_T\t*uhp;\n    char_u\tmsgbuf[80];\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_UNDO) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n\n    if (global_busy\t    // no messages now, wait until global is finished\n\t    || !messaging())  // 'lazyredraw' set, don't do messages now\n\treturn;\n\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t--u_newcount;\n\n    u_oldcount -= u_newcount;\n    if (u_oldcount == -1)\n\tmsgstr = N_(\"more line\");\n    else if (u_oldcount < 0)\n\tmsgstr = N_(\"more lines\");\n    else if (u_oldcount == 1)\n\tmsgstr = N_(\"line less\");\n    else if (u_oldcount > 1)\n\tmsgstr = N_(\"fewer lines\");\n    else\n    {\n\tu_oldcount = u_newcount;\n\tif (u_newcount == 1)\n\t    msgstr = N_(\"change\");\n\telse\n\t    msgstr = N_(\"changes\");\n    }\n\n    if (curbuf->b_u_curhead != NULL)\n    {\n\t// For \":undo N\" we prefer a \"after #N\" message.\n\tif (absolute && curbuf->b_u_curhead->uh_next.ptr != NULL)\n\t{\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n\t    did_undo = FALSE;\n\t}\n\telse if (did_undo)\n\t    uhp = curbuf->b_u_curhead;\n\telse\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n    }\n    else\n\tuhp = curbuf->b_u_newhead;\n\n    if (uhp == NULL)\n\t*msgbuf = NUL;\n    else\n\tadd_time(msgbuf, sizeof(msgbuf), uhp->uh_time);\n\n#ifdef FEAT_CONCEAL\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_buffer == curbuf && wp->w_p_cole > 0)\n\t\tredraw_win_later(wp, NOT_VALID);\n\t}\n    }\n#endif\n\n    smsg_attr_keep(0, _(\"%ld %s; %s #%ld  %s\"),\n\t    u_oldcount < 0 ? -u_oldcount : u_oldcount,\n\t    _(msgstr),\n\t    did_undo ? _(\"before\") : _(\"after\"),\n\t    uhp == NULL ? 0L : uhp->uh_seq,\n\t    msgbuf);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline void RENAME(bgr32ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)\n\n{\n\n\tint i;\n\n        assert(src1 == src2);\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tconst int a= ((uint32_t*)src1)[2*i+0];\n\n\t\tconst int e= ((uint32_t*)src1)[2*i+1];\n\n\t\tconst int l= (a&0xFF00FF) + (e&0xFF00FF);\n\n\t\tconst int h= (a&0x00FF00) + (e&0x00FF00);\n\n \t\tconst int b=  l&0x3FF;\n\n\t\tconst int g=  h>>8;\n\n\t\tconst int r=  l>>16;\n\n\n\n\t\tdstU[i]= ((RU*r + GU*g + BU*b)>>(RGB2YUV_SHIFT+1)) + 128;\n\n\t\tdstV[i]= ((RV*r + GV*g + BV*b)>>(RGB2YUV_SHIFT+1)) + 128;\n\n\t}\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void Magick::Image::alpha(const unsigned int alpha_)\n{\n  modifyImage();\n  GetPPException;\n  SetImageAlpha(image(),alpha_,exceptionInfo);\n  ThrowImageException;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void visit_type_int8(Visitor *v, int8_t *obj, const char *name, Error **errp)\n\n{\n\n    int64_t value;\n\n    if (!error_is_set(errp)) {\n\n        if (v->type_int8) {\n\n            v->type_int8(v, obj, name, errp);\n\n        } else {\n\n            value = *obj;\n\n            v->type_int(v, &value, name, errp);\n\n            if (value < INT8_MIN || value > INT8_MAX) {\n\n                error_set(errp, QERR_INVALID_PARAMETER_VALUE, name ? name : \"null\",\n\n                          \"int8_t\");\n\n                return;\n\n            }\n\n            *obj = value;\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n \t\t\tstruct oz_multiple_fixed *body =\n \t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n \t\t\tu8 *data = body->data;\n\t\t\tint n = (len - sizeof(struct oz_multiple_fixed)+1)\n \t\t\t\t/ body->unit_size;\n \t\t\twhile (n--) {\n \t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "get_num_tracks_generic(void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n\n  if (!p_env->toc_init)\n    p_env->cdio->op.read_toc (p_user_data);\n\n  return p_env->toc_init ? p_env->i_tracks : CDIO_INVALID_TRACK;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\n \tup = nla_data(rp);\n \tulen = xfrm_replay_state_esn_len(up);\n \n\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n \t\treturn -EINVAL;\n \n \tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n {\n \tif (file->f_flags & O_DSYNC)\n \t\treturn 0;\n \tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n \t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n \t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n \t\treturn 1;\n \treturn 0;\n }",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "soup_ntlm_parse_challenge (const char *challenge,\n\t\t\t   char      **nonce,\n\t\t\t   char      **default_domain,\n\t\t\t   gboolean   *ntlmv2_session,\n\t\t\t   gboolean   *negotiate_target,\n\t\t\t   char\t\t**target_info,\n\t\t\t   size_t\t*target_info_sz)\n{\n\tgsize clen;\n\tNTLMString domain;\n\tNTLMString target;\n\tguchar *chall;\n\tguint32 flags;\n\n\tchall = g_base64_decode (challenge, &clen);\n\tif (clen < NTLM_CHALLENGE_DOMAIN_STRING_OFFSET ||\n\t    clen < NTLM_CHALLENGE_NONCE_OFFSET + NTLM_CHALLENGE_NONCE_LENGTH) {\n\t\tg_free (chall);\n\t\treturn FALSE;\n\t}\n\n\tmemcpy (&flags, chall + NTLM_CHALLENGE_FLAGS_OFFSET, sizeof(flags));\n\tflags = GUINT_FROM_LE (flags);\n\t*ntlmv2_session = (flags & NTLM_FLAGS_NEGOTIATE_NTLMV2) ? TRUE : FALSE;\n\t/* To know if NTLMv2 responses should be calculated */\n\t*negotiate_target = (flags & NTLM_FLAGS_NEGOTIATE_TARGET_INFORMATION ) ? TRUE : FALSE;\n\n\tif (default_domain) {\n\t\tmemcpy (&domain, chall + NTLM_CHALLENGE_DOMAIN_STRING_OFFSET, sizeof (domain));\n\t\tdomain.length = GUINT16_FROM_LE (domain.length);\n\t\tdomain.offset = GUINT16_FROM_LE (domain.offset);\n\n\t\tif (clen < domain.length + domain.offset) {\n\t\t\tg_free (chall);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t*default_domain = g_convert ((char *)chall + domain.offset,\n\t\t\t\t\t     domain.length, \"UTF-8\", \"UCS-2LE\",\n\t\t\t\t\t     NULL, NULL, NULL);\n\t}\n\n\tif (nonce) {\n\t\t*nonce = g_memdup (chall + NTLM_CHALLENGE_NONCE_OFFSET,\n\t\t\t\t   NTLM_CHALLENGE_NONCE_LENGTH);\n\t}\n\t/* For NTLMv2 response */\n\tif (*negotiate_target && target_info) {\n\t\tmemcpy (&target, chall + NTLM_CHALLENGE_TARGET_INFORMATION_OFFSET, sizeof (target));\n\t\ttarget.length = GUINT16_FROM_LE (target.length);\n\t\ttarget.offset = GUINT16_FROM_LE (target.offset);\n\n\t\tif (clen < target.length + target.offset) {\n\t\t\tg_free (chall);\n\t\t\treturn FALSE;\n\t\t}\n\t\t*target_info = g_memdup (chall + target.offset, target.length);\n\t\t*target_info_sz = target.length;\n\t}\n\n\tg_free (chall);\n\treturn TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int build_expire(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct xfrm_user_expire *ue;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, 0, XFRM_MSG_EXPIRE, sizeof(*ue), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tue = nlmsg_data(nlh);\n\tcopy_to_user_state(x, &ue->state);\n\tue->hard = (c->data.hard != 0) ? 1 : 0;\n\n\terr = xfrm_mark_put(skb, &x->mark);\n\tif (err)\n\t\treturn err;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "time_delta_should_use_heuristics(const congestion_control_t *cc)\n{\n\n  /* If we have exited slow start, we should have processed at least\n   * a cwnd worth of RTTs */\n  if (!cc->in_slow_start) {\n    return true;\n  }\n\n  /* If we managed to get enough acks to estimate a SENDME BDP, then\n   * we have enough to estimate clock jumps relative to a baseline,\n   * too. (This is at least 'cc_bwe_min' acks). */\n  if (cc->bdp[BDP_ALG_SENDME_RATE]) {\n    return true;\n  }\n\n  /* Not enough data to estimate clock jumps */\n  return false;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\n\t/*\n\t * r4 contains the guest physical address of the RTAS args\n\t * Mask off the top 4 bits since this is a guest real address\n\t */\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\n\t/*\n\t * args->rets is a pointer into args->args. Now that we've\n\t * copied args we need to fix it up to point into our copy,\n\t * not the guest args. We also need to save the original\n\t * value so we can restore it on the way out.\n\t */\n\torig_rets = args.rets;\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn rc;\n\nfail:\n\t/*\n\t * We only get here if the guest has called RTAS with a bogus\n\t * args pointer. That means we can't get to the args, and so we\n\t * can't fail the RTAS call. So fail right out to userspace,\n\t * which should kill the guest.\n\t */\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* diag = GetInput(context, node, kDiagonalTensor);\n  FillDiagHelper(input, diag, output);\n  return kTfLiteOk;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "test_bson_new_1mm (void)\n{\n   bson_t *b;\n   int i;\n\n   for (i = 0; i < 1000000; i++) {\n      b = bson_new ();\n      bson_destroy (b);\n   }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void Bitmap_prepareToDraw(JNIEnv* env, jobject, jlong bitmapHandle) {\n SkBitmap* bitmap = reinterpret_cast<SkBitmap*>(bitmapHandle);\n    bitmap->lockPixels();\n    bitmap->unlockPixels();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin->w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\t// need to use vim_strsave() because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n\n    msgmore((long)count);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "flatpak_context_feature_from_string (const char *string, GError **error)\n{\n  FlatpakContextFeatures feature = flatpak_context_bitmask_from_string (string, flatpak_context_features);\n\n  if (feature == 0)\n    {\n      g_autofree char *values = g_strjoinv (\", \", (char **) flatpak_context_features);\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Unknown feature type %s, valid types are: %s\"), string, values);\n    }\n\n  return feature;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "QTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int apparmor_task_setrlimit(struct task_struct *task,\n\t\tunsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_profile *profile = __aa_current_profile();\n\tint error = 0;\n\n\tif (!unconfined(profile))\n\t\terror = aa_task_setrlimit(profile, task, resource, new_rlim);\n\n\treturn error;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void vmsvga_init(struct vmsvga_state_s *s,\n\n                        MemoryRegion *address_space, MemoryRegion *io)\n\n{\n\n    DisplaySurface *surface;\n\n\n\n    s->scratch_size = SVGA_SCRATCH_SIZE;\n\n    s->scratch = g_malloc(s->scratch_size * 4);\n\n\n\n    s->vga.con = graphic_console_init(vmsvga_update_display,\n\n                                      vmsvga_invalidate_display,\n\n                                      vmsvga_screen_dump,\n\n                                      vmsvga_text_update, s);\n\n    surface = qemu_console_surface(s->vga.con);\n\n\n\n    s->fifo_size = SVGA_FIFO_SIZE;\n\n    memory_region_init_ram(&s->fifo_ram, \"vmsvga.fifo\", s->fifo_size);\n\n    vmstate_register_ram_global(&s->fifo_ram);\n\n    s->fifo_ptr = memory_region_get_ram_ptr(&s->fifo_ram);\n\n\n\n    vga_common_init(&s->vga);\n\n    vga_init(&s->vga, address_space, io, true);\n\n    vmstate_register(NULL, 0, &vmstate_vga_common, &s->vga);\n\n    /* Save some values here in case they are changed later.\n\n     * This is suspicious and needs more though why it is needed. */\n\n    s->depth = surface_bits_per_pixel(surface);\n\n    s->bypp = surface_bytes_per_pixel(surface);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void numtostr(js_State *J, const char *fmt, int w, double n)\n {\n\tchar buf[32], *e;\n \tsprintf(buf, fmt, w, n);\n \te = strchr(buf, 'e');\n \tif (e) {\n\t\tint exp = atoi(e+1);\n\t\tsprintf(e, \"e%+d\", exp);\n\t}\n\tjs_pushstring(J, buf);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void smp_proc_enc_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n\n   uint8_t* p = p_data->p_data;\n \n   SMP_TRACE_DEBUG(\"%s\", __func__);\n   STREAM_TO_ARRAY(p_cb->ltk, p, BT_OCTET16_LEN);\n \n   smp_key_distribution(p_cb, NULL);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "ssize_t slirp_send(struct socket *so, const void *buf, size_t len, int flags)\n\n{\n\n    if (so->s == -1 && so->extra) {\n\n        qemu_chr_fe_write(so->extra, buf, len);\n\n        return len;\n\n    }\n\n\n\n    return send(so->s, buf, len, flags);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int make_cdt15_entry(int p1, int p2, int16_t *cdt)\n\n{\n\n    int r, b, lo;\n\n\n\n    b = cdt[p2];\n\n    r = cdt[p1] * 1024;\n\n    lo = b + r;\n\n    return (lo + (lo * (1 << 16))) * 2;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int bm_fill_super(struct super_block * sb, void * data, int silent)\n{\n\tstatic struct tree_descr bm_files[] = {\n\t\t[2] = {\"status\", &bm_status_operations, S_IWUSR|S_IRUGO},\n\t\t[3] = {\"register\", &bm_register_operations, S_IWUSR},\n\t\t/* last one */ {\"\"}\n\t};\n\tint err = simple_fill_super(sb, 0x42494e4d, bm_files);\n\tif (!err)\n\t\tsb->s_op = &s_ops;\n\treturn err;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "_dbus_restore_socket_errno (int saved_errno)\n{\n  errno = saved_errno;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)\n{\n\tskb->data -= len;\n\tskb->len  += len;\n\treturn skb->data;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void SMIException(struct pt_regs *regs)\n{\n\tdie(\"System Management Interrupt\", regs, SIGABRT);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "MemoryRegion *memory_map_ptr(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms, void *ptr)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram_ptr(uc, ram, size, ptr);\n    ram->perms = perms;\n    if (ram->addr == -1) {\n        // out of memory\n        return NULL;\n    }\n\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n\n    return ram;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "WM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n\n     if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n         return (NULL);\n     }\n     if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n         ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n     } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n\n    return (ret);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "NOEXPORT int init_section(int eof, SERVICE_OPTIONS **section_ptr) {\n    char *errstr;\n\n#ifndef USE_WIN32\n    (*section_ptr)->option.log_stderr=new_global_options.option.log_stderr;\n#endif /* USE_WIN32 */\n\n    if(*section_ptr==&new_service_options) {\n        /* end of global options or inetd mode -> initialize globals */\n        errstr=parse_global_option(CMD_INITIALIZE, NULL, NULL);\n        if(errstr) {\n            s_log(LOG_ERR, \"Global options: %s\", errstr);\n            return 1;\n        }\n    }\n\n    if(*section_ptr!=&new_service_options || eof) {\n        /* end service section or inetd mode -> initialize service */\n        if(*section_ptr==&new_service_options)\n            s_log(LOG_INFO, \"Initializing inetd mode configuration\");\n        else\n            s_log(LOG_INFO, \"Initializing service [%s]\",\n                (*section_ptr)->servname);\n        errstr=parse_service_option(CMD_INITIALIZE, section_ptr, NULL, NULL);\n        if(errstr) {\n            if(*section_ptr==&new_service_options)\n                s_log(LOG_ERR, \"Inetd mode: %s\", errstr);\n            else\n                s_log(LOG_ERR, \"Service [%s]: %s\",\n                    (*section_ptr)->servname, errstr);\n            return 1;\n        }\n    }\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void audio_init (PCIBus *pci_bus, qemu_irq *pic)\n\n{\n\n    struct soundhw *c;\n\n    int audio_enabled = 0;\n\n\n\n    for (c = soundhw; !audio_enabled && c->name; ++c) {\n\n        audio_enabled = c->enabled;\n\n    }\n\n\n\n    if (audio_enabled) {\n\n        AudioState *s;\n\n\n\n        s = AUD_init ();\n\n        if (s) {\n\n            for (c = soundhw; c->name; ++c) {\n\n                if (c->enabled) {\n\n                    if (c->isa) {\n\n                        c->init.init_isa (s, pic);\n\n                    }\n\n                    else {\n\n                        if (pci_bus) {\n\n                            c->init.init_pci (pci_bus, s);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void blk_mq_release(struct request_queue *q)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tunsigned int i;\n\n\t/* hctx kobj stays in hctx */\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tif (!hctx)\n\t\t\tcontinue;\n\t\tkfree(hctx->ctxs);\n\t\tkfree(hctx);\n\t}\n\n\tkfree(q->queue_hw_ctx);\n\n\t/* ctx kobj stays in queue_ctx */\n\tfree_percpu(q->queue_ctx);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void ArthurOutputDev::type3D0(GfxState *state, double wx, double wy)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void record_init(node_t * n)\n{\n    field_t *info;\n    pointf ul, sz;\n    int flip, len;\n    char *textbuf;\t\t/* temp buffer for storing labels */\n    int sides = BOTTOM | RIGHT | TOP | LEFT;\n\n    /* Always use rankdir to determine how records are laid out */\n    flip = NOT(GD_realflip(agraphof(n)));\n    reclblp = ND_label(n)->text;\n    len = strlen(reclblp);\n    /* For some forgotten reason, an empty label is parsed into a space, so\n     * we need at least two bytes in textbuf.\n     */\n    len = MAX(len, 1);\n    textbuf = N_NEW(len + 1, char);\n    if (!(info = parse_reclbl(n, flip, TRUE, textbuf))) {\n\tagerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\n\treclblp = \"\\\\N\";\n\tinfo = parse_reclbl(n, flip, TRUE, textbuf);\n    }\n    free(textbuf);\n    size_reclbl(n, info);\n    sz.x = POINTS(ND_width(n));\n    sz.y = POINTS(ND_height(n));\n    if (mapbool(late_string(n, N_fixed, \"false\"))) {\n\tif ((sz.x < info->size.x) || (sz.y < info->size.y)) {\n/* should check that the record really won't fit, e.g., there may be no text.\n\t\t\tagerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\n*/\n\t}\n    } else {\n\tsz.x = MAX(info->size.x, sz.x);\n\tsz.y = MAX(info->size.y, sz.y);\n    }\n    resize_reclbl(info, sz, mapbool(late_string(n, N_nojustify, \"false\")));\n    ul = pointfof(-sz.x / 2., sz.y / 2.);\t/* FIXME - is this still true:    suspected to introduce ronding error - see Kluge below */\n    pos_reclbl(info, ul, sides);\n    ND_width(n) = PS2INCH(info->size.x);\n    ND_height(n) = PS2INCH(info->size.y + 1);\t/* Kluge!!  +1 to fix rounding diff between layout and rendering \n\t\t\t\t\t\t   otherwise we can get -1 coords in output */\n    ND_shape_info(n) = (void *) info;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "pvscsi_on_cmd_adapter_reset(PVSCSIState *s)\n{\n    trace_pvscsi_on_cmd_arrived(\"PVSCSI_CMD_ADAPTER_RESET\");\n\n    pvscsi_reset_adapter(s);\n    return PVSCSI_COMMAND_PROCESSING_SUCCEEDED;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void Magick::Image::strokeAntiAlias(const bool flag_)\n{\n  modifyImage();\n  options()->strokeAntiAlias(flag_);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "copy_resource(fz_context *ctx, pdf_filter_processor *p, pdf_obj *key, const char *name)\n{\n\tpdf_obj *res, *obj;\n\n\tif (!name || name[0] == 0)\n\t\treturn;\n\n\tres = pdf_dict_get(ctx, p->old_rdb, key);\n\tobj = pdf_dict_gets(ctx, res, name);\n\tif (obj)\n\t{\n\t\tres = pdf_dict_get(ctx, p->new_rdb, key);\n\t\tif (!res)\n\t\t{\n\t\t\tres = pdf_new_dict(ctx, pdf_get_bound_document(ctx, p->new_rdb), 1);\n\t\t\tpdf_dict_put_drop(ctx, p->new_rdb, key, res);\n\t\t}\n\t\tpdf_dict_putp(ctx, res, name, obj);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int hmac_export(struct shash_desc *pdesc, void *out)\n{\n\tstruct shash_desc *desc = shash_desc_ctx(pdesc);\n\n\tdesc->flags = pdesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\treturn crypto_shash_export(desc, out);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "lexer_token_is_async (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                || context_p->token.type == LEXER_TEMPLATE_LITERAL);\n\n  return (context_p->token.keyword_type == LEXER_KEYW_ASYNC\n          && !context_p->token.lit_location.has_escape);\n} /* lexer_token_is_async */",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "unsigned long PeekBuffer() const {return m_buffer;}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "auth2_challenge_stop(Authctxt *authctxt)\n{\n\t/* unregister callback */\n\tdispatch_set(SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);\n\tif (authctxt->kbdintctxt != NULL)  {\n\t\tkbdint_free(authctxt->kbdintctxt);\n\t\tauthctxt->kbdintctxt = NULL;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "    void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if (size < 2 || o > size-2) throw Error(kerNotACrwImage);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \"Directory at offset \" << std::dec << o\n                  <<\", \" << count << \" entries \\n\";\n#endif\n        o += 2;\n        for (uint16_t i = 0; i < count; ++i) {\n            if (o + 10 > size) throw Error(kerNotACrwImage);\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::AutoPtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::AutoPtr(new CiffDirectory); break;\n            default: m = CiffComponent::AutoPtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(m);\n            o += 10;\n        }\n    }  // CiffDirectory::readDirectory",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "explicit RemoveRedundantReshapeOrBroadcastTo(\n      const GraphOptimizerContext& ctx,\n      const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"RemoveRedundantReshapeOrBroadcastTo\", ctx,\n                                 ctx_ext) {}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "TextInputClient* InputMethodBase::GetTextInputClient() const {\n  return system_toplevel_window_focused_ ? text_input_client_ : NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void FillSA(struct sockaddr *sa, const struct in6_addr *in6,\n\t\tuint16_t port)\n{\n\tif (IN6_IS_ADDR_V4MAPPED(in6)) {\n\t\tstruct sockaddr_in *sa4 = (struct sockaddr_in *)sa;\n\t\tsa4->sin_family = AF_INET;\n\t\tsa4->sin_addr.s_addr = ((uint32_t*)(in6)->s6_addr)[3];\n\t\tsa4->sin_port = htons(port);\n\t} else {\n\t\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *)sa;\n\t\tsa6->sin6_family = AF_INET6;\n\t\tsa6->sin6_addr = *in6;\n\t\tsa6->sin6_port = htons(port);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static double filter_cosine(const double x)\n{\n\tif ((x >= -1.0) && (x <= 1.0)) return ((cos(x * M_PI) + 1.0)/2.0);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void CE_CharToWide(char *str, unsigned short *w_str)\n{\n\tMultiByteToWideChar(CP_ACP, 0, str, -1, w_str, GF_MAX_PATH);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void init_dev(tc58128_dev * dev, const char *filename)\n\n{\n\n    int ret, blocks;\n\n\n\n    dev->state = WAIT;\n\n    dev->flash_contents = g_malloc0(FLASH_SIZE);\n\n    memset(dev->flash_contents, 0xff, FLASH_SIZE);\n\n    if (!dev->flash_contents) {\n\n\tfprintf(stderr, \"could not alloc memory for flash\\n\");\n\n\texit(1);\n\n    }\n\n    if (filename) {\n\n\t/* Load flash image skipping the first block */\n\n\tret = load_image(filename, dev->flash_contents + 528 * 32);\n\n\tif (ret < 0) {\n\n\t    fprintf(stderr, \"ret=%d\\n\", ret);\n\n\t    fprintf(stderr, \"qemu: could not load flash image %s\\n\",\n\n\t\t    filename);\n\n\t    exit(1);\n\n\t} else {\n\n\t    /* Build first block with number of blocks */\n\n\t    blocks = (ret + 528 * 32 - 1) / (528 * 32);\n\n\t    dev->flash_contents[0] = blocks & 0xff;\n\n\t    dev->flash_contents[1] = (blocks >> 8) & 0xff;\n\n\t    dev->flash_contents[2] = (blocks >> 16) & 0xff;\n\n\t    dev->flash_contents[3] = (blocks >> 24) & 0xff;\n\n\t    fprintf(stderr, \"loaded %d bytes for %s into flash\\n\", ret,\n\n\t\t    filename);\n\n\t}\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int jpc_atoaf(char *s, int *numvalues, double **values)\n{\n\tstatic char delim[] = \", \\t\\n\";\n\tchar buf[4096];\n\tint n;\n\tdouble *vs;\n\tchar *cp;\n\n\tstrncpy(buf, s, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = '\\0';\n\tn = 0;\n\tif ((cp = strtok(buf, delim))) {\n\t\t++n;\n\t\twhile ((cp = strtok(0, delim))) {\n\t\t\tif (cp != '\\0') {\n\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n) {\n\t\tif (!(vs = jas_malloc(n * sizeof(double)))) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tstrncpy(buf, s, sizeof(buf));\n\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\tn = 0;\n\t\tif ((cp = strtok(buf, delim))) {\n\t\t\tvs[n] = atof(cp);\n\t\t\t++n;\n\t\t\twhile ((cp = strtok(0, delim))) {\n\t\t\t\tif (cp != '\\0') {\n\t\t\t\t\tvs[n] = atof(cp);\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvs = 0;\n\t}\n\n\t*numvalues = n;\n\t*values = vs;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags)\n{\n    X509_VERIFY_PARAM_set_flags(ctx->param, flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int init_put_byte(ByteIOContext *s,\n\n                  unsigned char *buffer,\n\n                  int buffer_size,\n\n                  int write_flag,\n\n                  void *opaque,\n\n                  int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),\n\n                  int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),\n\n                  int64_t (*seek)(void *opaque, int64_t offset, int whence))\n\n{\n\n    s->buffer = buffer;\n\n    s->buffer_size = buffer_size;\n\n    s->buf_ptr = buffer;\n\n    url_resetbuf(s, write_flag ? URL_WRONLY : URL_RDONLY);\n\n    s->opaque = opaque;\n\n    s->write_packet = write_packet;\n\n    s->read_packet = read_packet;\n\n    s->seek = seek;\n\n    s->pos = 0;\n\n    s->must_flush = 0;\n\n    s->eof_reached = 0;\n\n    s->error = 0;\n\n    s->is_streamed = 0;\n\n    s->max_packet_size = 0;\n\n    s->update_checksum= NULL;\n\n    if(!read_packet && !write_flag){\n\n        s->pos = buffer_size;\n\n        s->buf_end = s->buffer + buffer_size;\n\n    }\n\n    s->read_pause = NULL;\n\n    s->read_seek  = NULL;\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "struct agp_memory *agp_generic_alloc_by_type(size_t page_count, int type)\n{\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "u32 gf_base16_encode(u8 *_in, u32 inSize, u8 *_out, u32 outSize)\n{\n\tu32 i = 0;\n\tunsigned char *in = (unsigned char *)_in;\n\tunsigned char *out = (unsigned char *)_out;\n\n\tif (outSize < (inSize * 2)+1) return 0;\n\n\tfor (i=0; i<inSize; i++) {\n\t\tout[2*i] = base_16[((in[i] & 0xf0) >> 4)];\n\t\tout[2*i+1] = base_16[(in[i] & 0x0f)];\n\t}\n\tout[(inSize * 2)] = 0;\n\n\treturn inSize * 2;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static av_cold int v4l2_decode_init(AVCodecContext *avctx)\n\n{\n\n    V4L2m2mContext *s = avctx->priv_data;\n\n    V4L2Context *capture = &s->capture;\n\n    V4L2Context *output = &s->output;\n\n    int ret;\n\n\n\n    /* if these dimensions are invalid (ie, 0 or too small) an event will be raised\n\n     * by the v4l2 driver; this event will trigger a full pipeline reconfig and\n\n     * the proper values will be retrieved from the kernel driver.\n\n     */\n\n    output->height = capture->height = avctx->coded_height;\n\n    output->width = capture->width = avctx->coded_width;\n\n\n\n    output->av_codec_id = avctx->codec_id;\n\n    output->av_pix_fmt  = AV_PIX_FMT_NONE;\n\n\n\n    capture->av_codec_id = AV_CODEC_ID_RAWVIDEO;\n\n    capture->av_pix_fmt = avctx->pix_fmt;\n\n\n\n    ret = ff_v4l2_m2m_codec_init(avctx);\n\n    if (ret) {\n\n        av_log(avctx, AV_LOG_ERROR, \"can't configure decoder\\n\");\n\n        return ret;\n\n    }\n\n\n\n    return v4l2_prepare_decoder(s);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "WandExport char *DrawGetClipPath(const DrawingWand *wand)\n{\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  if (CurrentContext->clip_mask != (char *) NULL)\n    return((char *) AcquireString(CurrentContext->clip_mask));\n  return((char *) NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Eina_Bool ewk_frame_editable_get(const Evas_Object* ewkFrame)\n{\n    EWK_FRAME_SD_GET_OR_RETURN(ewkFrame, smartData, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->frame, false);\n    return smartData->editable;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "uint32_t GPMF_StructSize(GPMF_stream *ms)\n{\n\tif (ms && ms->pos+1 < ms->buffer_size_longs)\n\t{\n\t\tuint32_t ssize = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1]);\n\t\tuint32_t size = (GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]) >> 2);\n\n\t\tif (GPMF_OK != IsValidSize(ms, size)) return 0; // as the structure is corrupted. i.e. GPMF_ERROR_BAD_STRUCTURE;\n\n\t\treturn ssize;\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "string expectedResult() {\n        return \"b\";\n    }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int64_t TensorByteSize(const TensorProto& t) {\n  // num_elements returns -1 if shape is not fully defined.\n  int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();\n  return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool HTMLFormControlElement::IsRequired() const {\n  return FastHasAttribute(kRequiredAttr);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "XML_SetEndNamespaceDeclHandler(XML_Parser parser,\n                               XML_EndNamespaceDeclHandler end) {\n  endNamespaceDeclHandler = end;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "_asn1_ltostr (long v, char *str)\n {\n   long d, r;\n   char temp[LTOSTR_MAX_SIZE];\n  int count, k, start;\n\n  if (v < 0)\n    {\n      str[0] = '-';\n      start = 1;\n      v = -v;\n    }\n  else\n    start = 0;\n\n  count = 0;\n  do\n    {\n      d = v / 10;\n      r = v - d * 10;\n      temp[start + count] = '0' + (char) r;\n       count++;\n       v = d;\n     }\n  while (v);\n \n   for (k = 0; k < count; k++)\n     str[k + start] = temp[start + count - k - 1];\n  str[count + start] = 0;\n  return str;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int apparmor_path_symlink(struct path *dir, struct dentry *dentry,\n\t\t\t\t const char *old_name)\n{\n\treturn common_perm_create(OP_SYMLINK, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFLNK);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int lua_ap_set_keepalive(lua_State *L)\n{\n    int returnValue;\n    request_rec    *r;\n    luaL_checktype(L, 1, LUA_TUSERDATA);\n    r = ap_lua_check_request_rec(L, 1);\n    returnValue = ap_set_keepalive(r);\n    lua_pushboolean(L, returnValue);\n    return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void * calloc(size_t n, size_t lb)\n {\n    if (lb && n > SIZE_MAX / lb)\n       return NULL;\n #   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n         /* libpthread allocated some memory that is only pointed to by  */\n        /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "is_anychar_star_quantifier(QtfrNode* qn)\n{\n  if (qn->greedy && IS_REPEAT_INFINITE(qn->upper) &&\n      NTYPE(qn->target) == NT_CANY)\n    return 1;\n  else\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "status_t Camera3Device::triggerAutofocus(uint32_t id) {\n    ATRACE_CALL();\n Mutex::Autolock il(mInterfaceLock);\n\n    ALOGV(\"%s: Triggering autofocus, id %d\", __FUNCTION__, id);\n RequestTrigger trigger[] = {\n {\n            ANDROID_CONTROL_AF_TRIGGER,\n            ANDROID_CONTROL_AF_TRIGGER_START\n },\n {\n            ANDROID_CONTROL_AF_TRIGGER_ID,\n static_cast<int32_t>(id)\n }\n };\n\n return mRequestThread->queueTrigger(trigger,\n sizeof(trigger)/sizeof(trigger[0]));\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int cli_hm_scan(const unsigned char *digest, uint32_t size, const char **virname, const struct cli_matcher *root, enum CLI_HASH_TYPE type) {\n    const struct cli_htu32_element *item;\n    unsigned int keylen;\n    struct cli_sz_hash *szh;\n    size_t l, r;\n\n    if(!digest || !size || size == 0xffffffff || !root || !root->hm.sizehashes[type].capacity)\n\treturn CL_CLEAN;\n\n    item = cli_htu32_find(&root->hm.sizehashes[type], size);\n    if(!item)\n\treturn CL_CLEAN;\n\n    szh = (struct cli_sz_hash *)item->data.as_ptr;\n    keylen = hashlen[type];\n\n    l = 0;\n    r = szh->items;\n    while(l <= r) {\n\tsize_t c = (l + r) / 2;\n\tint res = hm_cmp(digest, &szh->hash_array[keylen * c], keylen);\n\n\tif(res < 0) {\n\t    if(!c)\n\t\tbreak;\n\t    r = c - 1;\n\t} else if(res > 0)\n\t    l = c + 1;\n\telse {\n\t    if(virname)\n\t\t*virname = szh->virusnames[c];\n\t    return CL_VIRUS;\n\t}\n    }\n    return CL_CLEAN;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void gadget_config_attr_release(struct config_item *item)\n{\n\tstruct config_usb_cfg *cfg = to_config_usb_cfg(item);\n\n\tWARN_ON(!list_empty(&cfg->c.functions));\n\tlist_del(&cfg->c.list);\n\tkfree(cfg->c.label);\n\tkfree(cfg);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "png_set_rows(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_bytepp row_pointers)\n{\n   png_debug1(1, \"in %s storage function\", \"rows\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   if (info_ptr->row_pointers != NULL &&\n       (info_ptr->row_pointers != row_pointers))\n      png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);\n\n   info_ptr->row_pointers = row_pointers;\n\n   if (row_pointers != NULL)\n      info_ptr->valid |= PNG_INFO_IDAT;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void replace_mount_options(struct super_block *sb, char *options)\n{\n\tchar *old = sb->s_options;\n\trcu_assign_pointer(sb->s_options, options);\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tkfree(old);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static ssize_t regulator_suspend_disk_state_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_state(buf,\n\t\t\trdev->constraints->state_disk.enabled);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void ion_vm_open(struct vm_area_struct *vma)\n{\n\tstruct ion_buffer *buffer = vma->vm_private_data;\n\tstruct ion_vma_list *vma_list;\n\n\tvma_list = kmalloc(sizeof(struct ion_vma_list), GFP_KERNEL);\n\tif (!vma_list)\n\t\treturn;\n\tvma_list->vma = vma;\n\tmutex_lock(&buffer->lock);\n\tlist_add(&vma_list->list, &buffer->vmas);\n\tmutex_unlock(&buffer->lock);\n\tpr_debug(\"%s: adding %p\\n\", __func__, vma);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void bdrv_dev_change_media_cb(BlockDriverState *bs, bool load)\n{\n    if (bs->dev_ops && bs->dev_ops->change_media_cb) {\n        bool tray_was_closed = !bdrv_dev_is_tray_open(bs);\n        bs->dev_ops->change_media_cb(bs->dev_opaque, load);\n        if (tray_was_closed) {\n            /* tray open */\n            bdrv_emit_qmp_eject_event(bs, true);\n        }\n        if (load) {\n            /* tray close */\n            bdrv_emit_qmp_eject_event(bs, false);\n        }\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void decode_nal_sei_decoded_picture_hash(HEVCContext *s)\n\n{\n\n    int cIdx, i;\n\n    uint8_t hash_type;\n\n    //uint16_t picture_crc;\n\n    //uint32_t picture_checksum;\n\n    GetBitContext *gb = &s->HEVClc->gb;\n\n    hash_type = get_bits(gb, 8);\n\n\n\n    for (cIdx = 0; cIdx < 3/*((s->sps->chroma_format_idc == 0) ? 1 : 3)*/; cIdx++) {\n\n        if (hash_type == 0) {\n\n            s->is_md5 = 1;\n\n            for (i = 0; i < 16; i++)\n\n                s->md5[cIdx][i] = get_bits(gb, 8);\n\n        } else if (hash_type == 1) {\n\n            // picture_crc = get_bits(gb, 16);\n\n            skip_bits(gb, 16);\n\n        } else if (hash_type == 2) {\n\n            // picture_checksum = get_bits(gb, 32);\n\n            skip_bits(gb, 32);\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void put_persistent_gnt(struct xen_blkif *blkif,\n                               struct persistent_gnt *persistent_gnt)\n{\n\tif(!test_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags))\n\t          pr_alert_ratelimited(DRV_PFX \" freeing a grant already unused\");\n\tset_bit(PERSISTENT_GNT_WAS_ACTIVE, persistent_gnt->flags);\n\tclear_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags);\n\tatomic_dec(&blkif->persistent_gnt_in_use);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static gboolean nbd_negotiate_continue(QIOChannel *ioc,\n                                       GIOCondition condition,\n                                       void *opaque)\n{\n    qemu_coroutine_enter(opaque);\n    return TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void usb_cancel_packet(USBPacket * p)\n\n{\n\n    assert(p->owner != NULL);\n\n    usb_device_cancel_packet(p->owner->dev, p);\n\n    p->owner = NULL;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "TPML_ALG_PROPERTY_Unmarshal(TPML_ALG_PROPERTY *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    UINT32 i;\n   if (rc == TPM_RC_SUCCESS) {\n\trc = UINT32_Unmarshal(&target->count, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->count > MAX_CAP_ALGS) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {\n\trc = TPMS_ALG_PROPERTY_Unmarshal(&target->algProperties[i], buffer, size);\n    }\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)\n{\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct *odn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\tfl_owner_t id = current->files;\n\tint error = 0;\n\n\tif ((arg & ~DN_MULTISHOT) == 0) {\n\t\tdnotify_flush(filp, id);\n\t\treturn 0;\n\t}\n\tif (!dir_notify_enable)\n\t\treturn -EINVAL;\n\tinode = filp->f_path.dentry->d_inode;\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn -ENOTDIR;\n\tdn = kmem_cache_alloc(dn_cache, GFP_KERNEL);\n\tif (dn == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&inode->i_lock);\n\tprev = &inode->i_dnotify;\n\twhile ((odn = *prev) != NULL) {\n\t\tif ((odn->dn_owner == id) && (odn->dn_filp == filp)) {\n\t\t\todn->dn_fd = fd;\n\t\t\todn->dn_mask |= arg;\n\t\t\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\t\t\tgoto out_free;\n\t\t}\n\t\tprev = &odn->dn_next;\n\t}\n\n\terror = __f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\n\tif (error)\n\t\tgoto out_free;\n\n\tdn->dn_mask = arg;\n\tdn->dn_fd = fd;\n\tdn->dn_filp = filp;\n\tdn->dn_owner = id;\n\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\tdn->dn_next = inode->i_dnotify;\n\tinode->i_dnotify = dn;\n\tspin_unlock(&inode->i_lock);\n\n\tif (filp->f_op && filp->f_op->dir_notify)\n\t\treturn filp->f_op->dir_notify(filp, arg);\n\treturn 0;\n\nout_free:\n\tspin_unlock(&inode->i_lock);\n\tkmem_cache_free(dn_cache, dn);\n\treturn error;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void __timer_stats_timer_set_start_info(struct timer_list *timer, void *addr)\n{\n\tif (timer->start_site)\n\t\treturn;\n\n\ttimer->start_site = addr;\n\tmemcpy(timer->start_comm, current->comm, TASK_COMM_LEN);\n\ttimer->start_pid = current->pid;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int findyz(int x, int *y, int *z) {\n\tint i, j;\n\tfor (i = 0;i < 0xff; i++) {\n\t\tfor (j = 0;j < 0xf;j++) {\n\t\t\tint v = i << j;\n\t\t\tif (v > x) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (v == x) {\n\t\t\t\t*y = i;\n\t\t\t\t*z = 16 - (j / 2);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void InitializeSpdySsl() {\n    ssl_data_->SetNextProto(kProtoSPDY2);\n  }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void ParamTraits<IPC::ChannelHandle>::Log(const param_type& p,\n                                          std::string* l) {\n  l->append(StringPrintf(\"ChannelHandle(%s\", p.name.c_str()));\n#if defined(OS_POSIX)\n  l->append(\", \");\n  ParamTraits<base::FileDescriptor>::Log(p.socket, l);\n#endif\n  l->append(\")\");\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ews_backend_ref_connection_thread (GSimpleAsyncResult *simple,\n                                   GObject *object,\n                                   GCancellable *cancellable)\n{\n\tEEwsConnection *connection;\n\tGError *error = NULL;\n\n\tconnection = e_ews_backend_ref_connection_sync (E_EWS_BACKEND (object), NULL, cancellable, &error);\n\n\t/* Sanity check. */\n\tg_return_if_fail (\n\t\t((connection != NULL) && (error == NULL)) ||\n\t\t((connection == NULL) && (error != NULL)));\n\n\tif (connection != NULL)\n\t\tg_simple_async_result_set_op_res_gpointer (\n\t\t\tsimple, connection, g_object_unref);\n\n\tif (error != NULL)\n\t\tg_simple_async_result_take_error (simple, error);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void helper_rfdi(CPUPPCState *env)\n\n{\n\n    do_rfi(env, env->spr[SPR_BOOKE_DSRR0], SPR_BOOKE_DSRR1,\n\n           ~((target_ulong)0x3FFF0000), 0);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": " */\nstatic enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer)\n{\n\tstruct bfq_data *bfqd = container_of(timer, struct bfq_data,\n\t\t\t\t\t     idle_slice_timer);\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\n\t/*\n\t * Theoretical race here: the in-service queue can be NULL or\n\t * different from the queue that was idling if a new request\n\t * arrives for the current queue and there is a full dispatch\n\t * cycle that changes the in-service queue.  This can hardly\n\t * happen, but in the worst case we just expire a queue too\n\t * early.\n\t */\n\tif (bfqq)\n\t\tbfq_idle_slice_timer_body(bfqq);\n\n\treturn HRTIMER_NORESTART;",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void icp_set_cppr(struct icp_state *icp, int server, uint8_t cppr)\n\n{\n\n    struct icp_server_state *ss = icp->ss + server;\n\n    uint8_t old_cppr;\n\n    uint32_t old_xisr;\n\n\n\n    old_cppr = CPPR(ss);\n\n    ss->xirr = (ss->xirr & ~CPPR_MASK) | (cppr << 24);\n\n\n\n    if (cppr < old_cppr) {\n\n        if (XISR(ss) && (cppr <= ss->pending_priority)) {\n\n            old_xisr = XISR(ss);\n\n            ss->xirr &= ~XISR_MASK; /* Clear XISR */\n\n\n            qemu_irq_lower(ss->output);\n\n            ics_reject(icp->ics, old_xisr);\n\n        }\n\n    } else {\n\n        if (!XISR(ss)) {\n\n            icp_resend(icp, server);\n\n        }\n\n    }\n\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "setCurrRuleset(void __attribute__((unused)) *pVal, uchar *pszName)\n{\n\truleset_t *pRuleset;\n\trsRetVal localRet;\n\tDEFiRet;\n\n\tlocalRet = ruleset.SetCurrRuleset(pszName);\n\n\tif(localRet == RS_RET_NOT_FOUND) {\n\t\tDBGPRINTF(\"begin new current rule set '%s'\\n\", pszName);\n\t\tCHKiRet(ruleset.Construct(&pRuleset));\n\t\tCHKiRet(ruleset.SetName(pRuleset, pszName));\n\t\tCHKiRet(ruleset.ConstructFinalize(pRuleset));\n\t} else {\n\t\tABORT_FINALIZE(localRet);\n\t}\n\nfinalize_it:\n\tfree(pszName); /* no longer needed */\n\tRETiRet;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static const char *ccid3_rx_state_name(enum ccid3_hc_rx_states state)\n{\n\tstatic const char *const ccid3_rx_state_names[] = {\n\t[TFRC_RSTATE_NO_DATA] = \"NO_DATA\",\n\t[TFRC_RSTATE_DATA]    = \"DATA\",\n\t};\n\n\treturn ccid3_rx_state_names[state];\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "GfxColorSpace *GfxLabColorSpace::copy() const\n{\n    GfxLabColorSpace *cs;\n\n    cs = new GfxLabColorSpace();\n    cs->whiteX = whiteX;\n    cs->whiteY = whiteY;\n    cs->whiteZ = whiteZ;\n    cs->blackX = blackX;\n    cs->blackY = blackY;\n    cs->blackZ = blackZ;\n    cs->aMin = aMin;\n    cs->aMax = aMax;\n    cs->bMin = bMin;\n    cs->bMax = bMax;\n    cs->kr = kr;\n    cs->kg = kg;\n    cs->kb = kb;\n#ifdef USE_CMS\n    cs->transform = transform;\n#endif\n    return cs;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "imap_write_envelope(const struct imap_arg *args, string_t *str)\n{\n\timap_write_envelope_list(args, str, TRUE);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int shall_we_drop(AVFormatContext *s, int index)\n\n{\n\n    struct dshow_ctx *ctx = s->priv_data;\n\n    static const uint8_t dropscore[] = {62, 75, 87, 100};\n\n    const int ndropscores = FF_ARRAY_ELEMS(dropscore);\n\n    unsigned int buffer_fullness = (ctx->curbufsize[index]*100)/s->max_picture_buffer;\n\n\n\n    if(dropscore[++ctx->video_frame_num%ndropscores] <= buffer_fullness) {\n\n        av_log(s, AV_LOG_ERROR,\n\n              \"real-time buffer[%d] too full (%d%% of size: %d)! frame dropped!\\n\", index, buffer_fullness, s->max_picture_buffer);\n\n        return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "uint16_t AVRC_PassCmd(uint8_t handle, uint8_t label, tAVRC_MSG_PASS* p_msg) {\n  BT_HDR* p_buf;\n uint16_t status = AVRC_NO_RESOURCES;\n if (!p_msg) return AVRC_BAD_PARAM;\n\n  p_msg->hdr.ctype = AVRC_CMD_CTRL;\n  p_buf = avrc_pass_msg(p_msg);\n if (p_buf) {\n    status = AVCT_MsgReq(handle, label, AVCT_CMD, p_buf);\n if (status == AVCT_SUCCESS) {\n /* Start command timer to wait for response */\n      avrc_start_cmd_timer(handle, label, 0);\n }\n }\n return (status);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void TensorSlice::Clear() {\n  starts_.clear();\n  lengths_.clear();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "asn1_get_bit_der (const unsigned char *der, int der_len,\n\t\t  int *ret_len, unsigned char *str, int str_size,\n\t\t  int *bit_len)\n{\n  int len_len = 0, len_byte;\n\n  if (der_len <= 0)\n    return ASN1_GENERIC_ERROR;\n  len_byte = asn1_get_length_der (der, der_len, &len_len) - 1;\n  if (len_byte < 0)\n    return ASN1_DER_ERROR;\n\n  *ret_len = len_byte + len_len + 1;\n  *bit_len = len_byte * 8 - der[len_len];\n\n  if (*bit_len < 0)\n    return ASN1_DER_ERROR;\n\n  if (str_size >= len_byte)\n    {\n      if (len_byte > 0)\n        memcpy (str, der + len_len + 1, len_byte);\n    }\n  else\n    {\n      return ASN1_MEM_ERROR;\n    }\n\n  return ASN1_SUCCESS;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "vhost_scsi_send_bad_target(struct vhost_scsi *vs,\n\t\t\t   struct vhost_virtqueue *vq,\n\t\t\t   int head, unsigned out)\n{\n\tstruct virtio_scsi_cmd_resp __user *resp;\n\tstruct virtio_scsi_cmd_resp rsp;\n\tint ret;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\trsp.response = VIRTIO_SCSI_S_BAD_TARGET;\n\tresp = vq->iov[out].iov_base;\n\tret = __copy_to_user(resp, &rsp, sizeof(rsp));\n\tif (!ret)\n\t\tvhost_add_used_and_signal(&vs->dev, vq, head, 0);\n\telse\n\t\tpr_err(\"Faulted on virtio_scsi_cmd_resp\\n\");\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int fuse_fs_chown(struct fuse_fs *fs, const char *path, uid_t uid, gid_t gid)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.chown)\n        return fs->op.chown(path, uid, gid);\n    else\n        return -ENOSYS;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void Compute(OpKernelContext* context) override {\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    MaxPoolingOp<Device, T>::Compute(context);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void ff_mpeg_draw_horiz_band(MpegEncContext *s, int y, int h)\n\n{\n\n    ff_draw_horiz_band(s->avctx, &s->current_picture.f,\n\n                       &s->last_picture.f, y, h, s->picture_structure,\n\n                       s->first_field, s->low_delay);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void HELPER(divs)(CPUM68KState *env, uint32_t word)\n\n{\n\n    int32_t num;\n\n    int32_t den;\n\n    int32_t quot;\n\n    int32_t rem;\n\n\n\n    num = env->div1;\n\n    den = env->div2;\n\n    if (den == 0) {\n\n        raise_exception(env, EXCP_DIV0);\n\n    }\n\n    quot = num / den;\n\n    rem = num % den;\n\n\n\n    env->cc_v = (word && quot != (int16_t)quot ? -1 : 0);\n\n    env->cc_z = quot;\n\n    env->cc_n = quot;\n\n    env->cc_c = 0;\n\n\n\n    env->div1 = quot;\n\n    env->div2 = rem;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,\n\n        enum BlockAcctType type)\n\n{\n\n    assert(type < BDRV_MAX_IOTYPE);\n\n\n\n    cookie->bytes = bytes;\n\n    cookie->start_time_ns = get_clock();\n\n    cookie->type = type;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "gxps_archive_input_stream_read (GInputStream  *stream,\n\t\t\t\tvoid          *buffer,\n\t\t\t\tgsize          count,\n\t\t\t\tGCancellable  *cancellable,\n\t\t\t\tGError       **error)\n{\n\tGXPSArchiveInputStream *istream = GXPS_ARCHIVE_INPUT_STREAM (stream);\n        gssize                  bytes_read;\n\n\tif (g_cancellable_set_error_if_cancelled (cancellable, error))\n\t\treturn -1;\n\n        bytes_read = archive_read_data (istream->zip->archive, buffer, count);\n        if (bytes_read == 0 && istream->is_interleaved && !gxps_archive_input_stream_is_last_piece (istream)) {\n                /* Read next piece */\n                gxps_archive_input_stream_next_piece (istream);\n                bytes_read = gxps_archive_input_stream_read (stream, buffer, count, cancellable, error);\n        }\n\n\treturn bytes_read;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupname) {\n    robj *argv[7];\n    argv[0] = shared.xgroup;\n    argv[1] = shared.setid;\n    argv[2] = key;\n    argv[3] = groupname;\n    argv[4] = createObjectFromStreamID(&group->last_id);\n    argv[5] = shared.entriesread;\n    argv[6] = createStringObjectFromLongLong(group->entries_read);\n\n    alsoPropagate(c->db->id,argv,7,PROPAGATE_AOF|PROPAGATE_REPL);\n\n    decrRefCount(argv[4]);\n    decrRefCount(argv[6]);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "xmalloc(size_t n)\n{\n\tvoid *p;\n\n\tp = malloc(n);\n\tif (!p)\n\t\tfatal(\"malloc:\");\n\n\treturn p;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void ewk_view_paint_context_save(Ewk_View_Paint_Context* context)\n{\n    EINA_SAFETY_ON_NULL_RETURN(context);\n    cairo_save(context->cr);\n    context->graphicContext->save();\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void cirrus_pci_lfb_map(PCIDevice *d, int region_num,\n\t\t\t       uint32_t addr, uint32_t size, int type)\n{\n    CirrusVGAState *s = &((PCICirrusVGAState *)d)->cirrus_vga;\n\n    /* XXX: add byte swapping apertures */\n    cpu_register_physical_memory(addr, s->vram_size,\n\t\t\t\t s->cirrus_linear_io_addr);\n    cpu_register_physical_memory(addr + 0x1000000, 0x400000,\n\t\t\t\t s->cirrus_linear_bitblt_io_addr);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "TEST_F(PlaintextRecordTest, TestOverSize) {\n  addToQueue(\"1603014001\");\n  EXPECT_ANY_THROW(read_.read(queue_));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "explicit MemIterator(base::WeakPtr<MemBackendImpl> backend)\n      : backend_(backend) {}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "**/\n    static CImg<T>& empty() {\n      static CImg<T> _empty;\n      return _empty.assign();",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "bool testEscapingHelper(const wchar_t * in, const wchar_t * expectedOut,\n\t\t\tbool spaceToPlus = false, bool normalizeBreaks = false) {\n\t\twchar_t * const buffer = new wchar_t[(normalizeBreaks ? 6 : 3)\n\t\t\t\t* wcslen(in) + 1];\n\t\tif (uriEscapeW(in, buffer, spaceToPlus, normalizeBreaks)\n\t\t\t!= buffer + wcslen(expectedOut)) {\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\tconst bool equal = !wcscmp(buffer, expectedOut);\n\t\tdelete [] buffer;\n\t\treturn equal;\n\t}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permipc\") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n \t\t\tsa.aad.op = OP_SETPROCATTR;\n \t\t\tsa.aad.info = name;\n \t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED, NULL, GFP_KERNEL,\n \t\t\t\t\t&sa, NULL);\n \t\t}\n \t} else if (strcmp(name, \"exec\") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void destroy() {\n\t\tif (owner) {\n\t\t\tGenerationPtr newestGeneration;\n\t\t\ttry {\n\t\t\t\tnewestGeneration = getNewestGeneration();\n\t\t\t} catch (const FileSystemException &e) {\n\t\t\t\tif (e.code() == ENOENT) {\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tthrow;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newestGeneration == NULL) {\n\t\t\t\tremoveDirTree(path);\n\t\t\t}\n\t\t}\n\t}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "save_number(const char *fmt, int number, int len)\n{\n    if (len < 30)\n\tlen = 30;\t\t/* actually log10(MAX_INT)+1 */\n\n    get_space((size_t) len + 1);\n\n    _nc_SPRINTF(TPS(out_buff) + TPS(out_used),\n\t\t_nc_SLIMIT(TPS(out_size) - TPS(out_used))\n\t\tfmt, number);\n    TPS(out_used) += strlen(TPS(out_buff) + TPS(out_used));\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "rgb2bgr(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n\tdv[0] = sv[2];\n\tdv[1] = sv[1];\n\tdv[2] = sv[0];\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tgdImageJpegCtx (im, out, quality);\n\trv = gdDPExtractData (out, size);\n\tout->gd_free (out);\n\n\treturn rv;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "Returns true(1) if it is a valid date in gregorian calendar */\nPHP_FUNCTION(checkdate)\n{\n\tlong m, d, y;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"lll\", &m, &d, &y) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (y < 1 || y > 32767 || !timelib_valid_date(y, m, d)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\t/* True : This month, day, year arguments are valid */",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "user_change_icon_file_authorized_cb (Daemon                *daemon,\n                                     User                  *user,\n                                     GDBusMethodInvocation *context,\n                                     gpointer               data)\n\n{\n        g_autofree gchar *filename = NULL;\n        g_autoptr(GFile) file = NULL;\n        g_autoptr(GFileInfo) info = NULL;\n        guint32 mode;\n        GFileType type;\n        guint64 size;\n\n        filename = g_strdup (data);\n\n        if (filename == NULL ||\n            *filename == '\\0') {\n                g_autofree gchar *dest_path = NULL;\n                g_autoptr(GFile) dest = NULL;\n                g_autoptr(GError) error = NULL;\n\n                g_clear_pointer (&filename, g_free);\n\n                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);\n                dest = g_file_new_for_path (dest_path);\n\n                if (!g_file_delete (dest, NULL, &error) &&\n                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n                        throw_error (context, ERROR_FAILED, \"failed to remove user icon, %s\", error->message);\n                        return;\n                }\n                goto icon_saved;\n         }\n \n         file = g_file_new_for_path (filename);\n         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE \",\"\n                                         G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                return;\n        }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "Eina_Bool ewk_view_setting_enable_plugins_set(Evas_Object* ewkView, Eina_Bool enable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    enable = !!enable;\n    if (priv->settings.enablePlugins != enable) {\n        priv->pageSettings->setPluginsEnabled(enable);\n        priv->settings.enablePlugins = enable;\n    }\n    return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int nr_device_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = (struct net_device *)ptr;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\n\tnr_kill_by_device(dev);\n\tnr_rt_device_down(dev);\n\n\treturn NOTIFY_DONE;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void xenstore_update_be(char *watch, char *type, int dom,\n\n                               struct XenDevOps *ops)\n\n{\n\n    struct XenDevice *xendev;\n\n    char path[XEN_BUFSIZE], *dom0, *bepath;\n\n    unsigned int len, dev;\n\n\n\n    dom0 = xs_get_domain_path(xenstore, 0);\n\n    len = snprintf(path, sizeof(path), \"%s/backend/%s/%d\", dom0, type, dom);\n\n    free(dom0);\n\n    if (strncmp(path, watch, len) != 0) {\n\n        return;\n\n    }\n\n    if (sscanf(watch+len, \"/%u/%255s\", &dev, path) != 2) {\n\n        strcpy(path, \"\");\n\n        if (sscanf(watch+len, \"/%u\", &dev) != 1) {\n\n            dev = -1;\n\n        }\n\n    }\n\n    if (dev == -1) {\n\n        return;\n\n    }\n\n\n\n    xendev = xen_be_get_xendev(type, dom, dev, ops);\n\n    if (xendev != NULL) {\n\n        bepath = xs_read(xenstore, 0, xendev->be, &len);\n\n        if (bepath == NULL) {\n\n            xen_be_del_xendev(dom, dev);\n\n        } else {\n\n            free(bepath);\n\n            xen_be_backend_changed(xendev, path);\n\n            xen_be_check_state(xendev);\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void s390_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    S390CPU *cpu = S390_CPU(dev);\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(dev);\n\n\n\n    cpu_reset(CPU(cpu));\n\n\n\n    scc->parent_realize(dev, errp);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int ram_load_dead(QEMUFile *f, void *opaque)\n\n{\n\n    RamDecompressState s1, *s = &s1;\n\n    uint8_t buf[10];\n\n    ram_addr_t i;\n\n\n\n    if (ram_decompress_open(s, f) < 0)\n\n        return -EINVAL;\n\n    for(i = 0; i < last_ram_offset; i+= BDRV_HASH_BLOCK_SIZE) {\n\n        if (ram_decompress_buf(s, buf, 1) < 0) {\n\n            fprintf(stderr, \"Error while reading ram block header\\n\");\n\n            goto error;\n\n        }\n\n        if (buf[0] == 0) {\n\n            if (ram_decompress_buf(s, qemu_get_ram_ptr(i),\n\n                                   BDRV_HASH_BLOCK_SIZE) < 0) {\n\n                fprintf(stderr, \"Error while reading ram block address=0x%08\" PRIx64, (uint64_t)i);\n\n                goto error;\n\n            }\n\n        } else {\n\n        error:\n\n            printf(\"Error block header\\n\");\n\n            return -EINVAL;\n\n        }\n\n    }\n\n    ram_decompress_close(s);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "verify_stack_type_compatibility (VerifyContext *ctx, MonoType *type, ILStackDesc *stack)\n{\n\treturn verify_stack_type_compatibility_full (ctx, type, stack, FALSE, FALSE);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      // continuation line\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "RemoteSecurityContext* RemoteFrame::GetSecurityContext() const {\n  return security_context_.Get();\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "TagLib::uint Ogg::XiphComment::track() const\n{\n  if(!d->fieldListMap[\"TRACKNUMBER\"].isEmpty())\n    return d->fieldListMap[\"TRACKNUMBER\"].front().toInt();\n  if(!d->fieldListMap[\"TRACKNUM\"].isEmpty())\n    return d->fieldListMap[\"TRACKNUM\"].front().toInt();\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "template<typename t>\n    CImg<doubleT> eval(const char *const expression, const CImg<t>& xyzc,\n                       const CImgList<T> *const list_inputs=0, CImgList<T> *const list_outputs=0) {\n      return _eval(this,expression,xyzc,list_inputs,list_outputs);",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "CommandSilence(Module* Creator)\n\t\t: SplitCommand(Creator, \"SILENCE\")\n\t\t, msgprov(Creator, \"SILENCE\")\n\t\t, ext(\"silence_list\", ExtensionItem::EXT_USER, Creator)\n\t{\n\t\tallow_empty_last_param = false;\n\t\tsyntax = \"[(+|-)<mask> [CcdiNnPpTtx]]\";\n\t}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void run() {\n        intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());\n        intrusive_ptr<Expression> expression = ExpressionFieldPath::create(expCtx, \"a.b\");\n        assertBinaryEqual(fromjson(\"{'':[]}\"),\n                          toBson(expression->evaluate(fromBson(fromjson(\"{a:[undefined]}\")))));\n    }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "gpg_ctx_add_recipient (struct _GpgCtx *gpg,\n                       const gchar *keyid)\n{\n\tif (gpg->mode != GPG_CTX_MODE_ENCRYPT && gpg->mode != GPG_CTX_MODE_EXPORT)\n\t\treturn;\n\n\tif (!gpg->recipients)\n\t\tgpg->recipients = g_ptr_array_new ();\n\n\tg_ptr_array_add (gpg->recipients, g_strdup (keyid));\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "enum_field_types Item::field_type() const\n{\n  switch (result_type()) {\n  case STRING_RESULT:  return string_field_type();\n  case INT_RESULT:     return MYSQL_TYPE_LONGLONG;\n  case DECIMAL_RESULT: return MYSQL_TYPE_NEWDECIMAL;\n  case REAL_RESULT:    return MYSQL_TYPE_DOUBLE;\n  case ROW_RESULT:\n  case TIME_RESULT:\n  case IMPOSSIBLE_RESULT:\n    DBUG_ASSERT(0);\n    return MYSQL_TYPE_VARCHAR;\n  }\n  return MYSQL_TYPE_VARCHAR;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int encode_codebook(CinepakEncContext *s, int *codebook, int size, int chunk_type_yuv, int chunk_type_gray, unsigned char *buf)\n\n{\n\n    int x, y, ret, entry_size = s->pix_fmt == AV_PIX_FMT_YUV420P ? 6 : 4;\n\n\n\n    ret = write_chunk_header(buf, s->pix_fmt == AV_PIX_FMT_YUV420P ? chunk_type_yuv : chunk_type_gray, entry_size * size);\n\n\n\n    for(x = 0; x < size; x++)\n\n        for(y = 0; y < entry_size; y++)\n\n            buf[ret++] = codebook[y + x*entry_size] ^ (y >= 4 ? 0x80 : 0);\n\n\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static struct inode_security_struct *inode_security_novalidate(struct inode *inode)\n{\n\treturn inode->i_security;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void suffix_object( cJSON *prev, cJSON *item )\n{\n\tprev->next = item;\n\titem->prev = prev;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int kvm_io_bus_write(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,\n\t\t     int len, const void *val)\n{\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\tint r;\n\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\n\tbus = srcu_dereference(kvm->buses[bus_idx], &kvm->srcu);\n\tr = __kvm_io_bus_write(bus, &range, val);\n\treturn r < 0 ? r : 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static UChar32 escLeftBracket1Semicolon3Routine(UChar32 c) {\n    c = readUnicodeCharacter();\n    if (c == 0)\n        return 0;\n    thisKeyMetaCtrl |= META;\n    return doDispatch(c, escLeftBracket1Semicolon3or5Dispatch);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void DelegatedFrameHost::CopyFromCompositingSurface(\n     const gfx::Rect& src_subrect,\n    const gfx::Size& dst_size,\n     const base::Callback<void(bool, const SkBitmap&)>& callback,\n     const SkColorType color_type) {\n  bool format_support = ((color_type == kRGB_565_SkColorType) ||\n                         (color_type == kN32_SkColorType));\n  DCHECK(format_support);\n  if (!CanCopyToBitmap()) {\n    callback.Run(false, SkBitmap());\n     return;\n   }\n \n  const gfx::Size& dst_size_in_pixel =\n      client_->ConvertViewSizeToPixel(dst_size);\n   scoped_ptr<cc::CopyOutputRequest> request =\n       cc::CopyOutputRequest::CreateRequest(base::Bind(\n           &DelegatedFrameHost::CopyFromCompositingSurfaceHasResult,\n          dst_size_in_pixel,\n           color_type,\n           callback));\n  gfx::Rect src_subrect_in_pixel =\n      ConvertRectToPixel(client_->CurrentDeviceScaleFactor(), src_subrect);\n  request->set_area(src_subrect_in_pixel);\n   client_->RequestCopyOfOutput(request.Pass());\n }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "mono_type_get_underlying_type_any (MonoType *type)\n{\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype)\n\t\treturn mono_class_enum_basetype (type->data.klass);\n\tif (type->type == MONO_TYPE_GENERICINST && type->data.generic_class->container_class->enumtype)\n\t\treturn mono_class_enum_basetype (type->data.generic_class->container_class);\n\treturn type;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void luaC_fix (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(g->allgc == o);  /* object must be 1st in 'allgc' list! */\n  white2gray(o);  /* they will be gray forever */\n  setage(o, G_OLD);  /* and old forever */\n  g->allgc = o->next;  /* remove object from 'allgc' list */\n  o->next = g->fixedgc;  /* link it to 'fixedgc' list */\n  g->fixedgc = o;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "struct output_pixel_processor *dce100_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static bool is_nan(const unsigned char) { return false; }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline void debug_work_activate(struct work_struct *work) { }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static enum hrtimer_restart napi_watchdog(struct hrtimer *timer)\n{\n\tstruct napi_struct *napi;\n\n\tnapi = container_of(timer, struct napi_struct, timer);\n\n\t/* Note : we use a relaxed variant of napi_schedule_prep() not setting\n\t * NAPI_STATE_MISSED, since we do not react to a device IRQ.\n\t */\n\tif (napi->gro_bitmask && !napi_disable_pending(napi) &&\n\t    !test_and_set_bit(NAPI_STATE_SCHED, &napi->state))\n\t\t__napi_schedule_irqoff(napi);\n\n\treturn HRTIMER_NORESTART;",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void ScriptController::clearForOutOfMemory()\n{\n    clearForClose(true);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline unsigned int skb_end_offset(const struct sk_buff *skb)\n{\n\treturn skb->end - skb->head;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void read_partition(uint8_t *p, struct partition_record *r)\n\n{\n\n    r->bootable = p[0];\n\n    r->start_head = p[1];\n\n    r->start_cylinder = p[3] | ((p[2] << 2) & 0x0300);\n\n    r->start_sector = p[2] & 0x3f;\n\n    r->system = p[4];\n\n    r->end_head = p[5];\n\n    r->end_cylinder = p[7] | ((p[6] << 2) & 0x300);\n\n    r->end_sector = p[6] & 0x3f;\n\n    r->start_sector_abs = p[8] | p[9] << 8 | p[10] << 16 | p[11] << 24;\n\n    r->nb_sectors_abs = p[12] | p[13] << 8 | p[14] << 16 | p[15] << 24;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "__must_hold(wqe->lock)\n{\n\tstruct io_wqe_acct *acct = io_wqe_get_acct(worker);\n\tstruct io_wqe *wqe = worker->wqe;\n\n\tif (!(worker->flags & IO_WORKER_F_UP))\n\t\treturn;\n\n\tif (atomic_dec_and_test(&acct->nr_running) && io_acct_run_queue(acct)) {\n\t\tatomic_inc(&acct->nr_running);\n\t\tatomic_inc(&wqe->wq->worker_refs);\n\t\tio_queue_worker_create(worker, acct, create_worker_cb);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void init_frame_decoder(APEContext *ctx)\n\n{\n\n    int i;\n\n    init_entropy_decoder(ctx);\n\n    init_predictor_decoder(ctx);\n\n\n\n    for (i = 0; i < APE_FILTER_LEVELS; i++) {\n\n        if (!ape_filter_orders[ctx->fset][i])\n\n            break;\n\n        init_filter(ctx, ctx->filters[i], ctx->filterbuf[i],\n\n                    ape_filter_orders[ctx->fset][i]);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int main(int argc, char **argv)\n{\n    int ret;\n    unsigned char *source;\n    boost::uint32_t len, sourcelen, destlen;\n\n    if (argc < 2) return 2;\n    source = yank(argv[1], &len);\n    if (source == NULL) return 2;\n    sourcelen = len;\n    ret = puff(NIL, &destlen, source, &sourcelen);\n    if (ret)\n        printf(\"puff() failed with return code %d\\n\", ret);\n    else {\n        printf(\"puff() succeeded uncompressing %lu bytes\\n\", destlen);\n        if (sourcelen < len) printf(\"%lu compressed bytes unused\\n\",\n                                    len - sourcelen);\n    }\n    free(source);\n    return ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void DevToolsWindow::SetWindowBounds(int x, int y, int width, int height) {\n  if (!IsDocked())\n    browser_->window()->SetBounds(gfx::Rect(x, y, width, height));\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "de_dotdot( char* file )\n    {\n    char* cp;\n    char* cp2;\n    int l;\n\n    /* Collapse any multiple / sequences. */\n    while ( ( cp = strstr( file, \"//\") ) != (char*) 0 )\n\t{\n\tfor ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )\n\t    continue;\n\t(void) strcpy( cp + 1, cp2 );\n\t}\n\n    /* Remove leading ./ and any /./ sequences. */\n     while ( strncmp( file, \"./\", 2 ) == 0 )\n \t(void) memmove( file, file + 2, strlen( file ) - 1 );\n     while ( ( cp = strstr( file, \"/./\") ) != (char*) 0 )\n\t(void) memmove( cp, cp + 2, strlen( file ) - 1 );\n \n     /* Alternate between removing leading ../ and removing xxx/../ */\n     for (;;)\n\t{\n\twhile ( strncmp( file, \"../\", 3 ) == 0 )\n\t    (void) memmove( file, file + 3, strlen( file ) - 2 );\n\tcp = strstr( file, \"/../\" );\n\tif ( cp == (char*) 0 )\n\t    break;\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\t(void) strcpy( cp2 + 1, cp + 4 );\n\t}\n\n    /* Also elide any xxx/.. at the end. */\n    while ( ( l = strlen( file ) ) > 3 &&\n\t    strcmp( ( cp = file + l - 3 ), \"/..\" ) == 0 )\n\t{\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\tif ( cp2 < file )\n\t    break;\n\t*cp2 = '\\0';\n\t}\n    }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "UnitType unit_name_to_type(const char *n) {\n        const char *e;\n\n        assert(n);\n\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return _UNIT_TYPE_INVALID;\n\n        assert_se(e = strrchr(n, '.'));\n\n        return unit_type_from_string(e + 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "f2d_array (const float *src, double *dest, int count)\n{\twhile (--count >= 0)\n\t{\tdest [count] = src [count] ;\n\t\t} ;\n} /* f2d_array */",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "onig_get_callout_type_by_name_id(int name_id)\n{\n  return GlobalCalloutNameList->v[name_id].type;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "NCR_ModifyMinpoll(NCR_Instance inst, int new_minpoll)\n{\n  if (new_minpoll < MIN_POLL || new_minpoll > MAX_POLL)\n    return;\n  inst->minpoll = new_minpoll;\n  LOG(LOGS_INFO, LOGF_NtpCore, \"Source %s new minpoll %d\", UTI_IPToString(&inst->remote_addr.ip_addr), new_minpoll);\n  if (inst->maxpoll < inst->minpoll)\n    NCR_ModifyMaxpoll(inst, inst->minpoll);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "String_Schema_Obj Parser::parse_css_variable_value(bool top_level)\n  {\n    String_Schema_Obj schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    String_Schema_Obj tok;\n    if (!(tok = parse_css_variable_value_token(top_level))) {\n      return {};\n    }\n\n    schema->concat(tok);\n    while ((tok = parse_css_variable_value_token(top_level))) {\n      schema->concat(tok);\n    }\n\n    return schema.detach();\n  }",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void scsi_req_data(SCSIRequest *req, int len)\n\n{\n\n    trace_scsi_req_data(req->dev->id, req->lun, req->tag, len);\n\n    req->bus->ops->complete(req->bus, SCSI_REASON_DATA, req->tag, len);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "SPL_METHOD(SplFileObject, seek)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong line_pos;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &line_pos) == FAILURE) {\n\t\treturn;\n\t}\n\tif (line_pos < 0) {\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't seek file %s to negative line %ld\", intern->file_name, line_pos);\n\t\tRETURN_FALSE;\t\t\n\t}\n\t\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n\t\n\twhile(intern->u.file.current_line_num < line_pos) {\n\t\tif (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {\n\t\t\tbreak;\n\t\t}\n\t}\n} /* }}} */",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\n\tfree((void*)array);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "MagickExport MagickBooleanType ModuleComponentGenesis(void)\n{\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  if (module_semaphore == (SemaphoreInfo *) NULL)\n    module_semaphore=AllocateSemaphoreInfo();\n  exception=AcquireExceptionInfo();\n  status=IsModuleTreeInstantiated(exception);\n  exception=DestroyExceptionInfo(exception);\n  return(status);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void cdrom_sysctl_register(void)\n{\n\tstatic int initialized;\n\n\tif (initialized == 1)\n\t\treturn;\n\n\tcdrom_sysctl_header = register_sysctl_table(cdrom_root_table);\n\n\t/* set the defaults */\n\tcdrom_sysctl_settings.autoclose = autoclose;\n\tcdrom_sysctl_settings.autoeject = autoeject;\n\tcdrom_sysctl_settings.debug = debug;\n\tcdrom_sysctl_settings.lock = lockdoor;\n\tcdrom_sysctl_settings.check = check_media_type;\n\n\tinitialized = 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "TensorSlice::TensorSlice(\n    std::initializer_list<std::pair<int64_t, int64_t>> extents) {\n  starts_.reserve(extents.size());\n  lengths_.reserve(extents.size());\n  for (const auto& e : extents) {\n    starts_.push_back(e.first);\n    lengths_.push_back(e.second);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool BluetoothSocketAbstractConnectFunction::PreRunValidation(\n    std::string* error) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  if (!BluetoothSocketAsyncApiFunction::PreRunValidation(error))\n    return false;\n\n  params_ = bluetooth_socket::Connect::Params::Create(*args_);\n  EXTENSION_FUNCTION_PRERUN_VALIDATE(params_.get());\n\n  socket_event_dispatcher_ = GetSocketEventDispatcher(browser_context());\n  return socket_event_dispatcher_ != nullptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "size_t mptsas_config_io_unit_2(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDevice *pci = PCI_DEVICE(s);\n    uint8_t devfn = pci->devfn;\n    return MPTSAS_CONFIG_PACK(2, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x02,\n                              \"llbbw*b*b*w*b*b*w*b*b*w*l\",\n                              0, 0x100, 0 /* pci bus? */, devfn, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static CharDriverState *qemu_chr_open_pp_fd(int fd,\n\n                                            ChardevCommon *backend,\n\n                                            Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    ParallelCharDriver *drv;\n\n\n\n    if (ioctl(fd, PPCLAIM) < 0) {\n\n        error_setg_errno(errp, errno, \"not a parallel port\");\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n\n\n    drv = g_new0(ParallelCharDriver, 1);\n\n    drv->fd = fd;\n\n    drv->mode = IEEE1284_MODE_COMPAT;\n\n\n\n    chr = qemu_chr_alloc(backend, errp);\n\n    if (!chr) {\n\n        return NULL;\n\n    }\n\n    chr->chr_write = null_chr_write;\n\n    chr->chr_ioctl = pp_ioctl;\n\n    chr->chr_close = pp_close;\n\n    chr->opaque = drv;\n\n\n\n    return chr;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static av_cold int rv30_decode_init(AVCodecContext *avctx)\n\n{\n\n    RV34DecContext *r = avctx->priv_data;\n\n    int ret;\n\n\n\n    r->rv30 = 1;\n\n    if ((ret = ff_rv34_decode_init(avctx)) < 0)\n\n        return ret;\n\n    if(avctx->extradata_size < 2){\n\n        av_log(avctx, AV_LOG_ERROR, \"Extradata is too small.\\n\");\n\n        return -1;\n\n\n\n\n    r->max_rpr = avctx->extradata[1] & 7;\n\n\n\n\n\n\n\n    r->parse_slice_header = rv30_parse_slice_header;\n\n    r->decode_intra_types = rv30_decode_intra_types;\n\n    r->decode_mb_info     = rv30_decode_mb_info;\n\n    r->loop_filter        = rv30_loop_filter;\n\n    r->luma_dc_quant_i = rv30_luma_dc_quant;\n\n    r->luma_dc_quant_p = rv30_luma_dc_quant;\n\n    return 0;\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "TEST(WriterTest, NoConflictWithIOManip) {\n  using namespace std;\n  using namespace fmt;\n  EXPECT_EQ(\"cafe\", (MemoryWriter() << hex(0xcafe)).str());\n  EXPECT_EQ(\"12\", (MemoryWriter() << oct(012)).str());\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static struct rt6_info *ip6_pol_route_output(struct net *net, struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6, int flags)\n{\n\treturn ip6_pol_route(net, table, fl6->flowi6_oif, fl6, flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool cpu_restore_state(CPUState *cpu, uintptr_t retaddr)\n{\n    TranslationBlock *tb;\n    bool r = false;\n    tb_lock();\n    tb = tb_find_pc(retaddr);\n    if (tb) {\n        cpu_restore_state_from_tb(cpu, tb, retaddr);\n        if (tb->cflags & CF_NOCACHE) {\n            /* one-shot translation, invalidate it immediately */\n            tb_phys_invalidate(tb, -1);\n            tb_free(tb);\n        r = true;\n    tb_unlock();",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "GF_Err rtpo_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "XML_GetCurrentByteIndex(XML_Parser parser)\n{\n  if (eventPtr)\n    return parseEndByteIndex - (parseEndPtr - eventPtr);\n  return -1;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "PDFiumEngine::~PDFiumEngine() {\n  for (auto& page : pages_)\n    page->Unload();\n\n  if (doc_) {\n    FORM_DoDocumentAAction(form_, FPDFDOC_AACTION_WC);\n    FPDFDOC_ExitFormFillEnvironment(form_);\n    FPDF_CloseDocument(doc_);\n  }\n  FPDFAvail_Destroy(fpdf_availability_);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int count_contiguous_clusters(uint64_t nb_clusters, int cluster_size,\n\n        uint64_t *l2_table, uint64_t stop_flags)\n\n{\n\n    int i;\n\n    uint64_t mask = stop_flags | L2E_OFFSET_MASK | QCOW2_CLUSTER_COMPRESSED;\n\n    uint64_t first_entry = be64_to_cpu(l2_table[0]);\n\n    uint64_t offset = first_entry & mask;\n\n\n\n    if (!offset)\n\n        return 0;\n\n\n\n    assert(qcow2_get_cluster_type(first_entry) != QCOW2_CLUSTER_COMPRESSED);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t l2_entry = be64_to_cpu(l2_table[i]) & mask;\n\n        if (offset + (uint64_t) i * cluster_size != l2_entry) {\n\n            break;\n\n        }\n\n    }\n\n\n\n\treturn i;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ManifestReloadReason ShouldReloadExtensionManifest(const ExtensionInfo& info) {\n  if (info.extension_location == Extension::LOAD)\n    return UNPACKED_DIR;\n\n  if (extension_l10n_util::ShouldRelocalizeManifest(info))\n    return NEEDS_RELOCALIZATION;\n\n  return NOT_NEEDED;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static unsigned long mce_adjust_timer_default(unsigned long interval)\n{\n\treturn interval;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void v9fs_rename(void *opaque)\n{\n    int32_t fid;\n    ssize_t err = 0;\n    size_t offset = 7;\n    V9fsString name;\n    int32_t newdirfid;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &fid, &newdirfid, &name);\n    if (err < 0) {\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n    BUG_ON(fidp->fid_type != P9_FID_NONE);\n    /* if fs driver is not path based, return EOPNOTSUPP */\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n        err = -EOPNOTSUPP;\n        goto out;\n    v9fs_path_write_lock(s);\n    err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);\n    v9fs_path_unlock(s);\n    if (!err) {\n        err = offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_has_lapic(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int sb_is_blkdev_sb(struct super_block *sb)\n{\n\treturn sb == blockdev_superblock;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bool lock_sock_fast(struct sock *sk)\n{\n\tmight_sleep();\n\tspin_lock_bh(&sk->sk_lock.slock);\n\n\tif (!sk->sk_lock.owned)\n\t\t/*\n\t\t * Note : We must disable BH\n\t\t */\n\t\treturn false;\n\n\t__lock_sock(sk);\n\tsk->sk_lock.owned = 1;\n\tspin_unlock(&sk->sk_lock.slock);\n\t/*\n\t * The sk_lock has mutex_lock() semantics here:\n\t */\n\tmutex_acquire(&sk->sk_lock.dep_map, 0, 0, _RET_IP_);\n\tlocal_bh_enable();\n\treturn true;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void *zmalloc_no_tcache(size_t size) {\n    void *ptr = mallocx(size+PREFIX_SIZE, MALLOCX_TCACHE_NONE);\n    if (!ptr) zmalloc_oom_handler(size);\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "char * unescape(char * dest, const char * src)\n  {\n    while (*src) {\n      if (*src == '\\\\') {\n\t++src;\n\tswitch (*src) {\n\tcase 'n': *dest = '\\n'; break;\n\tcase 'r': *dest = '\\r'; break;\n\tcase 't': *dest = '\\t'; break;\n\tcase 'f': *dest = '\\f'; break;\n\tcase 'v': *dest = '\\v'; break;\n\tdefault: *dest = *src;\n\t}\n      } else {\n\t*dest = *src;\n      }\n      ++src;\n      ++dest;\n    }\n    *dest = '\\0';\n    return dest;\n  }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void dm_issue_global_event(void)\n{\n\tatomic_inc(&dm_global_event_nr);\n\twake_up(&dm_global_eventq);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void skcipher_geniv_exit(struct crypto_tfm *tfm)\n{\n\tcrypto_free_ablkcipher(tfm->crt_ablkcipher.base);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "is_dump_text_type(char *type)\n{\n    struct mailcap *mcap;\n    return (type && (mcap = searchExtViewer(type)) &&\n\t    (mcap->flags & (MAILCAP_HTMLOUTPUT | MAILCAP_COPIOUSOUTPUT)));\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int ssl3_do_change_cipher_spec(SSL *s)\n\t{\n\tint i;\n\tconst char *sender;\n\tint slen;\n\n\tif (s->state & SSL_ST_ACCEPT)\n\t\ti=SSL3_CHANGE_CIPHER_SERVER_READ;\n\telse\n\t\ti=SSL3_CHANGE_CIPHER_CLIENT_READ;\n\n\tif (s->s3->tmp.key_block == NULL)\n\t\t{\n\t\tif (s->session == NULL) \n\t\t\t{\n\t\t\t/* might happen if dtls1_read_bytes() calls this */\n\t\t\tSSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC,SSL_R_CCS_RECEIVED_EARLY);\n\t\t\treturn (0);\n\t\t\t}\n\n\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\tif (!s->method->ssl3_enc->setup_key_block(s)) return(0);\n\t\t}\n\n\tif (!s->method->ssl3_enc->change_cipher_state(s,i))\n\t\treturn(0);\n\n\t/* we have to record the message digest at\n\t * this point so we can get it before we read\n\t * the finished message */\n\tif (s->state & SSL_ST_CONNECT)\n\t\t{\n\t\tsender=s->method->ssl3_enc->server_finished_label;\n\t\tslen=s->method->ssl3_enc->server_finished_label_len;\n\t\t}\n\telse\n\t\t{\n\t\tsender=s->method->ssl3_enc->client_finished_label;\n\t\tslen=s->method->ssl3_enc->client_finished_label_len;\n\t\t}\n\n\ts->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\n\t\t&(s->s3->finish_dgst1),\n\t\t&(s->s3->finish_dgst2),\n\t\tsender,slen,s->s3->tmp.peer_finish_md);\n\n\treturn(1);\n\t}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "uint32_t TiffSubIfd::doSize() const\n    {\n        return static_cast<uint32_t>(ifds_.size()) * 4;\n    } // TiffSubIfd::doSize",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,\n\t\t\t      struct sys_reg_params *p,\n\t\t\t      const struct sys_reg_desc *r)\n{\n\tu64 idx;\n\n\tif (!kvm_arm_pmu_v3_ready(vcpu))\n\t\treturn trap_raz_wi(vcpu, p, r);\n\n\tif (r->CRn == 9 && r->CRm == 13) {\n\t\tif (r->Op2 == 2) {\n\t\t\t/* PMXEVCNTR_EL0 */\n\t\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\n\t\t\tidx = vcpu_sys_reg(vcpu, PMSELR_EL0)\n\t\t\t      & ARMV8_PMU_COUNTER_MASK;\n\t\t} else if (r->Op2 == 0) {\n\t\t\t/* PMCCNTR_EL0 */\n\t\t\tif (pmu_access_cycle_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n \n \t\t\tidx = ARMV8_PMU_CYCLE_IDX;\n \t\t} else {\n\t\t\tBUG();\n \t\t}\n \t} else if (r->CRn == 14 && (r->CRm & 12) == 8) {\n \t\t/* PMEVCNTRn_EL0 */\n \t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n \t\t\treturn false;\n \n \t\tidx = ((r->CRm & 3) << 3) | (r->Op2 & 7);\n \t} else {\n\t\tBUG();\n \t}\n \n \tif (!pmu_counter_idx_valid(vcpu, idx))\n\t\treturn false;\n\n\tif (p->is_write) {\n\t\tif (pmu_access_el0_disabled(vcpu))\n\t\t\treturn false;\n\n\t\tkvm_pmu_set_counter_value(vcpu, idx, p->regval);\n\t} else {\n\t\tp->regval = kvm_pmu_get_counter_value(vcpu, idx);\n\t}\n\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int RemoteIo::close()\n    {\n        if (p_->isMalloced_) {\n            p_->eof_ = false;\n            p_->idx_ = 0;\n        }\n#ifdef DEBUG\n        std::cerr << \"RemoteIo::close totalRead_ = \" << p_->totalRead_ << std::endl;\n#endif\n        if ( bigBlock_ ) {\n            delete [] bigBlock_;\n            bigBlock_=nullptr;\n        }\n        return 0;\n    }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static jas_image_cmpt_t *jas_image_cmpt_create(uint_fast32_t tlx, uint_fast32_t tly,\n  uint_fast32_t hstep, uint_fast32_t vstep, uint_fast32_t width, uint_fast32_t\n  height, uint_fast16_t depth, bool sgnd, uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tlong size;\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\treturn 0;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\n\tsize = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) : jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t\treturn 0;\n\t}\n\n\t/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. */\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t\treturn 0;\n\t}\n\n\treturn cmpt;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void __fanout_unlink(struct sock *sk, struct packet_sock *po)\n{\n\tstruct packet_fanout *f = po->fanout;\n\tint i;\n\n\tspin_lock(&f->lock);\n\tfor (i = 0; i < f->num_members; i++) {\n\t\tif (f->arr[i] == sk)\n\t\t\tbreak;\n\t}\n\tBUG_ON(i >= f->num_members);\n\tf->arr[i] = f->arr[f->num_members - 1];\n\tf->num_members--;\n\tspin_unlock(&f->lock);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline hwaddr vmxnet3_ring_curr_cell_pa(Vmxnet3Ring *ring)\n{\n    return ring->pa + ring->next * ring->cell_size;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void reply_outbuf(struct smb_request *req, uint8 num_words, uint32 num_bytes)\n{\n\tchar *outbuf;\n\tif (!create_outbuf(req, req, (char *)req->inbuf, &outbuf, num_words,\n\t\t\t   num_bytes)) {\n\t\tsmb_panic(\"could not allocate output buffer\\n\");\n\t}\n\treq->outbuf = (uint8_t *)outbuf;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "GF_Err esds_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tchar *enc_desc;\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\te = gf_odf_desc_write((GF_Descriptor *)ptr->desc, &enc_desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, enc_desc, descSize);\n\tgf_free(enc_desc);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void wdm_in_callback(struct urb *urb)\n {\n \tstruct wdm_device *desc = urb->context;\n \tint status = urb->status;\n \n \tspin_lock(&desc->iuspin);\n \tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n \t}\n \n \tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\n skip_error:\n \twake_up(&desc->wait);\n \n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int intel_vgpu_mmap(struct mdev_device *mdev, struct vm_area_struct *vma)\n{\n\tunsigned int index;\n\tu64 virtaddr;\n\tunsigned long req_size, pgoff = 0;\n\tpgprot_t pg_prot;\n\tstruct intel_vgpu *vgpu = mdev_get_drvdata(mdev);\n\n\tindex = vma->vm_pgoff >> (VFIO_PCI_OFFSET_SHIFT - PAGE_SHIFT);\n\tif (index >= VFIO_PCI_ROM_REGION_INDEX)\n\t\treturn -EINVAL;\n\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\tif ((vma->vm_flags & VM_SHARED) == 0)\n\t\treturn -EINVAL;\n\tif (index != VFIO_PCI_BAR2_REGION_INDEX)\n\t\treturn -EINVAL;\n\n\tpg_prot = vma->vm_page_prot;\n\tvirtaddr = vma->vm_start;\n\treq_size = vma->vm_end - vma->vm_start;\n\tpgoff = vgpu_aperture_pa_base(vgpu) >> PAGE_SHIFT;\n\n\treturn remap_pfn_range(vma, virtaddr, pgoff, req_size, pg_prot);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "p11_rpc_buffer_get_byte_array (p11_buffer *buf,\n                               size_t *offset,\n                               const unsigned char **data,\n                               size_t *length)\n{\n\tsize_t off = *offset;\n\tuint32_t len;\n\tif (!p11_rpc_buffer_get_uint32 (buf, &off, &len))\n\t\treturn false;\n\tif (len == 0xffffffff) {\n\t\t*offset = off;\n\t\tif (data)\n\t\t\t*data = NULL;\n\t\tif (length)\n\t\t\t*length = 0;\n\t\treturn true;\n\t} else if (len >= 0x7fffffff) {\n\t\tp11_buffer_fail (buf);\n\t\treturn false;\n\t}\n\n\tif (buf->len < len || *offset > buf->len - len) {\n\t\tp11_buffer_fail (buf);\n\t\treturn false;\n\t}\n\n\tif (data)\n\t\t*data = (unsigned char *)buf->data + off;\n\tif (length)\n\t\t*length = len;\n\t*offset = off + len;\n\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void nfnetlink_rcv(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tstruct net *net = sock_net(skb->sk);\n\tint msglen;\n\n\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t    skb->len < nlh->nlmsg_len)\n\t\treturn;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN)) {\n\t\tnetlink_ack(skb, nlh, -EPERM);\n\t\treturn;\n\t}\n\n\tif (nlh->nlmsg_type == NFNL_MSG_BATCH_BEGIN) {\n\t\tstruct nfgenmsg *nfgenmsg;\n\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t\t    skb->len < NLMSG_HDRLEN + sizeof(struct nfgenmsg))\n\t\t\treturn;\n\n\t\tnfgenmsg = nlmsg_data(nlh);\n\t\tskb_pull(skb, msglen);\n\t\tnfnetlink_rcv_batch(skb, nlh, nfgenmsg->res_id);\n\t} else {\n\t\tnetlink_rcv_skb(skb, &nfnetlink_rcv_msg);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void qemu_spice_add_memslot(SimpleSpiceDisplay *ssd, QXLDevMemSlot *memslot)\n{\n    ssd->worker->add_memslot(ssd->worker, memslot);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "str2jobflags(Pool *pool, char *s)\t/* modifies the string */\n{\n  int i, jobflags = 0;\n  while (s)\n    {\n      char *se = strchr(s, ',');\n      if (se)\n\t*se++ = 0;\n      for (i = 0; jobflags2str[i].str; i++)\n\tif (!strcmp(s, jobflags2str[i].str))\n\t  {\n\t    jobflags |= jobflags2str[i].flag;\n\t    break;\n\t  }\n      if (!jobflags2str[i].str)\n\tpool_error(pool, 0, \"str2job: unknown job flag '%s'\", s);\n      s = se;\n    }\n  return jobflags;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void RenderView::willClose(WebFrame* frame) {\n   if (!frame->parent()) {\n     const GURL& url = frame->url();\n    if (url.SchemeIs(\"http\") || url.SchemeIs(\"https\"))\n      DumpLoadHistograms();\n  }\n\n  WebDataSource* ds = frame->dataSource();\n   NavigationState* navigation_state = NavigationState::FromDataSource(ds);\n   navigation_state->user_script_idle_scheduler()->Cancel();\n \n  // TODO(jhawkins): Remove once frameDetached is called by WebKit.\n   autofill_helper_.FrameWillClose(frame);\n }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int vrend_decode_set_sub_ctx(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != 1)\n      return EINVAL;\n\n   uint32_t ctx_sub_id = get_buf_entry(ctx, 1);\n\n   vrend_renderer_set_sub_ctx(ctx->grctx, ctx_sub_id);\n   return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int cryptd_hash_finup_enqueue(struct ahash_request *req)\n{\n\treturn cryptd_hash_enqueue(req, cryptd_hash_finup);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int *sockaddr_len, int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n\t\treturn -ENOTCONN;\n\t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n\taddr = (struct sockaddr_atmpvc *)sockaddr;\n\taddr->sap_family = AF_ATMPVC;\n\taddr->sap_addr.itf = vcc->dev->number;\n\taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void sctp_assoc_free_asconf_queue(struct sctp_association *asoc)\n{\n\tstruct sctp_chunk *asconf;\n\tstruct sctp_chunk *tmp;\n\n\tlist_for_each_entry_safe(asconf, tmp, &asoc->addip_chunk_list, list) {\n\t\tlist_del_init(&asconf->list);\n\t\tsctp_chunk_free(asconf);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void toneport_start_pcm(struct work_struct *work)\n{\n\tstruct usb_line6_toneport *toneport =\n\t\tcontainer_of(work, struct usb_line6_toneport, pcm_work.work);\n\tstruct usb_line6 *line6 = &toneport->line6;\n\n\tline6_pcm_acquire(line6->line6pcm, LINE6_STREAM_MONITOR, true);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int host_pci_config_read(int pos, int len, uint32_t val)\n\n{\n\n    char path[PATH_MAX];\n\n    int config_fd;\n\n    ssize_t size = sizeof(path);\n\n    /* Access real host bridge. */\n\n    int rc = snprintf(path, size, \"/sys/bus/pci/devices/%04x:%02x:%02x.%d/%s\",\n\n                      0, 0, 0, 0, \"config\");\n\n\n\n    if (rc >= size || rc < 0) {\n\n        return -ENODEV;\n\n    }\n\n\n\n    config_fd = open(path, O_RDWR);\n\n    if (config_fd < 0) {\n\n        return -ENODEV;\n\n    }\n\n\n\n    if (lseek(config_fd, pos, SEEK_SET) != pos) {\n\n        return -errno;\n\n    }\n\n    do {\n\n        rc = read(config_fd, (uint8_t *)&val, len);\n\n    } while (rc < 0 && (errno == EINTR || errno == EAGAIN));\n\n    if (rc != len) {\n\n        return -errno;\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void RenderView::didCompleteClientRedirect(\n    WebFrame* frame, const WebURL& from) {\n  if (!frame->parent())\n    completed_client_redirect_src_ = from;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "_g_str_shell_escape (const char *filename)\n{\n\treturn _g_str_escape (filename, \"$'`\\\"\\\\!?* ()[]&|:;<>#\");\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int r_cmd_java_print_field_num_name (RBinJavaObj *obj) {\n\tRList * the_list = r_bin_java_get_field_num_name (obj);\n\tchar * str;\n\tRListIter *iter = NULL;\n\tr_list_foreach (the_list, iter, str) {\n\t\tr_cons_println (str);\n\t}\n\tr_list_free (the_list);\n\treturn true;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void timer_enable(struct xlx_timer *xt)\n\n{\n\n    uint64_t count;\n\n\n\n    D(printf(\"%s timer=%d down=%d\\n\", __func__,\n\n              xt->nr, xt->regs[R_TCSR] & TCSR_UDT));\n\n\n\n    ptimer_stop(xt->ptimer);\n\n\n\n    if (xt->regs[R_TCSR] & TCSR_UDT)\n\n        count = xt->regs[R_TLR];\n\n    else\n\n        count = ~0 - xt->regs[R_TLR];\n\n    ptimer_set_count(xt->ptimer, count);\n\n    ptimer_run(xt->ptimer, 1);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int dev_suspend(struct file *filp, struct dm_ioctl *param, size_t param_size)\n{\n\tif (param->flags & DM_SUSPEND_FLAG)\n\t\treturn do_suspend(param);\n\n\treturn do_resume(param);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void do_icbi (void)\n\n{\n\n    uint32_t tmp;\n\n    /* Invalidate one cache line :\n\n     * PowerPC specification says this is to be treated like a load\n\n     * (not a fetch) by the MMU. To be sure it will be so,\n\n     * do the load \"by hand\".\n\n     */\n\n#if defined(TARGET_PPC64)\n\n    if (!msr_sf)\n\n        T0 &= 0xFFFFFFFFULL;\n\n#endif\n\n    tmp = ldl_kernel(T0);\n\n    T0 &= ~(ICACHE_LINE_SIZE - 1);\n\n    tb_invalidate_page_range(T0, T0 + ICACHE_LINE_SIZE);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void DevToolsWindow::Observe(int type,\n                             const content::NotificationSource& source,\n                             const content::NotificationDetails& details) {\n  DCHECK_EQ(chrome::NOTIFICATION_BROWSER_THEME_CHANGED, type);\n  UpdateTheme();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "Pl_AES_PDF::flush(bool strip_padding)\n{\n    assert(this->offset == this->buf_size);\n\n    if (first)\n    {\n\tfirst = false;\n        bool return_after_init = false;\n\tif (this->cbc_mode)\n\t{\n\t    if (encrypt)\n\t    {\n\t\t// Set cbc_block to the initialization vector, and if\n\t\t// not zero, write it to the output stream.\n\t\tinitializeVector();\n                if (! (this->use_zero_iv || this->use_specified_iv))\n                {\n                    getNext()->write(this->cbc_block, this->buf_size);\n                }\n\t    }\n\t    else if (this->use_zero_iv || this->use_specified_iv)\n            {\n                // Initialize vector with zeroes; zero vector was not\n                // written to the beginning of the input file.\n                initializeVector();\n            }\n            else\n\t    {\n\t\t// Take the first block of input as the initialization\n\t\t// vector.  There's nothing to write at this time.\n\t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n\t\tthis->offset = 0;\n                return_after_init = true;\n\t    }\n\t}\n        this->crypto->rijndael_init(\n            encrypt, this->key.get(), key_bytes,\n            this->cbc_mode, this->cbc_block);\n        if (return_after_init)\n        {\n            return;\n        }\n    }\n\n    if (this->encrypt)\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    else\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    unsigned int bytes = this->buf_size;\n    if (strip_padding)\n    {\n\tunsigned char last = this->outbuf[this->buf_size - 1];\n\tif (last <= this->buf_size)\n\t{\n\t    bool strip = true;\n\t    for (unsigned int i = 1; i <= last; ++i)\n\t    {\n\t\tif (this->outbuf[this->buf_size - i] != last)\n\t\t{\n\t\t    strip = false;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (strip)\n\t    {\n\t\tbytes -= last;\n\t    }\n\t}\n    }\n    getNext()->write(this->outbuf, bytes);\n    this->offset = 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "JsVar *jsvArrayBufferGetFromName(JsVar *name) {\n  assert(jsvIsArrayBufferName(name));\n  size_t idx = (size_t)jsvGetInteger(name);\n  JsVar *arrayBuffer = jsvLock(jsvGetFirstChild(name));\n  JsVar *value = jsvArrayBufferGet(arrayBuffer, idx);\n  jsvUnLock(arrayBuffer);\n  return value;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "mono_thread_exit ()\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tTHREAD_DEBUG (g_message (\"%s: mono_thread_exit for %p (%\"G_GSIZE_FORMAT\")\", __func__, thread, (gsize)thread->tid));\n\n\tthread_cleanup (thread);\n\tSET_CURRENT_OBJECT (NULL);\n\tmono_domain_unset ();\n\n\t/* we could add a callback here for embedders to use. */\n\tif (mono_thread_get_main () && (thread == mono_thread_get_main ()->internal_thread))\n\t\texit (mono_environment_exitcode_get ());\n\tExitThread (-1);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void __init floppy_set_flags(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param)\n\t\t\tdefault_drive_params[i].params.flags |= param2;\n\t\telse\n\t\t\tdefault_drive_params[i].params.flags &= ~param2;\n\t}\n\tDPRINT(\"%s flag 0x%x\\n\", param2 ? \"Setting\" : \"Clearing\", param);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "const char *SSL_get_psk_identity_hint(const SSL *s)\n{\n    if (s == NULL || s->session == NULL)\n        return NULL;\n    return (s->session->psk_identity_hint);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void unit_status_printf(Unit *u, const char *status, const char *unit_status_msg_format) {\n        const char *d;\n\n        d = unit_description(u);\n        if (log_get_show_color())\n                d = strjoina(ANSI_HIGHLIGHT, d, ANSI_NORMAL);\n\n        DISABLE_WARNING_FORMAT_NONLITERAL;\n        manager_status_printf(u->manager, STATUS_TYPE_NORMAL, status, unit_status_msg_format, d);\n        REENABLE_WARNING;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void cp2112_gpio_irq_shutdown(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\n\tcancel_delayed_work_sync(&dev->gpio_poll_worker);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void LogOpenCLBuildFailure(MagickCLDevice device,const char *kernel,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    *log;\n\n  size_t\n    log_size;\n\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s%s%s\",\n    GetOpenCLCacheDirectory(),DirectorySeparator,\"magick_badcl.cl\");\n\n  (void) remove_utf8(filename);\n  (void) BlobToFile(filename,kernel,strlen(kernel),exception);\n\n  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,\n    CL_PROGRAM_BUILD_LOG,0,NULL,&log_size);\n  log=(char*)AcquireMagickMemory(log_size);\n  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,\n    CL_PROGRAM_BUILD_LOG,log_size,log,&log_size);\n\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s%s%s\",\n    GetOpenCLCacheDirectory(),DirectorySeparator,\"magick_badcl.log\");\n\n  (void) remove_utf8(filename);\n  (void) BlobToFile(filename,log,log_size,exception);\n  log=(char*)RelinquishMagickMemory(log);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "MagickPrivate void XWarning(const ExceptionType magick_unused(warning),\n  const char *reason,const char *description)\n{\n  char\n    text[MagickPathExtent];\n\n  XWindows\n    *windows;\n\n  if (reason == (char *) NULL)\n    return;\n  (void) CopyMagickString(text,reason,MagickPathExtent);\n  (void) ConcatenateMagickString(text,\":\",MagickPathExtent);\n  windows=XSetWindows((XWindows *) ~0);\n  XNoticeWidget(windows->display,windows,text,(char *) description);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void *my_malloc(size_t size)\n{\n    malloc_called += 1;\n    return malloc(size);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int libraw_COLOR(libraw_data_t *lr, int row, int col)\n  {\n    if (!lr)\n      return EINVAL;\n    LibRaw *ip = (LibRaw *)lr->parent_class;\n    return ip->COLOR(row, col);\n  }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void neon_store_reg(int reg, int pass, TCGv var)\n\n{\n\n    tcg_gen_st_i32(var, cpu_env, neon_reg_offset(reg, pass));\n\n    dead_tmp(var);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void vscsi_send_request_sense(VSCSIState *s, vscsi_req *req)\n\n{\n\n    SCSIDevice *sdev = req->sdev;\n\n    uint8_t *cdb = req->iu.srp.cmd.cdb;\n\n    int n;\n\n\n\n    cdb[0] = 3;\n\n    cdb[1] = 0;\n\n    cdb[2] = 0;\n\n    cdb[3] = 0;\n\n    cdb[4] = 96;\n\n    cdb[5] = 0;\n\n    req->sensing = 1;\n\n    n = sdev->info->send_command(sdev, req->qtag, cdb, req->lun);\n\n    dprintf(\"VSCSI: Queued request sense tag 0x%x\\n\", req->qtag);\n\n    if (n < 0) {\n\n        fprintf(stderr, \"VSCSI: REQUEST_SENSE wants write data !?!?!?\\n\");\n\n        sdev->info->cancel_io(sdev, req->qtag);\n\n        vscsi_makeup_sense(s, req, HARDWARE_ERROR, 0, 0);\n\n        vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    } else if (n == 0) {\n\n        return;\n\n    }\n\n    sdev->info->read_data(sdev, req->qtag);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static NTSTATUS smb1cli_pull_raw_error(const uint8_t *hdr)\n{\n\tuint32_t flags2 = SVAL(hdr, HDR_FLG2);\n\tNTSTATUS status = NT_STATUS(IVAL(hdr, HDR_RCLS));\n\n\tif (NT_STATUS_IS_OK(status)) {\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tif (flags2 & FLAGS2_32_BIT_ERROR_CODES) {\n\t\treturn status;\n\t}\n\n\treturn NT_STATUS_DOS(CVAL(hdr, HDR_RCLS), SVAL(hdr, HDR_ERR));\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int md5_sparc64_import(struct shash_desc *desc, const void *in)\n{\n\tstruct md5_state *sctx = shash_desc_ctx(desc);\n\n\tmemcpy(sctx, in, sizeof(*sctx));\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void cunary(JF, js_Ast *exp, int opcode)\n{\n\tcexp(J, F, exp->a);\n\temitline(J, F, exp);\n\temit(J, F, opcode);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void rds_send_sndbuf_remove(struct rds_sock *rs, struct rds_message *rm)\n{\n\tu32 len = be32_to_cpu(rm->m_inc.i_hdr.h_len);\n\n\tassert_spin_locked(&rs->rs_lock);\n\n\tBUG_ON(rs->rs_snd_bytes < len);\n\trs->rs_snd_bytes -= len;\n\n\tif (rs->rs_snd_bytes == 0)\n\t\trds_stats_inc(s_send_queue_empty);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static uint64_t toWire64(uint64_t x)   {return htonll(x);}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void gen_rfci_40x(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    /* Restore CPU state */\n\n    gen_helper_40x_rfci(cpu_env);\n\n    gen_sync_exception(ctx);\n\n#endif\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static bool vhost_work_seq_done(struct vhost_dev *dev, struct vhost_work *work,\n\t\t\t\tunsigned seq)\n{\n\tint left;\n\n\tspin_lock_irq(&dev->work_lock);\n\tleft = seq - work->done_seq;\n\tspin_unlock_irq(&dev->work_lock);\n\treturn left <= 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "R_API char *r_bin_java_print_unknown_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tsnprintf (value, size, \"%d.0x%04\"PFMT64x \".%s\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name);\n\t}\n\treturn value;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "map_reduce(mapobject *lz, PyObject *Py_UNUSED(ignored))\n{\n    Py_ssize_t numargs = PyTuple_GET_SIZE(lz->iters);\n    PyObject *args = PyTuple_New(numargs+1);\n    Py_ssize_t i;\n    if (args == NULL)\n        return NULL;\n    Py_INCREF(lz->func);\n    PyTuple_SET_ITEM(args, 0, lz->func);\n    for (i = 0; i<numargs; i++){\n        PyObject *it = PyTuple_GET_ITEM(lz->iters, i);\n        Py_INCREF(it);\n        PyTuple_SET_ITEM(args, i+1, it);\n    }\n\n    return Py_BuildValue(\"ON\", Py_TYPE(lz), args);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "struct sockaddr_nl *nlmsg_get_src(struct nl_msg *msg)\n{\n\treturn &msg->nm_src;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto err_out;\n\n\tif (rule_buf) {\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t info.rule_cnt * sizeof(u32)))\n\t\t\tgoto err_out;\n\t}\n\tret = 0;\n\nerr_out:\n\tkfree(rule_buf);\n\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "option_unset_env_cb (const gchar *option_name,\n                     const gchar *value,\n                     gpointer     data,\n                     GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (strchr (value, '=') != NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Environment variable name must not contain '=': %s\"), value);\n      return FALSE;\n    }\n\n  flatpak_context_set_env_var (context, value, NULL);\n  return TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "snd_info_create_entry(const char *name, struct snd_info_entry *parent,\n\t\t      struct module *module)\n{\n\tstruct snd_info_entry *entry;\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\tentry->name = kstrdup(name, GFP_KERNEL);\n\tif (entry->name == NULL) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->mode = S_IFREG | 0444;\n\tentry->content = SNDRV_INFO_CONTENT_TEXT;\n\tmutex_init(&entry->access);\n\tINIT_LIST_HEAD(&entry->children);\n\tINIT_LIST_HEAD(&entry->list);\n\tentry->parent = parent;\n\tentry->module = module;\n\tif (parent)\n\t\tlist_add_tail(&entry->list, &parent->children);\n\treturn entry;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo,\n\t\t\t\t const void *text, size_t text_size,\n\t\t\t\t void *digest)\n{\n\tstruct nettle_hash_ctx ctx;\n\tint ret;\n\n\tret = _ctx_init(algo, &ctx);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\n\tctx.update(&ctx, text_size, text);\n\tctx.digest(&ctx, ctx.length, digest);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline unsigned char *PopHexPixel(const char **hex_digits,\n  const size_t pixel,unsigned char *pixels)\n{\n  register const char\n    *hex;\n\n  hex=hex_digits[pixel];\n  *pixels++=(unsigned char) (*hex++);\n  *pixels++=(unsigned char) (*hex);\n  return(pixels);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int xfrm6_tunnel_spi_init(void)\n{\n\tint i;\n\n\txfrm6_tunnel_spi = 0;\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL, NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYADDR_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&xfrm6_tunnel_spi_byaddr[i]);\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYSPI_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&xfrm6_tunnel_spi_byspi[i]);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static __net_exit void dccp_net_exit(struct net *net)\n{\n\tnf_ct_l4proto_pernet_unregister(net, &dccp_proto6);\n\tnf_ct_l4proto_pernet_unregister(net, &dccp_proto4);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  uint pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  uint commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  if(commentFields > (data.size() - 8) / 4) {\n    return;\n  }\n\n  for(uint i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    uint commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    if(pos > data.size()) {\n      break;\n    }\n\n    int commentSeparatorPosition = comment.find(\"=\");\n    if(commentSeparatorPosition == -1) {\n      break;\n    }\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void __init xen_hvm_guest_init(void)\n{\n\tif (xen_pv_domain())\n\t\treturn;\n\n\tinit_hvm_pv_info();\n\n\treserve_shared_info();\n\txen_hvm_init_shared_info();\n\n\t/*\n\t * xen_vcpu is a pointer to the vcpu_info struct in the shared_info\n\t * page, we use it in the event channel upcall and in some pvclock\n\t * related functions.\n\t */\n\txen_vcpu_info_reset(0);\n\n\txen_panic_handler_init();\n\n\tif (!no_vector_callback && xen_feature(XENFEAT_hvm_callback_vector))\n\t\txen_have_vector_callback = 1;\n\n\txen_hvm_smp_init();\n\tWARN_ON(xen_cpuhp_setup(xen_cpu_up_prepare_hvm, xen_cpu_dead_hvm));\n\txen_unplug_emulated_devices();\n\tx86_init.irqs.intr_init = xen_init_IRQ;\n\txen_hvm_init_time_ops();\n\txen_hvm_init_mmu_ops();\n\n#ifdef CONFIG_KEXEC_CORE\n\tmachine_ops.shutdown = xen_hvm_shutdown;\n\tmachine_ops.crash_shutdown = xen_hvm_crash_shutdown;\n#endif\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int dxv_decompress_raw(AVCodecContext *avctx)\n{\n    DXVContext *ctx = avctx->priv_data;\n    GetByteContext *gbc = &ctx->gbc;\n    bytestream2_get_buffer(gbc, ctx->tex_data, ctx->tex_size);\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "AuthenticatorSheetModelBase::AuthenticatorSheetModelBase(\n    AuthenticatorRequestDialogModel* dialog_model)\n    : dialog_model_(dialog_model) {\n  DCHECK(dialog_model);\n  dialog_model_->AddObserver(this);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int init_sig_algs(SSL *s, unsigned int context)\n{\n    /* Clear any signature algorithms extension received */\n    OPENSSL_free(s->s3->tmp.peer_sigalgs);\n    s->s3->tmp.peer_sigalgs = NULL;\n\n    return 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *mem,\n \t\t      const nodemask_t *nodemask, unsigned long totalpages)\n {\n\tint points;\n \n \tif (oom_unkillable_task(p, mem, nodemask))\n \t\treturn 0;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * Shortcut check for a thread sharing p->mm that is OOM_SCORE_ADJ_MIN\n\t * so the entire heuristic doesn't need to be executed for something\n\t * that cannot be killed.\n\t */\n\tif (atomic_read(&p->mm->oom_disable_count)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The memory controller may have a limit of 0 bytes, so avoid a divide\n\t * by zero, if necessary.\n\t */\n\tif (!totalpages)\n\t\ttotalpages = 1;\n\n\t/*\n\t * The baseline for the badness score is the proportion of RAM that each\n\t * task's rss, pagetable and swap space use.\n\t */\n\tpoints = get_mm_rss(p->mm) + p->mm->nr_ptes;\n\tpoints += get_mm_counter(p->mm, MM_SWAPENTS);\n\n\tpoints *= 1000;\n\tpoints /= totalpages;\n\ttask_unlock(p);\n\n\t/*\n\t * Root processes get 3% bonus, just like the __vm_enough_memory()\n\t * implementation used by LSMs.\n\t */\n\tif (has_capability_noaudit(p, CAP_SYS_ADMIN))\n\t\tpoints -= 30;\n\n\t/*\n\t * /proc/pid/oom_score_adj ranges from -1000 to +1000 such that it may\n\t * either completely disable oom killing or always prefer a certain\n\t * task.\n\t */\n\tpoints += p->signal->oom_score_adj;\n\n\t/*\n\t * Never return 0 for an eligible task that may be killed since it's\n\t * possible that no single user task uses more than 0.1% of memory and\n\t * no single admin tasks uses more than 3.0%.\n\t */\n\tif (points <= 0)\n\t\treturn 1;\n\treturn (points < 1000) ? points : 1000;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "test_encode_decode_uint32_t (xd3_stream *stream, int unused)\n{\n  TEST_ENCODE_DECODE_INTEGER(uint32_t,1U,UINT32_MAX);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void CWebServer::Cmd_GetSerialDevices(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\troot[\"status\"] = \"OK\";\n\t\t\troot[\"title\"] = \"GetSerialDevices\";\n\n\t\t\tbool bUseDirectPath = false;\n\t\t\tstd::vector<std::string> serialports = GetSerialPorts(bUseDirectPath);\n\t\t\tint ii = 0;\n\t\t\tfor (const auto & itt : serialports)\n\t\t\t{\n\t\t\t\troot[\"result\"][ii][\"name\"] = itt;\n\t\t\t\troot[\"result\"][ii][\"value\"] = ii;\n\t\t\t\tii++;\n\t\t\t}\n\t\t}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void free_xattr(stat_x *sxp)\n{\n\tif (!sxp->xattr)\n\t\treturn;\n\trsync_xal_free(sxp->xattr);\n\tfree(sxp->xattr);\n\tsxp->xattr = NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void genl_unlock_all(void)\n{\n\tgenl_unlock();\n\tup_write(&cb_lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static gboolean nbd_accept(QIOChannel *ioc, GIOCondition condition,\n\n                           gpointer opaque)\n\n{\n\n    QIOChannelSocket *cioc;\n\n\n\n    if (!nbd_server) {\n\n        return FALSE;\n\n    }\n\n\n\n    cioc = qio_channel_socket_accept(QIO_CHANNEL_SOCKET(ioc),\n\n                                     NULL);\n\n    if (!cioc) {\n\n        return TRUE;\n\n    }\n\n\n\n    qio_channel_set_name(QIO_CHANNEL(cioc), \"nbd-server\");\n\n    nbd_client_new(NULL, cioc,\n\n                   nbd_server->tlscreds, NULL,\n\n                   nbd_client_put);\n\n    object_unref(OBJECT(cioc));\n\n    return TRUE;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "aspath_left_confed_check (struct aspath *aspath)\n{\n\n  if ( !(aspath && aspath->segments) )\n    return 0;\n\n  if ( (aspath->segments->type == AS_CONFED_SEQUENCE)\n      || (aspath->segments->type == AS_CONFED_SET) )\n    return 1;\n\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void FFmpegVideoDecodeEngine::Uninitialize() {\n  event_handler_->OnUninitializeComplete();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void RenderView::didFailLoad(WebFrame* frame, const WebURLError& error) {\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "uint32_t nghttp2_session_get_next_stream_id(nghttp2_session *session) {\n  return session->next_stream_id;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "QUtil::uint_to_string(unsigned long long num, int length)\n{\n    return int_to_string_base(num, 10, length);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "validate_group(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tstruct pmu_hw_events fake_pmu;\n\tDECLARE_BITMAP(fake_used_mask, ARMPMU_MAX_HWEVENTS);\n\n\t/*\n\t * Initialise the fake PMU. We only need to populate the\n\t * used_mask for the purposes of validation.\n\t */\n\tmemset(fake_used_mask, 0, sizeof(fake_used_mask));\n\tfake_pmu.used_mask = fake_used_mask;\n\n\tif (!validate_event(&fake_pmu, leader))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(sibling, &leader->sibling_list, group_entry) {\n\t\tif (!validate_event(&fake_pmu, sibling))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!validate_event(&fake_pmu, event))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int scsi_write_data(SCSIDevice *d, uint32_t tag)\n\n{\n\n    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, d);\n\n    SCSIGenericReq *r;\n\n    int ret;\n\n\n\n    DPRINTF(\"scsi_write_data 0x%x\\n\", tag);\n\n    r = scsi_find_request(s, tag);\n\n    if (!r) {\n\n        BADF(\"Bad write tag 0x%x\\n\", tag);\n\n        /* ??? This is the wrong error.  */\n\n        scsi_command_complete(r, -EINVAL);\n\n        return 0;\n\n    }\n\n\n\n    if (r->len == 0) {\n\n        r->len = r->buflen;\n\n        scsi_req_data(&r->req, r->len);\n\n        return 0;\n\n    }\n\n\n\n    ret = execute_command(s->bs, r, SG_DXFER_TO_DEV, scsi_write_complete);\n\n    if (ret == -1) {\n\n        scsi_command_complete(r, -EINVAL);\n\n        return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int shm_set_policy(struct vm_area_struct *vma, struct mempolicy *new)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tint err = 0;\n\n\tif (sfd->vm_ops->set_policy)\n\t\terr = sfd->vm_ops->set_policy(vma, new);\n\treturn err;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void msix_mmio_write(void *opaque, target_phys_addr_t addr,\n                            uint64_t val, unsigned size)\n{\n    PCIDevice *dev = opaque;\n    unsigned int offset = addr & (MSIX_PAGE_SIZE - 1) & ~0x3;\n    int vector = offset / PCI_MSIX_ENTRY_SIZE;\n    pci_set_long(dev->msix_table_page + offset, val);\n    msix_handle_mask_update(dev, vector);",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void test_tco2_status_bits(void)\n\n{\n\n    TestData d;\n\n    uint16_t ticks = 8;\n\n    uint16_t val;\n\n    int ret;\n\n\n\n    d.args = NULL;\n\n    d.noreboot = true;\n\n    test_init(&d);\n\n\n\n    stop_tco(&d);\n\n    clear_tco_status(&d);\n\n    reset_on_second_timeout(true);\n\n    set_tco_timeout(&d, ticks);\n\n    load_tco(&d);\n\n    start_tco(&d);\n\n    clock_step(ticks * TCO_TICK_NSEC * 2);\n\n\n\n    val = qpci_io_readw(d.dev, d.tco_io_base + TCO2_STS);\n\n    ret = val & (TCO_SECOND_TO_STS | TCO_BOOT_STS) ? 1 : 0;\n\n    g_assert(ret == 1);\n\n    qpci_io_writew(d.dev, d.tco_io_base + TCO2_STS, val);\n\n    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO2_STS), ==, 0);\n\n    qtest_end();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void qio_channel_test_validate(QIOChannelTest *test)\n\n{\n\n    g_assert_cmpint(memcmp(test->input,\n\n                           test->output,\n\n                           test->len), ==, 0);\n\n    g_assert(test->readerr == NULL);\n\n    g_assert(test->writeerr == NULL);\n\n\n\n    g_free(test->inputv);\n\n    g_free(test->outputv);\n\n    g_free(test->input);\n\n    g_free(test->output);\n\n    g_free(test);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n {\n \tstruct compat_timex tx32;\n \n \tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n \t\treturn -EFAULT;\n \n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void test_source_notify(void)\n\n{\n\n    while (g_main_context_iteration(NULL, false));\n\n    aio_notify(ctx);\n\n    g_assert(g_main_context_iteration(NULL, true));\n\n    g_assert(!g_main_context_iteration(NULL, false));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, PAGE_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\n\n error:\n\treturn ret;\n\n} /* end keyctl_join_session_keyring() */",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int sisusb_write_memio_byte(struct sisusb_usb_data *sisusb, int type,\n\t\tu32 addr, u8 data)\n{\n\tstruct sisusb_packet packet;\n\n\tpacket.header  = (1 << (addr & 3)) | (type << 6);\n\tpacket.address = addr & ~3;\n\tpacket.data    = data << ((addr & 3) << 3);\n\treturn sisusb_send_packet(sisusb, 10, &packet);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char print_buffer[256];\n\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n\n      if(len > width) {\n        size_t cut = width-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          /* not a single cutting position was found, just cut it at the\n             max text width then! */\n          cut = width-1;\n\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut + 1; /* skip the space too */\n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void RootWindow::ScheduleDraw() {\n  if (compositor_lock_) {\n    draw_on_compositor_unlock_ = true;\n  } else if (!defer_draw_scheduling_) {\n    defer_draw_scheduling_ = true;\n    MessageLoop::current()->PostTask(\n        FROM_HERE,\n        base::Bind(&RootWindow::Draw, schedule_paint_factory_.GetWeakPtr()));\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static ssize_t mp_user_getxattr(FsContext *ctx, const char *path,\n\n                                const char *name, void *value, size_t size)\n\n{\n\n    char *buffer;\n\n    ssize_t ret;\n\n\n\n    if (strncmp(name, \"user.virtfs.\", 12) == 0) {\n\n        /*\n\n         * Don't allow fetch of user.virtfs namesapce\n\n         * in case of mapped security\n\n         */\n\n        errno = ENOATTR;\n\n        return -1;\n\n    }\n\n    buffer = rpath(ctx, path);\n\n    ret = lgetxattr(buffer, name, value, size);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void ap_cancel_message(struct ap_device *ap_dev, struct ap_message *ap_msg)\n{\n\tstruct ap_message *tmp;\n\n\tspin_lock_bh(&ap_dev->lock);\n\tif (!list_empty(&ap_msg->list)) {\n\t\tlist_for_each_entry(tmp, &ap_dev->pendingq, list)\n\t\t\tif (tmp->psmid == ap_msg->psmid) {\n\t\t\t\tap_dev->pendingq_count--;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\tap_dev->requestq_count--;\n\tfound:\n\t\tlist_del_init(&ap_msg->list);\n\t}\n\tspin_unlock_bh(&ap_dev->lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void vga_unprotect(struct i740fb_par *par)\n{\n\t/* reenable display */\n\ti740outreg_mask(par, VGA_SEQ_I, VGA_SEQ_CLOCK_MODE, 0, 0x20);\n\n\ti740inb(par, 0x3DA);\n\ti740outb(par, VGA_ATT_W, 0x20);\t/* disable palette access */\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int x509_get_sig( unsigned char **p, const unsigned char *end, x509_buf *sig )\n{\n    int ret;\n    size_t len;\n\n    if( ( end - *p ) < 1 )\n        return( POLARSSL_ERR_X509_INVALID_SIGNATURE +\n                POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    sig->tag = **p;\n\n    if( ( ret = asn1_get_bitstring_null( p, end, &len ) ) != 0 )\n        return( POLARSSL_ERR_X509_INVALID_SIGNATURE + ret );\n\n    sig->len = len;\n    sig->p = *p;\n\n    *p += len;\n\n    return( 0 );\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int rb_head_page_set_head(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t struct buffer_page *head,\n\t\t\t\t struct buffer_page *prev,\n\t\t\t\t int old_flag)\n{\n\treturn rb_head_page_set(cpu_buffer, head, prev,\n\t\t\t\told_flag, RB_PAGE_HEAD);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int hci_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct hci_ufilter uf;\n\tstruct sock *sk = sock->sk;\n\tint len, opt, err = 0;\n\n\tBT_DBG(\"sk %p, opt %d\", sk, optname);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tif (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (optname) {\n\tcase HCI_DATA_DIR:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_DIR)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase HCI_TIME_STAMP:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_TSTAMP)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase HCI_FILTER:\n \t\t{\n \t\t\tstruct hci_filter *f = &hci_pi(sk)->filter;\n \n \t\t\tuf.type_mask = f->type_mask;\n \t\t\tuf.opcode    = f->opcode;\n \t\t\tuf.event_mask[0] = *((u32 *) f->event_mask + 0);\n\t\t\tuf.event_mask[1] = *((u32 *) f->event_mask + 1);\n\t\t}\n\n\t\tlen = min_t(unsigned int, len, sizeof(uf));\n\t\tif (copy_to_user(optval, &uf, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "impl_permission_manager_list (EphyPermissionManager *manager,\n                              const char *type)\n{\n  GList *list = NULL;\n  return list;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static MagickOffsetType TIFFTellCustomStream(void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  return(profile->offset);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "QPDFWriter::write()\n{\n    doWriteSetup();\n\n    // Set up progress reporting. We spent about equal amounts of time\n    // preparing and writing one pass. To get a rough estimate of\n    // progress, we track handling of indirect objects. For linearized\n    // files, we write two passes. events_expected is an\n    // approximation, but it's good enough for progress reporting,\n    // which is mostly a guess anyway.\n    this->m->events_expected = (\n        this->m->pdf.getObjectCount() * (this->m->linearized ? 3 : 2));\n\n    prepareFileForWrite();\n\n    if (this->m->linearized)\n    {\n\twriteLinearized();\n    }\n    else\n    {\n\twriteStandard();\n    }\n\n    this->m->pipeline->finish();\n    if (this->m->close_file)\n    {\n\tfclose(this->m->file);\n    }\n    this->m->file = 0;\n    if (this->m->buffer_pipeline)\n    {\n\tthis->m->output_buffer = this->m->buffer_pipeline->getBuffer();\n\tthis->m->buffer_pipeline = 0;\n    }\n    indicateProgress(false, true);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline void ModulateHSI(const double percent_hue,\n  const double percent_saturation,const double percent_intensity,double *red,\n  double *green,double *blue)\n{\n  double\n    intensity,\n    hue,\n    saturation;\n\n  /*\n    Increase or decrease color intensity, saturation, or hue.\n  */\n  ConvertRGBToHSI(*red,*green,*blue,&hue,&saturation,&intensity);\n  hue+=0.5*(0.01*percent_hue-1.0);\n  while (hue < 0.0)\n    hue+=1.0;\n  while (hue > 1.0)\n    hue-=1.0;\n  saturation*=0.01*percent_saturation;\n  intensity*=0.01*percent_intensity;\n  ConvertHSIToRGB(hue,saturation,intensity,red,green,blue);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n\t\treturn -EBUSY;\n\t}\n\n\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tclear_bit(0, &chip->is_open);\n\t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_set(&chip->data_pending, 0);\n\n\tfile->private_data = chip;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int am_unhex_digit(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 0xa;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 0xa;\n    } else {\n        return -1;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int dca_convert_bitstream(uint8_t * src, int src_size, uint8_t * dst,\n                          int max_size)\n{\n    uint32_t mrk;\n    int i, tmp;\n    uint16_t *ssrc = (uint16_t *) src, *sdst = (uint16_t *) dst;\n    PutBitContext pb;\n    mrk = AV_RB32(src);\n    switch (mrk) {\n    case DCA_MARKER_RAW_BE:\n        memcpy(dst, src, FFMIN(src_size, max_size));\n        return FFMIN(src_size, max_size);\n    case DCA_MARKER_RAW_LE:\n        for (i = 0; i < (FFMIN(src_size, max_size) + 1) >> 1; i++)\n            *sdst++ = bswap_16(*ssrc++);\n        return FFMIN(src_size, max_size);\n    case DCA_MARKER_14B_BE:\n    case DCA_MARKER_14B_LE:\n        init_put_bits(&pb, dst, max_size);\n        for (i = 0; i < (src_size + 1) >> 1; i++, src += 2) {\n            tmp = ((mrk == DCA_MARKER_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;\n            put_bits(&pb, 14, tmp);\n        }\n        flush_put_bits(&pb);\n        return (put_bits_count(&pb) + 7) >> 3;\n    default:\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static FlatView *address_space_get_flatview(AddressSpace *as)\n\n{\n\n    FlatView *view;\n\n\n\n    rcu_read_lock();\n\n    view = atomic_rcu_read(&as->current_map);\n\n    flatview_ref(view);\n\n    rcu_read_unlock();\n\n    return view;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n } /* header_put_be_int */",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "WavInFile::WavInFile(const char *fileName)\r\n{\r\n    // Try to open the file for reading\r\n    fptr = fopen(fileName, \"rb\");\r\n    if (fptr == NULL) \r\n    {\r\n        // didn't succeed\r\n        string msg = \"Error : Unable to open file \\\"\";\r\n        msg += fileName;\r\n        msg += \"\\\" for reading.\";\r\n        ST_THROW_RT_ERROR(msg.c_str());\r\n    }\r\n\r\n    init();\r\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void gen_bxx(DisasContext *dc, uint32_t code, uint32_t flags)\n\n{\n\n    I_TYPE(instr, code);\n\n\n\n    TCGLabel *l1 = gen_new_label();\n\n    tcg_gen_brcond_tl(flags, dc->cpu_R[instr.a], dc->cpu_R[instr.b], l1);\n\n    gen_goto_tb(dc, 0, dc->pc + 4);\n\n    gen_set_label(l1);\n\n    gen_goto_tb(dc, 1, dc->pc + 4 + (instr.imm16s & -4));\n\n    dc->is_jmp = DISAS_TB_JUMP;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void vp8_decode_mb_row_no_filter(AVCodecContext *avctx, void *tdata,\n\n                                        int jobnr, int threadnr)\n\n{\n\n    decode_mb_row_no_filter(avctx, tdata, jobnr, threadnr, 0);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int pci_ich9_uninit(PCIDevice *dev)\n\n{\n\n    struct AHCIPCIState *d;\n\n    d = DO_UPCAST(struct AHCIPCIState, card, dev);\n\n\n\n    if (msi_enabled(dev)) {\n\n        msi_uninit(dev);\n\n    }\n\n\n\n    qemu_unregister_reset(ahci_reset, d);\n\n    ahci_uninit(&d->ahci);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "getCharFromDots (widechar d)\n{\n  CharOrDots *cdPtr = getCharOrDots (d, 1);\n  if (cdPtr)\n    return cdPtr->found;\n  return ' ';\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int ethtool_get_value(struct net_device *dev, char __user *useraddr,\n\t\t\t     u32 cmd, u32 (*actor)(struct net_device *))\n{\n\tstruct ethtool_value edata = { .cmd = cmd };\n\n\tif (!actor)\n\t\treturn -EOPNOTSUPP;\n\n\tedata.data = actor(dev);\n\n\tif (copy_to_user(useraddr, &edata, sizeof(edata)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int oauth2_try_parse_jwt(const struct oauth2_settings *set,\n\t\t\t const char *token, ARRAY_TYPE(oauth2_field) *fields,\n\t\t\t bool *is_jwt_r, const char **error_r)\n{\n\tconst char *const *blobs = t_strsplit(token, \".\");\n\tint ret;\n\n\ti_assert(set->key_dict != NULL);\n\n\t/* we don't know if it's JWT token yet */\n\t*is_jwt_r = FALSE;\n\n\tif (str_array_length(blobs) != 3) {\n\t\t*error_r = \"Not a JWT token\";\n\t\treturn -1;\n\t}\n\n\t/* attempt to decode header */\n\tbuffer_t *header =\n\t\tt_base64url_decode_str(BASE64_DECODE_FLAG_NO_PADDING, blobs[0]);\n\n\tif (header->used == 0) {\n\t\t*error_r = \"Not a JWT token\";\n\t\treturn -1;\n\t}\n\n\tstruct json_tree *header_tree;\n\tif (oauth2_json_tree_build(header, &header_tree, error_r) < 0)\n\t\treturn -1;\n\n\tconst char *alg, *kid;\n\tret = oauth2_jwt_header_process(header_tree, &alg, &kid, error_r);\n\tjson_tree_deinit(&header_tree);\n\tif (ret < 0)\n\t\treturn -1;\n\n\t/* it is now assumed to be a JWT token */\n\t*is_jwt_r = TRUE;\n\n\tif (kid == NULL)\n\t\tkid = \"default\";\n\telse if (*kid == '\\0') {\n\t\t*error_r = \"'kid' field is empty\";\n\t\treturn -1;\n\t}\n\n\tsize_t pos = strcspn(kid, \"./%\");\n\tif (pos < strlen(kid)) {\n\t\t/* sanitize kid, cannot allow dots or / in it, so we encode them\n\t\t */\n\t\tstring_t *new_kid = t_str_new(strlen(kid));\n\t\t/* put initial data */\n\t\tstr_append_data(new_kid, kid, pos);\n\t\tfor (const char *c = kid+pos; *c != '\\0'; c++) {\n\t\t\tswitch (*c) {\n\t\t\tcase '.':\n\t\t\t\tstr_append(new_kid, \"%2e\");\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tstr_append(new_kid, \"%2f\");\n\t\t\t\tbreak;\n\t\t\tcase '%':\n\t\t\t\tstr_append(new_kid, \"%25\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstr_append_c(new_kid, *c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tkid = str_c(new_kid);\n\t}\n\n\t/* parse body */\n\tstruct json_tree *body_tree;\n\tbuffer_t *body =\n\t\tt_base64url_decode_str(BASE64_DECODE_FLAG_NO_PADDING, blobs[1]);\n\tif (oauth2_json_tree_build(body, &body_tree, error_r) == -1)\n\t\treturn -1;\n\tret = oauth2_jwt_body_process(set, alg, kid, fields, body_tree, blobs,\n\t\t\t\t      error_r);\n\tjson_tree_deinit(&body_tree);\n\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "path_length(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tfloat8\t\tresult = 0.0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tint\t\t\tiprev;\n\n\t\tif (i > 0)\n\t\t\tiprev = i - 1;\n\t\telse\n\t\t{\n\t\t\tif (!path->closed)\n\t\t\t\tcontinue;\n\t\t\tiprev = path->npts - 1;\t\t/* include the closure segment */\n\t\t}\n\n\t\tresult += point_dt(&path->p[iprev], &path->p[i]);\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void ib_uverbs_release_dev(struct device *device)\n{\n\tstruct ib_uverbs_device *dev =\n\t\t\tcontainer_of(device, struct ib_uverbs_device, dev);\n\n\tuverbs_destroy_api(dev->uapi);\n\tcleanup_srcu_struct(&dev->disassociate_srcu);\n\tkfree(dev);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "smp_fetch_capture_res_ver(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                          const struct arg *args, struct sample *smp, const char *kw)\n{\n\tstruct http_txn *txn = l7;\n\n\tif (txn->rsp.msg_state < HTTP_MSG_HDR_FIRST)\n\t\treturn 0;\n\n\tif (txn->rsp.flags & HTTP_MSGF_VER_11)\n\t\tsmp->data.str.str = \"HTTP/1.1\";\n\telse\n\t\tsmp->data.str.str = \"HTTP/1.0\";\n\n\tsmp->data.str.len = 8;\n\tsmp->type  = SMP_T_STR;\n\tsmp->flags = SMP_F_CONST;\n\treturn 1;\n\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "_TIFFprintAscii(FILE* fd, const char* cp)\n{\n\t_TIFFprintAsciiBounded( fd, cp, strlen(cp));\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "vte_terminal_emit_lower_window(VteTerminal *terminal)\n{\n\t_vte_debug_print(VTE_DEBUG_SIGNALS,\n\t\t\t\"Emitting `lower-window'.\\n\");\n\tg_signal_emit_by_name(terminal, \"lower-window\");\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "TestForReentrancy()\n      : cb_already_run(false),\n        cb(BindRepeating(&TestForReentrancy::AssertCBIsNull,\n                         Unretained(this))) {}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void qemu_add_balloon_handler(QEMUBalloonEvent *func, void *opaque)\n\n{\n\n    balloon_event_fn = func;\n\n    balloon_opaque = opaque;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int snd_usb_mixer_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t unsigned int size, unsigned int __user *_tlv)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tDECLARE_TLV_DB_MINMAX(scale, 0, 0);\n\n\tif (size < sizeof(scale))\n\t\treturn -ENOMEM;\n\tif (cval->min_mute)\n\t\tscale[0] = SNDRV_CTL_TLVT_DB_MINMAX_MUTE;\n\tscale[2] = cval->dBmin;\n\tscale[3] = cval->dBmax;\n\tif (copy_to_user(_tlv, scale, sizeof(scale)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void cparams(JF, js_Ast *list)\n{\n\tF->numparams = listlength(list);\n\twhile (list) {\n\t\taddlocal(J, F, list->a, 0);\n\t\tlist = list->b;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void __scm_destroy(struct scm_cookie *scm)\n{\n\tstruct scm_fp_list *fpl = scm->fp;\n\tint i;\n\n\tif (fpl) {\n\t\tscm->fp = NULL;\n\t\tfor (i=fpl->count-1; i>=0; i--)\n\t\t\tfput(fpl->fp[i]);\n\t\tkfree(fpl);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "Color FrameView::baseBackgroundColor() const\n{\n    return m_baseBackgroundColor;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\n\t\tbase_name = _g_path_get_relative_basename ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\tg_file_query_info_async (destination,\n\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t odata);\n\n\t\tg_object_unref (destination);\n\n\t\treturn;\n\t}\n\n\tif (odata->edata->file_list != NULL) {\n\t\t/* speed optimization: passing NULL when extracting all the\n\t\t * files is faster if the command supports the\n\t\t * propCanExtractAll property. */\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\n\tg_free (odata);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool DCTStream::isBinary(bool last)\n{\n    return str->isBinary(true);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "const AtomicString& HTMLFormControlElement::autocapitalize() const {\n  if (!FastGetAttribute(kAutocapitalizeAttr).IsEmpty())\n    return HTMLElement::autocapitalize();\n\n  if (HTMLFormElement* form = Form())\n    return form->autocapitalize();\n\n  return g_empty_atom;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "const struct bpf_func_proto * __weak bpf_get_trace_printk_proto(void)\n{\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void ext4_put_nojournal(handle_t *handle)\n{\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt == 0);\n\n\tref_cnt--;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n\n   while (new_len > string->space)\n     {\n       if (string->space == 0)\n\tstring->space = 1;\n       else\n\tstring->space *= 2;\n      if (string->space < 0)\n \t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n \t}\n     }\n \n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int __netif_receive_skb_one_core(struct sk_buff *skb, bool pfmemalloc)\n{\n\tstruct net_device *orig_dev = skb->dev;\n\tstruct packet_type *pt_prev = NULL;\n\tint ret;\n\n\tret = __netif_receive_skb_core(skb, pfmemalloc, &pt_prev);\n\tif (pt_prev)\n\t\tret = INDIRECT_CALL_INET(pt_prev->func, ipv6_rcv, ip_rcv, skb,\n\t\t\t\t\t skb->dev, pt_prev, orig_dev);\n\treturn ret;",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void ff_h264_free_tables(H264Context *h, int free_rbsp)\n{\n    int i;\n    H264Context *hx;\n\n    av_freep(&h->intra4x4_pred_mode);\n    av_freep(&h->chroma_pred_mode_table);\n    av_freep(&h->cbp_table);\n    av_freep(&h->mvd_table[0]);\n    av_freep(&h->mvd_table[1]);\n    av_freep(&h->direct_table);\n    av_freep(&h->non_zero_count);\n    av_freep(&h->slice_table_base);\n    h->slice_table = NULL;\n    av_freep(&h->list_counts);\n\n    av_freep(&h->mb2b_xy);\n    av_freep(&h->mb2br_xy);\n\n    av_buffer_pool_uninit(&h->qscale_table_pool);\n    av_buffer_pool_uninit(&h->mb_type_pool);\n    av_buffer_pool_uninit(&h->motion_val_pool);\n    av_buffer_pool_uninit(&h->ref_index_pool);\n\n     if (free_rbsp && h->DPB) {\n         for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)\n             ff_h264_unref_picture(h, &h->DPB[i]);\n         av_freep(&h->DPB);\n     } else if (h->DPB) {\n         for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)\n            h->DPB[i].needs_realloc = 1;\n    }\n\n    h->cur_pic_ptr = NULL;\n\n    for (i = 0; i < H264_MAX_THREADS; i++) {\n        hx = h->thread_context[i];\n        if (!hx)\n            continue;\n        av_freep(&hx->top_borders[1]);\n        av_freep(&hx->top_borders[0]);\n        av_freep(&hx->bipred_scratchpad);\n        av_freep(&hx->edge_emu_buffer);\n        av_freep(&hx->dc_val_base);\n        av_freep(&hx->er.mb_index2xy);\n        av_freep(&hx->er.error_status_table);\n        av_freep(&hx->er.er_temp_buffer);\n        av_freep(&hx->er.mbintra_table);\n        av_freep(&hx->er.mbskip_table);\n\n        if (free_rbsp) {\n            av_freep(&hx->rbsp_buffer[1]);\n            av_freep(&hx->rbsp_buffer[0]);\n            hx->rbsp_buffer_size[0] = 0;\n            hx->rbsp_buffer_size[1] = 0;\n        }\n        if (i)\n            av_freep(&h->thread_context[i]);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "strip_leading_slashes (char *name, int strip_leading)\n{\n  int s = strip_leading;\n  char *p, *n;\n\n  for (p = n = name;  *p;  p++)\n    {\n      if (ISSLASH (*p))\n\t{\n\t  while (ISSLASH (p[1]))\n\t    p++;\n\t  if (strip_leading < 0 || --s >= 0)\n\t      n = p+1;\n\t}\n    }\n  if ((strip_leading < 0 || s <= 0) && *n)\n    {\n      memmove (name, n, strlen (n) + 1);\n      return true;\n    }\n  else\n    return false;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void Jsi_MapDelete (Jsi_Map *mapPtr) {\n    SIGASSERTV(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: Jsi_HashDelete(mapPtr->v.hash); break;\n        case JSI_MAP_TREE: Jsi_TreeDelete(mapPtr->v.tree); break;\n        case JSI_MAP_LIST: Jsi_ListDelete(mapPtr->v.list); break;\n        default: return;\n    }\n    Jsi_Free(mapPtr);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "mrb_gc_mark(mrb_state *mrb, struct RBasic *obj)\n{\n  if (obj == 0) return;\n  if (!is_white(obj)) return;\n  mrb_assert((obj)->tt != MRB_TT_FREE);\n  add_gray_list(mrb, &mrb->gc, obj);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void pdf_run_M(fz_context *ctx, pdf_processor *proc, float miterlimit)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_gstate *gstate = pdf_flush_text(ctx, pr);\n\n\tpr->dev->flags &= ~FZ_DEVFLAG_MITERLIMIT_UNDEFINED;\n\tgstate->stroke_state = fz_unshare_stroke_state(ctx, gstate->stroke_state);\n\tgstate->stroke_state->miterlimit = miterlimit;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "inline bool colorSpaceHasAlpha(J_COLOR_SPACE) { return false; }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "Content_Obj Parser::parse_content_directive()\n  {\n    ParserState call_pos = pstate;\n    Arguments_Obj args = parse_arguments();\n\n    return SASS_MEMORY_NEW(Content, call_pos, args);\n  }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t      const void *data, int offset, int len)\n{\n\tstruct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\n\treturn __kvm_write_guest_page(slot, gfn, data, offset, len);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "open_temp_exec_file_name (char *name, int flags)\n{\n  int fd;\n\n#ifdef HAVE_MKOSTEMP\n  fd = mkostemp (name, flags);\n#else\n  fd = mkstemp (name);\n#endif\n\n  if (fd != -1)\n    unlink (name);\n\n  return fd;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "MONGO_EXPORT int mongo_run_command( mongo *conn, const char *db, const bson *command,\n                                    bson *out ) {\n    int ret = MONGO_OK;\n    bson response = {NULL, 0};\n    bson fields;\n    int sl = strlen( db );\n    char *ns = bson_malloc( sl + 5 + 1 ); /* \".$cmd\" + nul */\n    int res, success = 0;\n\n    strcpy( ns, db );\n    strcpy( ns+sl, \".$cmd\" );\n\n    res = mongo_find_one( conn, ns, command, bson_empty( &fields ), &response );\n    bson_free( ns );\n\n    if( res != MONGO_OK )\n        ret = MONGO_ERROR;\n    else {\n        bson_iterator it;\n        if( bson_find( &it, &response, \"ok\" ) )\n            success = bson_iterator_bool( &it );\n\n        if( !success ) {\n            conn->err = MONGO_COMMAND_FAILED;\n            bson_destroy( &response );\n            ret = MONGO_ERROR;\n        }\n        else {\n            if( out )\n                *out = response;\n            else\n                bson_destroy( &response );\n        }\n    }\n    return ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline void ohci_intr_update(OHCIState *ohci)\n{\n    int level = 0;\n\n    if ((ohci->intr & OHCI_INTR_MIE) &&\n        (ohci->intr_status & ohci->intr))\n        level = 1;\n\n    qemu_set_irq(ohci->irq, level);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "evutil_open_closeonexec_(const char *pathname, int flags, unsigned mode)\n{\n\tint fd;\n\n#ifdef O_CLOEXEC\n\tfd = open(pathname, flags|O_CLOEXEC, (mode_t)mode);\n\tif (fd >= 0 || errno == EINVAL)\n\t\treturn fd;\n\t/* If we got an EINVAL, fall through and try without O_CLOEXEC */\n#endif\n\tfd = open(pathname, flags, (mode_t)mode);\n\tif (fd < 0)\n\t\treturn -1;\n\n#if defined(FD_CLOEXEC)\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\treturn fd;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int mkv_field_order(MatroskaDemuxContext *matroska, int64_t field_order)\n\n{\n\n    int major, minor, micro, bttb = 0;\n\n\n\n    /* workaround a bug in our Matroska muxer, introduced in version 57.36 alongside\n\n     * this function, and fixed in 57.52 */\n\n    if (sscanf(matroska->muxingapp, \"Lavf%d.%d.%d\", &major, &minor, &micro) == 3)\n\n        bttb = (major == 57 && minor >= 36 && minor <= 51 && micro >= 100);\n\n\n\n    switch (field_order) {\n\n    case MATROSKA_VIDEO_FIELDORDER_PROGRESSIVE:\n\n        return AV_FIELD_PROGRESSIVE;\n\n    case MATROSKA_VIDEO_FIELDORDER_UNDETERMINED:\n\n        return AV_FIELD_UNKNOWN;\n\n    case MATROSKA_VIDEO_FIELDORDER_TT:\n\n        return AV_FIELD_TT;\n\n    case MATROSKA_VIDEO_FIELDORDER_BB:\n\n        return AV_FIELD_BB;\n\n    case MATROSKA_VIDEO_FIELDORDER_BT:\n\n        return bttb ? AV_FIELD_TB : AV_FIELD_BT;\n\n    case MATROSKA_VIDEO_FIELDORDER_TB:\n\n        return bttb ? AV_FIELD_BT : AV_FIELD_TB;\n\n    default:\n\n        return AV_FIELD_UNKNOWN;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int cx24116_set_symbolrate(struct cx24116_state *state, u32 rate)\n{\n\tdprintk(\"%s(%d)\\n\", __func__, rate);\n\n\t/*  check if symbol rate is within limits */\n\tif ((rate > state->frontend.ops.info.symbol_rate_max) ||\n\t    (rate < state->frontend.ops.info.symbol_rate_min)) {\n\t\tdprintk(\"%s() unsupported symbol_rate = %d\\n\", __func__, rate);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tstate->dnxt.symbol_rate = rate;\n\tdprintk(\"%s() symbol_rate = %d\\n\", __func__, rate);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void load_cpu(const char *fname) {\n\tif (!fname)\n\t\treturn;\n\n\tFILE *fp = fopen(fname, \"re\");\n\tif (fp) {\n\t\tunsigned tmp;\n\t\tint rv = fscanf(fp, \"%x\", &tmp);\n\t\tif (rv)\n\t\t\tcfg.cpus = (uint32_t) tmp;\n\t\tfclose(fp);\n\t}\n\telse\n\t\tfwarning(\"cannot load cpu affinity mask\\n\");\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static coroutine_fn int parallels_co_read(BlockDriverState *bs, int64_t sector_num,\n                                          uint8_t *buf, int nb_sectors)\n{\n    int ret;\n    BDRVParallelsState *s = bs->opaque;\n    qemu_co_mutex_lock(&s->lock);\n    ret = parallels_read(bs, sector_num, buf, nb_sectors);\n    qemu_co_mutex_unlock(&s->lock);\n    return ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int fuse_release(struct inode *inode, struct file *file)\n{\n\tfuse_release_common(file, FUSE_RELEASE);\n\n\t/* return value is ignored by VFS */\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "/**\n      \\param img Image to insert.\n    **/",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)\n{\n   unsigned s1 = adler & 0xffff;\n   unsigned s2 = (adler >> 16) & 0xffff;\n\n  while(len > 0)\n  {\n    /*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/\n    unsigned amount = len > 5550 ? 5550 : len;\n    len -= amount;\n    while(amount > 0)\n    {\n      s1 += (*data++);\n      s2 += s1;\n      amount--;\n    }\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s2 << 16) | s1;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void __init __acpi_unmap_table(char *map, unsigned long size)\n{\n\tif (!map || !size)\n\t\treturn;\n\n\tearly_iounmap(map, size);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int dss_read_metadata_date(AVFormatContext *s, unsigned int offset,\n\n                                  const char *key)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    char datetime[64], string[DSS_TIME_SIZE + 1] = { 0 };\n\n    int y, month, d, h, minute, sec;\n\n    int ret;\n\n\n\n    avio_seek(pb, offset, SEEK_SET);\n\n\n\n    ret = avio_read(s->pb, string, DSS_TIME_SIZE);\n\n    if (ret < DSS_TIME_SIZE)\n\n        return ret < 0 ? ret : AVERROR_EOF;\n\n\n\n    sscanf(string, \"%2d%2d%2d%2d%2d%2d\", &y, &month, &d, &h, &minute, &sec);\n\n    /* We deal with a two-digit year here, so set the default date to 2000\n\n     * and hope it will never be used in the next century. */\n\n    snprintf(datetime, sizeof(datetime), \"%.4d-%.2d-%.2dT%.2d:%.2d:%.2d\",\n\n             y + 2000, month, d, h, minute, sec);\n\n    return av_dict_set(&s->metadata, key, datetime, 0);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "choose_filters(struct archive_read *a)\n {\n\tint number_bidders, i, bid, best_bid;\n \tstruct archive_read_filter_bidder *bidder, *best_bidder;\n \tstruct archive_read_filter *filter;\n \tssize_t avail;\n \tint r;\n \n\tfor (;;) {\n \t\tnumber_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);\n \n \t\tbest_bid = 0;\n\t\tbest_bidder = NULL;\n\n\t\tbidder = a->bidders;\n\t\tfor (i = 0; i < number_bidders; i++, bidder++) {\n\t\t\tif (bidder->bid != NULL) {\n\t\t\t\tbid = (bidder->bid)(bidder, a->filter);\n\t\t\t\tif (bid > best_bid) {\n\t\t\t\t\tbest_bid = bid;\n\t\t\t\t\tbest_bidder = bidder;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* If no bidder, we're done. */\n\t\tif (best_bidder == NULL) {\n\t\t\t/* Verify the filter by asking it for some data. */\n\t\t\t__archive_read_filter_ahead(a->filter, 1, &avail);\n\t\t\tif (avail < 0) {\n\t\t\t\t__archive_read_close_filters(a);\n\t\t\t\t__archive_read_free_filters(a);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->archive.compression_name = a->filter->name;\n\t\t\ta->archive.compression_code = a->filter->code;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\n\t\tfilter\n\t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n\t\tif (filter == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfilter->bidder = best_bidder;\n\t\tfilter->archive = a;\n\t\tfilter->upstream = a->filter;\n\t\ta->filter = filter;\n\t\tr = (best_bidder->init)(a->filter);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t__archive_read_close_filters(a);\n\t\t\t__archive_read_free_filters(a);\n \t\t\treturn (ARCHIVE_FATAL);\n \t\t}\n \t}\n }",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int64_t OpLevelCostEstimator::CalculateOutputSize(const OpInfo& op_info,\n                                                  bool* found_unknown_shapes) {\n  int64_t total_output_size = 0;\n  // Use float as default for calculations.\n  for (const auto& output : op_info.outputs()) {\n    DataType dt = output.dtype();\n    const auto& original_output_shape = output.shape();\n    int64_t output_size = DataTypeSize(BaseType(dt));\n    int num_dims = std::max(1, original_output_shape.dim_size());\n    auto output_shape = MaybeGetMinimumShape(original_output_shape, num_dims,\n                                             found_unknown_shapes);\n    for (const auto& dim : output_shape.dim()) {\n      output_size *= dim.size();\n    }\n    total_output_size += output_size;\n    VLOG(1) << \"Output Size: \" << output_size\n            << \" Total Output Size:\" << total_output_size;\n  }\n  return total_output_size;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "AVFrame *ff_framequeue_take(FFFrameQueue *fq)\n\n{\n\n    FFFrameBucket *b;\n\n\n\n    check_consistency(fq);\n\n    av_assert1(fq->queued);\n\n    b = bucket(fq, 0);\n\n    fq->queued--;\n\n    fq->tail++;\n\n    fq->tail &= fq->allocated - 1;\n\n    fq->total_frames_tail++;\n\n    fq->total_samples_tail += b->frame->nb_samples;\n\n\n    check_consistency(fq);\n\n    return b->frame;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void print_maps(struct pid_info_t* info)\n {\n     FILE *maps;\n     size_t offset;\n     char device[10];\n     long int inode;\n    char file[PATH_MAX];\n \n     strlcat(info->path, \"maps\", sizeof(info->path));\n \n    maps = fopen(info->path, \"r\");\n\n     if (!maps)\n         goto out;\n \n    while (fscanf(maps, \"%*x-%*x %*s %zx %s %ld %s\\n\", &offset, device, &inode,\n            file) == 4) {\n         if (inode == 0 || !strcmp(device, \"00:00\"))\n             continue;\n\n        printf(\"%-9s %5d %10s %4s %9s %18s %9zd %10ld %s\\n\",\n                info->cmdline, info->pid, info->user, \"mem\",\n \"???\", device, offset, inode, file);\n }\n\n    fclose(maps);\n\nout:\n    info->path[info->parent_length] = '\\0';\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "ut64 Elf_(r_bin_elf_get_section_addr_end)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\treturn section? section->rva + section->size: UT64_MAX;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "start_pass_merged_upsample(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n\n  /* Mark the spare buffer empty */\n  upsample->spare_full = FALSE;\n  /* Initialize total-height counter for detecting bottom of image */\n  upsample->rows_to_go = cinfo->output_height;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static u32 vvc_ctb_to_tile_row_bd(VVCSliceInfo *si, u32 ctb_addr_y)\n{\n\tu32 i, tile_y = 0;\n\tu32 tile_row_bd_val = 0;\n\n\tfor (i=0; i <= si->pps->pic_height_in_ctbsY; i++) {\n\t\tif (i == tile_row_bd_val + si->pps->tile_rows_height_ctb[tile_y]) {\n\t\t\ttile_row_bd_val += si->pps->tile_rows_height_ctb[tile_y];\n\t\t\ttile_y++;\n\t\t}\n\t\tif (ctb_addr_y == i) return tile_row_bd_val;\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int adaptive_cb_search(const int16_t *adapt_cb, float *work,\n\n                              const float *coefs, float *data)\n\n{\n\n    int i, best_vect;\n\n    float score, gain, best_score, best_gain;\n\n    float exc[BLOCKSIZE];\n\n\n\n    gain = best_score = 0;\n\n    for (i = BLOCKSIZE / 2; i <= BUFFERSIZE; i++) {\n\n        create_adapt_vect(exc, adapt_cb, i);\n\n        get_match_score(work, coefs, exc, NULL, NULL, data, &score, &gain);\n\n        if (score > best_score) {\n\n            best_score = score;\n\n            best_vect = i;\n\n            best_gain = gain;\n\n        }\n\n    }\n\n    if (!best_score)\n\n        return 0;\n\n\n\n    /**\n\n     * Re-calculate the filtered vector from the vector with maximum match score\n\n     * and remove its contribution from input data.\n\n     */\n\n    create_adapt_vect(exc, adapt_cb, best_vect);\n\n    ff_celp_lp_synthesis_filterf(work, coefs, exc, BLOCKSIZE, LPC_ORDER);\n\n    for (i = 0; i < BLOCKSIZE; i++)\n\n        data[i] -= best_gain * work[i];\n\n    return best_vect - BLOCKSIZE / 2 + 1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void ssl_write_renegotiation_ext( ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t *olen )\n{\n    unsigned char *p = buf;\n\n    *olen = 0;\n\n    if( ssl->renegotiation != SSL_RENEGOTIATION )\n        return;\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding renegotiation extension\" ) );\n\n    /*\n     * Secure renegotiation\n     */\n    *p++ = (unsigned char)( ( TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = ( ssl->verify_data_len + 1 ) & 0xFF;\n    *p++ = ssl->verify_data_len & 0xFF;\n\n    memcpy( p, ssl->own_verify_data, ssl->verify_data_len );\n\n    *olen = 5 + ssl->verify_data_len;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static bool binder_has_work_ilocked(struct binder_thread *thread,\n\t\t\t\t    bool do_proc_work)\n{\n\treturn thread->process_todo ||\n\t\tthread->looper_need_return ||\n\t\t(do_proc_work &&\n\t\t !binder_worklist_empty_ilocked(&thread->proc->todo));\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "backend_forkexec(Port *port)\n{\n\tchar\t   *av[4];\n\tint\t\t\tac = 0;\n\n\tav[ac++] = \"postgres\";\n\tav[ac++] = \"--forkbackend\";\n\tav[ac++] = NULL;\t\t\t/* filled in by internal_forkexec */\n\n\tav[ac] = NULL;\n\tAssert(ac < lengthof(av));\n\n\treturn internal_forkexec(ac, av, port);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int local_mkdir(FsContext *fs_ctx, const char *path, FsCred *credp)\n\n{\n\n    int err = -1;\n\n    int serrno = 0;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        err = mkdir(rpath(fs_ctx, path), SM_LOCAL_DIR_MODE_BITS);\n\n        if (err == -1) {\n\n            return err;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFDIR;\n\n        err = local_set_xattr(rpath(fs_ctx, path), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        err = mkdir(rpath(fs_ctx, path), credp->fc_mode);\n\n        if (err == -1) {\n\n            return err;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    return err;\n\n\n\nerr_end:\n\n    remove(rpath(fs_ctx, path));\n\n    errno = serrno;\n\n    return err;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n {\n         uint8* bufp = buf;\n         int32  bytes_read = 0;\n        uint16 strip, nstrips   = TIFFNumberOfStrips(in);\n         uint32 stripsize = TIFFStripSize(in);\n         uint32 rows = 0;\n         uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += bytes_read;\n        }\n\n        return 1;\n} /* end readContigStripsIntoBuffer */",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void rdma_umap_priv_init(struct rdma_umap_priv *priv,\n\t\t\t\tstruct vm_area_struct *vma)\n{\n\tstruct ib_uverbs_file *ufile = vma->vm_file->private_data;\n\n\tpriv->vma = vma;\n\tvma->vm_private_data = priv;\n\tvma->vm_ops = &rdma_umap_ops;\n\n\tmutex_lock(&ufile->umap_lock);\n\tlist_add(&priv->list, &ufile->umaps);\n\tmutex_unlock(&ufile->umap_lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void qxl_check_state(PCIQXLDevice *d)\n\n{\n\n    QXLRam *ram = d->ram;\n\n\n\n    assert(SPICE_RING_IS_EMPTY(&ram->cmd_ring));\n\n    assert(SPICE_RING_IS_EMPTY(&ram->cursor_ring));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void * calloc(size_t n, size_t lb)\n {\n    if (lb && n > GC_SIZE_MAX / lb)\n       return NULL;\n #   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n         /* libpthread allocated some memory that is only pointed to by  */\n        /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void libraw_close(libraw_data_t *lr)\n  {\n    if (!lr)\n      return;\n    LibRaw *ip = (LibRaw *)lr->parent_class;\n    delete ip;\n  }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void ram_control_after_iterate(QEMUFile *f, uint64_t flags)\n\n{\n\n    int ret = 0;\n\n\n\n    if (f->ops->after_ram_iterate) {\n\n        ret = f->ops->after_ram_iterate(f, f->opaque, flags);\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline bool bad_area_access_from_pkeys(unsigned long error_code,\n\t\tstruct vm_area_struct *vma)\n{\n\t/* This code is always called on the current mm */\n\tbool foreign = false;\n\n\tif (!boot_cpu_has(X86_FEATURE_OSPKE))\n\t\treturn false;\n\tif (error_code & X86_PF_PK)\n\t\treturn true;\n\t/* this checks permission keys on the VMA: */\n\tif (!arch_vma_access_permitted(vma, (error_code & X86_PF_WRITE),\n\t\t\t\t       (error_code & X86_PF_INSTR), foreign))\n\t\treturn true;\n\treturn false;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void bio_chain(struct bio *bio, struct bio *parent)\n{\n\tBUG_ON(bio->bi_private || bio->bi_end_io);\n\n\tbio->bi_private = parent;\n\tbio->bi_end_io\t= bio_chain_endio;\n\tbio_inc_remaining(parent);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void caps_print_filter(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// exit if no permission to join the sandbox\n\tcheck_join_permission(pid);\n\n\tuint64_t caps = extract_caps(pid);\n\tint i;\n\tuint64_t mask;\n\tint elems = sizeof(capslist) / sizeof(capslist[0]);\n\tfor (i = 0, mask = 1; i < elems; i++, mask <<= 1) {\n\t\tprintf(\"%-18.18s  - %s\\n\", capslist[i].name, (mask & caps)? \"enabled\": \"disabled\");\n\t}\n\n\texit(0);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "BufferInputSource::seek(qpdf_offset_t offset, int whence)\n{\n    switch (whence)\n    {\n      case SEEK_SET:\n\tthis->cur_offset = offset;\n\tbreak;\n\n      case SEEK_END:\n\tthis->cur_offset = this->buf->getSize() + offset;\n\tbreak;\n\n      case SEEK_CUR:\n\tthis->cur_offset += offset;\n\tbreak;\n\n      default:\n\tthrow std::logic_error(\n\t    \"INTERNAL ERROR: invalid argument to BufferInputSource::seek\");\n\tbreak;\n    }\n\n    if (this->cur_offset < 0)\n    {\n        throw std::runtime_error(\n            this->description + \": seek before beginning of buffer\");\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline void *ResizeBlock(void *block,size_t size)\n{\n  register void\n    *memory;\n\n  if (block == (void *) NULL)\n    return(AcquireBlock(size));\n  memory=AcquireBlock(size);\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n  if (size <= (SizeOfBlock(block)-sizeof(size_t)))\n    (void) memcpy(memory,block,size);\n  else\n    (void) memcpy(memory,block,SizeOfBlock(block)-sizeof(size_t));\n  memory_pool.allocation+=size;\n  return(memory);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "json_t *json_object(void)\n{\n    json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n    if(!object)\n        return NULL;\n    json_init(&object->json, JSON_OBJECT);\n\n    if(hashtable_init(&object->hashtable))\n    {\n        jsonp_free(object);\n        return NULL;\n    }\n\n    object->serial = 0;\n    object->visited = 0;\n\n    return &object->json;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(fud->fc);\n\tint rc;\n\n\t/* remove from the conntbl, no more access from this point on */\n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\n\t/* remove device */\n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n \t\tunregister_chrdev_region(cc->cdev->dev, 1);\n \t\tcdev_del(cc->cdev);\n \t}\n \n \trc = fuse_dev_release(inode, file);\t/* puts the base reference */\n \n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "unblock_all_signals(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tcurrent->notifier = NULL;\n\tcurrent->notifier_data = NULL;\n\trecalc_sigpending();\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int coroutine_fn bdrv_co_do_writev(BlockDriverState *bs,\n    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov)\n{\n    BlockDriver *drv = bs->drv;\n    BdrvTrackedRequest req;\n    int ret;\n    if (!bs->drv) {\n        return -ENOMEDIUM;\n    if (bs->read_only) {\n        return -EACCES;\n    if (bdrv_check_request(bs, sector_num, nb_sectors)) {\n        return -EIO;\n    /* throttling disk write I/O */\n    if (bs->io_limits_enabled) {\n        bdrv_io_limits_intercept(bs, true, nb_sectors);\n    tracked_request_begin(&req, bs, sector_num, nb_sectors, true);\n    ret = drv->bdrv_co_writev(bs, sector_num, nb_sectors, qiov);\n    if (bs->dirty_bitmap) {\n        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);\n    if (bs->wr_highest_sector < sector_num + nb_sectors - 1) {\n        bs->wr_highest_sector = sector_num + nb_sectors - 1;\n    tracked_request_end(&req);\n    return ret;",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "PHP_FUNCTION(tempnam)\n{\n\tchar *dir, *prefix;\n\tint dir_len, prefix_len;\n\tsize_t p_len;\n\tchar *opened_path;\n\tchar *p;\n\tint fd;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &dir, &dir_len, &prefix, &prefix_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (PG(safe_mode) &&(!php_checkuid(dir, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_check_open_basedir(dir TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_basename(prefix, prefix_len, NULL, 0, &p, &p_len TSRMLS_CC);\n\tif (p_len > 64) {\n\t\tp[63] = '\\0';\n\t}\n\t\n\tRETVAL_FALSE;\n\n\tif ((fd = php_open_temporary_fd(dir, p, &opened_path TSRMLS_CC)) >= 0) {\n\t\tclose(fd);\n\t\tRETVAL_STRING(opened_path, 0);\n\t}\n\tefree(p);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int hostmatch(const char *hostname, const char *pattern)\n{\n  for(;;) {\n    char c = *pattern++;\n\n    if(c == '\\0')\n      return (*hostname ? HOST_NOMATCH : HOST_MATCH);\n\n    if(c == '*') {\n      c = *pattern;\n      if(c == '\\0')      /* \"*\\0\" matches anything remaining */\n        return HOST_MATCH;\n\n      while(*hostname) {\n        /* The only recursive function in libcurl! */\n        if(hostmatch(hostname++,pattern) == HOST_MATCH)\n          return HOST_MATCH;\n      }\n      break;\n    }\n\n    if(Curl_raw_toupper(c) != Curl_raw_toupper(*hostname++))\n      break;\n  }\n  return HOST_NOMATCH;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static ssize_t local_readlink(FsContext *fs_ctx, const char *path,\n\n        char *buf, size_t bufsz)\n\n{\n\n    ssize_t tsize = -1;\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        int fd;\n\n        fd = open(rpath(fs_ctx, path), O_RDONLY);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n        do {\n\n            tsize = read(fd, (void *)buf, bufsz);\n\n        } while (tsize == -1 && errno == EINTR);\n\n        close(fd);\n\n        return tsize;\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        tsize = readlink(rpath(fs_ctx, path), buf, bufsz);\n\n    }\n\n    return tsize;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void EbmlElement::Read(EbmlStream & inDataStream, const EbmlSemanticContext & /* Context */, int & /* UpperEltFound */, EbmlElement * & /* FoundElt */, bool /* AllowDummyElt */, ScopeMode ReadFully)\n{\n  ReadData(inDataStream.I_O(), ReadFully);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "force_luks_teardown_data_unref (ForceLuksTeardownData *data)\n{\n  if (data->device != NULL)\n    g_object_unref (data->device);\n  g_free (data->dm_name);\n  g_free (data);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static u8 dccp_feat_is_valid_nn_val(u8 feat_num, u64 val)\n{\n\tswitch (feat_num) {\n\tcase DCCPF_ACK_RATIO:\n\t\treturn val <= DCCPF_ACK_RATIO_MAX;\n\tcase DCCPF_SEQUENCE_WINDOW:\n\t\treturn val >= DCCPF_SEQ_WMIN && val <= DCCPF_SEQ_WMAX;\n\t}\n\treturn 0;\t/* feature unknown - so we can't tell */\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static LayoutPoint CornerPointOfRect(LayoutRect rect, Corner which_corner) {\n  switch (which_corner) {\n    case Corner::kTopLeft:\n      return rect.MinXMinYCorner();\n    case Corner::kTopRight:\n      return rect.MaxXMinYCorner();\n  }\n  NOTREACHED();\n  return LayoutPoint();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int main()\n{\n    check_file(\"heap_overflow_1.tga\");\n    check_file(\"heap_overflow_2.tga\");\n\n    return gdNumFailures();\n}\n\n\nstatic void check_file(char *basename)\n {\n     gdImagePtr im;\n     char *buffer;\n     size_t size;\n \n    size = read_test_file(&buffer, basename);\n     im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n     gdTestAssert(im == NULL);\n     free(buffer);\n }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int dns_stream_complete(DnsStream *s, int error) {\n        assert(s);\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n\n        if (s->complete)\n                s->complete(s, error);\n        else /* the default action if no completion function is set is to close the stream */\n                dns_stream_unref(s);\n\n        return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void rtl8139_timer(void *opaque)\n{\n    RTL8139State *s = opaque;\n\n    if (!s->clock_enabled)\n    {\n        DPRINTF(\">>> timer: clock is not running\\n\");\n        return;\n    }\n\n    s->IntrStatus |= PCSTimeout;\n    rtl8139_update_irq(s);\n    rtl8139_set_next_tctr_time(s);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void av_register_input_format(AVInputFormat *format)\n\n{\n\n    AVInputFormat **p = last_iformat;\n\n\n\n    format->next = NULL;\n\n    while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, format))\n\n        p = &(*p)->next;\n\n    last_iformat = &format->next;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\tkenter(\"{%d}\", key->serial);\n\n\tBUG_ON(key != ctx->match_data);\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "dopr_outch(int c, PrintfTarget *target)\n{\n\tif (target->bufend != NULL && target->bufptr >= target->bufend)\n\t{\n\t\t/* buffer full, can we dump to stream? */\n\t\tif (target->stream == NULL)\n\t\t\treturn;\t\t\t\t/* no, lose the data */\n\t\tflushbuffer(target);\n\t}\n\t*(target->bufptr++) = c;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "GURL GlobalConfirmInfoBar::DelegateProxy::GetLinkURL() const {\n  return global_info_bar_ ? global_info_bar_->delegate_->GetLinkURL()\n                          : GURL();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void smtc_unmap_smem(struct smtcfb_info *sfb)\n{\n\tif (sfb && sfb->fb->screen_base) {\n\t\tif (sfb->chip_id == 0x720)\n\t\t\tsfb->fb->screen_base -= 0x00200000;\n\t\tiounmap(sfb->fb->screen_base);\n\t\tsfb->fb->screen_base = NULL;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "unsigned ff_dxva2_get_surface_index(const AVCodecContext *avctx,\n\n                                    const AVDXVAContext *ctx,\n\n                                    const AVFrame *frame)\n\n{\n\n    void *surface = ff_dxva2_get_surface(frame);\n\n    unsigned i;\n\n\n\n    for (i = 0; i < DXVA_CONTEXT_COUNT(avctx, ctx); i++)\n\n        if (DXVA_CONTEXT_SURFACE(avctx, ctx, i) == surface)\n\n            return i;\n\n\n\n    assert(0);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "QByteArray PamData::getResponse(const struct pam_message* msg) {\n        QByteArray response = findPrompt(msg).response;\n        m_currentRequest.prompts.removeOne(findPrompt(msg));\n        if (m_currentRequest.prompts.length() == 0)\n            m_sent = false;\n        return response;\n    }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void ide_transfer_start(IDEState *s, uint8_t *buf, int size,\n                        EndTransferFunc *end_transfer_func)\n{\n    s->end_transfer_func = end_transfer_func;\n    s->data_ptr = buf;\n    s->data_end = buf + size;\n    if (!(s->status & ERR_STAT)) {\n        s->status |= DRQ_STAT;\n    }\n    if (s->bus->dma->ops->start_transfer) {\n        s->bus->dma->ops->start_transfer(s->bus->dma);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "_gnutls_hmac (digest_hd_st * handle, const void *text, size_t textlen)\n{\n  if (textlen > 0)\n    {\n      return handle->hash (handle->handle, text, textlen);\n    }\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void ndpi_md5(const u_char *data, size_t data_len, u_char hash[16]) {\n  ndpi_MD5_CTX ctx;\n\n  ndpi_MD5Init(&ctx);\n  ndpi_MD5Update(&ctx, data, data_len);\n  ndpi_MD5Final(hash, &ctx);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int  AVI_video_width(avi_t *AVI)\n{\n\treturn AVI->width;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "World *world_alloc(Rocker *r, size_t sizeof_private,\n\n                   enum rocker_world_type type, WorldOps *ops)\n\n{\n\n    World *w = g_malloc0(sizeof(World) + sizeof_private);\n\n\n\n    if (w) {\n\n        w->r = r;\n\n        w->type = type;\n\n        w->ops = ops;\n\n        if (w->ops->init) {\n\n            w->ops->init(w);\n\n        }\n\n    }\n\n\n\n    return w;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool Item::cache_const_expr_analyzer(uchar **arg)\n{\n  bool *cache_flag= (bool*)*arg;\n  if (!*cache_flag)\n  {\n    Item *item= real_item();\n    /*\n      Cache constant items unless it's a basic constant, constant field or\n      a subselect (they use their own cache).\n    */\n    if (const_item() &&\n        !(basic_const_item() || item->basic_const_item() ||\n          item->type() == Item::FIELD_ITEM ||\n          item->type() == SUBSELECT_ITEM ||\n           /*\n             Do not cache GET_USER_VAR() function as its const_item() may\n             return TRUE for the current thread but it still may change\n             during the execution.\n           */\n          (item->type() == Item::FUNC_ITEM &&\n           ((Item_func*)item)->functype() == Item_func::GUSERVAR_FUNC)))\n      *cache_flag= TRUE;\n    return TRUE;\n  }\n  return FALSE;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)\n{\n    if (index < 0)\n    {\n        return NULL;\n    }\n\n    return get_array_item(array, (size_t)index);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "_parse_cat (GstMpegtsSection * section)\n{\n  guint8 *data;\n  guint desc_len;\n\n  /* Skip parts already parsed */\n  data = section->data + 8;\n\n  /* descriptors */\n  desc_len = section->section_length - 4 - 8;\n  return (gpointer) gst_mpegts_parse_descriptors (data, desc_len);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void ewk_view_title_set(Evas_Object* ewkView, const char* title)\n{\n    DBG(\"ewkView=%p, title=%s\", ewkView, title ? title : \"(null)\");\n    evas_object_smart_callback_call(ewkView, \"title,changed\", (void*)title);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int protocol_client_vencrypt_init(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    if (data[0] != 0 ||\n\n        data[1] != 2) {\n\n        VNC_DEBUG(\"Unsupported VeNCrypt protocol %d.%d\\n\", (int)data[0], (int)data[1]);\n\n        vnc_write_u8(vs, 1); /* Reject version */\n\n        vnc_flush(vs);\n\n        vnc_client_error(vs);\n\n    } else {\n\n        VNC_DEBUG(\"Sending allowed auth %d\\n\", vs->subauth);\n\n        vnc_write_u8(vs, 0); /* Accept version */\n\n        vnc_write_u8(vs, 1); /* Number of sub-auths */\n\n        vnc_write_u32(vs, vs->subauth); /* The supported auth */\n\n        vnc_flush(vs);\n\n        vnc_read_when(vs, protocol_client_vencrypt_auth, 4);\n\n    }\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "SPL_METHOD(Array, exchangeArray)\n{\n\tzval *object = getThis(), *tmp, **array;\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\n\tarray_init(return_value);\n\tzend_hash_copy(HASH_OF(return_value), spl_array_get_hash_table(intern, 0 TSRMLS_CC), (copy_ctor_func_t) zval_add_ref, &tmp, sizeof(zval*));\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &array) == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_array_set_array(object, intern, array, 0L, 1 TSRMLS_CC);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "PHP_FUNCTION(snmp2_get)\n{\n\tphp_snmp(INTERNAL_FUNCTION_PARAM_PASSTHRU, SNMP_CMD_GET, SNMP_VERSION_2c);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "proto_tree_set_uint64(field_info *fi, guint64 value)\n{\n\theader_field_info *hfinfo;\n\tguint64\t\t   integer;\n\n\thfinfo = fi->hfinfo;\n\tinteger = value;\n\n\tif (hfinfo->bitmask) {\n\t\t/* Mask out irrelevant portions */\n\t\tinteger &= hfinfo->bitmask;\n\n\t\t/* Shift bits */\n\t\tinteger >>= hfinfo_bitshift(hfinfo);\n\n\t\tFI_SET_FLAG(fi, FI_BITS_OFFSET(hfinfo_bitoffset(hfinfo)));\n\t\tFI_SET_FLAG(fi, FI_BITS_SIZE(hfinfo_mask_bitwidth(hfinfo)));\n\t}\n\n\tfvalue_set_uinteger64(&fi->value, integer);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int releaseintf(struct usb_dev_state *ps, unsigned int ifnum)\n{\n\tstruct usb_device *dev;\n\tstruct usb_interface *intf;\n\tint err;\n\n\terr = -EINVAL;\n\tif (ifnum >= 8*sizeof(ps->ifclaimed))\n\t\treturn err;\n\tdev = ps->dev;\n\tintf = usb_ifnum_to_if(dev, ifnum);\n\tif (!intf)\n\t\terr = -ENOENT;\n\telse if (test_and_clear_bit(ifnum, &ps->ifclaimed)) {\n\t\tusb_driver_release_interface(&usbfs_driver, intf);\n\t\terr = 0;\n\t}\n\treturn err;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "_binder_node_unlock(struct binder_node *node, int line)\n{\n\tbinder_debug(BINDER_DEBUG_SPINLOCKS,\n\t\t     \"%s: line=%d\\n\", __func__, line);\n\tspin_unlock(&node->lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n{\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n\t\tupdateToolCapabilities();\n\treturn result;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void DevToolsWindow::CloseContents(content::WebContents* source) {\n  CHECK(IsDocked());\n  BrowserWindow* inspected_window = GetInspectedBrowserWindow();\n  if (inspected_window)\n    inspected_window->UpdateDevTools();\n  delete web_contents_;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "struct ldb_message *ldb_msg_copy_shallow(TALLOC_CTX *mem_ctx,\n\t\t\t\t\t const struct ldb_message *msg)\n{\n\tstruct ldb_message *msg2;\n\tunsigned int i;\n\n\tmsg2 = talloc(mem_ctx, struct ldb_message);\n\tif (msg2 == NULL) return NULL;\n\n\t*msg2 = *msg;\n\n\tmsg2->elements = talloc_array(msg2, struct ldb_message_element,\n\t\t\t\t      msg2->num_elements);\n\tif (msg2->elements == NULL) goto failed;\n\n\tfor (i=0;i<msg2->num_elements;i++) {\n\t\tmsg2->elements[i] = msg->elements[i];\n\t}\n\n\treturn msg2;\n\nfailed:\n\ttalloc_free(msg2);\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "inline int megasas_cmd_type(struct scsi_cmnd *cmd)\n{\n\tint ret;\n\n\tswitch (cmd->cmnd[0]) {\n\tcase READ_10:\n\tcase WRITE_10:\n\tcase READ_12:\n\tcase WRITE_12:\n\tcase READ_6:\n\tcase WRITE_6:\n\tcase READ_16:\n\tcase WRITE_16:\n\t\tret = (MEGASAS_IS_LOGICAL(cmd->device)) ?\n\t\t\tREAD_WRITE_LDIO : READ_WRITE_SYSPDIO;\n\t\tbreak;\n\tdefault:\n\t\tret = (MEGASAS_IS_LOGICAL(cmd->device)) ?\n\t\t\tNON_READ_WRITE_LDIO : NON_READ_WRITE_SYSPDIO;\n\t}\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "print_response_line (const char *prefix, const char *b, const char *e)\n{\n  char *copy;\n  BOUNDED_TO_ALLOCA(b, e, copy);\n  logprintf (LOG_ALWAYS, \"%s%s\\n\", prefix,\n             quotearg_style (escape_quoting_style, copy));\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void __key_check(const struct key *key)\n{\n\tprintk(\"__key_check: key %p {%08x} should be {%08x}\\n\",\n\t       key, key->magic, KEY_DEBUG_MAGIC);\n\tBUG();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "MODRET set_accessdenymsg(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  c = add_config_param_str(cmd->argv[0], 1, cmd->argv[1]);\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    NetCharDriver *s = chr->opaque;\n\n    gsize bytes_read = 0;\n\n    GIOStatus status;\n\n\n\n    if (s->max_size == 0) {\n\n        return TRUE;\n\n    }\n\n    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),\n\n                                     &bytes_read, NULL);\n\n    s->bufcnt = bytes_read;\n\n    s->bufptr = s->bufcnt;\n\n    if (status != G_IO_STATUS_NORMAL) {\n\n        if (s->tag) {\n\n            g_source_remove(s->tag);\n\n            s->tag = 0;\n\n        }\n\n        return FALSE;\n\n    }\n\n\n\n    s->bufptr = 0;\n\n    while (s->max_size > 0 && s->bufptr < s->bufcnt) {\n\n        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);\n\n        s->bufptr++;\n\n        s->max_size = qemu_chr_be_can_write(chr);\n\n    }\n\n\n\n    return TRUE;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int devicepvalidate(i_ctx_t *i_ctx_p, ref *space, float *values, int num_comps)\n{\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "#if cimg_verbosity>=3\n    T *data(const unsigned int x, const unsigned int y=0, const unsigned int z=0, const unsigned int c=0) {\n      const ulongT off = (ulongT)offset(x,y,z,c);\n      if (off>=size())\n        cimg::warn(_cimg_instance\n                   \"data(): Invalid pointer request, at coordinates (%u,%u,%u,%u) [offset=%u].\",\n                   cimg_instance,\n                   x,y,z,c,off);\n      return _data + off;",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static struct cli_map *get_hashtab(struct cli_bc_ctx *ctx, int32_t id)\n{\n    if (id < 0 || id >= ctx->nmaps || !ctx->maps)\n\treturn NULL;\n    return &ctx->maps[id];\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static cJSON *cJSON_New_Item( void )\n{\n\tcJSON* node = (cJSON*) cJSON_malloc( sizeof(cJSON) );\n\tif ( node )\n\t\tmemset( node, 0, sizeof(cJSON) );\n\treturn node;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "krb5_decode(void *app_data, void *buf, int len,\n            int level UNUSED_PARAM,\n            struct connectdata *conn UNUSED_PARAM)\n{\n  gss_ctx_id_t *context = app_data;\n  OM_uint32 maj, min;\n  gss_buffer_desc enc, dec;\n\n  (void)level;\n  (void)conn;\n\n  enc.value = buf;\n  enc.length = len;\n  maj = gss_unwrap(&min, *context, &enc, &dec, NULL, NULL);\n  if(maj != GSS_S_COMPLETE) {\n    if(len >= 4)\n      strcpy(buf, \"599 \");\n    return -1;\n  }\n\n  memcpy(buf, dec.value, dec.length);\n  len = curlx_uztosi(dec.length);\n  gss_release_buffer(&min, &dec);\n\n  return len;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n{\n\tstruct nfs_delegation *delegation;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline void ModulateLCHuv(const double percent_luma,\n  const double percent_chroma,const double percent_hue,double *red,\n  double *green,double *blue)\n{\n  double\n    hue,\n    luma,\n    chroma;\n\n  /*\n    Increase or decrease color luma, chroma, or hue.\n  */\n  ConvertRGBToLCHuv(*red,*green,*blue,&luma,&chroma,&hue);\n  luma*=0.01*percent_luma;\n  chroma*=0.01*percent_chroma;\n  hue+=fmod((percent_hue-100.0),200.0)/200.0;\n  ConvertLCHuvToRGB(luma,chroma,hue,red,green,blue);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int count_paths(const char **paths)\n{\n\tint i = 0;\n\twhile (*paths++)\n\t\ti++;\n\treturn i;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "const char *cpu_parse_cpu_model(const char *typename, const char *cpu_model)\n\n{\n\n    ObjectClass *oc;\n\n    CPUClass *cc;\n\n    Error *err = NULL;\n\n    gchar **model_pieces;\n\n    const char *cpu_type;\n\n\n\n    model_pieces = g_strsplit(cpu_model, \",\", 2);\n\n\n\n    oc = cpu_class_by_name(typename, model_pieces[0]);\n\n    if (oc == NULL) {\n\n        g_strfreev(model_pieces);\n\n        return NULL;\n\n    }\n\n\n\n    cpu_type = object_class_get_name(oc);\n\n    cc = CPU_CLASS(oc);\n\n    cc->parse_features(cpu_type, model_pieces[1], &err);\n\n    g_strfreev(model_pieces);\n\n    if (err != NULL) {\n\n        error_report_err(err);\n\n        return NULL;\n\n    }\n\n    return cpu_type;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "xmlSubstituteEntitiesDefault(int val) {\n    int old = xmlSubstituteEntitiesDefaultValue;\n\n    xmlSubstituteEntitiesDefaultValue = val;\n    return(old);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "av_cold void ff_mpv_idct_init(MpegEncContext *s)\n{\n    ff_idctdsp_init(&s->idsp, s->avctx);\n\n    /* load & permutate scantables\n     * note: only wmv uses different ones\n     */\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void gen_tlbld_6xx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_6xx_tlbd(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int vhost_set_vring_file(struct vhost_dev *dev,\n\n                                VhostUserRequest request,\n\n                                struct vhost_vring_file *file)\n\n{\n\n    int fds[VHOST_MEMORY_MAX_NREGIONS];\n\n    size_t fd_num = 0;\n\n    VhostUserMsg msg = {\n\n        .request = request,\n\n        .flags = VHOST_USER_VERSION,\n\n        .payload.u64 = file->index & VHOST_USER_VRING_IDX_MASK,\n\n        .size = sizeof(msg.payload.u64),\n\n    };\n\n\n\n    if (ioeventfd_enabled() && file->fd > 0) {\n\n        fds[fd_num++] = file->fd;\n\n    } else {\n\n        msg.payload.u64 |= VHOST_USER_VRING_NOFD_MASK;\n\n    }\n\n\n\n    vhost_user_write(dev, &msg, fds, fd_num);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "AudioNode* AudioHandler::GetNode() const {\n  DCHECK(IsMainThread());\n  return node_;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n \tstruct media_entity *ent;\n \tstruct media_entity_desc u_ent;\n \n \tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n \t\treturn -EFAULT;\n \n\tent = find_entity(mdev, u_ent.id);\n\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "guestfs___parse_major_minor (guestfs_h *g, struct inspect_fs *fs)\n{\n  char *major, *minor;\n\n  if (match2 (g, fs->product_name, re_major_minor, &major, &minor)) {\n    fs->major_version = guestfs___parse_unsigned_int (g, major);\n    free (major);\n    if (fs->major_version == -1) {\n      free (minor);\n      return -1;\n    }\n    fs->minor_version = guestfs___parse_unsigned_int (g, minor);\n    free (minor);\n    if (fs->minor_version == -1)\n      return -1;\n  }\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ZEND_API int ZEND_FASTCALL zend_binary_strncmp(const char *s1, size_t len1, const char *s2, size_t len2, size_t length) /* {{{ */\n{\n\tint retval;\n\n\tif (s1 == s2) {\n\t\treturn 0;\n\t}\n\tretval = memcmp(s1, s2, MIN(length, MIN(len1, len2)));\n\tif (!retval) {\n\t\treturn (int)(MIN(length, len1) - MIN(length, len2));\n\t} else {\n\t\treturn retval;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void kvm_set_pfn_dirty(kvm_pfn_t pfn)\n{\n\tif (!kvm_is_reserved_pfn(pfn)) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tif (!PageReserved(page))\n\t\t\tSetPageDirty(page);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "bool PngImg::Crop(png_uint_32 offsetX, png_uint_32 offsetY, png_uint_32 width, png_uint_32 height)\n{\n    if(!InBounds_(offsetX, offsetY, width, height))\n    {\n        error_ = \"Out of the bounds\";\n        return false;\n    }\n\n    for(size_t i = 0; i < height; ++i) {\n        rowPtrs_[i] = rowPtrs_[i + offsetY] + offsetX * info_.pxlsize;\n    }\n    rowPtrs_.resize(height);\n\n    info_.width = width;\n    info_.height = height;\n    info_.rowbytes = info_.pxlsize * width;\n    return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int test_x509_time(int idx)\n{\n    ASN1_TIME *t = NULL;\n    int result, rv = 0;\n\n    if (x509_format_tests[idx].set_string) {\n        /* set-string mode */\n        t = ASN1_TIME_new();\n        if (t == NULL) {\n            TEST_info(\"test_x509_time(%d) failed: internal error\\n\", idx);\n            return 0;\n        }\n    }\n\n    result = ASN1_TIME_set_string_X509(t, x509_format_tests[idx].data);\n    /* time string parsing result is always checked against what's expected */\n    if (!TEST_int_eq(result, x509_format_tests[idx].expected)) {\n        TEST_info(\"test_x509_time(%d) failed: expected %d, got %d\\n\",\n                idx, x509_format_tests[idx].expected, result);\n        goto out;\n    }\n\n    /* if t is not NULL but expected_type is ignored(-1), it is an 'OK' case */\n    if (t != NULL && x509_format_tests[idx].expected_type != -1) {\n        if (!TEST_int_eq(t->type, x509_format_tests[idx].expected_type)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_type %d, got %d\\n\",\n                    idx, x509_format_tests[idx].expected_type, t->type);\n            goto out;\n        }\n    }\n\n    /* if t is not NULL but expected_string is NULL, it is an 'OK' case too */\n    if (t != NULL && x509_format_tests[idx].expected_string) {\n        if (!TEST_str_eq((const char *)t->data,\n                    x509_format_tests[idx].expected_string)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_string %s, got %s\\n\",\n                    idx, x509_format_tests[idx].expected_string, t->data);\n            goto out;\n        }\n    }\n\n    rv = 1;\nout:\n    if (t != NULL)\n        ASN1_TIME_free(t);\n    return rv;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\n\tif (!ax)\n\t\treturn;\n\n\t/*\n\t * We have now ensured that nobody can start using ap from now on, but\n\t * we have to wait for all existing users to finish.\n\t */\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\t/*\n\t * Halt the transmit queue so that a new transmit cannot scribble\n\t * on our buffers\n\t */\n\tnetif_stop_queue(ax->dev);\n\n\tax->tty = NULL;\n\n\tunregister_netdev(ax->dev);\n\n\t/* Free all AX25 frame buffers after unreg. */\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\n\tfree_netdev(ax->dev);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int slice_area_is_free(struct mm_struct *mm, unsigned long addr,\n\t\t\t      unsigned long len)\n{\n\tstruct vm_area_struct *vma;\n\n\tif ((mm->task_size - len) < addr)\n\t\treturn 0;\n\tvma = find_vma(mm, addr);\n\treturn (!vma || (addr + len) <= vma->vm_start);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\n\tstrlcpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\n\t\t    sizeof(struct crypto_report_acomp), &racomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void mmap_release_buffer(AVPacket *pkt)\n{\n    struct v4l2_buffer buf;\n    int res, fd;\n    struct buff_data *buf_descriptor = pkt->priv;\n    memset(&buf, 0, sizeof(struct v4l2_buffer));\n    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n    buf.memory = V4L2_MEMORY_MMAP;\n    buf.index = buf_descriptor->index;\n    fd = buf_descriptor->fd;\n    av_free(buf_descriptor);\n    res = ioctl (fd, VIDIOC_QBUF, &buf);\n    if (res < 0) {\n        av_log(NULL, AV_LOG_ERROR, \"ioctl(VIDIOC_QBUF)\\n\");\n    pkt->data = NULL;\n    pkt->size = 0;",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void _MD5_encode(unsigned char *pout, unsigned int *pin, unsigned int len) {\n   unsigned int i, j;\n\n   for (i = 0, j = 0; j < len; i++, j += 4) {\n      pout[j] = (unsigned char) (pin[i] & 0x0ff);\n      pout[j + 1] = (unsigned char) ((pin[i] >> 8) & 0x0ff);\n      pout[j + 2] = (unsigned char) ((pin[i] >> 16) & 0x0ff);\n      pout[j + 3] = (unsigned char) ((pin[i] >> 24) & 0x0ff);\n   }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n \tstruct nft_chain *chain, *nc;\n \tstruct nft_set *set, *ns;\n \n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n \t\tctx->chain = chain;\n \n \t\terr = nft_delrule_by_chain(ctx);\n \t\tif (err < 0)\n \t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n \t}\n \n \tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n \t\t\tgoto out;\n \t}\n \n \terr = nft_deltable(ctx);\n out:\n \treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "vc4_update_bo_seqnos(struct vc4_exec_info *exec, uint64_t seqno)\n{\n\tstruct vc4_bo *bo;\n\tunsigned i;\n\n\tfor (i = 0; i < exec->bo_count; i++) {\n\t\tbo = to_vc4_bo(&exec->bo[i]->base);\n\t\tbo->seqno = seqno;\n\t}\n\n\tlist_for_each_entry(bo, &exec->unref_list, unref_head) {\n\t\tbo->seqno = seqno;\n\t}\n\n\tfor (i = 0; i < exec->rcl_write_bo_count; i++) {\n\t\tbo = to_vc4_bo(&exec->rcl_write_bo[i]->base);\n\t\tbo->write_seqno = seqno;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "bool QueryManager::AddPendingTransferQuery(\n    Query* query,\n    base::subtle::Atomic32 submit_count) {\n  DCHECK(query);\n  DCHECK(!query->IsDeleted());\n  if (!RemovePendingQuery(query)) {\n    return false;\n  }\n  query->MarkAsPending(submit_count);\n  pending_transfer_queries_.push_back(query);\n  return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void TiffCopier::visitIfdMakernote(TiffIfdMakernote* object)\n    {\n        copyObject(object);\n    }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void cancel_apic_timer(struct kvm_lapic *apic)\n{\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tpreempt_disable();\n\tif (apic->lapic_timer.hv_timer_in_use)\n\t\tcancel_hv_timer(apic);\n\tpreempt_enable();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n {\n \tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n \treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "INST_HANDLER (inc) {\t// INC Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tESIL_A (\"1,r%d,+,\", d);\t\t\t\t\t// ++Rd\n\tESIL_A (\"0,RPICK,0x80,==,vf,=,\");\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void ff_frame_thread_encoder_free(AVCodecContext *avctx){\n\n    int i;\n\n    ThreadContext *c= avctx->internal->frame_thread_encoder;\n\n\n\n    pthread_mutex_lock(&c->task_fifo_mutex);\n\n    c->exit = 1;\n\n    pthread_cond_broadcast(&c->task_fifo_cond);\n\n    pthread_mutex_unlock(&c->task_fifo_mutex);\n\n\n\n    for (i=0; i<avctx->thread_count; i++) {\n\n         pthread_join(c->worker[i], NULL);\n\n    }\n\n\n\n    pthread_mutex_destroy(&c->task_fifo_mutex);\n\n    pthread_mutex_destroy(&c->finished_task_mutex);\n\n    pthread_mutex_destroy(&c->buffer_mutex);\n\n    pthread_cond_destroy(&c->task_fifo_cond);\n\n    pthread_cond_destroy(&c->finished_task_cond);\n\n    av_fifo_freep(&c->task_fifo);\n\n    av_freep(&avctx->internal->frame_thread_encoder);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void gdb_exit(CPUArchState *env, int code)\n\n{\n\n  GDBState *s;\n\n  char buf[4];\n\n\n\n  s = gdbserver_state;\n\n  if (!s) {\n\n      return;\n\n  }\n\n#ifdef CONFIG_USER_ONLY\n\n  if (gdbserver_fd < 0 || s->fd < 0) {\n\n      return;\n\n  }\n\n#endif\n\n\n\n  snprintf(buf, sizeof(buf), \"W%02x\", (uint8_t)code);\n\n  put_packet(s, buf);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n  if (s->chr) {\n\n      qemu_chr_delete(s->chr);\n\n  }\n\n#endif\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "GetNumWrongData(const byte * curPtr, const int maxnum)\n{\n    int count = 0;\n\n    if (1 == maxnum) {\n        return (1);\n    }\n    while (*(curPtr + count) != *(curPtr + count + 1) && maxnum > count) {\n        count++;\n    }\n\n    return (count);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void qxl_destroy_primary(PCIQXLDevice *d)\n\n{\n\n    if (d->mode == QXL_MODE_UNDEFINED) {\n\n        return;\n\n    }\n\n\n\n    dprint(d, 1, \"%s\\n\", __FUNCTION__);\n\n\n\n    d->mode = QXL_MODE_UNDEFINED;\n\n\n    d->ssd.worker->destroy_primary_surface(d->ssd.worker, 0);\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int qemu_register_machine(QEMUMachine *m)\n\n{\n\n    TypeInfo ti = {\n\n        .name       = g_strconcat(m->name, TYPE_MACHINE_SUFFIX, NULL),\n\n        .parent     = TYPE_MACHINE,\n\n        .class_init = machine_class_init,\n\n        .class_data = (void *)m,\n\n    };\n\n\n\n    type_register(&ti);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "const git_tree_entry *git_tree_entry_byindex(\n\tconst git_tree *tree, size_t idx)\n{\n\tassert(tree);\n\treturn git_vector_get(&tree->entries, idx);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "AvahiService::~AvahiService()\n{\n    stop();\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "StatusOr<int> convertToXfrmAddr(const std::string& strAddr, xfrm_address_t* xfrmAddr) {\n if (strAddr.length() == 0) {\n        memset(xfrmAddr, 0, sizeof(*xfrmAddr));\n return AF_UNSPEC;\n }\n\n if (inet_pton(AF_INET6, strAddr.c_str(), reinterpret_cast<void*>(xfrmAddr))) {\n return AF_INET6;\n } else if (inet_pton(AF_INET, strAddr.c_str(), reinterpret_cast<void*>(xfrmAddr))) {\n return AF_INET;\n } else {\n return netdutils::statusFromErrno(EAFNOSUPPORT, \"Invalid address family\");\n }\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int inotify_rm_wd(struct inotify_handle *ih, u32 wd)\n{\n\tstruct inotify_watch *watch;\n\tstruct inode *inode;\n\n\tmutex_lock(&ih->mutex);\n\twatch = idr_find(&ih->idr, wd);\n\tif (unlikely(!watch)) {\n\t\tmutex_unlock(&ih->mutex);\n\t\treturn -EINVAL;\n\t}\n\tget_inotify_watch(watch);\n\tinode = watch->inode;\n\tmutex_unlock(&ih->mutex);\n\n\tmutex_lock(&inode->inotify_mutex);\n\tmutex_lock(&ih->mutex);\n\n\t/* make sure that we did not race */\n\tif (likely(idr_find(&ih->idr, wd) == watch))\n\t\tinotify_remove_watch_locked(ih, watch);\n\n\tmutex_unlock(&ih->mutex);\n\tmutex_unlock(&inode->inotify_mutex);\n\tput_inotify_watch(watch);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "//! Compute image laplacian.\n    CImg<T>& laplacian() {\n      return get_laplacian().move_to(*this);",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Nonlocal(asdl_seq * names, int lineno, int col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = Nonlocal_kind;\n    p->v.Nonlocal.names = names;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    return p;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void vmxnet3_update_rx_mode(VMXNET3State *s)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    s->rx_mode = VMXNET3_READ_DRV_SHARED32(d, s->drv_shmem,\n                                           devRead.rxFilterConf.rxMode);\n    VMW_CFPRN(\"RX mode: 0x%08X\", s->rx_mode);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline unsigned long native_store_tr(void)\n{\n\tunsigned long tr;\n\tasm volatile(\"str %0\":\"=r\" (tr));\n\treturn tr;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "MONGO_EXPORT int mongo_check_connection( mongo *conn ) {\n    if( ! conn->connected )\n        return MONGO_ERROR;\n\n    if( mongo_simple_int_command( conn, \"admin\", \"ping\", 1, NULL ) == MONGO_OK )\n        return MONGO_OK;\n    else\n        return MONGO_ERROR;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "newEntry(struct rx_call *call, char aname[], afs_int32 flag, afs_int32 oid,\n\t afs_int32 *aid, afs_int32 *cid)\n{\n    afs_int32 code;\n    struct ubik_trans *tt;\n    int admin;\n    char cname[PR_MAXNAMELEN];\n    stolower(aname);\n    code = Initdb();\n    if (code)\n\treturn code;\n    code = ubik_BeginTrans(dbase, UBIK_WRITETRANS, &tt);\n    if (code)\n\treturn code;\n    code = ubik_SetLock(tt, 1, 1, LOCKWRITE);\n    if (code)\n\tABORT_WITH(tt, code);\n    code = read_DbHeader(tt);\n    if (code)\n\tABORT_WITH(tt, code);\n\n    /* this is for cross-cell self registration. It is not added in the\n     * SPR_INewEntry because we want self-registration to only do\n      * automatic id assignment.\n      */\n     code = WhoIsThisWithName(call, tt, cid, cname);\n    if (code != 2) {           /* 2 specifies that this is a foreign cell request */\n       if (code)\n           ABORT_WITH(tt, PRPERM);\n       admin = IsAMemberOf(tt, *cid, SYSADMINID);\n    } else {\n       admin = ((!restricted && !strcmp(aname, cname))) || IsAMemberOf(tt, *cid, SYSADMINID);\n       oid = *cid = SYSADMINID;\n     }\n     if (!CreateOK(tt, *cid, oid, flag, admin))\n        ABORT_WITH(tt, PRPERM);\n    if (code)\n\treturn code;\n    return PRSUCCESS;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "vte_terminal_emit_deiconify_window(VteTerminal *terminal)\n{\n\t_vte_debug_print(VTE_DEBUG_SIGNALS,\n\t\t\t\"Emitting `deiconify-window'.\\n\");\n\tg_signal_emit_by_name(terminal, \"deiconify-window\");\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void vmport_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = vmport_realizefn;\n\n    dc->no_user = 1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static struct pending_op *send_read(struct btd_device *device,\n\t\t\t\t\tstruct gatt_db_attribute *attrib,\n\t\t\t\t\tGDBusProxy *proxy,\n\t\t\t\t\tstruct queue *owner_queue,\n\t\t\t\t\tunsigned int id,\n\t\t\t\t\tuint16_t offset,\n\t\t\t\t\tuint8_t link_type)\n{\n\tstruct pending_op *op;\n\n\top = pending_read_new(device, owner_queue, attrib, id, offset,\n\t\t\t\t\t\t\tlink_type);\n\n\tif (g_dbus_proxy_method_call(proxy, \"ReadValue\", read_setup_cb,\n\t\t\t\tread_reply_cb, op, pending_op_free) == TRUE)\n\t\treturn op;\n\n\tpending_op_free(op);\n\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\treturn xchg(sptep, spte);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void bdrv_ioctl_bh_cb(void *opaque)\n\n{\n\n    BdrvIoctlCompletionData *data = opaque;\n\n\n\n    bdrv_co_io_em_complete(data->co, -ENOTSUP);\n\n    qemu_bh_delete(data->bh);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void scrub_submit(struct scrub_ctx *sctx)\n{\n\tstruct scrub_bio *sbio;\n\n\tif (sctx->curr == -1)\n\t\treturn;\n\n\tsbio = sctx->bios[sctx->curr];\n\tsctx->curr = -1;\n\tscrub_pending_bio_inc(sctx);\n\tbtrfsic_submit_bio(sbio->bio);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "main_file_isopen (main_file *xfile)\n{\n#if XD3_STDIO\n  return xfile->file != NULL;\n\n#elif XD3_POSIX\n  return xfile->file != -1;\n\n#elif XD3_WIN32\n  return xfile->file != INVALID_HANDLE_VALUE;\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "av_cold void ff_mpv_idct_init(MpegEncContext *s)\n {\n     ff_idctdsp_init(&s->idsp, s->avctx);\n \n     /* load & permutate scantables\n     * note: only wmv uses different ones\n     */\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n*/\n\tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n\tif (ctxt) {\n\t\tzend_bool old;\n\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\told = php_libxml_disable_entity_loader(1);\n\t\txmlParseDocument(ctxt);\n\t\tphp_libxml_disable_entity_loader(old);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "GF_Err adkm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeDRMKeyManagementSystemBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tif (ptr->header) gf_isom_box_dump((GF_Box *)ptr->header, trace);\n\tif (ptr->au_format) gf_isom_box_dump((GF_Box *)ptr->au_format, trace);\n\tgf_isom_box_dump_done(\"AdobeDRMKeyManagementSystemBox\", a, trace);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "PDFEngineExports* PDFEngineExports::Get() {\n  return g_pdf_engine_exports.Pointer();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int _pam_get_item(const pam_handle_t *pamh,\n\t\t\t int item_type,\n\t\t\t const void *_item)\n{\n\tconst void **item = (const void **)_item;\n\treturn pam_get_item(pamh, item_type, item);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "TabSpecificContentSettings::~TabSpecificContentSettings() {\n  FOR_EACH_OBSERVER(\n      SiteDataObserver, observer_list_, ContentSettingsDestroyed());\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "}\n\n    //! Load a 3d object from a .OFF file \\newinstance.\n    template<typename tf, typename tc>",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void ipxitf_insert(struct ipx_interface *intrfc)\n{\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tlist_add_tail(&intrfc->node, &ipx_interfaces);\n\tspin_unlock_bh(&ipx_interfaces_lock);\n\n\tif (ipxcfg_auto_select_primary && !ipx_primary_net)\n\t\tipx_primary_net = intrfc;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int hashtable_do_del(hashtable_t *hashtable,\n                            const char *key, size_t hash)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t index;\n\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return -1;\n\n    if(&pair->list == bucket->first && &pair->list == bucket->last)\n        bucket->first = bucket->last = &hashtable->list;\n\n    else if(&pair->list == bucket->first)\n        bucket->first = pair->list.next;\n\n    else if(&pair->list == bucket->last)\n        bucket->last = pair->list.prev;\n\n    list_remove(&pair->list);\n    json_decref(pair->value);\n\n    jsonp_free(pair);\n    hashtable->size--;\n\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void pmcraid_send_hcam(struct pmcraid_instance *pinstance, u8 type)\n{\n\tstruct pmcraid_cmd *cmd = pmcraid_init_hcam(pinstance, type);\n\tpmcraid_send_hcam_cmd(cmd);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "const char* YesNoStateToString(bool is_yes) {\n  if (is_yes) {\n    return \"yes\";\n  } else {\n    return \"no\";\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void new_pes_packet(PESContext *pes, AVPacket *pkt)\n\n{\n\n    av_init_packet(pkt);\n\n\n\n    pkt->destruct = av_destruct_packet;\n\n    pkt->data = pes->buffer;\n\n    pkt->size = pes->data_index;\n\n    memset(pkt->data+pkt->size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n    // Separate out the AC3 substream from an HDMV combined TrueHD/AC3 PID\n\n    if (pes->sub_st && pes->stream_type == 0x83 && pes->extended_stream_id == 0x76)\n\n        pkt->stream_index = pes->sub_st->index;\n\n    else\n\n        pkt->stream_index = pes->st->index;\n\n    pkt->pts = pes->pts;\n\n    pkt->dts = pes->dts;\n\n    /* store position of first TS packet of this PES packet */\n\n    pkt->pos = pes->ts_packet_pos;\n\n\n\n\n    /* reset pts values */\n\n    pes->pts = AV_NOPTS_VALUE;\n\n    pes->dts = AV_NOPTS_VALUE;\n\n    pes->buffer = NULL;\n\n    pes->data_index = 0;\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "SPL_METHOD(DirectoryIterator, isDot)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {\n  if (HasTextBeingDragged())\n    return ui::DragDropTypes::DRAG_NONE;\n\n  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {\n    GURL url;\n    base::string16 title;\n    if (data.GetURLAndTitle(\n            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {\n      base::string16 text(\n          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));\n      if (model()->CanPasteAndGo(text)) {\n        model()->PasteAndGo(text);\n        return ui::DragDropTypes::DRAG_COPY;\n      }\n    }\n   } else if (data.HasString()) {\n     base::string16 text;\n     if (data.GetString(&text)) {\n      base::string16 collapsed_text(base::CollapseWhitespace(text, true));\n       if (model()->CanPasteAndGo(collapsed_text))\n         model()->PasteAndGo(collapsed_text);\n       return ui::DragDropTypes::DRAG_COPY;\n    }\n  }\n\n  return ui::DragDropTypes::DRAG_NONE;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "PHP_FUNCTION(rewinddir)\n{\n\tzval *id = NULL, **tmp, *myself;\n\tphp_stream *dirp;\n\t\n\tFETCH_DIRP();\n\n\tif (!(dirp->flags & PHP_STREAM_FLAG_IS_DIR)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%d is not a valid Directory resource\", dirp->rsrc_id);\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_stream_rewinddir(dirp);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static uint32_t byteSwap4(DataBuf& buf,size_t offset,bool bSwap)\n    {\n        uint32_t v;\n        char*    p = (char*) &v;\n        p[0] = buf.pData_[offset];\n        p[1] = buf.pData_[offset+1];\n        p[2] = buf.pData_[offset+2];\n        p[3] = buf.pData_[offset+3];\n        return byteSwap(v,bSwap);\n    }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static bool hrtimer_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_init(timer, &hrtimer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "AP_DECLARE(int) ap_update_child_status_from_conn(ap_sb_handle_t *sbh, int status,\n                                                 conn_rec *c)\n{\n    if (!sbh || (sbh->child_num < 0))\n        return -1;\n\n    return update_child_status_internal(sbh->child_num, sbh->thread_num,\n                                        status, c, NULL, NULL, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "CoreBasicHandler::CoreBasicHandler(CoreNetwork *parent)\n    : BasicHandler(parent),\n    _network(parent)\n{\n    connect(this, SIGNAL(displayMsg(Message::Type, BufferInfo::Type, const QString &, const QString &, const QString &, Message::Flags)),\n        network(), SLOT(displayMsg(Message::Type, BufferInfo::Type, const QString &, const QString &, const QString &, Message::Flags)));\n\n    connect(this, SIGNAL(putCmd(QString, const QList<QByteArray> &, const QByteArray &)),\n        network(), SLOT(putCmd(QString, const QList<QByteArray> &, const QByteArray &)));\n\n    connect(this, SIGNAL(putRawLine(const QByteArray &)),\n        network(), SLOT(putRawLine(const QByteArray &)));\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int selinux_sb_alloc_security(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec;\n\n\tsbsec = kzalloc(sizeof(struct superblock_security_struct), GFP_KERNEL);\n\tif (!sbsec)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&sbsec->lock);\n\tINIT_LIST_HEAD(&sbsec->isec_head);\n\tspin_lock_init(&sbsec->isec_lock);\n\tsbsec->sb = sb;\n\tsbsec->sid = SECINITSID_UNLABELED;\n\tsbsec->def_sid = SECINITSID_FILE;\n\tsbsec->mntpoint_sid = SECINITSID_UNLABELED;\n\tsb->s_security = sbsec;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void test_json_append_escaped(void)\n{\n\tstring_t *str = t_str_new(32);\n\n\ttest_begin(\"json_append_escaped()\");\n\tjson_append_escaped(str, \"\\b\\f\\r\\n\\t\\\"\\\\\\001\\002-\\xC3\\xA4\\xf0\\x90\\x90\\xb7\");\n\ttest_assert(strcmp(str_c(str), \"\\\\b\\\\f\\\\r\\\\n\\\\t\\\\\\\"\\\\\\\\\\\\u0001\\\\u0002-\\\\u00e4\\\\ud801\\\\udc37\") == 0);\n\ttest_end();\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void blk_mq_free_request(struct request *rq)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct request_queue *q = rq->q;\n\n\thctx = q->mq_ops->map_queue(q, rq->mq_ctx->cpu);\n\tblk_mq_free_hctx_request(hctx, rq);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "Eina_Bool ewk_view_visibility_state_set(Evas_Object* ewkView, Ewk_Page_Visibility_State pageVisibilityState, Eina_Bool initialState)\n{\n#if ENABLE(PAGE_VISIBILITY_API)\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n\n    priv->page->setVisibilityState(static_cast<WebCore::PageVisibilityState>(pageVisibilityState), initialState);\n\n    return true;\n#else\n    DBG(\"PAGE_VISIBILITY_API is disabled.\");\n    return false;\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n\tstrncpy(rrng.type, \"rng\", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n \n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static bool pfn_range_valid_gigantic(struct zone *z,\n\t\t\tunsigned long start_pfn, unsigned long nr_pages)\n{\n\tunsigned long i, end_pfn = start_pfn + nr_pages;\n\tstruct page *page;\n\n\tfor (i = start_pfn; i < end_pfn; i++) {\n\t\tif (!pfn_valid(i))\n\t\t\treturn false;\n\n\t\tpage = pfn_to_page(i);\n\n\t\tif (page_zone(page) != z)\n\t\t\treturn false;\n\n\t\tif (PageReserved(page))\n\t\t\treturn false;\n\n\t\tif (page_count(page) > 0)\n\t\t\treturn false;\n\n\t\tif (PageHuge(page))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ves_icall_type_isbyref (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn type->type->byref;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void gen_mfsr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    t0 = tcg_const_tl(SR(ctx->opcode));\n\n    gen_helper_load_sr(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n#endif\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void ssl_cert_free(CERT *c)\n\t{\n\tint i;\n\n\tif(c == NULL)\n\t    return;\n\n\ti=CRYPTO_add(&c->references,-1,CRYPTO_LOCK_SSL_CERT);\n#ifdef REF_PRINT\n\tREF_PRINT(\"CERT\",c);\n#endif\n\tif (i > 0) return;\n#ifdef REF_CHECK\n\tif (i < 0)\n\t\t{\n\t\tfprintf(stderr,\"ssl_cert_free, bad reference count\\n\");\n\t\tabort(); /* ok */\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_RSA\n\tif (c->rsa_tmp) RSA_free(c->rsa_tmp);\n#endif\n#ifndef OPENSSL_NO_DH\n\tif (c->dh_tmp) DH_free(c->dh_tmp);\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tif (c->ecdh_tmp) EC_KEY_free(c->ecdh_tmp);\n#endif\n\n\tssl_cert_clear_certs(c);\n\tif (c->peer_sigalgs)\n\t\tOPENSSL_free(c->peer_sigalgs);\n\tif (c->conf_sigalgs)\n\t\tOPENSSL_free(c->conf_sigalgs);\n\tOPENSSL_free(c);\n\t}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "rsvg_new_filter_primitive_erode (void)\n{\n    RsvgFilterPrimitiveErode *filter;\n    filter = g_new (RsvgFilterPrimitiveErode, 1);\n    _rsvg_node_init (&filter->super.super);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =\n        filter->super.height.factor = 'n';\n    filter->rx = 0;\n    filter->ry = 0;\n    filter->mode = 0;\n    filter->super.render = &rsvg_filter_primitive_erode_render;\n    filter->super.super.free = &rsvg_filter_primitive_erode_free;\n    filter->super.super.set_atts = rsvg_filter_primitive_erode_set_atts;\n    return (RsvgNode *) filter;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "FilePathWatcher::FilePathWatcher() {\n  impl_ = new FilePathWatcherImpl();\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "FLAC__bool write_bitbuffer_(FLAC__StreamEncoder *encoder, uint32_t samples, FLAC__bool is_last_block)\n{\n\tconst FLAC__byte *buffer;\n\tsize_t bytes;\n\n\tFLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));\n\n\tif(!FLAC__bitwriter_get_buffer(encoder->private_->frame, &buffer, &bytes)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\n\tif(encoder->protected_->verify) {\n\t\tencoder->private_->verify.output.data = buffer;\n\t\tencoder->private_->verify.output.bytes = bytes;\n\t\tif(encoder->private_->verify.state_hint == ENCODER_IN_MAGIC) {\n\t\t\tencoder->private_->verify.needs_magic_hack = true;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__stream_decoder_process_single(encoder->private_->verify.decoder)) {\n\t\t\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\t\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\t\t\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA)\n\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(write_frame_(encoder, buffer, bytes, samples, is_last_block) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\treturn false;\n\t}\n\n\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\tFLAC__bitwriter_clear(encoder->private_->frame);\n\n\tif(samples > 0) {\n\t\tencoder->private_->streaminfo.data.stream_info.min_framesize = flac_min(bytes, encoder->private_->streaminfo.data.stream_info.min_framesize);\n\t\tencoder->private_->streaminfo.data.stream_info.max_framesize = flac_max(bytes, encoder->private_->streaminfo.data.stream_info.max_framesize);\n\t}\n\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "Status LoadMetagraphIntoSession(const SessionOptions& session_options,\n                                const MetaGraphDef& meta_graph,\n                                std::unique_ptr<Session>* session) {\n  Session* session_p = nullptr;\n  TF_RETURN_IF_ERROR(NewSession(session_options, &session_p));\n  session->reset(session_p);\n  TF_RETURN_IF_ERROR(ValidateSavedTensors(meta_graph.graph_def()));\n  return (*session)->Create(meta_graph.graph_def());\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int _ber_skip_length(int length)\n{\n\tif (length > 0x80)\n\t\treturn 3;\n\telse\n\t\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong(uint32 value)\n{\n\tif (value>0xFF)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void HTMLMediaElement::SetCcLayer(cc::Layer* cc_layer) {\n  if (cc_layer == cc_layer_)\n    return;\n\n  if (!cc_layer_ || !cc_layer)\n    SetNeedsCompositingUpdate();\n\n  if (cc_layer_)\n    GraphicsLayer::UnregisterContentsLayer(cc_layer_);\n  cc_layer_ = cc_layer;\n  if (cc_layer_)\n    GraphicsLayer::RegisterContentsLayer(cc_layer_);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static ssize_t total_time_ms_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct wakeup_source *ws = dev_get_drvdata(dev);\n\tktime_t active_time;\n\tktime_t total_time = ws->total_time;\n\n\tif (ws->active) {\n\t\tactive_time = ktime_sub(ktime_get(), ws->last_time);\n\t\ttotal_time = ktime_add(total_time, active_time);\n\t}\n\treturn sprintf(buf, \"%lld\\n\", ktime_to_ms(total_time));\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline size_t GetPSDPacketSize(const Image *image)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (image->colors > 256)\n        return(2);\n    }\n  if (image->depth > 16)\n    return(4);\n  if (image->depth > 8)\n    return(2);\n\n  return(1);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void hpet_device_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = hpet_realize;\n\n    dc->reset = hpet_reset;\n\n    dc->vmsd = &vmstate_hpet;\n\n    dc->props = hpet_device_properties;\n\n\n\n\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "test1(void)\n{\n    int nret = EXIT_FAILURE;\n\n    nret = EXIT_SUCCESS;\n\n    return nret;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n \t\t * Pin all pages we are about to map in memory. This is\n \t\t * important because we unmap and unpin in 4kb steps later.\n \t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size);\n \t\tif (is_error_noslot_pfn(pfn)) {\n \t\t\tgfn += 1;\n \t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n \t\tif (r) {\n \t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n \t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size);\n \t\t\tgoto unmap_pages;\n \t\t}\n \n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\n\t}\n\n\treturn 0;\n\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "mm_chall_setup(char **name, char **infotxt, u_int *numprompts,\n    char ***prompts, u_int **echo_on)\n{\n\t*name = xstrdup(\"\");\n\t*infotxt = xstrdup(\"\");\n\t*numprompts = 1;\n\t*prompts = xcalloc(*numprompts, sizeof(char *));\n\t*echo_on = xcalloc(*numprompts, sizeof(u_int));\n\t(*echo_on)[0] = 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static bool hns_nic_tx_fini_pro(struct hns_nic_ring_data *ring_data)\n{\n\tstruct hnae_ring *ring = ring_data->ring;\n\tint head;\n\n\tring_data->ring->q->handle->dev->ops->toggle_ring_irq(ring, 0);\n\n\thead = readl_relaxed(ring->io_base + RCB_REG_HEAD);\n\n\tif (head != ring->next_to_clean) {\n\t\tring_data->ring->q->handle->dev->ops->toggle_ring_irq(\n\t\t\tring_data->ring, 1);\n\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "pb_controller::~pb_controller() {\n\tdelete cfg;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "Jsi_Value* Jsi_ValueNewObj(Jsi_Interp *interp, Jsi_Obj *o) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_ValueMakeObject(interp, &v, o);\n    return v;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int spapr_tce_dma_zero(VIOsPAPRDevice *dev, uint64_t taddr, uint32_t size)\n\n{\n\n    /* FIXME: allocating a temp buffer is nasty, but just stepping\n\n     * through writing zeroes is awkward.  This will do for now. */\n\n    uint8_t zeroes[size];\n\n\n\n#ifdef DEBUG_TCE\n\n    fprintf(stderr, \"spapr_tce_dma_zero taddr=0x%llx size=0x%x\\n\",\n\n            (unsigned long long)taddr, size);\n\n#endif\n\n\n\n    memset(zeroes, 0, size);\n\n    return spapr_tce_dma_write(dev, taddr, zeroes, size);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  IndexPacket\n    *indexes;\n\n  PixelPacket\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  unsigned short\n    nibble;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)\n{\n    int     i, id, dummy;\n    char   *buf, *c;\n    long    start, sz;\n\n    start = ftell(fp);\n\n    /* Load all kids for all xref tables (versions) */\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))\n        {\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            while (SAFE_F(fp, (fgetc(fp) != 't')))\n                ; /* Iterate to trailer */\n \n             /* Get root catalog */\n             sz = pdf->xrefs[i].end - ftell(fp);\n            buf = malloc(sz + 1);\n             SAFE_E(fread(buf, 1, sz, fp), sz, \"Failed to load /Root.\\n\");\n             buf[sz] = '\\0';\n             if (!(c = strstr(buf, \"/Root\")))\n            {\n                free(buf);\n                continue;\n            }\n\n            /* Jump to catalog (root) */\n            id = atoi(c + strlen(\"/Root\") + 1);\n            free(buf);\n            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);\n            if (!buf || !(c = strstr(buf, \"/Pages\")))\n            {\n                free(buf);\n                continue;\n            }\n\n            /* Start at the first Pages obj and get kids */\n            id = atoi(c + strlen(\"/Pages\") + 1);\n            load_kids(fp, id, &pdf->xrefs[i]);\n            free(buf); \n        }\n    }\n            \n    fseek(fp, start, SEEK_SET);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "vbf_stp_fail(struct worker *wrk, const struct busyobj *bo)\n{\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\n\tassert(bo->fetch_objcore->boc->state < BOS_FINISHED);\n\tHSH_Fail(bo->fetch_objcore);\n\tif (!(bo->fetch_objcore->flags & OC_F_BUSY))\n\t\tHSH_Kill(bo->fetch_objcore);\n\tObjSetState(wrk, bo->fetch_objcore, BOS_FAILED);\n\treturn (F_STP_DONE);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void bnx2x_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnx2x *bp;\n\n\tif (!dev) {\n\t\tdev_err(&pdev->dev, \"BAD net device from bnx2x_init_one\\n\");\n\t\treturn;\n\t}\n\tbp = netdev_priv(dev);\n\n\t__bnx2x_remove(pdev, dev, bp, true);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "virConnectNumOfDomains(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (conn->driver->connectNumOfDomains) {\n        int ret = conn->driver->connectNumOfDomains(conn);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void sigusr1_handler(int sig)\n{\n\n\t/* Linux has \"one-shot\" signals, reinstall the signal handler */\n\tsignal(SIGUSR1, sigusr1_handler);\n\n\tdlog(LOG_DEBUG, 4, \"sigusr1_handler called\");\n\n\tsigusr1_received = 1;\n\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "pkcs11rsa_verify(dst_context_t *dctx, const isc_region_t *sig) {\n\tCK_RV rv;\n\tpk11_context_t *pk11_ctx = dctx->ctxdata.pk11_ctx;\n\tisc_result_t ret = ISC_R_SUCCESS;\n\n\tPK11_CALL(pkcs_C_VerifyFinal,\n\t\t  (pk11_ctx->session,\n\t\t   (CK_BYTE_PTR) sig->base,\n\t\t   (CK_ULONG) sig->length),\n\t\t  DST_R_VERIFYFAILURE);\n\treturn (ret);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "explicit QuantizedMaxPoolingOp(OpKernelConstruction* context)\n      : MaxPoolingOp<Device, T>(context) {}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "//! Convert pixel values from HSV to RGB color spaces \\newinstance.\n    CImg<Tuchar> get_HSVtoRGB() const {\n      return CImg<Tuchar>(*this,false).HSVtoRGB();",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "bool cancel_delayed_work_sync(struct delayed_work *dwork)\n{\n\treturn __cancel_work_timer(&dwork->work, true);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn raw;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void sdhci_send_command(SDHCIState *s)\n{\n    SDRequest request;\n    uint8_t response[16];\n    int rlen;\n\n    s->errintsts = 0;\n    s->acmd12errsts = 0;\n    request.cmd = s->cmdreg >> 8;\n    request.arg = s->argument;\n\n    trace_sdhci_send_command(request.cmd, request.arg);\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n        if (rlen == 4) {\n            s->rspreg[0] = ldl_be_p(response);\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n            trace_sdhci_response4(s->rspreg[0]);\n        } else if (rlen == 16) {\n            s->rspreg[0] = ldl_be_p(&response[11]);\n            s->rspreg[1] = ldl_be_p(&response[7]);\n            s->rspreg[2] = ldl_be_p(&response[3]);\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n                            response[2];\n            trace_sdhci_response16(s->rspreg[3], s->rspreg[2],\n                                   s->rspreg[1], s->rspreg[0]);\n        } else {\n            trace_sdhci_error(\"timeout waiting for command response\");\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n                s->norintsts |= SDHC_NIS_ERR;\n            }\n        }\n\n        if (!(s->quirks & SDHCI_QUIRK_NO_BUSY_IRQ) &&\n            (s->norintstsen & SDHC_NISEN_TRSCMP) &&\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n            s->norintsts |= SDHC_NIS_TRSCMP;\n        }\n    }\n\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n        s->norintsts |= SDHC_NIS_CMDCMP;\n    }\n\n    sdhci_update_irq(s);\n\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n        s->data_count = 0;\n        sdhci_data_transfer(s);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "XML_GetCurrentByteCount(XML_Parser parser) {\n  if (parser == NULL)\n    return 0;\n  if (parser->m_eventEndPtr && parser->m_eventPtr)\n    return (int)(parser->m_eventEndPtr - parser->m_eventPtr);\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)\n{\n    replace_item_in_object(object, string, newitem, true);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void ff_lzw_decode_tail(LZWState *p)\n\n{\n\n    struct LZWState *s = (struct LZWState *)p;\n\n    while(!s->eob_reached)\n\n        lzw_get_code(s);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int hfs_decompress_lzvn_block(char* rawBuf, uint32_t len, char* uncBuf, uint64_t* uncLen)\n{\n    if (len > 0 && rawBuf[0] != 0x06) {\n        *uncLen = lzvn_decode_buffer(uncBuf, COMPRESSION_UNIT_SIZE, rawBuf, len);\n        return 1;  // apparently this can't fail\n    }\n    else {\n        return hfs_decompress_noncompressed_block(rawBuf, len, uncBuf, uncLen);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void unix_dgram_peer_wake_disconnect_wakeup(struct sock *sk,\n\t\t\t\t\t\t   struct sock *other)\n{\n\tunix_dgram_peer_wake_disconnect(sk, other);\n\twake_up_interruptible_poll(sk_sleep(sk),\n\t\t\t\t   POLLOUT |\n\t\t\t\t   POLLWRNORM |\n\t\t\t\t   POLLWRBAND);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "UseNewLEDField(enum led_field field, LedInfo *old, LedInfo *new,\n               bool report, enum led_field *collide)\n{\n    if (!(old->defined & field))\n        return true;\n\n    if (new->defined & field) {\n        if (report)\n            *collide |= field;\n\n        if (new->merge != MERGE_AUGMENT)\n            return true;\n    }\n\n    return false;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void uc32_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    UniCore32CPUClass *ucc = UNICORE32_CPU_GET_CLASS(dev);\n    ucc->parent_realize(dev, errp);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "xps_true_callback_glyph_name(gs_font *pfont, gs_glyph glyph, gs_const_string *pstr)\n{\n    /* This function is copied verbatim from plfont.c */\n\n    int table_length;\n     int table_offset;\n \n     ulong format;\n    uint numGlyphs;\n     uint glyph_name_index;\n     const byte *postp; /* post table pointer */\n \n     /* guess if the font type is not truetype */\n     if ( pfont->FontType != ft_TrueType )\n     {\n            pstr->size = strlen((char*)pstr->data);\n            return 0;\n        }\n        else\n        {\n            return gs_throw1(-1, \"glyph index %lu out of range\", (ulong)glyph);\n        }\n    }",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int __init i740fb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"i740fb\", &option))\n\t\treturn -ENODEV;\n\ti740fb_setup(option);\n#endif\n\n\treturn pci_register_driver(&i740fb_driver);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void GfxPath::close() {\n  if (justMoved) {\n    if (n >= size) {\n      size += 16;\n      subpaths = (GfxSubpath **)\n\tgreallocn(subpaths, size, sizeof(GfxSubpath *));\n    }\n    subpaths[n] = new GfxSubpath(firstX, firstY);\n    ++n;\n    justMoved = gFalse;\n  }\n  subpaths[n-1]->close();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "netsnmp_mibindex_lookup( const char *dirname )\n{\n    int i;\n    static char tmpbuf[300];\n\n    for (i=0; i<_mibindex; i++) {\n        if ( _mibindexes[i] &&\n             strcmp( _mibindexes[i], dirname ) == 0) {\n             snprintf(tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                      get_persistent_directory(), i);\n             tmpbuf[sizeof(tmpbuf)-1] = 0;\n             DEBUGMSGTL((\"mibindex\", \"lookup: %s (%d) %s\\n\", dirname, i, tmpbuf ));\n             return tmpbuf;\n        }\n    }\n    DEBUGMSGTL((\"mibindex\", \"lookup: (none)\\n\"));\n    return NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool JPEGImageDecoder::isSizeAvailable()\n{\n    if (!ImageDecoder::isSizeAvailable())\n         decode(true);\n\n    return ImageDecoder::isSizeAvailable();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void EditorClientBlackBerry::textDidChangeInTextField(Element* element)\n{\n    if (m_webPagePrivate->m_webSettings->isFormAutofillEnabled()) {\n        if (HTMLInputElement* inputElement = element->toInputElement())\n            m_webPagePrivate->m_autofillManager->didChangeInTextField(inputElement);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void assert_avoptions(AVDictionary *m)\n\n{\n\n    AVDictionaryEntry *t;\n\n    if ((t = av_dict_get(m, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Option %s not found.\\n\", t->key);\n\n        exit(1);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "DownloadItemImpl::RequestInfo::RequestInfo(const GURL& url)\n    : url_chain(std::vector<GURL>(1, url)), start_time(base::Time::Now()) {}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int drive_add(const char *file, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    int index = drive_opt_get_free_idx();\n\n\n\n    if (nb_drives_opt >= MAX_DRIVES || index == -1) {\n\n        fprintf(stderr, \"qemu: too many drives\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    drives_opt[index].file = file;\n\n    va_start(ap, fmt);\n\n    vsnprintf(drives_opt[index].opt,\n\n              sizeof(drives_opt[0].opt), fmt, ap);\n\n    va_end(ap);\n\n\n\n    nb_drives_opt++;\n\n    return index;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "explicit ApproximateEqualOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    float tolerance;\n    OP_REQUIRES_OK(context, context->GetAttr(\"tolerance\", &tolerance));\n    tolerance_ = T(tolerance);\n  }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void unix_start_incoming_migration(const char *path, Error **errp)\n\n{\n\n    int s;\n\n\n\n    s = unix_listen(path, NULL, 0, errp);\n\n    if (s < 0) {\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s, NULL, unix_accept_incoming_migration, NULL,\n\n                         (void *)(intptr_t)s);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tchar *options;\n\n\tif (flags & MS_KERNMOUNT) {\n\t\tns = (struct pid_namespace *)data;\n\t\toptions = NULL;\n\t} else {\n\t\tns = task_active_pid_ns(current);\n\t\toptions = data;\n\n\t\t/* Does the mounter have privilege over the pid namespace? */\n\t\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))\n\t\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);\n \tif (IS_ERR(sb))\n \t\treturn ERR_CAST(sb);\n \n \tif (!proc_parse_options(options, ns)) {\n \t\tdeactivate_locked_super(sb);\n \t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!sb->s_root) {\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t\t/* User space would break if executables appear on proc */\n\t\tsb->s_iflags |= SB_I_NOEXEC;\n\t}\n\n\treturn dget(sb->s_root);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "vncProperties::SavePassword(HKEY key, char *buffer)\r\n{\r\n\tRegSetValueEx(key, \"Password\", 0, REG_BINARY, (LPBYTE) buffer, MAXPWLEN);\r\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "//! Load image from an INRIMAGE-4 file \\overloading.\n    CImg<T>& load_inr(std::FILE *const file, float *const voxel_size=0) {\n      return _load_inr(file,0,voxel_size);",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tport_t *port = dev_to_port(dev);\n\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifr->ifr_settings.size < size) {\n \t\t\tifr->ifr_settings.size = size; /* data size wanted */\n \t\t\treturn -ENOBUFS;\n \t\t}\n \t\tline.clock_type = get_status(port)->clocking;\n \t\tline.clock_rate = 0;\n \t\tline.loopback = 0;\n\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL; /* No such clock setting */\n\n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n        }\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int kill_ok_by_cred(struct task_struct *t)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct cred *tcred = __task_cred(t);\n\n\tif (uid_eq(cred->euid, tcred->suid) ||\n\t    uid_eq(cred->euid, tcred->uid)  ||\n\t    uid_eq(cred->uid,  tcred->suid) ||\n\t    uid_eq(cred->uid,  tcred->uid))\n\t\treturn 1;\n\n\tif (ns_capable(tcred->user_ns, CAP_KILL))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void muscle_load_single_acl(sc_file_t* file, int operation, unsigned short acl)\n{\n\tint key;\n\t/* Everybody by default.... */\n\tsc_file_add_acl_entry(file, operation, SC_AC_NONE, 0);\n\tif(acl == 0xFFFF) {\n\t\tsc_file_add_acl_entry(file, operation, SC_AC_NEVER, 0);\n\t\treturn;\n\t}\n\tfor(key = 0; key < 16; key++) {\n\t\tif(acl >> key & 1) {\n\t\t\tsc_file_add_acl_entry(file, operation, SC_AC_CHV, key);\n\t\t}\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "rsrc_cmp_key(const struct archive_rb_node *n, const void *key)\n{\n\tconst struct zip_entry *e = (const struct zip_entry *)n;\n\treturn (strcmp((const char *)key, e->rsrcname.s));\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void InputEngine::ProcessText(const std::string& message,\n                              ProcessTextCallback callback) {\n  NOTIMPLEMENTED();  // Text message not used in the rulebased engine.\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "SMB_ACL_T free_empty_sys_acl(connection_struct *conn, SMB_ACL_T the_acl)\n{\n\tSMB_ACL_ENTRY_T entry;\n\n\tif (!the_acl)\n\t\treturn NULL;\n\tif (SMB_VFS_SYS_ACL_GET_ENTRY(conn, the_acl, SMB_ACL_FIRST_ENTRY, &entry) != 1) {\n\t\tSMB_VFS_SYS_ACL_FREE_ACL(conn, the_acl);\n\t\treturn NULL;\n\t}\n\treturn the_acl;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int get_high_utility_cell(elbg_data *elbg)\n\n{\n\n    int i=0;\n\n    /* Using linear search, do binary if it ever turns to be speed critical */\n\n    int r = av_lfg_get(elbg->rand_state)%elbg->utility_inc[elbg->numCB-1] + 1;\n\n    while (elbg->utility_inc[i] < r)\n\n        i++;\n\n\n\n    av_assert2(elbg->cells[i]);\n\n\n\n    return i;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void scsi_remove_request(SCSIGenericReq *r)\n\n{\n\n    qemu_free(r->buf);\n\n    scsi_req_free(&r->req);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int qemu_chr_open_win_file(HANDLE fd_out, CharDriverState **pchr)\n\n{\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    s->hcom = fd_out;\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    qemu_chr_generic_open(chr);\n\n    *pchr = chr;\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int extract_status_code(char *buffer, size_t size)\n {\n\tchar *buf_code;\n\tchar *begin;\n \tchar *end = buffer + size;\n\tsize_t inc = 0;\n\tint code;\n\t/* Allocate the room */\n\tbuf_code = (char *)MALLOC(10);\n \n \t/* Status-Code extraction */\n\twhile (buffer < end && *buffer++ != ' ') ;\n\tbegin = buffer;\n\twhile (buffer < end && *buffer++ != ' ')\n\t\tinc++;\n\tstrncat(buf_code, begin, inc);\n\tcode = atoi(buf_code);\n\tFREE(buf_code);\n \treturn code;\n }",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int rtp_write(URLContext *h, const uint8_t *buf, int size)\n{\n    RTPContext *s = h->priv_data;\n    int ret;\n    URLContext *hd;\n    if (RTP_PT_IS_RTCP(buf[1])) {\n        /* RTCP payload type */\n        hd = s->rtcp_hd;\n    } else {\n        /* RTP payload type */\n        hd = s->rtp_hd;\n    }\n    ret = ffurl_write(hd, buf, size);\n    return ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "walk_string(fz_context *ctx, int uni, int remove, editable_str *str)\n {\n        int rune;\n \n       if (str->utf8 == NULL)\n                return;\n \n        do\n\t{\n\t\tchar *s = &str->utf8[str->pos];\n\t\tsize_t len;\n\t\tint n = fz_chartorune(&rune, s);\n\t\tif (rune == uni)\n\t\t{\n\t\t\t/* Match. Skip over that one. */\n\t\t\tstr->pos += n;\n\t\t}\n\t\telse if (uni == 32) {\n\t\t\t/* We don't care if we're given whitespace\n\t\t\t * and it doesn't match the string. Don't\n\t\t\t * skip forward. Nothing to remove. */\n\t\t\tbreak;\n\t\t}\n\t\telse if (rune == 32) {\n\t\t\t/* The string has a whitespace, and we\n\t\t\t * don't match it; that's forgivable as\n\t\t\t * PDF often misses out spaces. Remove this\n\t\t\t * if we are removing stuff. */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Mismatch. No point in tracking through any more. */\n\t\t\tstr->pos = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (remove)\n\t\t{\n\t\t\tlen = strlen(s+n);\n\t\t\tmemmove(s, s+n, len+1);\n\t\t\tstr->edited = 1;\n\t\t}\n\t}\n\twhile (rune != uni);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static struct sock *__vsock_find_bound_socket(struct sockaddr_vm *addr)\n{\n\tstruct vsock_sock *vsk;\n\n\tlist_for_each_entry(vsk, vsock_bound_sockets(addr), bound_table)\n\t\tif (addr->svm_port == vsk->local_addr.svm_port)\n\t\t\treturn sk_vsock(vsk);\n\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "ofputil_decode_tlv_table_reply(const struct ofp_header *oh,\n                                  struct ofputil_tlv_table_reply *ttr)\n{\n    struct ofpbuf msg = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&msg);\n\n    struct nx_tlv_table_reply *nx_ttr = ofpbuf_pull(&msg, sizeof *nx_ttr);\n    ttr->max_option_space = ntohl(nx_ttr->max_option_space);\n    ttr->max_fields = ntohs(nx_ttr->max_fields);\n\n    return decode_tlv_table_mappings(&msg, ttr->max_fields, &ttr->mappings);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int sha1_ssse3_export(struct shash_desc *desc, void *out)\n{\n\tstruct sha1_state *sctx = shash_desc_ctx(desc);\n\n\tmemcpy(out, sctx, sizeof(*sctx));\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int qemu_rdma_write(QEMUFile *f, RDMAContext *rdma,\n\n                           uint64_t block_offset, uint64_t offset,\n\n                           uint64_t len)\n\n{\n\n    uint64_t current_addr = block_offset + offset;\n\n    uint64_t index = rdma->current_index;\n\n    uint64_t chunk = rdma->current_chunk;\n\n    int ret;\n\n\n\n    /* If we cannot merge it, we flush the current buffer first. */\n\n    if (!qemu_rdma_buffer_mergable(rdma, current_addr, len)) {\n\n        ret = qemu_rdma_write_flush(f, rdma);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n        rdma->current_length = 0;\n\n        rdma->current_addr = current_addr;\n\n\n\n        ret = qemu_rdma_search_ram_block(rdma, block_offset,\n\n                                         offset, len, &index, &chunk);\n\n        if (ret) {\n\n            fprintf(stderr, \"ram block search failed\\n\");\n\n            return ret;\n\n        }\n\n        rdma->current_index = index;\n\n        rdma->current_chunk = chunk;\n\n    }\n\n\n\n    /* merge it */\n\n    rdma->current_length += len;\n\n\n\n    /* flush it if buffer is too large */\n\n    if (rdma->current_length >= RDMA_MERGE_MAX) {\n\n        return qemu_rdma_write_flush(f, rdma);\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin();\n\tint sig = SIGSEGV;\n\n\tif (__die(str, regs, err))\n\t\tsig = 0;\n\toops_end(flags, regs, sig);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "inline int nr_offset(int row, int col) throw()\n  {\n    return (row * nr_width + col);\n  }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "hb_set_intersect (hb_set_t       *set,\n\t\t  const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->intersect (*other);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static gboolean fd_trampoline(GIOChannel *chan, GIOCondition cond, gpointer opaque)\n\n{\n\n    IOTrampoline *tramp = opaque;\n\n\n\n    if (tramp->opaque == NULL) {\n\n        return FALSE;\n\n    }\n\n\n\n    if ((cond & G_IO_IN) && tramp->fd_read) {\n\n        tramp->fd_read(tramp->opaque);\n\n    }\n\n\n\n    if ((cond & G_IO_OUT) && tramp->fd_write) {\n\n        tramp->fd_write(tramp->opaque);\n\n    }\n\n\n\n    return TRUE;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void Magick::Image::channelDepth(const ChannelType channel_,\n  const size_t depth_)\n{\n  modifyImage();\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  SetImageDepth(image(),depth_,exceptionInfo);\n  RestorePPChannelMask;\n  ThrowImageException;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline int prb_queue_frozen(struct kbdq_core *pkc)\n{\n\treturn pkc->reset_pending_on_curr_blk;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int ax88179_read_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t\t u16 index, u16 size, void *data)\n{\n\tint ret;\n\n\tif (2 == size) {\n\t\tu16 buf;\n\t\tret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 1);\n\t\tle16_to_cpus(&buf);\n\t\t*((u16 *)data) = buf;\n\t} else if (4 == size) {\n\t\tu32 buf;\n\t\tret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 1);\n\t\tle32_to_cpus(&buf);\n\t\t*((u32 *)data) = buf;\n\t} else {\n\t\tret = __ax88179_read_cmd(dev, cmd, value, index, size, data, 1);\n\t}\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\tstruct vm_area_struct *next;\n\n\taddress &= PAGE_MASK;\n\tnext = vma->vm_next;\n\tif (next && next->vm_start == address + PAGE_SIZE) {\n\t\tif (!(next->vm_flags & VM_GROWSUP))\n\t\t\treturn -ENOMEM;\n\t}\n\treturn expand_upwards(vma, address);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void ip_slowtimo(Slirp *slirp)\n{\n    struct qlink *l;\n\n    DEBUG_CALL(\"ip_slowtimo\");\n\n    l = slirp->ipq.ip_link.next;\n\n    if (l == NULL)\n        return;\n\n    while (l != &slirp->ipq.ip_link) {\n        struct ipq *fp = container_of(l, struct ipq, ip_link);\n        l = l->next;\n        if (--fp->ipq_ttl == 0) {\n            ip_freef(slirp, fp);\n        }\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void dentry_unhash(struct dentry *dentry)\n{\n\tshrink_dcache_parent(dentry);\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_lockref.count == 1)\n\t\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "status_t ESDS::parseESDescriptor(size_t offset, size_t size) {\n if (size < 3) {\n return ERROR_MALFORMED;\n }\n\n    offset += 2; // skip ES_ID\n    size -= 2;\n\n unsigned streamDependenceFlag = mData[offset] & 0x80;\n unsigned URL_Flag = mData[offset] & 0x40;\n unsigned OCRstreamFlag = mData[offset] & 0x20;\n\n ++offset;\n\n     --size;\n \n     if (streamDependenceFlag) {\n         offset += 2;\n         size -= 2;\n     }\n\n if (URL_Flag) {\n if (offset >= size) {\n\n             return ERROR_MALFORMED;\n         }\n         unsigned URLlength = mData[offset];\n         offset += URLlength + 1;\n         size -= URLlength + 1;\n     }\n \n     if (OCRstreamFlag) {\n         offset += 2;\n         size -= 2;\n \n if ((offset >= size || mData[offset] != kTag_DecoderConfigDescriptor)\n && offset - 2 < size\n && mData[offset - 2] == kTag_DecoderConfigDescriptor) {\n            offset -= 2;\n            size += 2;\n\n            ALOGW(\"Found malformed 'esds' atom, ignoring missing OCR_ES_Id.\");\n }\n }\n\n if (offset >= size) {\n return ERROR_MALFORMED;\n }\n\n uint8_t tag;\n size_t sub_offset, sub_size;\n status_t err = skipDescriptorHeader(\n            offset, size, &tag, &sub_offset, &sub_size);\n\n if (err != OK) {\n return err;\n }\n\n if (tag != kTag_DecoderConfigDescriptor) {\n return ERROR_MALFORMED;\n }\n\n    err = parseDecoderConfigDescriptor(sub_offset, sub_size);\n\n return err;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\n\tif (!npt_enabled) {\n\t\t/* Shadow paging assumes NX to be available.  */\n\t\tefer |= EFER_NX;\n\n\t\tif (!(efer & EFER_LMA))\n\t\t\tefer &= ~EFER_LME;\n\t}\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)\n{\n\tstruct socket *sock, *oldsock;\n\tstruct vhost_virtqueue *vq;\n\tstruct vhost_net_virtqueue *nvq;\n\tstruct vhost_net_ubuf_ref *ubufs, *oldubufs = NULL;\n\tint r;\n\n\tmutex_lock(&n->dev.mutex);\n\tr = vhost_dev_check_owner(&n->dev);\n\tif (r)\n\t\tgoto err;\n\n\tif (index >= VHOST_NET_VQ_MAX) {\n\t\tr = -ENOBUFS;\n\t\tgoto err;\n\t}\n\tvq = &n->vqs[index].vq;\n\tnvq = &n->vqs[index];\n\tmutex_lock(&vq->mutex);\n\n\t/* Verify that ring has been setup correctly. */\n\tif (!vhost_vq_access_ok(vq)) {\n\t\tr = -EFAULT;\n\t\tgoto err_vq;\n\t}\n\tsock = get_socket(fd);\n\tif (IS_ERR(sock)) {\n\t\tr = PTR_ERR(sock);\n\t\tgoto err_vq;\n\t}\n\n\t/* start polling new socket */\n\toldsock = rcu_dereference_protected(vq->private_data,\n\t\t\t\t\t    lockdep_is_held(&vq->mutex));\n\tif (sock != oldsock) {\n\t\tubufs = vhost_net_ubuf_alloc(vq,\n\t\t\t\t\t     sock && vhost_sock_zcopy(sock));\n\t\tif (IS_ERR(ubufs)) {\n\t\t\tr = PTR_ERR(ubufs);\n\t\t\tgoto err_ubufs;\n\t\t}\n\n\t\tvhost_net_disable_vq(n, vq);\n\t\trcu_assign_pointer(vq->private_data, sock);\n\t\tr = vhost_init_used(vq);\n\t\tif (r)\n\t\t\tgoto err_used;\n\t\tr = vhost_net_enable_vq(n, vq);\n\t\tif (r)\n\t\t\tgoto err_used;\n\n\t\toldubufs = nvq->ubufs;\n\t\tnvq->ubufs = ubufs;\n\n\t\tn->tx_packets = 0;\n\t\tn->tx_zcopy_err = 0;\n\t\tn->tx_flush = false;\n\t}\n\n \tmutex_unlock(&vq->mutex);\n \n \tif (oldubufs) {\n\t\tvhost_net_ubuf_put_and_wait(oldubufs);\n \t\tmutex_lock(&vq->mutex);\n \t\tvhost_zerocopy_signal_used(n, vq);\n \t\tmutex_unlock(&vq->mutex);\n\t}\n\n\tif (oldsock) {\n\t\tvhost_net_flush_vq(n, index);\n\t\tfput(oldsock->file);\n\t}\n\n\tmutex_unlock(&n->dev.mutex);\n\treturn 0;\n\nerr_used:\n \trcu_assign_pointer(vq->private_data, oldsock);\n \tvhost_net_enable_vq(n, vq);\n \tif (ubufs)\n\t\tvhost_net_ubuf_put_and_wait(ubufs);\n err_ubufs:\n \tfput(sock->file);\n err_vq:\n\tmutex_unlock(&vq->mutex);\nerr:\n\tmutex_unlock(&n->dev.mutex);\n\treturn r;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static __exit void cgw_module_exit(void)\n{\n\trtnl_unregister_all(PF_CAN);\n\n\tunregister_netdevice_notifier(&notifier);\n\n\tunregister_pernet_subsys(&cangw_pernet_ops);\n\trcu_barrier(); /* Wait for completion of call_rcu()'s */\n\n\tkmem_cache_destroy(cgw_cache);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline int get_priv_size(__u16\targs)\n{\n\tint\tnum = args & IW_PRIV_SIZE_MASK;\n\tint\ttype = (args & IW_PRIV_TYPE_MASK) >> 12;\n\n\treturn num * iw_priv_type_size[type];\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool __fastcall TSiteRawDialog::Execute(TSessionData * Data)\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TSessionData> RawData(new TSessionData(L\"\"));\r\n  RawData->Assign(Data);\r\n  // SFTP-only is not reflected by the protocol prefix, we have to use rawsettings for that\r\n  if (RawData->FSProtocol != fsSFTPonly)\r\n  {\r\n    RawData->FSProtocol = FactoryDefaults->FSProtocol;\r\n  }\r\n  RawData->HostName = FactoryDefaults->HostName;\r\n  RawData->PortNumber = FactoryDefaults->PortNumber;\r\n  RawData->UserName = FactoryDefaults->UserName;\r\n  RawData->Password = FactoryDefaults->Password;\r\n  RawData->Ftps = FactoryDefaults->Ftps;\r\n\r\n  std::unique_ptr<TStrings> Options(RawData->SaveToOptions(FactoryDefaults.get(), false, false));\r\n\r\n  SettingsMemo->Lines = Options.get();\r\n\r\n  bool Result = TCustomDialog::Execute();\r\n  if (Result)\r\n  {\r\n    std::unique_ptr<TSessionData> BackupData(new TSessionData(L\"\"));\r\n    BackupData->Assign(Data);\r\n    Data->DefaultSettings();\r\n\r\n    Data->FSProtocol = BackupData->FSProtocol;\r\n    Data->HostName = BackupData->HostName;\r\n    Data->PortNumber = BackupData->PortNumber;\r\n    Data->UserName = BackupData->UserName;\r\n    Data->Password = BackupData->Password;\r\n    Data->Ftps = BackupData->Ftps;\r\n\r\n    Data->ApplyRawSettings(SettingsMemo->Lines);\r\n  }\r\n  return Result;\r\n}\r",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "png_set_compression_strategy(png_structp png_ptr, int strategy)\n{\n   png_debug(1, \"in png_set_compression_strategy\");\n\n   if (png_ptr == NULL)\n      return;\n   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_STRATEGY;\n   png_ptr->zlib_strategy = strategy;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "optional<ARN> ARN::parse(const string& s, bool wildcards) {\n  static const char str_wild[] = \"arn:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)\";\n  static const regex rx_wild(str_wild,\n\t\t\t\t    sizeof(str_wild) - 1,\n\t\t\t\t    ECMAScript | optimize);\n  static const char str_no_wild[]\n    = \"arn:([^:*]*):([^:*]*):([^:*]*):([^:*]*):([^:*]*)\";\n  static const regex rx_no_wild(str_no_wild,\n\t\t\t\tsizeof(str_no_wild) - 1,\n\t\t\t\tECMAScript | optimize);\n\n  smatch match;\n\n  if ((s == \"*\") && wildcards) {\n    return ARN(Partition::wildcard, Service::wildcard, \"*\", \"*\", \"*\");\n  } else if (regex_match(s, match, wildcards ? rx_wild : rx_no_wild)) {\n    ceph_assert(match.size() == 6);\n\n    ARN a;\n    {\n      auto p = to_partition(match[1], wildcards);\n      if (!p)\n\treturn none;\n\n      a.partition = *p;\n    }\n    {\n      auto s = to_service(match[2], wildcards);\n      if (!s) {\n\treturn none;\n      }\n      a.service = *s;\n    }\n\n    a.region = match[3];\n    a.account = match[4];\n    a.resource = match[5];\n\n    return a;\n  }\n  return none;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void vsock_remove_connected(struct vsock_sock *vsk)\n{\n\tspin_lock_bh(&vsock_table_lock);\n\t__vsock_remove_connected(vsk);\n\tspin_unlock_bh(&vsock_table_lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void free_buffers(VP8Context *s)\n\n{\n\n    int i;\n\n    if (s->thread_data)\n\n        for (i = 0; i < MAX_THREADS; i++) {\n\n\n\n\n\n            av_freep(&s->thread_data[i].filter_strength);\n\n            av_freep(&s->thread_data[i].edge_emu_buffer);\n\n        }\n\n    av_freep(&s->thread_data);\n\n    av_freep(&s->macroblocks_base);\n\n    av_freep(&s->intra4x4_pred_mode_top);\n\n    av_freep(&s->top_nnz);\n\n    av_freep(&s->top_border);\n\n\n\n    s->macroblocks = NULL;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "ga_concat_shorten_esc(garray_T *gap, char_u *str)\n{\n    char_u  *p;\n    char_u  *s;\n    int\t    c;\n    int\t    clen;\n    char_u  buf[NUMBUFLEN];\n    int\t    same_len;\n\n    if (str == NULL)\n    {\n\tga_concat(gap, (char_u *)\"NULL\");\n\treturn;\n    }\n\n    for (p = str; *p != NUL; ++p)\n    {\n\tsame_len = 1;\n\ts = p;\n\tc = mb_ptr2char_adv(&s);\n\tclen = s - p;\n\twhile (*s != NUL && c == mb_ptr2char(s))\n\t{\n\t    ++same_len;\n\t    s += clen;\n\t}\n\tif (same_len > 20)\n\t{\n\t    ga_concat(gap, (char_u *)\"\\\\[\");\n\t    ga_concat_esc(gap, p, clen);\n\t    ga_concat(gap, (char_u *)\" occurs \");\n\t    vim_snprintf((char *)buf, NUMBUFLEN, \"%d\", same_len);\n\t    ga_concat(gap, buf);\n\t    ga_concat(gap, (char_u *)\" times]\");\n\t    p = s - 1;\n\t}\n\telse\n\t    ga_concat_esc(gap, p, clen);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void tcg_target_qemu_prologue(TCGContext *s)\n\n{\n\n    /* stmdb sp!, { r9 - r11, lr } */\n\n    tcg_out32(s, (COND_AL << 28) | 0x092d4e00);\n\n\n\n    tcg_out_bx(s, COND_AL, TCG_REG_R0);\n\n    tb_ret_addr = s->code_ptr;\n\n\n\n    /* ldmia sp!, { r9 - r11, pc } */\n\n    tcg_out32(s, (COND_AL << 28) | 0x08bd8e00);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void vc1_sprite_flush(AVCodecContext *avctx)\n\n{\n\n    VC1Context *v     = avctx->priv_data;\n\n    MpegEncContext *s = &v->s;\n\n    AVFrame *f = &s->current_picture.f;\n\n    int plane, i;\n\n\n\n    /* Windows Media Image codecs have a convergence interval of two keyframes.\n\n       Since we can't enforce it, clear to black the missing sprite. This is\n\n       wrong but it looks better than doing nothing. */\n\n\n\n    if (f->data[0])\n\n        for (plane = 0; plane < (s->flags&CODEC_FLAG_GRAY ? 1 : 3); plane++)\n\n            for (i = 0; i < v->sprite_height>>!!plane; i++)\n\n                memset(f->data[plane] + i * f->linesize[plane],\n\n                       plane ? 128 : 0, f->linesize[plane]);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ImagingCopyInfo(Imaging destination, Imaging source)\n{\n    if (source->palette) {\n        if (destination->palette)\n            ImagingPaletteDelete(destination->palette);\n        destination->palette = ImagingPaletteDuplicate(source->palette);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void compose_search(char *type, char *buf, size_t len)\n{\n\tsnprintf(buf, len, \"M-SEARCH * HTTP/1.1\\r\\n\"\n\t\t \"Host: %s:%d\\r\\n\"\n\t\t \"MAN: \\\"ssdp:discover\\\"\\r\\n\"\n\t\t \"MX: 1\\r\\n\"\n\t\t \"ST: %s\\r\\n\"\n\t\t \"User-Agent: %s\\r\\n\"\n\t\t \"\\r\\n\",\n\t\t MC_SSDP_GROUP, MC_SSDP_PORT,\n\t\t type,\n\t\t server_string);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int udp_socket_create(UDPContext *s, struct sockaddr_storage *addr,\n\n                             socklen_t *addr_len, const char *localaddr)\n\n{\n\n    int udp_fd = -1;\n\n    struct addrinfo *res0 = NULL, *res = NULL;\n\n    int family = AF_UNSPEC;\n\n\n\n    if (((struct sockaddr *) &s->dest_addr)->sa_family)\n\n        family = ((struct sockaddr *) &s->dest_addr)->sa_family;\n\n    res0 = udp_resolve_host(localaddr[0] ? localaddr : NULL, s->local_port,\n\n                            SOCK_DGRAM, family, AI_PASSIVE);\n\n    if (res0 == 0)\n\n        goto fail;\n\n    for (res = res0; res; res=res->ai_next) {\n\n        udp_fd = ff_socket(res->ai_family, SOCK_DGRAM, 0);\n\n        if (udp_fd != -1) break;\n\n        log_net_error(NULL, AV_LOG_ERROR, \"socket\");\n\n    }\n\n\n\n    if (udp_fd < 0)\n\n        goto fail;\n\n\n\n    memcpy(addr, res->ai_addr, res->ai_addrlen);\n\n    *addr_len = res->ai_addrlen;\n\n\n\n    freeaddrinfo(res0);\n\n\n\n    return udp_fd;\n\n\n\n fail:\n\n    if (udp_fd >= 0)\n\n        closesocket(udp_fd);\n\n    if(res0)\n\n        freeaddrinfo(res0);\n\n    return -1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void test_init(void)\n\n{\n\n    uint64_t barsize;\n\n\n\n    dev = get_device();\n\n\n\n    dev_base = qpci_iomap(dev, 0, &barsize);\n\n\n\n    g_assert(dev_base != NULL);\n\n\n\n    qpci_device_enable(dev);\n\n\n\n    test_timer();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "sock_ops_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_setsockopt:\n\t\treturn &bpf_setsockopt_proto;\n\tcase BPF_FUNC_getsockopt:\n\t\treturn &bpf_getsockopt_proto;\n\tcase BPF_FUNC_sock_ops_cb_flags_set:\n\t\treturn &bpf_sock_ops_cb_flags_set_proto;\n\tcase BPF_FUNC_sock_map_update:\n\t\treturn &bpf_sock_map_update_proto;\n\tdefault:\n\t\treturn bpf_base_func_proto(func_id);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int wc_RsaSetNonBlock(RsaKey* key, RsaNb* nb)\n{\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    if (nb) {\n        XMEMSET(nb, 0, sizeof(RsaNb));\n    }\n\n    /* Allow nb == NULL to clear non-block mode */\n    key->nb = nb;\n\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n {\n\tunsigned int len;\n\tunsigned long start=0, off;\n \tstruct au1200fb_device *fbdev = info->par;\n \n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; /* CCA=7 */\n \n\treturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\t  vma->vm_end - vma->vm_start,\n\t\t\t\t  vma->vm_page_prot);\n }",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void memory_region_sync_dirty_bitmap(MemoryRegion *mr)\n\n{\n\n    FlatRange *fr;\n\n\n\n    FOR_EACH_FLAT_RANGE(fr, &address_space_memory.current_map) {\n\n        if (fr->mr == mr) {\n\n            MEMORY_LISTENER_UPDATE_REGION(fr, &address_space_memory,\n\n                                          Forward, log_sync);\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void visit_start_implicit_struct(Visitor *v, void **obj, size_t size,\n\n                                 Error **errp)\n\n{\n\n    if (!error_is_set(errp) && v->start_implicit_struct) {\n\n        v->start_implicit_struct(v, obj, size, errp);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu)\n{\n\tu64 *eoi_exit_bitmap = vcpu->arch.eoi_exit_bitmap;\n\tif (!vmx_cpu_uses_apicv(vcpu))\n\t\treturn;\n\n\tvmcs_write64(EOI_EXIT_BITMAP0, eoi_exit_bitmap[0]);\n\tvmcs_write64(EOI_EXIT_BITMAP1, eoi_exit_bitmap[1]);\n\tvmcs_write64(EOI_EXIT_BITMAP2, eoi_exit_bitmap[2]);\n\tvmcs_write64(EOI_EXIT_BITMAP3, eoi_exit_bitmap[3]);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "unsigned long usecs_to_jiffies(const unsigned int u)\n{\n\tif (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))\n\t\treturn MAX_JIFFY_OFFSET;\n#if HZ <= USEC_PER_SEC && !(USEC_PER_SEC % HZ)\n\treturn (u + (USEC_PER_SEC / HZ) - 1) / (USEC_PER_SEC / HZ);\n#elif HZ > USEC_PER_SEC && !(HZ % USEC_PER_SEC)\n\treturn u * (HZ / USEC_PER_SEC);\n#else\n\treturn ((u64)USEC_TO_HZ_MUL32 * u + USEC_TO_HZ_ADJ32)\n\t\t>> USEC_TO_HZ_SHR32;\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int MVGMacroCompare(const void *target,const void *source)\n{\n  const char\n    *p,\n    *q;\n\n  p=(const char *) target;\n  q=(const char *) source;\n  return(strcmp(p,q));\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline void ext4_iget_extra_inode(struct inode *inode,\n\t\t\t\t\t struct ext4_inode *raw_inode,\n\t\t\t\t\t struct ext4_inode_info *ei)\n{\n\t__le32 *magic = (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize;\n\tif (EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize + sizeof(__le32) <=\n\t    EXT4_INODE_SIZE(inode->i_sb) &&\n\t    *magic == cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t\text4_find_inline_data_nolock(inode);\n\t} else\n\t\tEXT4_I(inode)->i_inline_off = 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "PowerPopupView() {\n     SetHorizontalAlignment(ALIGN_RIGHT);\n     UpdateText();\n   }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "bool RootWindow::CanFocus() const {\n  return IsVisible();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int uas_switch_interface(struct usb_device *udev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tint alt;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn alt;\n\n\treturn usb_set_interface(udev,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void ext4_exit_feat_adverts(void)\n{\n\tkobject_put(&ext4_feat->f_kobj);\n\twait_for_completion(&ext4_feat->f_kobj_unregister);\n\tkfree(ext4_feat);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static ssize_t clusterip_proc_write(struct file *file, const char __user *input,\n\t\t\t\tsize_t size, loff_t *ofs)\n{\n\tstruct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;\n#define PROC_WRITELEN\t10\n\tchar buffer[PROC_WRITELEN+1];\n\tunsigned long nodenum;\n\n\tif (copy_from_user(buffer, input, PROC_WRITELEN))\n\t\treturn -EFAULT;\n\n\tif (*buffer == '+') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL, 10);\n\t\tif (clusterip_add_node(c, nodenum))\n\t\t\treturn -ENOMEM;\n\t} else if (*buffer == '-') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL,10);\n\t\tif (clusterip_del_node(c, nodenum))\n\t\t\treturn -ENOENT;\n\t} else\n\t\treturn -EIO;\n\n\treturn size;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void reserve(std::size_t capacity) {\n    if (capacity > capacity_)\n      grow(capacity);\n  }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\n\tif (quality == -1) {\n \t\tquality = 80;\n \t}\n \n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n \t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\n\nfreeargb:\n\tgdFree(argb);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static bool perms_include(int fmode, mode_t req_mode)\n{\n\tmode_t r;\n\n\tswitch (req_mode & O_ACCMODE) {\n\tcase O_RDONLY:\n\t\tr = S_IROTH;\n\t\tbreak;\n\tcase O_WRONLY:\n\t\tr = S_IWOTH;\n\t\tbreak;\n\tcase O_RDWR:\n\t\tr = S_IROTH | S_IWOTH;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn ((fmode & r) == r);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "storageConnectNumOfDefinedStoragePools(virConnectPtr conn)\n{\n    if (virConnectNumOfDefinedStoragePoolsEnsureACL(conn) < 0)\n        return -1;\n\n    return virStoragePoolObjNumOfStoragePools(driver->pools, conn, false,\n                                               virConnectNumOfDefinedStoragePoolsCheckACL);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void pl031_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = pl031_init;\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_pl031;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void interface_set_client_capabilities(QXLInstance *sin,\n                                              uint8_t client_present,\n                                              uint8_t caps[58])\n{\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n    qxl->shadow_rom.client_present = client_present;\n    memcpy(qxl->shadow_rom.client_capabilities, caps, sizeof(caps));\n    qxl->rom->client_present = client_present;\n    memcpy(qxl->rom->client_capabilities, caps, sizeof(caps));\n    qxl_rom_set_dirty(qxl);\n    qxl_send_events(qxl, QXL_INTERRUPT_CLIENT);",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void tg3_tx_timeout(struct net_device *dev)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (netif_msg_tx_err(tp)) {\n\t\tnetdev_err(dev, \"transmit timed out, resetting\\n\");\n\t\ttg3_dump_state(tp);\n\t}\n\n\ttg3_reset_task_schedule(tp);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int av_lockmgr_register(int (*cb)(void **mutex, enum AVLockOp op))\n\n{\n\n    if (lockmgr_cb) {\n\n        // There is no good way to rollback a failure to destroy the\n\n        // mutex, so we ignore failures.\n\n        lockmgr_cb(&codec_mutex,    AV_LOCK_DESTROY);\n\n        lockmgr_cb(&avformat_mutex, AV_LOCK_DESTROY);\n\n        lockmgr_cb     = NULL;\n\n        codec_mutex    = NULL;\n\n        avformat_mutex = NULL;\n\n    }\n\n\n\n    if (cb) {\n\n        void *new_codec_mutex    = NULL;\n\n        void *new_avformat_mutex = NULL;\n\n        int err;\n\n        if (err = cb(&new_codec_mutex, AV_LOCK_CREATE)) {\n\n            return err > 0 ? AVERROR_UNKNOWN : err;\n\n        }\n\n        if (err = cb(&new_avformat_mutex, AV_LOCK_CREATE)) {\n\n            // Ignore failures to destroy the newly created mutex.\n\n            cb(&new_codec_mutex, AV_LOCK_DESTROY);\n\n            return err > 0 ? AVERROR_UNKNOWN : err;\n\n        }\n\n        lockmgr_cb     = cb;\n\n        codec_mutex    = new_codec_mutex;\n\n        avformat_mutex = new_avformat_mutex;\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int ath6kl_wmi_mcast_filter_cmd(struct wmi *wmi, u8 if_idx, bool mc_all_on)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_mcast_filter_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_mcast_filter_cmd *) skb->data;\n\tcmd->mcast_all_enable = mc_all_on;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_MCAST_FILTER_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "AttestationPermissionRequestSheetModel::AttestationPermissionRequestSheetModel(\n    AuthenticatorRequestDialogModel* dialog_model)\n    : AuthenticatorSheetModelBase(dialog_model) {}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int can_safely_read(GetBitContext* gb, int bits) {\n\n    return get_bits_left(gb) >= bits;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void uat_umts_fp_record_free_cb(void*r) {\n    uat_umts_fp_ep_and_ch_record_t *rec = (uat_umts_fp_ep_and_ch_record_t *)r;\n\n    g_free(rec->srcIP);\n    g_free(rec->dstIP);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "exif_entry_new (void)\n{\n\tExifMem *mem = exif_mem_new_default ();\n\tExifEntry *e = exif_entry_new_mem (mem);\n\n\texif_mem_unref (mem);\n\n\treturn e;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "i915_gem_check_execbuffer(struct drm_i915_gem_execbuffer2 *exec)\n{\n\treturn ((exec->batch_start_offset | exec->batch_len) & 0x7) == 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void run_block_job(BlockJob *job, Error **errp)\n\n{\n\n    AioContext *aio_context = blk_get_aio_context(job->blk);\n\n\n\n    /* FIXME In error cases, the job simply goes away and we access a dangling\n\n     * pointer below. */\n\n    aio_context_acquire(aio_context);\n\n    do {\n\n        aio_poll(aio_context, true);\n\n        qemu_progress_print(job->len ?\n\n                            ((float)job->offset / job->len * 100.f) : 0.0f, 0);\n\n    } while (!job->ready);\n\n\n\n    block_job_complete_sync(job, errp);\n\n    aio_context_release(aio_context);\n\n\n\n    /* A block job may finish instantaneously without publishing any progress,\n\n     * so just signal completion here */\n\n    qemu_progress_print(100.f, 0);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx,\n                                      int (*cb) (X509_STORE_CTX *, void *),\n                                      void *arg)\n{\n    ctx->app_verify_callback = cb;\n    ctx->app_verify_arg = arg;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "**/\n    CImgList<T>& assign(const unsigned int n, const unsigned int width, const unsigned int height,\n                        const unsigned int depth, const unsigned int spectrum,\n                        const double val0, const double val1, ...) {\n      _CImgList_stdarg(double);\n      return *this;",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "MojoResult Core::CreateMessage(MojoMessageHandle* message_handle) {\n  if (!message_handle)\n    return MOJO_RESULT_INVALID_ARGUMENT;\n  *message_handle = reinterpret_cast<MojoMessageHandle>(\n      UserMessageImpl::CreateEventForNewMessage().release());\n  return MOJO_RESULT_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int try_decode_frame(AVStream *st, AVPacket *avpkt)\n\n{\n\n    int16_t *samples;\n\n    AVCodec *codec;\n\n    int got_picture, data_size, ret=0;\n\n    AVFrame picture;\n\n\n\n    if(!st->codec->codec){\n\n        codec = avcodec_find_decoder(st->codec->codec_id);\n\n        if (!codec)\n\n            return -1;\n\n        ret = avcodec_open(st->codec, codec);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    if(!has_codec_parameters(st->codec)){\n\n        switch(st->codec->codec_type) {\n\n        case CODEC_TYPE_VIDEO:\n\n\n            ret = avcodec_decode_video2(st->codec, &picture,\n\n                                        &got_picture, avpkt);\n\n            break;\n\n        case CODEC_TYPE_AUDIO:\n\n            data_size = FFMAX(avpkt->size, AVCODEC_MAX_AUDIO_FRAME_SIZE);\n\n            samples = av_malloc(data_size);\n\n            if (!samples)\n\n                goto fail;\n\n            ret = avcodec_decode_audio3(st->codec, samples,\n\n                                        &data_size, avpkt);\n\n            av_free(samples);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n fail:\n\n    return ret;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static bool foo_check_config(const char *cfgstring, char **reason)\n{\n\t return true;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void cleanup_capng(void)\n{\n    free(cap.saved);\n    cap.saved = NULL;\n    pthread_mutex_destroy(&cap.mutex);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int vfio_ccw_handle_request(ORB *orb, SCSW *scsw, void *data)\n\n{\n\n    S390CCWDevice *cdev = data;\n\n    VFIOCCWDevice *vcdev = DO_UPCAST(VFIOCCWDevice, cdev, cdev);\n\n    struct ccw_io_region *region = vcdev->io_region;\n\n    int ret;\n\n\n\n    QEMU_BUILD_BUG_ON(sizeof(region->orb_area) != sizeof(ORB));\n\n    QEMU_BUILD_BUG_ON(sizeof(region->scsw_area) != sizeof(SCSW));\n\n    QEMU_BUILD_BUG_ON(sizeof(region->irb_area) != sizeof(IRB));\n\n\n\n    memset(region, 0, sizeof(*region));\n\n\n\n    memcpy(region->orb_area, orb, sizeof(ORB));\n\n    memcpy(region->scsw_area, scsw, sizeof(SCSW));\n\n\n\nagain:\n\n    ret = pwrite(vcdev->vdev.fd, region,\n\n                 vcdev->io_region_size, vcdev->io_region_offset);\n\n    if (ret != vcdev->io_region_size) {\n\n        if (errno == EAGAIN) {\n\n            goto again;\n\n        }\n\n        error_report(\"vfio-ccw: wirte I/O region failed with errno=%d\", errno);\n\n        return -errno;\n\n    }\n\n\n\n    return region->ret_code;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static uint_fast32_t jpc_abstorelstepsize(jpc_fix_t absdelta, int scaleexpn)\n{\n\tint p;\n\tuint_fast32_t mant;\n\tuint_fast32_t expn;\n\tint n;\n\n\tif (absdelta < 0) {\n\t\tabort();\n\t}\n\n\tp = jpc_fix_firstone(absdelta) - JPC_FIX_FRACBITS;\n\tn = 11 - jpc_fix_firstone(absdelta);\n\tmant = ((n < 0) ? (absdelta >> (-n)) : (absdelta << n)) & 0x7ff;\n\texpn = scaleexpn - p;\n\tif (scaleexpn < p) {\n\t\tabort();\n\t}\n\treturn JPC_QCX_EXPN(expn) | JPC_QCX_MANT(mant);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "char *target_strerror(int err)\n\n{\n\n\n\n\n    return strerror(target_to_host_errno(err));\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "OFString DcmSCP::getCalledAETitle() const\n{\n  if (m_assoc == NULL)\n    return \"\";\n  return m_assoc->params->DULparams.calledAPTitle;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "PHPAPI void var_push_dtor_no_addref(php_unserialize_data_t *var_hashx, zval **rval)\n{\n\tvar_entries *var_hash = (*var_hashx)->last_dtor;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_push_dtor_no_addref(%ld): %d (%d)\\n\", var_hash?var_hash->used_slots:-1L, Z_TYPE_PP(rval), Z_REFCOUNT_PP(rval));\n#endif\n\n\tif (!var_hash || var_hash->used_slots == VAR_ENTRIES_MAX) {\n\t\tvar_hash = emalloc(sizeof(var_entries));\n\t\tvar_hash->used_slots = 0;\n\t\tvar_hash->next = 0;\n\n\t\tif (!(*var_hashx)->first_dtor) {\n\t\t\t(*var_hashx)->first_dtor = var_hash;\n\t\t} else {\n\t\t\t((var_entries *) (*var_hashx)->last_dtor)->next = var_hash;\n\t\t}\n\n\t\t(*var_hashx)->last_dtor = var_hash;\n\t}\n\n\tvar_hash->data[var_hash->used_slots++] = *rval;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void Compute(OpKernelContext* context) override {\n    // Only create one, if one does not exist already. Report status for all\n    // other exceptions. If one already exists, it unrefs the new one.\n    // An epsilon value of zero could cause performance issues and is therefore,\n    // disallowed.\n    const Tensor* epsilon_t;\n    OP_REQUIRES_OK(context, context->input(kEpsilonName, &epsilon_t));\n    float epsilon = epsilon_t->scalar<float>()();\n    OP_REQUIRES(\n        context, epsilon > 0,\n        errors::InvalidArgument(\"An epsilon value of zero is not allowed.\"));\n\n    const Tensor* num_streams_t;\n    OP_REQUIRES_OK(context, context->input(kNumStreamsName, &num_streams_t));\n    int64_t num_streams = num_streams_t->scalar<int64>()();\n\n    auto result =\n        new QuantileStreamResource(epsilon, max_elements_, num_streams);\n    auto status = CreateResource(context, HandleFromInput(context, 0), result);\n    if (!status.ok() && status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES(context, false, status);\n    }\n  }",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "sound_load_event (char *evt, char *file)\n{\n\tint i = 0;\n\n\tif (file[0] && pevent_find (evt, &i) != -1)\n\t{\n\t\tg_free (sound_files[i]);\n\t\tsound_files[i] = g_strdup (file);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "set_bound_node_opt_info(OptNode* opt, MinMaxLen* plen)\n{\n  mml_copy(&(opt->sb.mm),  plen);\n  mml_copy(&(opt->spr.mm), plen);\n  mml_copy(&(opt->map.mm), plen);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1, KM_USER0);\n\taddr2 = kmap_atomic(page2, KM_USER1);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2, KM_USER1);\n\tkunmap_atomic(addr1, KM_USER0);\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int write_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t   void *val, int bytes)\n{\n\tmemcpy(vcpu->mmio_data, val, bytes);\n\tmemcpy(vcpu->run->mmio.data, vcpu->mmio_data, 8);\n\treturn X86EMUL_CONTINUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_string_t );\n\n    p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\\0, -name, -size */\n    if( p_box->data.p_string->psz_text == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    memcpy( p_box->data.p_string->psz_text, p_peek, p_box->i_size - 8 );\n    p_box->data.p_string->psz_text[p_box->i_size - 8] = '\\0';\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"%4.4s\\\" text=`%s'\", (char *) & p_box->i_type,\n                 p_box->data.p_string->psz_text );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ipa_get_jf_ancestor_result (struct ipa_jump_func *jfunc, tree input)\n{\n  gcc_checking_assert (TREE_CODE (input) != TREE_BINFO);\n  if (TREE_CODE (input) == ADDR_EXPR)\n    {\n      tree t = TREE_OPERAND (input, 0);\n      t = build_ref_for_offset (EXPR_LOCATION (t), t,\n\t\t\t\tipa_get_jf_ancestor_offset (jfunc), false,\n\t\t\t\tptr_type_node, NULL, false);\n      return build_fold_addr_expr (t);\n    }\n  else\n    return NULL_TREE;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int catc_stop(struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\n\tnetif_stop_queue(netdev);\n\n\tif (!catc->is_f5u011)\n\t\tdel_timer_sync(&catc->timer);\n\n\tusb_kill_urb(catc->rx_urb);\n\tusb_kill_urb(catc->tx_urb);\n\tusb_kill_urb(catc->irq_urb);\n\tusb_kill_urb(catc->ctrl_urb);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int64_t qemu_icount_delta(void)\n\n{\n\n    if (!use_icount) {\n\n        return 5000 * (int64_t) 1000000;\n\n    } else if (use_icount == 1) {\n\n        /* When not using an adaptive execution frequency\n\n           we tend to get badly out of sync with real time,\n\n           so just delay for a reasonable amount of time.  */\n\n        return 0;\n\n    } else {\n\n        return cpu_get_icount() - cpu_get_clock();\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static u64 kvm_dr6_fixed(struct kvm_vcpu *vcpu)\n{\n\tu64 fixed = DR6_FIXED_1;\n\n\tif (!guest_cpuid_has_rtm(vcpu))\n\t\tfixed |= DR6_RTM;\n\treturn fixed;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int _find_waiter(struct waiter *w, uint32_t *jp)\n{\n\treturn (w->jobid == *jp);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void blkverify_aio_bh(void *opaque)\n\n{\n\n    BlkverifyAIOCB *acb = opaque;\n\n\n\n    if (acb->buf) {\n\n        qemu_iovec_destroy(&acb->raw_qiov);\n\n        qemu_vfree(acb->buf);\n\n    }\n\n    acb->common.cb(acb->common.opaque, acb->ret);\n\n    qemu_aio_unref(acb);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "input_csi_dispatch_rm(struct input_ctx *ictx)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase 4:\t\t/* IRM */\n\t\t\tscreen_write_mode_clear(&ictx->ctx, MODE_INSERT);\n\t\t\tbreak;\n\t\tcase 34:\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void ff_mpeg4_init_direct_mv(MpegEncContext *s){\n\n    //FIXME table is stored in MpegEncContext for thread-safety,\n\n    // but a static array would be faster\n\n    static const int tab_size = sizeof(s->direct_scale_mv[0])/sizeof(int16_t);\n\n    static const int tab_bias = (tab_size/2);\n\n    int i;\n\n    for(i=0; i<tab_size; i++){\n\n        s->direct_scale_mv[0][i] = (i-tab_bias)*s->pb_time/s->pp_time;\n\n        s->direct_scale_mv[1][i] = (i-tab_bias)*(s->pb_time-s->pp_time)/s->pp_time;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Jsi_MapEntry* Jsi_MapEntryFind (Jsi_Map *mapPtr, const void *key){\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashEntryFind(mapPtr->v.hash, key);\n        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeEntryFind(mapPtr->v.tree, key);\n        case JSI_MAP_LIST:\n            return (Jsi_MapEntry*) (key == NULL? Jsi_ListGetFront(mapPtr->v.list) : Jsi_ListGetBack(mapPtr->v.list));\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static bool memory_region_dispatch_write(MemoryRegion *mr,\n\n                                         hwaddr addr,\n\n                                         uint64_t data,\n\n                                         unsigned size)\n\n{\n\n    if (!memory_region_access_valid(mr, addr, size, true)) {\n\n        unassigned_mem_write(mr, addr, data, size);\n\n        return true;\n\n    }\n\n\n\n    adjust_endianness(mr, &data, size);\n\n\n\n    if (mr->ops->write) {\n\n        access_with_adjusted_size(addr, &data, size,\n\n                                  mr->ops->impl.min_access_size,\n\n                                  mr->ops->impl.max_access_size,\n\n                                  memory_region_write_accessor, mr);\n\n    } else {\n\n        access_with_adjusted_size(addr, &data, size, 1, 4,\n\n                                  memory_region_oldmmio_write_accessor, mr);\n\n    }\n\n    return false;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "free_ldap_seqof_key_data(ldap_seqof_key_data *keysets, krb5_int16 n_keysets)\n{\n    int i;\n\n    if (keysets == NULL)\n        return;\n\n    for (i = 0; i < n_keysets; i++)\n        k5_free_key_data(keysets[i].n_key_data, keysets[i].key_data);\n    free(keysets);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void fz_init_cached_color_converter(fz_context *ctx, fz_color_converter *cc, fz_colorspace *is, fz_colorspace *ds, fz_colorspace *ss, const fz_color_params *params)\n{\n\tint n = ss->n;\n\tfz_cached_color_converter *cached = fz_malloc_struct(ctx, fz_cached_color_converter);\n\n\tcc->opaque = cached;\n\tcc->convert = fz_cached_color_convert;\n\tcc->ds = ds ? ds : fz_device_gray(ctx);\n\tcc->ss = ss;\n\tcc->is = is;\n\n\tfz_try(ctx)\n\t{\n\t\tfz_find_color_converter(ctx, &cached->base, is, cc->ds, ss, params);\n\t\tcached->hash = fz_new_hash_table(ctx, 256, n * sizeof(float), -1, fz_free);\n\t}\n\tfz_catch(ctx)\n\t{\n                fz_drop_color_converter(ctx, &cached->base);\n                fz_drop_hash_table(ctx, cached->hash);\n                fz_free(ctx, cached);\n                fz_rethrow(ctx);\n        }\n }",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void RegisterProcess(const std::string& site, RenderProcessHost* process) {\n    SiteToProcessMap::iterator i = map_.find(site);\n    if (i == map_.end())\n      map_[site] = process;\n  }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int __sk_attach_prog(struct bpf_prog *prog, struct sock *sk)\n{\n\tstruct sk_filter *fp, *old_fp;\n\n\tfp = kmalloc(sizeof(*fp), GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tfp->prog = prog;\n\n\tif (!__sk_filter_charge(sk, fp)) {\n\t\tkfree(fp);\n\t\treturn -ENOMEM;\n\t}\n\trefcount_set(&fp->refcnt, 1);\n\n\told_fp = rcu_dereference_protected(sk->sk_filter,\n\t\t\t\t\t   lockdep_sock_is_held(sk));\n\trcu_assign_pointer(sk->sk_filter, fp);\n\n\tif (old_fp)\n\t\tsk_filter_uncharge(sk, old_fp);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int mov_read_dpxe(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_R10K);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static CURLcode file_disconnect(struct connectdata *conn,\n                                bool dead_connection)\n{\n  struct FILEPROTO *file = conn->data->req.protop;\n  (void)dead_connection; /* not used */\n\n  if(file) {\n    Curl_safefree(file->freepath);\n    file->path = NULL;\n    if(file->fd != -1)\n      close(file->fd);\n    file->fd = -1;\n  }\n\n  return CURLE_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int red_channel_test_remote_common_cap(RedChannel *channel, uint32_t cap)\n{\n    RingItem *link;\n\n    RING_FOREACH(link, &channel->clients) {\n        RedChannelClient *rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);\n\n        if (!red_channel_client_test_remote_common_cap(rcc, cap)) {\n            return FALSE;\n        }\n    }\n    return TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "png_set_tRNS_to_alpha(png_structp png_ptr)\n{\n   png_debug(1, \"in png_set_tRNS_to_alpha\");\n\n   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);\n   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline int cris_addc(int a, const int b)\n\n{\n\n\tasm (\"addc\\t%1, %0\\n\" : \"+r\" (a) : \"r\" (b));\n\n\treturn a;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "dns_zone_setstatistics(dns_zone_t *zone, bool on) {\n\t/*\n\t * This function is obsoleted.\n\t */\n\tUNUSED(zone);\n\tUNUSED(on);\n\treturn (ISC_R_NOTIMPLEMENTED);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "SAPI_API void sapi_shutdown(void)\n{\n#ifdef ZTS\n\tts_free_id(sapi_globals_id);\n#else\n\tsapi_globals_dtor(&sapi_globals);\n#endif\n\n\treentrancy_shutdown();\n\n\tvirtual_cwd_shutdown();\n\n#ifdef PHP_WIN32\n\ttsrm_win32_shutdown();\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void qemu_tcg_configure(QemuOpts *opts, Error **errp)\n\n{\n\n    const char *t = qemu_opt_get(opts, \"thread\");\n\n    if (t) {\n\n        if (strcmp(t, \"multi\") == 0) {\n\n            if (TCG_OVERSIZED_GUEST) {\n\n                error_setg(errp, \"No MTTCG when guest word size > hosts\");\n\n            } else if (use_icount) {\n\n                error_setg(errp, \"No MTTCG when icount is enabled\");\n\n            } else {\n\n\n\n\n\n                if (!check_tcg_memory_orders_compatible()) {\n\n                    error_report(\"Guest expects a stronger memory ordering \"\n\n                                 \"than the host provides\");\n\n                    error_printf(\"This may cause strange/hard to debug errors\");\n\n                }\n\n                mttcg_enabled = true;\n\n            }\n\n        } else if (strcmp(t, \"single\") == 0) {\n\n            mttcg_enabled = false;\n\n        } else {\n\n            error_setg(errp, \"Invalid 'thread' setting %s\", t);\n\n        }\n\n    } else {\n\n        mttcg_enabled = default_mttcg_enabled();\n\n    }\n\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n \n \tcase RXE_MEM_TYPE_MR:\n \tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n \n \tdefault:\n \t\treturn -EFAULT;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "fc_dma_unmap_sg(struct device *dev, struct scatterlist *sg, int nents,\n\t\tenum dma_data_direction dir)\n{\n\tif (dev)\n\t\tdma_unmap_sg(dev, sg, nents, dir);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n {\n \tGF_HandlerBox *p = (GF_HandlerBox *)a;\n \tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n \t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n \t} else {\n \t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "Formattable::getString(UErrorCode& status) \n{\n    if (fType != kString) {\n        setError(status, U_INVALID_FORMAT_ERROR);\n        return *getBogus();\n    }\n    if (fValue.fString == NULL) {\n    \tsetError(status, U_MEMORY_ALLOCATION_ERROR);\n    \treturn *getBogus();\n    }\n    return *fValue.fString;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "struct vfsmount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\t      int dir)\n{\n\tstruct list_head *head = mount_hashtable + hash(mnt, dentry);\n\tstruct list_head *tmp = head;\n\tstruct vfsmount *p, *found = NULL;\n\n\tfor (;;) {\n\t\ttmp = dir ? tmp->next : tmp->prev;\n\t\tp = NULL;\n\t\tif (tmp == head)\n\t\t\tbreak;\n\t\tp = list_entry(tmp, struct vfsmount, mnt_hash);\n\t\tif (p->mnt_parent == mnt && p->mnt_mountpoint == dentry) {\n\t\t\tfound = p;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "spell_expand_check_cap(colnr_T col)\n{\n    spell_expand_need_cap = check_need_cap(curwin->w_cursor.lnum, col);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ast_for_del_stmt(struct compiling *c, const node *n)\n{\n    asdl_seq *expr_list;\n\n    /* del_stmt: 'del' exprlist */\n    REQ(n, del_stmt);\n\n    expr_list = ast_for_exprlist(c, CHILD(n, 1), Del);\n    if (!expr_list)\n        return NULL;\n    return Delete(expr_list, LINENO(n), n->n_col_offset, c->c_arena);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static bool prep_compound_gigantic_page_for_demote(struct page *page,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\treturn __prep_compound_gigantic_page(page, order, true);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "_archive_write_data(struct archive *_a, const void *buff, size_t s)\n {\n \tstruct archive_write *a = (struct archive_write *)_a;\n \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n \t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n \tarchive_clear_error(&a->archive);\n \treturn ((a->format_write_data)(a, buff, s));\n }",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline unsigned int compound_order(struct page *page)\n{\n\tif (!PageHead(page))\n\t\treturn 0;\n\treturn page[1].compound_order;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int av_write_trailer(AVFormatContext *s)\n\n{\n\n    int ret, i;\n\n\n\n    for (;; ) {\n\n        AVPacket pkt;\n\n        ret = interleave_packet(s, &pkt, NULL, 1);\n\n        if (ret < 0) //FIXME cleanup needed for ret<0 ?\n\n            goto fail;\n\n        if (!ret)\n\n            break;\n\n\n\n        ret = s->oformat->write_packet(s, &pkt);\n\n        if (ret >= 0)\n\n            s->streams[pkt.stream_index]->nb_frames++;\n\n\n\n        av_free_packet(&pkt);\n\n\n\n        if (ret < 0)\n\n            goto fail;\n\n    }\n\n\n\n    if (s->oformat->write_trailer)\n\n        ret = s->oformat->write_trailer(s);\n\n\n\n    if (!(s->oformat->flags & AVFMT_NOFILE))\n\n        avio_flush(s->pb);\n\n\n\nfail:\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        av_freep(&s->streams[i]->priv_data);\n\n        av_freep(&s->streams[i]->index_entries);\n\n    }\n\n    if (s->oformat->priv_class)\n\n        av_opt_free(s->priv_data);\n\n    av_freep(&s->priv_data);\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "explicit DialogHandler(v8::Handle<v8::Value> dialogArguments, ScriptState* scriptState)\n        : m_scriptState(scriptState)\n        , m_dialogArguments(dialogArguments)\n    {\n    }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static unsigned long pfn_max_align_down(unsigned long pfn)\n{\n\treturn pfn & ~(max_t(unsigned long, MAX_ORDER_NR_PAGES,\n\t\t\t     pageblock_nr_pages) - 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void smp_br_pairing_complete(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n\n if (p_cb->total_tx_unacked == 0) {\n /* process the pairing complete */\n    smp_proc_pairing_cmpl(p_cb);\n }\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline void handle_socket_receive_unknown(\n\tfastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,\n\tfastd_buffer_t *buffer) {\n\tconst uint8_t *packet_type = buffer->data;\n\n\tswitch (*packet_type) {\n\tcase PACKET_DATA:\n\t\tfastd_buffer_free(buffer);\n\n\t\tif (!backoff_unknown(remote_addr)) {\n\t\t\tpr_debug(\"unexpectedly received payload data from unknown address %I\", remote_addr);\n\t\t\tconf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);\n\t\t}\n\t\tbreak;\n\n\tcase PACKET_HANDSHAKE:\n\t\tfastd_handshake_handle(sock, local_addr, remote_addr, NULL, buffer);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool pb_decode_svarint(pb_istream_t *stream, pb_int64_t *dest)\n{\n    pb_uint64_t value;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    if (value & 1)\n        *dest = (pb_int64_t)(~(value >> 1));\n    else\n        *dest = (pb_int64_t)(value >> 1);\n    \n    return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void qcow2_close(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    g_free(s->l1_table);\n\n    /* else pre-write overlap checks in cache_destroy may crash */\n\n    s->l1_table = NULL;\n\n\n\n    if (!(bs->open_flags & BDRV_O_INCOMING)) {\n\n        qcow2_cache_flush(bs, s->l2_table_cache);\n\n        qcow2_cache_flush(bs, s->refcount_block_cache);\n\n\n\n        qcow2_mark_clean(bs);\n\n    }\n\n\n\n    qcow2_cache_destroy(bs, s->l2_table_cache);\n\n    qcow2_cache_destroy(bs, s->refcount_block_cache);\n\n\n\n    g_free(s->unknown_header_fields);\n\n    cleanup_unknown_header_ext(bs);\n\n\n\n    g_free(s->cluster_cache);\n\n    qemu_vfree(s->cluster_data);\n\n    qcow2_refcount_close(bs);\n\n    qcow2_free_snapshots(bs);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "gen_svm_check_intercept_param(DisasContext *s, target_ulong pc_start,\n                              uint32_t type, uint64_t param)\n{\n    /* no SVM activated; fast case */\n    if (likely(!(s->flags & HF_SVMI_MASK)))\n        return;\n    gen_update_cc_op(s);\n    gen_jmp_im(pc_start - s->cs_base);\n    gen_helper_svm_check_intercept_param(cpu_env, tcg_const_i32(type),\n                                         tcg_const_i64(param));\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void ppc6xx_irq_init (CPUState *env)\n\n{\n\n    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc6xx_set_irq, env, 6);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "**/\n    static void save_empty_cimg(const char *const filename,\n                                const unsigned int dx, const unsigned int dy=1,\n                                const unsigned int dz=1, const unsigned int dc=1) {\n      return CImgList<T>::save_empty_cimg(filename,1,dx,dy,dz,dc);",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void sp_setup(struct net_device *dev)\n{\n\t/* Finish setting up the DEVICE info. */\n\tdev->netdev_ops\t\t= &sp_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->mtu\t\t= SIXP_MTU;\n\tdev->hard_header_len\t= AX25_MAX_HEADER_LEN;\n\tdev->header_ops \t= &ax25_header_ops;\n\n\tdev->addr_len\t\t= AX25_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_AX25;\n\tdev->tx_queue_len\t= 10;\n\n\t/* Only activated in AX.25 mode */\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\n\tdev->flags\t\t= 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "PromptBase() : promptPreviousInputLen(0) {}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void setUpFullyClippedStack(BitStack& stack, Node* node)\n{\n    Vector<Node*, 100> ancestry;\n    for (Node* parent = node->parentOrShadowHostNode(); parent; parent = parent->parentOrShadowHostNode())\n        ancestry.append(parent);\n\n    size_t size = ancestry.size();\n    for (size_t i = 0; i < size; ++i)\n        pushFullyClippedState(stack, ancestry[size - i - 1]);\n    pushFullyClippedState(stack, node);\n\n    ASSERT(stack.size() == 1 + depthCrossingShadowBoundaries(node));\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int fw_cfg_add_callback(FWCfgState *s, uint16_t key, FWCfgCallback callback,\n\n                        void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    if (!(key & FW_CFG_WRITE_CHANNEL))\n\n        return 0;\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    if (key >= FW_CFG_MAX_ENTRY || len > 65535)\n\n        return 0;\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n\n\n    return 1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n \tstruct sockaddr_llc sllc;\n \tstruct sock *sk = sock->sk;\n \tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n \n \tmemset(&sllc, 0, sizeof(sllc));\n \tlock_sock(sk);\n \tif (sock_flag(sk, SOCK_ZAPPED))\n \t\tgoto out;\n \t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n \tif (peer) {\n \t\trc = -ENOTCONN;\n \t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "catch_handler_new(codegen_scope *s)\n{\n  size_t newsize = sizeof(struct mrb_irep_catch_handler) * (s->irep->clen + 1);\n  s->catch_table = (struct mrb_irep_catch_handler *)codegen_realloc(s, (void *)s->catch_table, newsize);\n  return s->irep->clen ++;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "sysfs_get_double (const char *dir,\n                  const char *attribute)\n{\n  double result;\n  char *contents;\n  char *filename;\n\n  result = 0.0;\n  filename = g_build_filename (dir, attribute, NULL);\n  if (g_file_get_contents (filename, &contents, NULL, NULL))\n    {\n      result = atof (contents);\n      g_free (contents);\n    }\n  g_free (filename);\n\n  return result;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int crt_reinit(gnutls_x509_crt_t crt)\n{\n\tint result;\n\n\tcrt->raw_dn.size = 0;\n\tcrt->raw_issuer_dn.size = 0;\n\n\tasn1_delete_structure(&crt->cert);\n\n\tresult = asn1_create_element(_gnutls_get_pkix(),\n\t\t\t\t     \"PKIX1.Certificate\",\n\t\t\t\t     &crt->cert);\n\tif (result != ASN1_SUCCESS) {\n\t\tresult = _gnutls_asn2err(result);\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int sh_init(struct curl_hash *hash, int hashsize)\n{\n  return Curl_hash_init(hash, hashsize, hash_fd, fd_key_compare,\n                        sh_freeentry);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int dn_fib_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct dn_fib_table *tb;\n\tstruct rtmsg *r = nlmsg_data(nlh);\n\tstruct nlattr *attrs[RTA_MAX+1];\n\tint err;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EINVAL;\n\n\terr = nlmsg_parse(nlh, sizeof(*r), attrs, RTA_MAX, rtm_dn_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\ttb = dn_fib_get_table(rtm_get_table(attrs, r->rtm_table), 0);\n\tif (!tb)\n\t\treturn -ESRCH;\n\n\treturn tb->delete(tb, r, attrs, nlh, &NETLINK_CB(skb));\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "ParseNodePtr Parser::CreateUniNode(OpCode nop, ParseNodePtr pnode1, charcount_t ichMin,charcount_t ichLim)\n{\n    Assert(!this->m_deferringAST);\n    DebugOnly(VerifyNodeSize(nop, kcbPnUni));\n\n    ParseNodePtr pnode = (ParseNodePtr)m_nodeAllocator.Alloc(kcbPnUni);\n\n    Assert(m_pCurrentAstSize != NULL);\n    *m_pCurrentAstSize += kcbPnUni;\n\n    InitNode(nop, pnode);\n\n    pnode->sxUni.pnode1 = pnode1;\n\n    pnode->ichMin = ichMin;\n    pnode->ichLim = ichLim;\n\n    return pnode;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            /* Deny all control-characters. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                           \"Control character detected in URL.\");\n             return HTTP_BAD_REQUEST;\n         }\n     }\n \n     return OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "MYSQL *mysql_connect_ssl_check(MYSQL *mysql_arg, const char *host,\n                               const char *user, const char *passwd,\n                               const char *db, uint port,\n                               const char *unix_socket, ulong client_flag,\n                               my_bool ssl_required MY_ATTRIBUTE((unused)))\n{\n  MYSQL *mysql= mysql_real_connect(mysql_arg, host, user, passwd, db, port,\n                                   unix_socket, client_flag);\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (mysql &&                                   /* connection established. */\n      ssl_required &&                            /* --ssl-mode=REQUIRED. */\n      !mysql_get_ssl_cipher(mysql))              /* non-SSL connection. */\n  {\n    NET *net= &mysql->net;\n    net->last_errno= CR_SSL_CONNECTION_ERROR;\n    strmov(net->last_error, \"--ssl-mode=REQUIRED option forbids non SSL connections\");\n    strmov(net->sqlstate, \"HY000\");\n    return NULL;\n  }\n#endif\n  return mysql;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void ElectronBrowserHandlerImpl::MessageSync(bool internal,\n                                             const std::string& channel,\n                                             blink::CloneableMessage arguments,\n                                             MessageSyncCallback callback) {\n  api::WebContents* api_web_contents = api::WebContents::From(web_contents());\n  if (api_web_contents) {\n    api_web_contents->MessageSync(internal, channel, std::move(arguments),\n                                  std::move(callback), GetRenderFrameHost());\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "validate_args(asdl_seq *args)\n{\n    Py_ssize_t i;\n    for (i = 0; i < asdl_seq_LEN(args); i++) {\n        arg_ty arg = asdl_seq_GET(args, i);\n        if (arg->annotation && !validate_expr(arg->annotation, Load))\n            return 0;\n    }\n    return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static bool __unpin_devmap_managed_user_page(struct page *page)\n{\n\treturn false;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int ssl_hmac_final(SSL_HMAC *ctx, unsigned char *md, size_t *len,\n                   size_t max_size)\n{\n    if (ctx->ctx != NULL)\n        return EVP_MAC_final(ctx->ctx, md, len, max_size);\n#ifndef OPENSSL_NO_DEPRECATED_3_0\n    if (ctx->old_ctx != NULL) {\n        unsigned int l;\n\n        if (HMAC_Final(ctx->old_ctx, md, &l) > 0) {\n            if (len != NULL)\n                *len = l;\n            return 1;\n        }\n    }\n#endif\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int ff_insert_pad(unsigned idx, unsigned *count, size_t padidx_off,\n\n                   AVFilterPad **pads, AVFilterLink ***links,\n\n                   AVFilterPad *newpad)\n\n{\n\n    AVFilterLink **newlinks;\n\n    AVFilterPad *newpads;\n\n    unsigned i;\n\n\n\n    idx = FFMIN(idx, *count);\n\n\n\n    newpads  = av_realloc_array(*pads,  *count + 1, sizeof(AVFilterPad));\n\n    newlinks = av_realloc_array(*links, *count + 1, sizeof(AVFilterLink*));\n\n    if (newpads)\n\n        *pads  = newpads;\n\n    if (newlinks)\n\n        *links = newlinks;\n\n    if (!newpads || !newlinks)\n\n        return AVERROR(ENOMEM);\n\n\n\n    memmove(*pads  + idx + 1, *pads  + idx, sizeof(AVFilterPad)   * (*count - idx));\n\n    memmove(*links + idx + 1, *links + idx, sizeof(AVFilterLink*) * (*count - idx));\n\n    memcpy(*pads + idx, newpad, sizeof(AVFilterPad));\n\n    (*links)[idx] = NULL;\n\n\n\n    (*count)++;\n\n    for (i = idx + 1; i < *count; i++)\n\n        if (*links[i])\n\n            (*(unsigned *)((uint8_t *) *links[i] + padidx_off))++;\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\x0d\\x0a\\x87\\x0a\",4) == 0)\n    return(MagickTrue);\n  if (length < 12)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\x00\\x00\\x00\\x0c\\x6a\\x50\\x20\\x20\\x0d\\x0a\\x87\\x0a\",12) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void rfcomm_sk_data_ready(struct rfcomm_dlc *d, struct sk_buff *skb)\n{\n\tstruct sock *sk = d->owner;\n\tif (!sk)\n\t\treturn;\n\n\tatomic_add(skb->len, &sk->sk_rmem_alloc);\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_data_ready(sk, skb->len);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\trfcomm_dlc_throttle(d);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void TensorSliceReader::LoadAllShards() const {\n  VLOG(1) << \"Loading all shards for \" << filepattern_;\n  for (size_t i = 0; i < fnames_.size() && status_.ok(); ++i) {\n    LoadShard(i);\n  }\n  all_shards_loaded_ = true;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "cin_has_js_key(char_u *text)\n{\n    char_u *s = skipwhite(text);\n    int\t    quote = -1;\n\n    if (*s == '\\'' || *s == '\"')\n    {\n\t// can be 'key': or \"key\":\n\tquote = *s;\n\t++s;\n    }\n    if (!vim_isIDc(*s))\t    // need at least one ID character\n\treturn FALSE;\n\n    while (vim_isIDc(*s))\n\t++s;\n    if (*s == quote)\n\t++s;\n\n    s = cin_skipcomment(s);\n\n    // \"::\" is not a label, it's C++\n    return (*s == ':' && s[1] != ':');\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "TPMA_ALGORITHM_Unmarshal(TPMA_ALGORITHM *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT32_Unmarshal((UINT32 *)target, buffer, size); /* libtpms changed */\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (*target & TPMA_ALGORITHM_reserved) {\n\t    rc = TPM_RC_RESERVED_BITS;\n\t}\n    }\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int is_regular_file(struct dirent *dent, const char *dirname)\n{\n    if (dent->d_type == DT_REG)\n        return 1;\n    if (dent->d_type != DT_UNKNOWN)\n        return 0;\n\n    char *fullname = xasprintf(\"%s/%s\", dirname, dent->d_name);\n    struct stat statbuf;\n    int r = lstat(fullname, &statbuf);\n    free(fullname);\n\n    return r == 0 && S_ISREG(statbuf.st_mode);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void FrameView::forceLayout(bool allowSubtree)\n{\n    layout(allowSubtree);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline int nla_ok(const struct nlattr *nla, int remaining)\n{\n\treturn remaining >= sizeof(*nla) &&\n\t       nla->nla_len >= sizeof(*nla) &&\n\t       nla->nla_len <= remaining;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int cap_task_setioprio(struct task_struct *p, int ioprio)\n{\n\treturn cap_safe_nice(p);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "seamless_send_sync()\n{\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\treturn seamless_send(\"SYNC\", \"\");\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "bool fulltest(const unsigned char *hash, const unsigned char *target)\n{\n\tunsigned char hash2[32];\n\tswap32tobe(hash2, hash, 32 / 4);\n\treturn hash_target_check_v(hash2, target);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int selinux_socket_create(int family, int type,\n\t\t\t\t int protocol, int kern)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\tu32 newsid;\n\tu16 secclass;\n\tint rc;\n\n\tif (kern)\n\t\treturn 0;\n\n\tsecclass = socket_type_to_security_class(family, type, protocol);\n\trc = socket_sockcreate_sid(tsec, secclass, &newsid);\n\tif (rc)\n\t\treturn rc;\n\n\treturn avc_has_perm(tsec->sid, newsid, secclass, SOCKET__CREATE, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "uint64_t PaintLayerScrollableArea::Id() const {\n  return DOMNodeIds::IdForNode(GetLayoutBox()->GetNode());\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline void xfrm_dev_state_advance_esn(struct xfrm_state *x)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "fbFetchPixel_r8g8b8 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD8   *pixel = ((CARD8 *) bits) + (offset*3);\n#if IMAGE_BYTE_ORDER == MSBFirst\n    return (0xff000000 |\n\t    (READ(pixel + 0) << 16) |\n\t    (READ(pixel + 1) << 8) |\n\t    (READ(pixel + 2)));\n#else\n    return (0xff000000 |\n            (READ(pixel + 2) << 16) |\n            (READ(pixel + 1) << 8) |\n            (READ(pixel + 0)));\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int getAPPNAMELen(msg_t *pM, sbool bLockMutex)\n{\n\tassert(pM != NULL);\n\tprepareAPPNAME(pM, bLockMutex);\n\treturn (pM->pCSAPPNAME == NULL) ? 0 : rsCStrLen(pM->pCSAPPNAME);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void rt6_clean_tohost(struct net *net, struct in6_addr *gateway)\n{\n\tfib6_clean_all(net, fib6_clean_tohost, gateway);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool threadSafeMatch(const Vector<UChar, inlineCapacity>& vector, const QualifiedName& qname)\n{\n    return equalIgnoringNullity(vector, qname.localName().impl());\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int inet_csk_compat_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t       char __user *optval, unsigned int optlen)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_af_ops->compat_setsockopt)\n\t\treturn icsk->icsk_af_ops->compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t\t    optval, optlen);\n\treturn icsk->icsk_af_ops->setsockopt(sk, level, optname,\n\t\t\t\t\t     optval, optlen);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool Image::isLittleEndianPlatform() { return !isBigEndianPlatform(); }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void bnx2x_init_dropless_fc(struct bnx2x *bp)\n{\n\tu32 pause_enabled = 0;\n\n\tif (!CHIP_IS_E1(bp) && bp->dropless_fc && bp->link_vars.link_up) {\n\t\tif (bp->link_vars.flow_ctrl & BNX2X_FLOW_CTRL_TX)\n\t\t\tpause_enabled = 1;\n\n\t\tREG_WR(bp, BAR_USTRORM_INTMEM +\n\t\t\t   USTORM_ETH_PAUSE_ENABLED_OFFSET(BP_PORT(bp)),\n\t\t       pause_enabled);\n\t}\n\n\tDP(NETIF_MSG_IFUP | NETIF_MSG_LINK, \"dropless_fc is %s\\n\",\n\t   pause_enabled ? \"enabled\" : \"disabled\");\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void test_jwt_kid_escape(void)\n{\n\ttest_begin(\"JWT kid escape\");\n\t/* save a token */\n\t buffer_t *secret = t_buffer_create(32);\n\t void *ptr = buffer_append_space_unsafe(secret, 32);\n\t random_fill(ptr, 32);\n\t buffer_t *b64_key = t_base64_encode(0, SIZE_MAX,\n\t\t\t\t\t     secret->data, secret->used);\n\t save_key_to(\"HS256\", \"hello%2eworld%2f%25\", str_c(b64_key));\n\t/* make a token */\n\tbuffer_t *tokenbuf = create_jwt_token_kid(\"HS256\", \"hello.world/%\");\n\t/* sign it */\n\tsign_jwt_token_hs256(tokenbuf, secret);\n\ttest_jwt_token(str_c(tokenbuf));\n\ttest_end();\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static PHP_FUNCTION(session_decode)\n{\n\tzend_string *str = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"S\", &str) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (PS(session_status) != php_session_active) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Session is not active. You cannot decode session data\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_session_decode(str) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Cache::resourceAccessed(CachedResource* resource)\n{\n    ASSERT(resource->inCache());\n    \n    removeFromLRUList(resource);\n    \n    resource->increaseAccessCount();\n    \n    insertInLRUList(resource);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "long SSL_get_default_timeout(const SSL *s)\n{\n    return (s->method->get_timeout());\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int GetCPUCoreCount() {\n int cpuCoreCount = 1;\n#if defined(_SC_NPROCESSORS_ONLN)\n    cpuCoreCount = sysconf(_SC_NPROCESSORS_ONLN);\n#else\n    cpuCoreCount = sysconf(_SC_NPROC_ONLN);\n#endif\n    CHECK(cpuCoreCount >= 1);\n    ALOGV(\"Number of CPU cores: %d\", cpuCoreCount);\n return cpuCoreCount;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "validate_msg_fds(struct VhostUserMsg *msg, int expected_fds)\n{\n\tif (msg->fd_num == expected_fds)\n\t\treturn 0;\n\n\tVHOST_LOG_CONFIG(ERR,\n\t\t\" Expect %d FDs for request %s, received %d\\n\",\n\t\texpected_fds,\n\t\tvhost_message_str[msg->request.master],\n\t\tmsg->fd_num);\n\n\tclose_msg_fds(msg);\n\n\treturn -1;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "Rational LangAltValue::toRational(long /*n*/) const\n    {\n        ok_ = false;\n        return Rational(0, 0);\n    }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void crypto_cbc_exit_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_cbc_ctx *ctx = crypto_tfm_ctx(tfm);\n\tcrypto_free_cipher(ctx->child);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "mwifiex_ie_index_used_by_other_intf(struct mwifiex_private *priv, u16 idx)\n{\n\tint i;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_ie *ie;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (adapter->priv[i] != priv) {\n\t\t\tie = &adapter->priv[i]->mgmt_ie[idx];\n\t\t\tif (ie->mgmt_subtype_mask && ie->ie_length)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "INST_HANDLER (eor) {\t// EOR Rd, Rr\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,^,\", r, d);\t\t\t// 0: Rd ^ Rr\n\t__generic_bitop_flags (op);\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int arm_reset_cpu(uint64_t cpuid)\n\n{\n\n    CPUState *target_cpu_state;\n\n    ARMCPU *target_cpu;\n\n\n\n    DPRINTF(\"cpu %\" PRId64 \"\\n\", cpuid);\n\n\n\n    /* change to the cpu we are resetting */\n\n    target_cpu_state = arm_get_cpu_by_id(cpuid);\n\n    if (!target_cpu_state) {\n\n        return QEMU_ARM_POWERCTL_INVALID_PARAM;\n\n    }\n\n    target_cpu = ARM_CPU(target_cpu_state);\n\n    if (target_cpu->powered_off) {\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"[ARM]%s: CPU %\" PRId64 \" is off\\n\",\n\n                      __func__, cpuid);\n\n        return QEMU_ARM_POWERCTL_IS_OFF;\n\n    }\n\n\n\n    /* Reset the cpu */\n\n    cpu_reset(target_cpu_state);\n\n\n\n    return QEMU_ARM_POWERCTL_RET_SUCCESS;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "reg_enc_error(VALUE re, VALUE str)\n{\n    rb_raise(rb_eEncCompatError,\n\t     \"incompatible encoding regexp match (%s regexp with %s string)\",\n\t     rb_enc_name(rb_enc_get(re)),\n\t     rb_enc_name(rb_enc_get(str)));\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k,\n                                                        struct opj_stream_private *p_stream,\n                                                        struct opj_event_mgr * p_manager )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        p_j2k->cstr_index->main_head_end = opj_stream_tell(p_stream);\n\n        return OPJ_TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int ssh_scp_init(ssh_scp scp)\n{\n    int rc;\n    char execbuffer[1024] = {0};\n\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (scp->state != SSH_SCP_NEW) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"ssh_scp_init called under invalid state\");\n        return SSH_ERROR;\n    }\n\n    SSH_LOG(SSH_LOG_PROTOCOL,\n            \"Initializing scp session %s %son location '%s'\",\n            scp->mode == SSH_SCP_WRITE?\"write\":\"read\",\n            scp->recursive?\"recursive \":\"\",\n            scp->location);\n\n    scp->channel = ssh_channel_new(scp->session);\n    if (scp->channel == NULL) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    rc = ssh_channel_open_session(scp->channel);\n    if (rc == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    if (scp->mode == SSH_SCP_WRITE) {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -t %s %s\",\n                scp->recursive ? \"-r\":\"\", scp->location);\n    } else {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -f %s %s\",\n                scp->recursive ? \"-r\":\"\", scp->location);\n    }\n\n    if (ssh_channel_request_exec(scp->channel, execbuffer) == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    if (scp->mode == SSH_SCP_WRITE) {\n        rc = ssh_scp_response(scp, NULL);\n        if (rc != 0) {\n            return SSH_ERROR;\n        }\n    } else {\n        ssh_channel_write(scp->channel, \"\", 1);\n    }\n\n    if (scp->mode == SSH_SCP_WRITE) {\n        scp->state = SSH_SCP_WRITE_INITED;\n    } else {\n        scp->state = SSH_SCP_READ_INITED;\n    }\n\n    return SSH_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (*s && len > 0) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS));\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS));\n\t\t\t} else {\n\t\t\t\t*op++ = (wchar_t) u;\n\t\t\t}\n\t\t\ts += size;\n\t\t\tlen -= size;\n\t\t} else {\n\t\t\t*op++ = *s++;\n\t\t\tlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void ff_add_pixels_clamped_c(const DCTELEM *block, uint8_t *restrict pixels,\n\n                             int line_size)\n\n{\n\n    int i;\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n\n\n    /* read the pixels */\n\n    for(i=0;i<8;i++) {\n\n        pixels[0] = cm[pixels[0] + block[0]];\n\n        pixels[1] = cm[pixels[1] + block[1]];\n\n        pixels[2] = cm[pixels[2] + block[2]];\n\n        pixels[3] = cm[pixels[3] + block[3]];\n\n        pixels[4] = cm[pixels[4] + block[4]];\n\n        pixels[5] = cm[pixels[5] + block[5]];\n\n        pixels[6] = cm[pixels[6] + block[6]];\n\n        pixels[7] = cm[pixels[7] + block[7]];\n\n        pixels += line_size;\n\n        block += 8;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bitsubstr(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_VARBIT_P(bitsubstring(PG_GETARG_VARBIT_P(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(2),\n\t\t\t\t\t\t\t\t\tfalse));\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\t/* Mark all delegations for reclaim */\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "can_vma_merge_after(struct vm_area_struct *vma, unsigned long vm_flags,\n\tstruct anon_vma *anon_vma, struct file *file, pgoff_t vm_pgoff)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma)) {\n\t\tpgoff_t vm_pglen;\n\t\tvm_pglen = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;\n\t\tif (vma->vm_pgoff + vm_pglen == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "std::string normalize_path(const std::string &fpath)\n{\n\tif (fpath.empty()) {\n\t\treturn fpath;\n\t}\n\n\treturn bfs::absolute(fpath).string();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "av_cold int ff_vp8_decode_init(AVCodecContext *avctx)\n\n{\n\n    VP8Context *s = avctx->priv_data;\n\n    int ret;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n\n    avctx->internal->allocate_progress = 1;\n\n\n\n    ff_videodsp_init(&s->vdsp, 8);\n\n    ff_h264_pred_init(&s->hpc, AV_CODEC_ID_VP8, 8, 1);\n\n    ff_vp8dsp_init(&s->vp8dsp);\n\n\n\n    if ((ret = vp8_init_frames(s)) < 0) {\n\n        ff_vp8_decode_free(avctx);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "BlockDriverState *bdrv_new(void)\n{\n    BlockDriverState *bs;\n    int i;\n    bs = g_new0(BlockDriverState, 1);\n    QLIST_INIT(&bs->dirty_bitmaps);\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n        QLIST_INIT(&bs->op_blockers[i]);\n    }\n    notifier_with_return_list_init(&bs->before_write_notifiers);\n    bs->refcnt = 1;\n    bs->aio_context = qemu_get_aio_context();\n    QTAILQ_INSERT_TAIL(&all_bdrv_states, bs, bs_list);\n    return bs;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void ChromeDownloadManagerDelegate::GetNextId(\n    const content::DownloadIdCallback& callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  if (profile_->IsOffTheRecord()) {\n    content::BrowserContext::GetDownloadManager(\n        profile_->GetOriginalProfile())->GetDelegate()->GetNextId(callback);\n    return;\n  }\n  if (next_download_id_ == content::DownloadItem::kInvalidId) {\n    id_callbacks_.push_back(callback);\n    return;\n  }\n  ReturnNextId(callback);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void encode_signal_range(VC2EncContext *s)\n\n{\n\n    int idx;\n\n    AVCodecContext *avctx = s->avctx;\n\n    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    const int depth = fmt->comp[0].depth;\n\n    if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) {\n\n        idx = 1;\n\n        s->bpp = 1;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG ||\n\n               avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) {\n\n        idx = 2;\n\n        s->bpp = 1;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 10) {\n\n        idx = 3;\n\n        s->bpp = 2;\n\n        s->diff_offset = 512;\n\n    } else {\n\n        idx = 4;\n\n        s->bpp = 2;\n\n        s->diff_offset = 2048;\n\n    }\n\n    put_bits(&s->pb, 1, !s->strict_compliance);\n\n    if (!s->strict_compliance)\n\n        put_vc2_ue_uint(&s->pb, idx);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void sdhci_initfn(Object *obj)\n\n{\n\n    SDHCIState *s = SDHCI(obj);\n\n    DriveInfo *di;\n\n\n\n    di = drive_get_next(IF_SD);\n\n    s->card = sd_init(di ? di->bdrv : NULL, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n    s->eject_cb = qemu_allocate_irqs(sdhci_insert_eject_cb, s, 1)[0];\n\n    s->ro_cb = qemu_allocate_irqs(sdhci_card_readonly_cb, s, 1)[0];\n\n    sd_set_cb(s->card, s->ro_cb, s->eject_cb);\n\n\n\n    s->insert_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, sdhci_raise_insertion_irq, s);\n\n    s->transfer_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, sdhci_do_data_transfer, s);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void RenderFrameHostImpl::OnCreateChildFrame(int new_routing_id,\n                                             const std::string& frame_name) {\n  RenderFrameHostImpl* new_frame = frame_tree_->AddFrame(\n      frame_tree_node_, new_routing_id, frame_name);\n  if (delegate_)\n    delegate_->RenderFrameCreated(new_frame);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "QPDFFormFieldObjectHelper::getQuadding()\n{\n    int result = 0;\n    QPDFObjectHandle fv = getInheritableFieldValue(\"/Q\");\n    if (fv.isInteger())\n    {\n        QTC::TC(\"qpdf\", \"QPDFFormFieldObjectHelper Q present\");\n        result = static_cast<int>(fv.getIntValue());\n    }\n    return result;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void create_subpartition_name(char *out, const char *in1,\n                              const char *in2, const char *in3,\n                              uint name_variant)\n{\n  char transl_part_name[FN_REFLEN], transl_subpart_name[FN_REFLEN];\n\n  tablename_to_filename(in2, transl_part_name, FN_REFLEN);\n  tablename_to_filename(in3, transl_subpart_name, FN_REFLEN);\n  if (name_variant == NORMAL_PART_NAME)\n    strxmov(out, in1, \"#P#\", transl_part_name,\n            \"#SP#\", transl_subpart_name, NullS);\n  else if (name_variant == TEMP_PART_NAME)\n    strxmov(out, in1, \"#P#\", transl_part_name,\n            \"#SP#\", transl_subpart_name, \"#TMP#\", NullS);\n  else if (name_variant == RENAMED_PART_NAME)\n    strxmov(out, in1, \"#P#\", transl_part_name,\n            \"#SP#\", transl_subpart_name, \"#REN#\", NullS);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int finish_frame(AVCodecContext *avctx, AVFrame *pict)\n\n{\n\n    RV34DecContext *r = avctx->priv_data;\n\n    MpegEncContext *s = &r->s;\n\n    int got_picture = 0;\n\n\n\n    ff_er_frame_end(s);\n\n    ff_MPV_frame_end(s);\n\n\n\n\n    if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n\n        ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX, 0);\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n        *pict = s->current_picture_ptr->f;\n\n        got_picture = 1;\n\n    } else if (s->last_picture_ptr != NULL) {\n\n        *pict = s->last_picture_ptr->f;\n\n        got_picture = 1;\n\n    }\n\n    if (got_picture)\n\n        ff_print_debug_info(s, pict);\n\n\n\n    return got_picture;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "Tensor get_allocated_tensor(int index) const {\n    return allocated_tensors_[index];\n  }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void handle_arg_cpu(const char *arg)\n\n{\n\n    cpu_model = strdup(arg);\n\n    if (cpu_model == NULL || strcmp(cpu_model, \"?\") == 0) {\n\n        /* XXX: implement xxx_cpu_list for targets that still miss it */\n\n#if defined(cpu_list_id)\n\n        cpu_list_id(stdout, &fprintf, \"\");\n\n#elif defined(cpu_list)\n\n        cpu_list(stdout, &fprintf); /* deprecated */\n\n#endif\n\n        exit(1);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "htmlParseFile(const char *filename, const char *encoding) {\n    return(htmlSAXParseFile(filename, encoding, NULL, NULL));\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\n\t/* If init exists in the container, don't bind mount a static one */\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\n\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void IDNSpoofChecker::SetAllowedUnicodeSet(UErrorCode* status) {\n  if (U_FAILURE(*status))\n    return;\n\n  const icu::UnicodeSet* recommended_set =\n      uspoof_getRecommendedUnicodeSet(status);\n  icu::UnicodeSet allowed_set;\n  allowed_set.addAll(*recommended_set);\n  const icu::UnicodeSet* inclusion_set = uspoof_getInclusionUnicodeSet(status);\n  allowed_set.addAll(*inclusion_set);\n\n  allowed_set.remove(0x338u);\n\n  allowed_set.remove(0x58au);  // Armenian Hyphen\n  allowed_set.remove(0x2010u);\n  allowed_set.remove(0x2019u);  // Right Single Quotation Mark\n  allowed_set.remove(0x2027u);\n  allowed_set.remove(0x30a0u);  // Katakana-Hiragana Double Hyphen\n\n   allowed_set.remove(0x2bbu);  // Modifier Letter Turned Comma\n   allowed_set.remove(0x2bcu);  // Modifier Letter Apostrophe\n \n#if defined(OS_MACOSX)\n\n  allowed_set.remove(0x0620u);\n\n  allowed_set.remove(0x0F8Cu);\n  allowed_set.remove(0x0F8Du);\n  allowed_set.remove(0x0F8Eu);\n  allowed_set.remove(0x0F8Fu);\n#endif\n\n  allowed_set.remove(0x01CDu, 0x01DCu);  // Latin Ext B; Pinyin\n  allowed_set.remove(0x1C80u, 0x1C8Fu);  // Cyrillic Extended-C\n  allowed_set.remove(0x1E00u, 0x1E9Bu);  // Latin Extended Additional\n  allowed_set.remove(0x1F00u, 0x1FFFu);  // Greek Extended\n  allowed_set.remove(0xA640u, 0xA69Fu);  // Cyrillic Extended-B\n  allowed_set.remove(0xA720u, 0xA7FFu);  // Latin Extended-D\n\n  uspoof_setAllowedUnicodeSet(checker_, &allowed_set, status);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n {\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void pit_common_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = pit_common_realize;\n\n    dc->vmsd = &vmstate_pit_common;\n\n    dc->no_user = 1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "cmsHPROFILE CMSEXPORT cmsCreateLab2ProfileTHR(cmsContext ContextID, const cmsCIExyY* WhitePoint)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* LUT = NULL;\n\n    hProfile = cmsCreateRGBProfileTHR(ContextID, WhitePoint == NULL ? cmsD50_xyY() : WhitePoint, NULL, NULL);\n    if (hProfile == NULL) return NULL;\n\n    cmsSetProfileVersion(hProfile, 2.1);\n\n    cmsSetDeviceClass(hProfile, cmsSigAbstractClass);\n    cmsSetColorSpace(hProfile,  cmsSigLabData);\n    cmsSetPCS(hProfile,         cmsSigLabData);\n\n    if (!SetTextTags(hProfile, L\"Lab identity built-in\")) return NULL;\n\n    // An identity LUT is all we need\n    LUT = cmsPipelineAlloc(ContextID, 3, 3);\n    if (LUT == NULL) goto Error;\n\n    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCLut(ContextID, 3));\n\n    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;\n    cmsPipelineFree(LUT);\n\n    return hProfile;\n\nError:\n\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hProfile != NULL)\n        cmsCloseProfile(hProfile);\n\n    return NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void net_close(struct wif *wi)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\n\tclose(pn->pn_s);\n\tdo_net_free(wi);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "ZEND_API void zend_ts_hash_merge_ex(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, uint size, merge_checker_func_t pMergeSource, void *pParam)\n{\n\tbegin_read(source);\n\tbegin_write(target);\n\tzend_hash_merge_ex(TS_HASH(target), TS_HASH(source), pCopyConstructor, size, pMergeSource, pParam);\n\tend_write(target);\n\tend_read(source);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "template<typename t>\n    CImgList<t>& move_to(CImgList<t>& list) {\n      list.assign(_width);\n      bool is_one_shared_element = false;\n      cimglist_for(*this,l) is_one_shared_element|=_data[l]._is_shared;\n      if (is_one_shared_element) cimglist_for(*this,l) list[l].assign(_data[l]);\n      else cimglist_for(*this,l) _data[l].move_to(list[l]);\n      assign();\n      return list;",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int IntensityCompare(const void *x,const void *y)\n{\n  PixelPacket\n    *color_1,\n    *color_2;\n\n  ssize_t\n    intensity;\n\n  color_1=(PixelPacket *) x;\n  color_2=(PixelPacket *) y;\n  intensity=(ssize_t) PixelPacketIntensity(color_1)-\n    (ssize_t) PixelPacketIntensity(color_2);\n  return((int) intensity);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "struct FFTW3_info {\n      FFTW3_info() {\n        fftw_init_threads();",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "bytes_rstrip(PyBytesObject *self, PyObject *args)\n{\n    if (PyTuple_GET_SIZE(args) == 0)\n        return do_strip(self, RIGHTSTRIP); /* Common case */\n    else\n        return do_argstrip(self, RIGHTSTRIP, args);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded)\n{\n\tu8 *buffer;\n\tint err;\n\n\tbuffer = kzalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer[0] = 0;\n\tbuffer[1] = !!loaded;\n\n\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD, buffer,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD_REQ_LEN);\n\tkfree(buffer);\n\n\treturn err;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void cirrus_linear_bitblt_writew(void *opaque, target_phys_addr_t addr,\n\t\t\t\t uint32_t val)\n{\n#ifdef TARGET_WORDS_BIGENDIAN\n    cirrus_linear_bitblt_writeb(opaque, addr, (val >> 8) & 0xff);\n    cirrus_linear_bitblt_writeb(opaque, addr + 1, val & 0xff);\n#else\n    cirrus_linear_bitblt_writeb(opaque, addr, val & 0xff);\n    cirrus_linear_bitblt_writeb(opaque, addr + 1, (val >> 8) & 0xff);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n \t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n \t\t\tatomic_dec(&key->user->nikeys);\n \n\t\tkey_user_put(key->user);\n \t\t/* now throw away the key memory */\n \t\tif (key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \n \t\tkfree(key->description);\n \n #ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n         *index_rtrn = NULL;\n        return true;\n     case EXPR_ARRAY_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n         *index_rtrn = expr->array_ref.entry;\n         return true;\n     default:\n         break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int nwfilterConnectClose(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "pk_transaction_status_changed_emit (PkTransaction *transaction, PkStatusEnum status)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* already set */\n\tif (transaction->priv->status == status)\n\t\treturn;\n\n\ttransaction->priv->status = status;\n\n\t/* emit */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"Status\",\n\t\t\t\t\t      g_variant_new_uint32 (status));\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void ServerConnectionImpl::onUrl(const char* data, size_t length) {\n  if (active_request_.has_value()) {\n    active_request_.value().request_url_.append(data, length);\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "GF_Box *tims_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TSHintEntryBox, GF_ISOM_BOX_TYPE_TIMS);\n\treturn (GF_Box *)tmp;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "cmsPipeline* _cmsReadFloatInputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)\n{\n    cmsContext ContextID       = cmsGetProfileContextID(hProfile);\n    cmsPipeline* Lut           = cmsPipelineDup((cmsPipeline*) cmsReadTag(hProfile, tagFloat));\n    cmsColorSpaceSignature spc = cmsGetColorSpace(hProfile);\n    cmsColorSpaceSignature PCS = cmsGetPCS(hProfile);\n    \n    if (Lut == NULL) return NULL;\n    \n    // input and output of transform are in lcms 0..1 encoding.  If XYZ or Lab spaces are used, \n    //  these need to be normalized into the appropriate ranges (Lab = 100,0,0, XYZ=1.0,1.0,1.0)\n    if ( spc == cmsSigLabData)\n    {\n        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID));\n    }\n    else if (spc == cmsSigXYZData)\n    {\n        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID));\n    }\n    \n    if ( PCS == cmsSigLabData)\n    {\n        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID));\n    }\n    else if( PCS == cmsSigXYZData)\n    {\n        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID));\n    }\n    \n    return Lut;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline int64_t add64(const int64_t a, const int64_t b)\n\n{\n\n\treturn a + b;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "struct kern_ipc_perm *ipc_obtain_object_check(struct ipc_ids *ids, int id)\n{\n\tstruct kern_ipc_perm *out = ipc_obtain_object(ids, id);\n\n\tif (IS_ERR(out))\n\t\tgoto out;\n\n\tif (ipc_checkid(out, id))\n\t\treturn ERR_PTR(-EIDRM);\nout:\n\treturn out;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "does_person_exist(const person_t* person)\n{\n\tint i;\n\n\tfor (i = 0; i < s_num_persons; ++i)\n\t\tif (person == s_persons[i]) return true;\n\treturn false;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "rdt_new_context (void)\n\n{\n\n    PayloadContext *rdt = av_mallocz(sizeof(PayloadContext));\n\n\n\n    avformat_open_input(&rdt->rmctx, \"\", &ff_rdt_demuxer, NULL);\n\n\n\n    return rdt;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int line6_init_pcm(struct usb_line6 *line6,\n\t\t   struct line6_pcm_properties *properties)\n{\n\tint i, err;\n\tunsigned ep_read = line6->properties->ep_audio_r;\n\tunsigned ep_write = line6->properties->ep_audio_w;\n\tstruct snd_pcm *pcm;\n\tstruct snd_line6_pcm *line6pcm;\n\n\tif (!(line6->properties->capabilities & LINE6_CAP_PCM))\n\t\treturn 0;\t/* skip PCM initialization and report success */\n\n\terr = snd_line6_new_pcm(line6, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tline6pcm = kzalloc(sizeof(*line6pcm), GFP_KERNEL);\n\tif (!line6pcm)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&line6pcm->state_mutex);\n\tline6pcm->pcm = pcm;\n\tline6pcm->properties = properties;\n\tline6pcm->volume_playback[0] = line6pcm->volume_playback[1] = 255;\n\tline6pcm->volume_monitor = 255;\n\tline6pcm->line6 = line6;\n\n\tline6pcm->max_packet_size_in =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_rcvisocpipe(line6->usbdev, ep_read), 0);\n\tline6pcm->max_packet_size_out =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_sndisocpipe(line6->usbdev, ep_write), 1);\n\n\tspin_lock_init(&line6pcm->out.lock);\n\tspin_lock_init(&line6pcm->in.lock);\n\tline6pcm->impulse_period = LINE6_IMPULSE_DEFAULT_PERIOD;\n\n\tline6->line6pcm = line6pcm;\n\n\tpcm->private_data = line6pcm;\n\tpcm->private_free = line6_cleanup_pcm;\n\n\terr = line6_create_audio_out_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = line6_create_audio_in_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* mixer: */\n\tfor (i = 0; i < ARRAY_SIZE(line6_controls); i++) {\n\t\terr = snd_ctl_add(line6->card,\n\t\t\t\t  snd_ctl_new1(&line6_controls[i], line6pcm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\n \tif (!err && (iattr->ia_valid & ATTR_UID)) {\n \t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n \n\t\tsock->sk->sk_uid = iattr->ia_uid;\n \t}\n \n \treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "mcs_send_edrq(void)\n{\n\tSTREAM s;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_init(5);\n\n\tout_uint8(s, (MCS_EDRQ << 2));\n\tout_uint16_be(s, 1);\t/* height */\n\tout_uint16_be(s, 1);\t/* interval */\n\n\ts_mark_end(s);\n\tiso_send(s);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "tca_get_fill(struct sk_buff *skb, struct tc_action *a, u32 pid, u32 seq,\n             u16 flags, int event, int bind, int ref)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\t\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tif (tcf_action_dump(skb, a, bind, ref) < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8*)x;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "pp::ImageData Instance::CreateResourceImage(PP_ResourceImage image_id) {\n  pp::ImageData resource_data;\n  if (hidpi_enabled_) {\n    resource_data =\n        pp::PDF::GetResourceImageForScale(this, image_id, device_scale_);\n  }\n\n  return resource_data.data() ? resource_data\n                              : pp::PDF::GetResourceImage(this, image_id);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline void vring_used_flags_set_bit(VirtQueue *vq, int mask)\n\n{\n\n    VRingMemoryRegionCaches *caches = atomic_rcu_read(&vq->vring.caches);\n\n    VirtIODevice *vdev = vq->vdev;\n\n    hwaddr pa = offsetof(VRingUsed, flags);\n\n    uint16_t flags = virtio_lduw_phys_cached(vq->vdev, &caches->used, pa);\n\n\n\n    virtio_stw_phys_cached(vdev, &caches->used, pa, flags | mask);\n\n    address_space_cache_invalidate(&caches->used, pa, sizeof(flags));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "SplashError Splash::clipToRect(SplashCoord x0, SplashCoord y0,\n\t\t\t       SplashCoord x1, SplashCoord y1) {\n  return state->clip->clipToRect(x0, y0, x1, y1);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "dns_zone_setnotifydelay(dns_zone_t *zone, uint32_t delay) {\n\tREQUIRE(DNS_ZONE_VALID(zone));\n\n\tLOCK_ZONE(zone);\n\tzone->notifydelay = delay;\n\tUNLOCK_ZONE(zone);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void nfs4_locku_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\tif ((calldata->lsp->ls_flags & NFS_LOCK_INITIALIZED) == 0) {\n\t\t/* Note: exit _without_ running nfs4_locku_done */\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tcalldata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(calldata->server,\n\t\t\t\t&calldata->arg.seq_args,\n\t\t\t\t&calldata->res.seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void RenderMenuList::updateFromElement()\n{\n    if (m_optionsChanged) {\n        updateOptionsWidth();\n        m_optionsChanged = false;\n    }\n\n    if (m_popupIsVisible)\n        m_popup->updateFromElement();\n    else\n        setTextFromOption(toHTMLSelectElement(node())->selectedIndex());\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150) /* \"HEAP\" */\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int usb_cypress_writemem(struct usb_device *udev,u16 addr,u8 *data, u8 len)\n{\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev,0),\n\t\t\t0xa0, USB_TYPE_VENDOR, addr, 0x00, data, len, 5000);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "ByteOrder byteOrder() const\n            {\n                assert(isValid());\n                return byteOrder_;\n            }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "PHP_FUNCTION(pg_field_is_null)\n{\n\tphp_pgsql_data_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_PG_DATA_ISNULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static av_always_inline int mvd_decode(HEVCContext *s)\n\n{\n\n    int ret = 2;\n\n    int k = 1;\n\n\n\n    while (k < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc)) {\n\n        ret += 1 << k;\n\n        k++;\n\n    }\n\n    if (k == CABAC_MAX_BIN)\n\n        av_log(s->avctx, AV_LOG_ERROR, \"CABAC_MAX_BIN : %d\\n\", k);\n\n    while (k--)\n\n        ret += get_cabac_bypass(&s->HEVClc->cc) << k;\n\n    return get_cabac_bypass_sign(&s->HEVClc->cc, -ret);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "g_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn __g_next(m, pos);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "pci_set_cfgdata8(struct pci_vdev *dev, int offset, uint8_t val)\n{\n\tassert(offset <= PCI_REGMAX);\n\t*(uint8_t *)(dev->cfgdata + offset) = val;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)\n\n{\n\n    HostMemoryBackendFile *fb = MEMORY_BACKEND_FILE(backend);\n\n\n\n    if (!backend->size) {\n\n        error_setg(errp, \"can't create backend with size 0\");\n\n        return;\n\n    }\n\n    if (!fb->mem_path) {\n\n        error_setg(errp, \"mem-path property not set\");\n\n        return;\n\n    }\n\n#ifndef CONFIG_LINUX\n\n    error_setg(errp, \"-mem-path not supported on this host\");\n\n#else\n\n    if (!memory_region_size(&backend->mr)) {\n\n        backend->force_prealloc = mem_prealloc;\n\n        memory_region_init_ram_from_file(&backend->mr, OBJECT(backend),\n\n                                 object_get_canonical_path(OBJECT(backend)),\n\n                                 backend->size, fb->share,\n\n                                 fb->mem_path, errp);\n\n    }\n\n#endif\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "PackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned vaddr = get_te32(&phdr->p_vaddr);\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    unsigned align = get_te32(&phdr->p_align);\n    if (s < t || (u32_t)file_size < s\n    ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)\n    ||  (-1+ align) & (t ^ vaddr)\n    ||  (unsigned long)file_size <= memsz\n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "dirserv_get_measured_bw_cache_size(void)\n{\n  if (mbw_cache) return digestmap_size(mbw_cache);\n  else return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i, slot, spi;\n\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\t/* Allow zero-byte read from NULL, regardless of pointer type */\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(regs[regno]))\n\t\t\treturn 0;\n\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\n\t/* Only allow fixed-offset stack reads */\n\tif (!tnum_is_const(regs[regno].var_off)) {\n\t\tchar tn_buf[48];\n\n \t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n \t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n \t\t\tregno, tn_buf);\n \t}\n \toff = regs[regno].off + regs[regno].var_off.value;\n \tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size < 0 || (access_size == 0 && !zero_size_allowed)) {\n\t\tverbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\n\tif (env->prog->aux->stack_depth < -off)\n\t\tenv->prog->aux->stack_depth = -off;\n\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < access_size; i++) {\n\t\tslot = -(off + i) - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot ||\n\t\t    state->stack[spi].slot_type[slot % BPF_REG_SIZE] !=\n\t\t\tSTACK_MISC) {\n\t\t\tverbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "TEST(ExpressionTypeTest, WithDateValue) {\n    Date_t dateVal = BSON(\"\" << DATENOW).firstElement().Date();\n    assertExpectedResults(\"$type\", {{{Value(dateVal)}, Value(\"date\"_sd)}});\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "php_mysqlnd_net_field_length(zend_uchar **packet)\n{\n\tregister zend_uchar *p= (zend_uchar *)*packet;\n\n\tif (*p < 251) {\n\t\t(*packet)++;\n\t\treturn (unsigned long) *p;\n\t}\n\n\tswitch (*p) {\n\t\tcase 251:\n\t\t\t(*packet)++;\n\t\t\treturn MYSQLND_NULL_LENGTH;\n\t\tcase 252:\n\t\t\t(*packet) += 3;\n\t\t\treturn (unsigned long) uint2korr(p+1);\n\t\tcase 253:\n\t\t\t(*packet) += 4;\n\t\t\treturn (unsigned long) uint3korr(p+1);\n\t\tdefault:\n\t\t\t(*packet) += 9;\n\t\t\treturn (unsigned long) uint4korr(p+1);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "// Insert code instructions for processing scalars.\n      unsigned int scalar() { // Insert new scalar in memory\n        if (mempos>=mem._width) { mem.resize(-200,1,1,1,0); memtype.resize(mem._width,1,1,1,0); }\n        return mempos++;",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void test_notify(void)\n\n{\n\n    g_assert(!aio_poll(ctx, false));\n\n    aio_notify(ctx);\n\n    g_assert(!aio_poll(ctx, true));\n\n    g_assert(!aio_poll(ctx, false));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "vips_foreign_load_iscompat( VipsImage *a, VipsImage *b )\n{\n\tif( a->Xsize != b->Xsize ||\n\t\ta->Ysize != b->Ysize ||\n\t\ta->Bands != b->Bands ||\n\t\ta->Coding != b->Coding ||\n\t\ta->BandFmt != b->BandFmt ) {\n\t\tvips_error( \"VipsForeignLoad\",\n\t\t\t\"%s\", _( \"images do not match\" ) ); \n\t\treturn( FALSE );\n\t}\n\n\treturn( TRUE );\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int MockNetworkTransaction::RestartWithAuth(\n    const AuthCredentials& credentials,\n    const CompletionCallback& callback) {\n  if (!IsReadyToRestartForAuth())\n     return ERR_FAILED;\n \n   HttpRequestInfo auth_request_info = *request_;\n  auth_request_info.extra_headers.AddHeaderFromString(\"Authorization: Bar\");\n \n  return StartInternal(&auth_request_info, callback, BoundNetLog());\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "build_qp_table(PPS *pps, int index)\n\n{\n\n    int i;\n\n    for(i = 0; i < 255; i++)\n\n        pps->chroma_qp_table[i & 0xff] = chroma_qp[av_clip(i + index, 0, 51)];\n\n    pps->chroma_qp_index_offset = index;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "QPDFObjectHandle::assertReserved()\n{\n    assertType(\"Reserved\", isReserved());\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int inotify_update_watch(struct fsnotify_group *group, struct inode *inode, u32 arg)\n{\n\tint ret = 0;\n\n\tmutex_lock(&group->mark_mutex);\n\t/* try to update and existing watch with the new arg */\n\tret = inotify_update_existing_watch(group, inode, arg);\n\t/* no mark present, try to add a new one */\n\tif (ret == -ENOENT)\n\t\tret = inotify_new_watch(group, inode, arg);\n\tmutex_unlock(&group->mark_mutex);\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "char *AllocString(cmsIT8* it8, const char* str)\n{\n    cmsUInt32Number Size = (cmsUInt32Number) strlen(str)+1;\n    char *ptr;\n\n\n    ptr = (char *) AllocChunk(it8, Size);\n    if (ptr) strncpy (ptr, str, Size-1);\n\n    return ptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void detach_task_cfs_rq(struct task_struct *p)\n{\n\tstruct sched_entity *se = &p->se;\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\n\tif (!vruntime_normalized(p)) {\n\t\t/*\n\t\t * Fix up our vruntime so that the current sleep doesn't\n\t\t * cause 'unlimited' sleep bonus.\n\t\t */\n\t\tplace_entity(cfs_rq, se, 0);\n\t\tse->vruntime -= cfs_rq->min_vruntime;\n\t}\n\n\tdetach_entity_cfs_rq(se);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "ufmt_getDecNumChars(UFormattable *fmt, int32_t *len, UErrorCode *status) {\n  if(U_FAILURE(*status)) {\n    return \"\";\n  }\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n  CharString *charString = obj->internalGetCharString(*status);\n  if(U_FAILURE(*status)) {\n    return \"\";\n  }\n  if(charString == NULL) {\n    *status = U_MEMORY_ALLOCATION_ERROR;\n    return \"\";\n  } else {\n    if(len!=NULL) {\n      *len = charString->length();\n    }\n    return charString->data();\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static bool bdrv_requests_pending(BlockDriverState *bs)\n{\n    if (!QLIST_EMPTY(&bs->tracked_requests)) {\n        return true;\n    }\n    if (!qemu_co_queue_empty(&bs->throttled_reqs[0])) {\n        return true;\n    }\n    if (!qemu_co_queue_empty(&bs->throttled_reqs[1])) {\n        return true;\n    }\n    if (bs->file && bdrv_requests_pending(bs->file)) {\n        return true;\n    }\n    if (bs->backing_hd && bdrv_requests_pending(bs->backing_hd)) {\n        return true;\n    }\n    return false;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void ZipTest::testCrcAndSizeAfterDataWithArchive()\n{\n\tstd::string testFile = getTestFile(\"data\", \"data.zip\");\n\tstd::ifstream inp(testFile.c_str(), std::ios::binary);\n\tassert (inp.good());\n\tPoco::Zip::ZipArchive zip(inp);\n\tinp.clear();\n\tinp.seekg(0);\n\tPoco::Zip::ZipArchive::FileHeaders::const_iterator it = zip.headerBegin();\n\tfor ( ; it!=zip.headerEnd(); ++it)\n\t{\n\t\tPoco::Zip::ZipInputStream zipis(inp,it->second);\n\t\tPoco::Path path(it->second.getFileName());\n\t\tif (path.isFile())\n\t\t{\n\t\t\tstd::ofstream os(\"test.dat\");\n\t\t\tPoco::StreamCopier::copyStream(zipis,os);\n\t\t}\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int mg_casecmp(const char *s1, const char *s2) {\n  return mg_ncasecmp(s1, s2, (size_t) ~0);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool ATSParser::Stream::isAudio() const {\n switch (mStreamType) {\n case STREAMTYPE_MPEG1_AUDIO:\n case STREAMTYPE_MPEG2_AUDIO:\n case STREAMTYPE_MPEG2_AUDIO_ADTS:\n case STREAMTYPE_LPCM_AC3:\n case STREAMTYPE_AC3:\n return true;\n\n default:\n return false;\n }\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\n\tset_pte(ptep, pte);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "Bool TY_(IsNewline)(uint c)\n{\n    uint map = MAP(c);\n    return (map & newline)!=0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void rgb16tobgr16(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tlong i;\n\n\tlong num_pixels = src_size >> 1;\n\n\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x7E0)>>5;\n\n\t    b = (rgb&0xF800)>>11;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x3F)<<5) | ((r&0x1F)<<11);\n\n\t}\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "std::string read_file(const std::string &fname)\n{\n\tscoped_istream is = istream_file(fname);\n\tstd::stringstream ss;\n\tss << is->rdbuf();\n\treturn ss.str();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static float quantize_band_cost(struct AACEncContext *s, const float *in,\n\n                                const float *scaled, int size, int scale_idx,\n\n                                int cb, const float lambda, const float uplim,\n\n                                int *bits, int rtz)\n\n{\n\n    return get_band_cost(s, NULL, in, scaled, size, scale_idx, cb, lambda, uplim, bits);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int apparmor_path_chown(struct path *path, uid_t uid, gid_t gid)\n{\n\tstruct path_cond cond =  { path->dentry->d_inode->i_uid,\n\t\t\t\t   path->dentry->d_inode->i_mode\n\t};\n\n\tif (!mediated_filesystem(path->dentry->d_inode))\n\t\treturn 0;\n\n\treturn common_perm(OP_CHOWN, path, AA_MAY_CHOWN, &cond);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void r_pkcs7_free_extendedcertificatesandcertificates (RPKCS7ExtendedCertificatesAndCertificates *ecac) {\n\tut32 i;\n\tif (ecac) {\n\t\tfor (i = 0; i < ecac->length; ++i) {\n\t\t\tr_x509_free_certificate (ecac->elements[i]);\n\t\t\tecac->elements[i] = NULL;\n\t\t}\n\t\tR_FREE (ecac->elements);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void HTMLMediaElement::ScheduleTextTrackResourceLoad() {\n  BLINK_MEDIA_LOG << \"scheduleTextTrackResourceLoad(\" << (void*)this << \")\";\n\n  pending_action_flags_ |= kLoadTextTrackResource;\n\n  if (!load_timer_.IsActive())\n    load_timer_.StartOneShot(TimeDelta(), FROM_HERE);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "struct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new(const ut8* buf, ut64 size) {\n\tstruct r_bin_dyldcache_obj_t *bin;\n\tif (!(bin = malloc (sizeof (struct r_bin_dyldcache_obj_t)))) {\n\t\treturn NULL;\n\t}\n\tmemset (bin, 0, sizeof (struct r_bin_dyldcache_obj_t));\n\tif (!buf) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->b = r_buf_new();\n\tif (!r_buf_set_bytes (bin->b, buf, size)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tif (!r_bin_dyldcache_init (bin)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->size = size;\n\treturn bin;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void usb_free_coherent(struct usb_device *dev, size_t size, void *addr,\n\t\t       dma_addr_t dma)\n{\n\tif (!dev || !dev->bus)\n\t\treturn;\n\tif (!addr)\n\t\treturn;\n\thcd_buffer_free(dev->bus, size, addr, dma);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int io_add_buffers(struct io_provide_buf *pbuf, struct io_buffer **head)\n{\n\tstruct io_buffer *buf;\n\tu64 addr = pbuf->addr;\n\tint i, bid = pbuf->bid;\n\n\tfor (i = 0; i < pbuf->nbufs; i++) {\n\t\tbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tbreak;\n\n\t\tbuf->addr = addr;\n\t\tbuf->len = pbuf->len;\n\t\tbuf->bid = bid;\n\t\taddr += pbuf->len;\n\t\tbid++;\n\t\tif (!*head) {\n\t\t\tINIT_LIST_HEAD(&buf->list);\n\t\t\t*head = buf;\n\t\t} else {\n\t\t\tlist_add_tail(&buf->list, &(*head)->list);\n\t\t}\n\t}\n\n\treturn i ? i : -ENOMEM;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void RendererSchedulerImpl::AddVirtualTimeObserver(\n    VirtualTimeObserver* observer) {\n  main_thread_only().virtual_time_observers.AddObserver(observer);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void local_rewinddir(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    rewinddir(fs->dir.stream);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void negotiate(CLIENT *client) {\n\tchar zeros[300];\n\tu64 size_host;\n\n\tmemset(zeros, 0, 290);\n\tif (write(client->net, INIT_PASSWD, 8) < 0)\n\t\terr(\"Negotiation failed: %m\");\n\tcliserv_magic = htonll(cliserv_magic);\n\tif (write(client->net, &cliserv_magic, sizeof(cliserv_magic)) < 0)\n\t\terr(\"Negotiation failed: %m\");\n\tsize_host = htonll((u64)(client->exportsize));\n\tif (write(client->net, &size_host, 8) < 0)\n\t\terr(\"Negotiation failed: %m\");\n\tif (write(client->net, zeros, 128) < 0)\n\t\terr(\"Negotiation failed: %m\");\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline int unserialize_allowed_class(zend_string *class_name, HashTable *classes)\n{\n\tzend_string *lcname;\n\tint res;\n\tALLOCA_FLAG(use_heap)\n\n\tif(classes == NULL) {\n\t\treturn 1;\n\t}\n\tif(!zend_hash_num_elements(classes)) {\n\t\treturn 0;\n\t}\n\n\tSTR_ALLOCA_ALLOC(lcname, class_name->len, use_heap);\n\tzend_str_tolower_copy(lcname->val, class_name->val, class_name->len);\n\tres = zend_hash_exists(classes, lcname);\n\tSTR_ALLOCA_FREE(lcname, use_heap);\n\treturn res;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "status_t BufferQueueConsumer::setTransformHint(uint32_t hint) {\n    ATRACE_CALL();\n    BQ_LOGV(\"setTransformHint: %#x\", hint);\n Mutex::Autolock lock(mCore->mMutex);\n    mCore->mTransformHint = hint;\n return NO_ERROR;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "Ins_NROUND( INS_ARG )\n  {\n    DO_NROUND\n  }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void serial_update_parameters(SerialState *s)\n{\n    int speed, parity, data_bits, stop_bits, frame_size;\n    QEMUSerialSetParams ssp;\n\n    if (s->divider == 0)\n        return;\n\n    /* Start bit. */\n    frame_size = 1;\n    if (s->lcr & 0x08) {\n        /* Parity bit. */\n        frame_size++;\n        if (s->lcr & 0x10)\n            parity = 'E';\n        else\n            parity = 'O';\n    } else {\n            parity = 'N';\n    }\n    if (s->lcr & 0x04)\n        stop_bits = 2;\n    else\n        stop_bits = 1;\n\n    data_bits = (s->lcr & 0x03) + 5;\n    frame_size += data_bits + stop_bits;\n    speed = s->baudbase / s->divider;\n    ssp.speed = speed;\n    ssp.parity = parity;\n    ssp.data_bits = data_bits;\n    ssp.stop_bits = stop_bits;\n    s->char_transmit_time =  (NANOSECONDS_PER_SECOND / speed) * frame_size;\n    qemu_chr_fe_ioctl(s->chr, CHR_IOCTL_SERIAL_SET_PARAMS, &ssp);\n\n    DPRINTF(\"speed=%d parity=%c data=%d stop=%d\\n\",\n           speed, parity, data_bits, stop_bits);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void Type_S15Fixed16_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": " */\nstatic void io_drop_inflight_file(struct io_kiocb *req)\n{\n\tif (unlikely(req->flags & REQ_F_INFLIGHT)) {\n\t\tfput(req->file);\n\t\treq->file = NULL;\n\t\treq->flags &= ~REQ_F_INFLIGHT;\n\t}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int fprintf_mtab_fs(FILE *f, struct libmnt_fs *fs)\n{\n\tchar *o;\n\tchar *m1, *m2, *m3, *m4;\n\tint rc;\n\n\tassert(fs);\n\tassert(f);\n\n\to = mnt_fs_strdup_options(fs);\n\tif (!o)\n\t\treturn -ENOMEM;\n\n\tm1 = mangle(mnt_fs_get_source(fs));\n\tm2 = mangle(mnt_fs_get_target(fs));\n\tm3 = mangle(mnt_fs_get_fstype(fs));\n\tm4 = mangle(o);\n\n\tif (m1 && m2 && m3 && m4)\n\t\trc = !fprintf(f, \"%s %s %s %s %d %d\\n\",\n\t\t\t\tm1, m2, m3, m4,\n\t\t\t\tmnt_fs_get_freq(fs),\n\t\t\t\tmnt_fs_get_passno(fs));\n\telse\n\t\trc = -ENOMEM;\n\n\tfree(o);\n\tfree(m1);\n\tfree(m2);\n\tfree(m3);\n\tfree(m4);\n\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "TORRENT_TEST(invalid_digit)\n{\n\tchar b[] = \"0o\";\n\tboost::int64_t val = 0;\n\tbdecode_errors::error_code_enum ec;\n\tchar const* e = parse_int(b, b + sizeof(b)-1, 'e', val, ec);\n\tTEST_EQUAL(ec, bdecode_errors::expected_digit);\n\tTEST_EQUAL(e, b + 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "last_paren_match_getter(void)\n{\n    return rb_reg_match_last(rb_backref_get());\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "menu_add_separator_image(WebKitWebView *page, GArray *argv, GString *result) {\n    (void) page;\n    (void) result;\n\n    add_separator_to_menu(argv, WEBKIT_HIT_TEST_RESULT_CONTEXT_IMAGE);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static bool rtl_usb_tx_chk_waitq_insert(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\treturn false;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static struct sk_buff *udp_gro_receive_segment(struct list_head *head,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_hdr(skb);\n\tstruct sk_buff *pp = NULL;\n\tstruct udphdr *uh2;\n\tstruct sk_buff *p;\n\n\t/* requires non zero csum, for symmetry with GSO */\n\tif (!uh->check) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\n\t/* pull encapsulating udp header */\n\tskb_gro_pull(skb, sizeof(struct udphdr));\n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tuh2 = udp_hdr(p);\n\n\t\t/* Match ports only, as csum is always non zero */\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Terminate the flow on len mismatch or if it grow \"too much\".\n\t\t * Under small packet flood GRO count could elsewhere grow a lot\n\t\t * leading to execessive truesize values.\n\t\t * On len mismatch merge the first packet shorter than gso_size,\n\t\t * otherwise complete the GRO packet.\n\t\t */\n\t\tif (uh->len > uh2->len || skb_gro_receive(p, skb) ||\n\t\t    uh->len != uh2->len ||\n\t\t    NAPI_GRO_CB(p)->count >= UDP_GRO_CNT_MAX)\n\t\t\tpp = p;\n\n\t\treturn pp;\n\t}\n\n\t/* mismatch, but we never need to flush */\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static const uint8_t *parse_opus_ts_header(const uint8_t *start, int *payload_len, int buf_len)\n\n{\n\n    const uint8_t *buf = start + 1;\n\n    int start_trim_flag, end_trim_flag, control_extension_flag, control_extension_length;\n\n    uint8_t flags;\n\n\n\n    GetByteContext gb;\n\n    bytestream2_init(&gb, buf, buf_len);\n\n\n\n    flags = bytestream2_get_byte(&gb);\n\n    start_trim_flag        = (flags >> 4) & 1;\n\n    end_trim_flag          = (flags >> 3) & 1;\n\n    control_extension_flag = (flags >> 2) & 1;\n\n\n\n    *payload_len = 0;\n\n    while (bytestream2_peek_byte(&gb) == 0xff)\n\n        *payload_len += bytestream2_get_byte(&gb);\n\n\n\n    *payload_len += bytestream2_get_byte(&gb);\n\n\n\n    if (start_trim_flag)\n\n        bytestream2_skip(&gb, 2);\n\n    if (end_trim_flag)\n\n        bytestream2_skip(&gb, 2);\n\n    if (control_extension_flag) {\n\n        control_extension_length = bytestream2_get_byte(&gb);\n\n        bytestream2_skip(&gb, control_extension_length);\n\n    }\n\n\n\n    return buf + bytestream2_tell(&gb);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void WebContentsImpl::WasOccluded() {\n  const Visibility previous_visibility = GetVisibility();\n\n  if (!IsBeingCaptured()) {\n    for (RenderWidgetHostView* view : GetRenderWidgetHostViewsInTree())\n      view->WasOccluded();\n  }\n\n  should_normally_be_occluded_ = true;\n  NotifyVisibilityChanged(previous_visibility);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool CSPSource::schemeMatches(const KURL& url) const\n {\n     if (m_scheme.isEmpty())\n         return m_policy->protocolMatchesSelf(url);\n     return equalIgnoringCase(url.protocol(), m_scheme);\n }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tsize_t olen;\n\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "std::string Http2Session::diagnostic_name() const {\n  return std::string(\"Http2Session \") + TypeName() + \" (\" +\n      std::to_string(static_cast<int64_t>(get_async_id())) + \")\";\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "nfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n \n \tif (sfsname) {\n \t\t/* file system ID is ASCII, not numeric, for this server OS */\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n \n \t\t/* Make sure string is null-terminated */\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n \t\t/* Remove trailing spaces */\n \t\tspacep = strchr(temp, ' ');\n \t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\t/* Print the undecoded handle */\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "virtual bool isCryptoSchemeSupported(const uint8_t uuid[16], const String8 &mimeType) {\n Parcel data, reply;\n        data.writeInterfaceToken(IDrm::getInterfaceDescriptor());\n        data.write(uuid, 16);\n        data.writeString8(mimeType);\n status_t status = remote()->transact(IS_CRYPTO_SUPPORTED, data, &reply);\n if (status != OK) {\n            ALOGE(\"isCryptoSchemeSupported: binder call failed: %d\", status);\n return false;\n }\n\n return reply.readInt32() != 0;\n }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "Ins_ADD( FT_Long*  args )\n  {\n    args[0] = ADD_LONG( args[0], args[1] );\n  }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void PpapiPluginProcessHost::OpenChannelToPlugin(Client* client) {\n  if (process_->GetHost()->IsChannelOpening()) {\n    pending_requests_.push_back(client);\n    return;\n  }\n\n  RequestPluginChannel(client);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void unregister_displaychangelistener(DisplayChangeListener *dcl)\n\n{\n\n    DisplayState *ds = dcl->ds;\n\n    trace_displaychangelistener_unregister(dcl, dcl->ops->dpy_name);\n\n    if (dcl->con) {\n\n        dcl->con->dcls--;\n\n    }\n\n    QLIST_REMOVE(dcl, next);\n\n\n    gui_setup_refresh(ds);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline int ipmi_si_is_busy(struct timespec64 *ts)\n{\n\treturn ts->tv_nsec != -1;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void qtest_irq_handler(void *opaque, int n, int level)\n\n{\n\n    qemu_irq old_irq = *(qemu_irq *)opaque;\n\n    qemu_set_irq(old_irq, level);\n\n\n\n    if (irq_levels[n] != level) {\n\n        CharDriverState *chr = qtest_chr;\n\n        irq_levels[n] = level;\n\n        qtest_send_prefix(chr);\n\n        qtest_send(chr, \"IRQ %s %d\\n\",\n\n                   level ? \"raise\" : \"lower\", n);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header, *c;\n\n    header = get_header(fp);\n\n    /* Locate version string start and make sure we dont go past header */\n    if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n\n    free(header);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "PHP_METHOD(PharFileInfo, getPharFlags)\n{\n\tPHAR_ENTRY_OBJECT();\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(entry_obj->entry->flags & ~(PHAR_ENT_PERM_MASK|PHAR_ENT_COMPRESSION_MASK));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool ThreadSafeMatch(const Vector<UChar, inlineCapacity>& vector,\n                     const QualifiedName& qname) {\n  return EqualIgnoringNullity(vector, qname.LocalName().Impl());\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "PPC_OP(test_ctrz)\n\n{\n\n    T0 = (regs->ctr == 0);\n\n    RETURN();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int br_ip4_multicast_add_group(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      __be32 group,\n\t\t\t\t      __u16 vid)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv4_is_local_multicast(group))\n\t\treturn 0;\n\n\tbr_group.u.ip4 = group;\n\tbr_group.proto = htons(ETH_P_IP);\n\tbr_group.vid = vid;\n\n\treturn br_multicast_add_group(br, port, &br_group);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "char *url_decode_r(char *to, char *url, size_t size) {\n    char *s = url,           // source\n         *d = to,            // destination\n         *e = &to[size - 1]; // destination end\n\n    while(*s && d < e) {\n        if(unlikely(*s == '%')) {\n            if(likely(s[1] && s[2])) {\n                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);\n                s += 2;\n            }\n        }\n        else if(unlikely(*s == '+'))\n            *d++ = ' ';\n\n        else\n            *d++ = *s;\n\n        s++;\n    }\n\n    *d = '\\0';\n\n    return to;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int get_walk(struct kvm_vcpu *vcpu, u64 addr, u64 *sptes, int *root_level)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tint leaf = -1;\n\tu64 spte;\n\n\tfor (shadow_walk_init(&iterator, vcpu, addr),\n\t     *root_level = iterator.level;\n\t     shadow_walk_okay(&iterator);\n\t     __shadow_walk_next(&iterator, spte)) {\n\t\tleaf = iterator.level;\n\t\tspte = mmu_spte_get_lockless(iterator.sptep);\n\n\t\tsptes[leaf] = spte;\n\t}\n\n\treturn leaf;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static bool __vsock_in_bound_table(struct vsock_sock *vsk)\n{\n\treturn !list_empty(&vsk->bound_table);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void clear_ftrace_pid(struct pid *pid)\n{\n\tstruct task_struct *p;\n\n\trcu_read_lock();\n\tdo_each_pid_task(pid, PIDTYPE_PID, p) {\n\t\tclear_tsk_trace_trace(p);\n\t} while_each_pid_task(pid, PIDTYPE_PID, p);\n\trcu_read_unlock();\n\n\tput_pid(pid);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void adaptive_gain_control(float *out, const float *in,\n\n                                  const float *speech_synth,\n\n                                  int size, float alpha, float *gain_mem)\n\n{\n\n    int i;\n\n    float speech_energy = 0.0, postfilter_energy = 0.0, gain_scale_factor;\n\n    float mem = *gain_mem;\n\n\n\n    for (i = 0; i < size; i++) {\n\n        speech_energy     += fabsf(speech_synth[i]);\n\n        postfilter_energy += fabsf(in[i]);\n\n    }\n\n    gain_scale_factor = (1.0 - alpha) * speech_energy / postfilter_energy;\n\n\n\n    for (i = 0; i < size; i++) {\n\n        mem = alpha * mem + gain_scale_factor;\n\n        out[i] = in[i] * mem;\n\n    }\n\n\n\n    *gain_mem = mem;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "cmsBool CMSEXPORT cmsIsToneCurveLinear(const cmsToneCurve* Curve)\n{\n    cmsUInt32Number i;\n    int diff;\n\n    _cmsAssert(Curve != NULL);\n\n    for (i=0; i < Curve ->nEntries; i++) {\n\n        diff = abs((int) Curve->Table16[i] - (int) _cmsQuantizeVal(i, Curve ->nEntries));\n        if (diff > 0x0f)\n            return FALSE;\n    }\n\n    return TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void * calloc(size_t n, size_t lb)\n {\n #   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n         /* libpthread allocated some memory that is only pointed to by  */\n         /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "content::WebContents* web_contents() { return web_contents_; }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "GF_Box *prft_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "DECLAREcpFunc(cpContigTiles2ContigStrips)\n{\n\treturn cpImage(in, out,\n\t    readContigTilesIntoBuffer,\n\t    writeBufferToContigStrips,\n\t    imagelength, imagewidth, spp);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "is_code_ctype(OnigCodePoint code, unsigned int ctype, OnigEncoding enc ARG_UNUSED)\n{\n  if (code < 256)\n    return ENC_IS_ISO_8859_4_CTYPE(code, ctype);\n  else\n    return FALSE;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static BROTLI_INLINE void GetBlockLengthPrefixCode(uint32_t len, size_t* code,\n    uint32_t* n_extra, uint32_t* extra) {\n  *code = BlockLengthPrefixCode(len);\n  *n_extra = kBlockLengthPrefixCode[*code].nbits;\n  *extra = len - kBlockLengthPrefixCode[*code].offset;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "std::string OutOfProcessInstance::GetLocalizedString(PP_ResourceString id) {\n  pp::Var rv(pp::PDF::GetLocalizedString(this, id));\n  if (!rv.is_string())\n    return std::string();\n\n  return rv.AsString();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "kernel_ptr(void)\n{\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n\tstruct media_entity *ent;\n\tstruct media_entity_desc u_ent;\n\n\tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n\t\treturn -EFAULT;\n\n\tent = find_entity(mdev, u_ent.id);\n\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static char *token(FILE *stream)\n{\n    int ch, idx;\n\n    /* skip over white space */\n    while ((ch = fgetc(stream)) == ' ' || ch == lineterm || \n            ch == ',' || ch == '\\t' || ch == ';');\n    \n    idx = 0;\n    while (ch != EOF && ch != ' ' && ch != lineterm \n           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)\n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n\n    if (ch == EOF && idx < 1) return ((char *)NULL);\n    if (idx >= 1 && ch != ':' ) ungetc(ch, stream);\n    if (idx < 1 ) ident[idx++] = ch;\t/* single-character token */\n    ident[idx] = 0;\n    \n    return(ident);\t/* returns pointer to the token */\n\n} /* token */",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static bool _is_batch_job_finished(uint32_t job_id)\n{\n\tbool found_job = false;\n\tint i;\n\n\tslurm_mutex_lock(&fini_mutex);\n\tfor (i = 0; i < FINI_JOB_CNT; i++) {\n\t\tif (fini_job_id[i] == job_id) {\n\t\t\tfound_job = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tslurm_mutex_unlock(&fini_mutex);\n\n\treturn found_job;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool AudioNode::DisconnectFromOutputIfConnected(unsigned output_index,\n                                                AudioParam& param) {\n  AudioNodeOutput& output = Handler().Output(output_index);\n  if (!output.IsConnectedToAudioParam(param.Handler()))\n    return false;\n  output.DisconnectAudioParam(param.Handler());\n  connected_params_[output_index]->erase(&param);\n  return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "template<typename t>\n    CImg<doubleT> eval(const char *const expression, const CImg<t>& xyzc,\n                       const CImgList<T> *const list_inputs=0, CImgList<T> *const list_outputs=0) const {\n      return _eval(0,expression,xyzc,list_inputs,list_outputs);",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "progress (int c)\n{\n  if (progress_cb)\n    progress_cb (progress_cb_data, \"pk_elg\", c, 0, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int message(int priority, const char *msg) {\n    char buf[1024];\n\n    /* only handle errno if this is not an informational message */\n    if(errno && priority < 5) {\n\tsprintf(buf, \"%s: %s\", msg, strerror(errno));\n\terrno = 0;\n    } else strcpy(buf, msg);\n    if(use_syslog) syslog(priority, \"%s\", buf);\n    else           fprintf(stderr, \"%s: %s\\n\", progname, buf);\n    return(0);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int nut_read_close(AVFormatContext *s)\n\n{\n\n    NUTContext *nut = s->priv_data;\n\n\n\n\n    av_freep(&nut->time_base);\n\n    av_freep(&nut->stream);\n\n\n\n\n\n\n    return 0;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void tlb_fill(CPUState *env1, target_ulong addr, int is_write, int mmu_idx,\n\n              void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    CPUState *saved_env;\n\n    unsigned long pc;\n\n    int ret;\n\n\n\n    saved_env = env;\n\n\n    ret = cpu_arm_handle_mmu_fault(env, addr, is_write, mmu_idx);\n\n    if (unlikely(ret)) {\n\n        if (retaddr) {\n\n            /* now we have a real cpu fault */\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                /* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault */\n\n                cpu_restore_state(tb, env, pc);\n\n            }\n\n        }\n\n        raise_exception(env->exception_index);\n\n    }\n\n    env = saved_env;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "dump_xml_formatted(xmlNode * an_xml_node)\n{\n    char *buffer = NULL;\n    int offset = 0, max = 0;\n\n    crm_xml_dump(an_xml_node, xml_log_option_formatted, &buffer, &offset, &max, 0);\n    return buffer;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int do_drive_del(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *id = qdict_get_str(qdict, \"id\");\n\n    BlockDriverState *bs;\n\n    BlockDriverState **ptr;\n\n    Property *prop;\n\n\n\n    bs = bdrv_find(id);\n\n    if (!bs) {\n\n        qerror_report(QERR_DEVICE_NOT_FOUND, id);\n\n        return -1;\n\n    }\n\n    if (bdrv_in_use(bs)) {\n\n        qerror_report(QERR_DEVICE_IN_USE, id);\n\n        return -1;\n\n    }\n\n\n\n    /* quiesce block driver; prevent further io */\n\n    qemu_aio_flush();\n\n    bdrv_flush(bs);\n\n    bdrv_close(bs);\n\n\n\n    /* clean up guest state from pointing to host resource by\n\n     * finding and removing DeviceState \"drive\" property */\n\n    if (bs->peer) {\n\n        for (prop = bs->peer->info->props; prop && prop->name; prop++) {\n\n            if (prop->info->type == PROP_TYPE_DRIVE) {\n\n                ptr = qdev_get_prop_ptr(bs->peer, prop);\n\n                if (*ptr == bs) {\n\n                    bdrv_detach(bs, bs->peer);\n\n                    *ptr = NULL;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /* clean up host side */\n\n    drive_uninit(drive_get_by_blockdev(bs));\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int drm_mode_connector_attach_encoder(struct drm_connector *connector,\n\t\t\t\t      struct drm_encoder *encoder)\n{\n\tint i;\n\n\tfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\n\t\tif (connector->encoder_ids[i] == 0) {\n\t\t\tconnector->encoder_ids[i] = encoder->base.id;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOMEM;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void _php_do_opendir(INTERNAL_FUNCTION_PARAMETERS, int createobject)\n{\n\tchar *dirname;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tphp_stream *dirp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|r\", &dirname, &dir_len, &zcontext) == FAILURE) {\n\t\tRETURN_NULL();\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\t\n\tdirp = php_stream_opendir(dirname, REPORT_ERRORS, context);\n\n\tif (dirp == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tdirp->flags |= PHP_STREAM_FLAG_NO_FCLOSE;\n\t\t\n\tphp_set_default_dir(dirp->rsrc_id TSRMLS_CC);\n\n\tif (createobject) {\n\t\tobject_init_ex(return_value, dir_class_entry_ptr);\n\t\tadd_property_stringl(return_value, \"path\", dirname, dir_len, 1);\n\t\tadd_property_resource(return_value, \"handle\", dirp->rsrc_id);\n\t\tphp_stream_auto_cleanup(dirp); /* so we don't get warnings under debug */\n\t} else {\n\t\tphp_stream_to_zval(dirp, return_value);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void EditorClientBlackBerry::pageDestroyed()\n{\n    delete this;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "QPDF::QPDF() :\n    encrypted(false),\n    encryption_initialized(false),\n    ignore_xref_streams(false),\n    suppress_warnings(false),\n    out_stream(&std::cout),\n    err_stream(&std::cerr),\n    attempt_recovery(true),\n    encryption_V(0),\n    encryption_R(0),\n    encrypt_metadata(true),\n    cf_stream(e_none),\n    cf_string(e_none),\n    cf_file(e_none),\n    cached_key_objid(0),\n    cached_key_generation(0),\n    pushed_inherited_attributes_to_pages(false),\n    copied_stream_data_provider(0),\n    first_xref_item_offset(0),\n    uncompressed_after_compressed(false)\n{\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void auth_heimdal_gssapi_version_report(FILE *f) {}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "close_uzbl (WebKitWebView *page, GArray *argv, GString *result) {\n    (void)page;\n    (void)argv;\n    (void)result;\n    gtk_main_quit ();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "Status AuthorizationManager::_initializeUserFromPrivilegeDocument(User* user,\n                                                                  const BSONObj& privDoc) {\n    V2UserDocumentParser parser;\n    std::string userName = parser.extractUserNameFromUserDocument(privDoc);\n    if (userName != user->getName().getUser()) {\n        return Status(ErrorCodes::BadValue,\n                      mongoutils::str::stream() << \"User name from privilege document \\\"\"\n                                                << userName\n                                                << \"\\\" doesn't match name of provided User \\\"\"\n                                                << user->getName().getUser()\n                                                << \"\\\"\",\n                      0);\n    }\n\n    Status status = parser.initializeUserCredentialsFromUserDocument(user, privDoc);\n    if (!status.isOK()) {\n        return status;\n    }\n    status = parser.initializeUserRolesFromUserDocument(privDoc, user);\n    if (!status.isOK()) {\n        return status;\n    }\n    status = parser.initializeUserIndirectRolesFromUserDocument(privDoc, user);\n    if (!status.isOK()) {\n        return status;\n    }\n    status = parser.initializeUserPrivilegesFromUserDocument(privDoc, user);\n    if (!status.isOK()) {\n        return status;\n    }\n\n    return Status::OK();\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int evm_calc_hmac(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  char *digest)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\treq_xattr_value_len, EVM_XATTR_HMAC, digest);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void unit_reset_failed(Unit *u) {\n        assert(u);\n\n        if (UNIT_VTABLE(u)->reset_failed)\n                UNIT_VTABLE(u)->reset_failed(u);\n\n        RATELIMIT_RESET(u->start_limit);\n        u->start_limit_hit = false;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int qcow2_refcount_init(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    unsigned int refcount_table_size2, i;\n\n    int ret;\n\n\n\n    assert(s->refcount_table_size <= INT_MAX / sizeof(uint64_t));\n\n    refcount_table_size2 = s->refcount_table_size * sizeof(uint64_t);\n\n    s->refcount_table = g_try_malloc(refcount_table_size2);\n\n\n\n    if (s->refcount_table_size > 0) {\n\n        if (s->refcount_table == NULL) {\n\n            goto fail;\n\n        }\n\n        BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_LOAD);\n\n        ret = bdrv_pread(bs->file, s->refcount_table_offset,\n\n                         s->refcount_table, refcount_table_size2);\n\n        if (ret != refcount_table_size2)\n\n            goto fail;\n\n        for(i = 0; i < s->refcount_table_size; i++)\n\n            be64_to_cpus(&s->refcount_table[i]);\n\n    }\n\n    return 0;\n\n fail:\n\n    return -ENOMEM;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static av_cold int vp9_decode_free(AVCodecContext *ctx)\n\n{\n\n    VP9Context *s = ctx->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < 2; i++) {\n\n        if (s->frames[i].tf.f->data[0])\n\n            vp9_unref_frame(ctx, &s->frames[i]);\n\n        av_frame_free(&s->frames[i].tf.f);\n\n    }\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->refs[i].f->data[0])\n\n            ff_thread_release_buffer(ctx, &s->refs[i]);\n\n        av_frame_free(&s->refs[i].f);\n\n        if (s->next_refs[i].f->data[0])\n\n            ff_thread_release_buffer(ctx, &s->next_refs[i]);\n\n        av_frame_free(&s->next_refs[i].f);\n\n    }\n\n    av_freep(&s->above_partition_ctx);\n\n    av_freep(&s->c_b);\n\n    s->c_b_size = 0;\n\n    av_freep(&s->b_base);\n\n    av_freep(&s->block_base);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n    int pending;\n\n\n\n    assert(!qemu_file_is_writable(f));\n\n\n\n    pending = f->buf_size - f->buf_index;\n\n    if (pending > 0) {\n\n        memmove(f->buf, f->buf + f->buf_index, pending);\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = pending;\n\n\n\n    len = f->ops->get_buffer(f->opaque, f->buf + pending, f->pos,\n\n                        IO_BUF_SIZE - pending);\n\n    if (len > 0) {\n\n        f->buf_size += len;\n\n        f->pos += len;\n\n    } else if (len == 0) {\n\n        qemu_file_set_error(f, -EIO);\n\n    } else if (len != -EAGAIN) {\n\n        qemu_file_set_error(f, len);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int Curl_polarssl_init(void)\n{\n  return Curl_polarsslthreadlock_thread_setup();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n {\n \tstruct cred *cred;\n \n \tif (!(unshare_flags & CLONE_NEWUSER))\n \t\treturn 0;\n \n \tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n \n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void esp_set_tc(ESPState *s, uint32_t dmalen)\n{\n    s->rregs[ESP_TCLO] = dmalen;\n    s->rregs[ESP_TCMID] = dmalen >> 8;\n    s->rregs[ESP_TCHI] = dmalen >> 16;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  /* error message uses memory */\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n  va_end(argp);\n  if (isLua(ci))  /* if Lua function, add source:line information */\n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int airspy_enum_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index >= NUM_FORMATS)\n\t\treturn -EINVAL;\n\n\tstrlcpy(f->description, formats[f->index].name, sizeof(f->description));\n\tf->pixelformat = formats[f->index].pixelformat;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int PDFiumEngine::Form_GetPlatform(FPDF_FORMFILLINFO* param,\n                                   void* platform,\n                                   int length) {\n  int platform_flag = -1;\n\n#if defined(WIN32)\n  platform_flag = 0;\n#elif defined(__linux__)\n  platform_flag = 1;\n#else\n  platform_flag = 2;\n#endif\n\n  std::string javascript =\n      \"alert(\\\"Platform:\" + base::NumberToString(platform_flag) + \"\\\")\";\n\n  return platform_flag;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "QPDFWriter::enqueueObject(QPDFObjectHandle object)\n{\n    if (object.isIndirect())\n    {\n        if (object.getOwningQPDF() != &(this->pdf))\n        {\n            QTC::TC(\"qpdf\", \"QPDFWriter foreign object\");\n            throw std::logic_error(\n                \"QPDFObjectHandle from different QPDF found while writing.\"\n                \"  Use QPDF::copyForeignObject to add objects from\"\n                \" another file.\");\n        }\n\n\tQPDFObjGen og = object.getObjGen();\n\n\tif (obj_renumber.count(og) == 0)\n\t{\n\t    if (this->object_to_object_stream.count(og))\n\t    {\n\t\t// This is in an object stream.  Don't process it\n\t\t// here.  Instead, enqueue the object stream.  Object\n\t\t// streams always have generation 0.\n\t\tint stream_id = this->object_to_object_stream[og];\n\t\tenqueueObject(this->pdf.getObjectByID(stream_id, 0));\n\t    }\n\t    else\n\t    {\n\t\tobject_queue.push_back(object);\n\t\tobj_renumber[og] = next_objid++;\n\n\t\tif ((og.getGen() == 0) &&\n                    this->object_stream_to_objects.count(og.getObj()))\n\t\t{\n\t\t    // For linearized files, uncompressed objects go\n\t\t    // at end, and we take care of assigning numbers\n\t\t    // to them elsewhere.\n\t\t    if (! this->linearized)\n\t\t    {\n\t\t\tassignCompressedObjectNumbers(og);\n\t\t    }\n\t\t}\n\t\telse if ((! this->direct_stream_lengths) && object.isStream())\n\t\t{\n\t\t    // reserve next object ID for length\n\t\t    ++next_objid;\n\t\t}\n\t    }\n\t}\n    }\n    else if (object.isArray())\n    {\n\tint n = object.getArrayNItems();\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getArrayItem(i));\n\t    }\n\t}\n    }\n    else if (object.isDictionary())\n    {\n\tstd::set<std::string> keys = object.getKeys();\n\tfor (std::set<std::string>::iterator iter = keys.begin();\n\t     iter != keys.end(); ++iter)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getKey(*iter));\n\t    }\n\t}\n    }\n    else\n    {\n\t// ignore\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int burl_is_unreserved (const int c)\n{\n    return (light_isalnum(c) || c == '-' || c == '.' || c == '_' || c == '~');\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "sshpkt_send(struct ssh *ssh)\n{\n\tif (compat20)\n\t\treturn ssh_packet_send2(ssh);\n\telse\n\t\treturn ssh_packet_send1(ssh);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "file_default(struct magic_set *ms, size_t nb)\n{\n\tif (ms->flags & MAGIC_MIME) {\n\t\tif ((ms->flags & MAGIC_MIME_TYPE) &&\n\t\t    file_printf(ms, \"application/%s\",\n\t\t\tnb ? \"octet-stream\" : \"x-empty\") == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\tif (ms->flags & MAGIC_APPLE) {\n\t\tif (file_printf(ms, \"UNKNUNKN\") == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\tif (ms->flags & MAGIC_EXTENSION) {\n\t\tif (file_printf(ms, \"???\") == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "DISAS_INSN(divl)\n\n{\n\n    TCGv num;\n\n    TCGv den;\n\n    TCGv reg;\n\n    uint16_t ext;\n\n\n\n    ext = read_im16(env, s);\n\n    if (ext & 0x87f8) {\n\n        gen_exception(s, s->pc - 4, EXCP_UNSUPPORTED);\n\n        return;\n\n    }\n\n    num = DREG(ext, 12);\n\n    reg = DREG(ext, 0);\n\n    tcg_gen_mov_i32(QREG_DIV1, num);\n\n    SRC_EA(env, den, OS_LONG, 0, NULL);\n\n    tcg_gen_mov_i32(QREG_DIV2, den);\n\n    if (ext & 0x0800) {\n\n        gen_helper_divs(cpu_env, tcg_const_i32(0));\n\n    } else {\n\n        gen_helper_divu(cpu_env, tcg_const_i32(0));\n\n    }\n\n    if ((ext & 7) == ((ext >> 12) & 7)) {\n\n        /* div */\n\n        tcg_gen_mov_i32 (reg, QREG_DIV1);\n\n    } else {\n\n        /* rem */\n\n        tcg_gen_mov_i32 (reg, QREG_DIV2);\n\n    }\n\n    set_cc_op(s, CC_OP_FLAGS);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "mrb_const_get_sym(mrb_state *mrb, mrb_value mod, mrb_sym id)\n{\n  check_const_name_sym(mrb, id);\n  return mrb_const_get(mrb, mod, id);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int mem_online_node(int nid)\n{\n\tpg_data_t\t*pgdat;\n\tint\tret;\n\n\tlock_memory_hotplug();\n\tpgdat = hotadd_new_pgdat(nid, 0);\n\tif (!pgdat) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnode_set_online(nid);\n\tret = register_one_node(nid);\n\tBUG_ON(ret);\n\nout:\n\tunlock_memory_hotplug();\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "kuid_t sock_i_uid(struct sock *sk)\n{\n\tkuid_t uid;\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tuid = sk->sk_socket ? SOCK_INODE(sk->sk_socket)->i_uid : GLOBAL_ROOT_UID;\n\tread_unlock_bh(&sk->sk_callback_lock);\n\treturn uid;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void adx_decode(ADXContext *c, int16_t *out, const uint8_t *in, int ch)\n\n{\n\n    ADXChannelState *prev = &c->prev[ch];\n\n    GetBitContext gb;\n\n    int scale = AV_RB16(in);\n\n    int i;\n\n    int s0, s1, s2, d;\n\n\n\n    init_get_bits(&gb, in + 2, (18 - 2) * 8);\n\n    s1 = prev->s1;\n\n    s2 = prev->s2;\n\n    for (i = 0; i < 32; i++) {\n\n        d  = get_sbits(&gb, 4);\n\n        s0 = (BASEVOL * d * scale + SCALE1 * s1 - SCALE2 * s2) >> 14;\n\n        s2 = s1;\n\n        s1 = av_clip_int16(s0);\n\n        *out = s1;\n\n        out += c->channels;\n\n    }\n\n    prev->s1 = s1;\n\n    prev->s2 = s2;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static ssize_t order_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", oo_order(s->oo));\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int WavpackGetMD5Sum (WavpackContext *wpc, unsigned char data [16])\n{\n    if (wpc->config.flags & CONFIG_MD5_CHECKSUM) {\n        if (!wpc->config.md5_read && wpc->reader->can_seek (wpc->wv_in))\n            seek_eof_information (wpc, NULL, FALSE);\n\n        if (wpc->config.md5_read) {\n            memcpy (data, wpc->config.md5_checksum, 16);\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "__releases(journal->j_state_lock)\n{\n\tDEFINE_WAIT(wait);\n\tint need_to_start;\n\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\tprepare_to_wait(&journal->j_wait_transaction_locked, &wait,\n\t\t\tTASK_UNINTERRUPTIBLE);\n\tneed_to_start = !tid_geq(journal->j_commit_request, tid);\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\tjbd2_might_wait_for_commit(journal);\n\tschedule();\n\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline int onenand_load_spare(OneNANDState *s, int sec, int secn,\n\n                void *dest)\n\n{\n\n    uint8_t buf[512];\n\n\n\n    if (s->blk_cur) {\n\n        if (blk_read(s->blk_cur, s->secs_cur + (sec >> 5), buf, 1) < 0) {\n\n            return 1;\n\n        }\n\n        memcpy(dest, buf + ((sec & 31) << 4), secn << 4);\n\n    } else if (sec + secn > s->secs_cur) {\n\n        return 1;\n\n    } else {\n\n        memcpy(dest, s->current + (s->secs_cur << 9) + (sec << 4), secn << 4);\n\n    }\n\n \n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, struct nameidata *nd)\n{\n\tstruct dentry * dentry = __d_lookup(parent, name);\n\n\t/* lockess __d_lookup may fail due to concurrent d_move() \n\t * in some unrelated directory, so try with d_lookup\n\t */\n\tif (!dentry)\n\t\tdentry = d_lookup(parent, name);\n\n\tif (dentry && dentry->d_op && dentry->d_op->d_revalidate)\n\t\tdentry = do_revalidate(dentry, nd);\n\n\treturn dentry;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int      stbi__pnm_isspace(char c)\n{\n   return c == ' ' || c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r';\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline int gic_get_current_vcpu(GICState *s)\n{\n    return gic_get_current_cpu(s) + GIC_NCPU;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "memxor(void *dst_in, const void *src_in, size_t n)\n{\n  char *dst = dst_in;\n  const char *src = src_in;\n\n  if (n >= WORD_T_THRESH)\n    {\n      unsigned i;\n      unsigned offset;\n      size_t nwords;\n      /* There are at least some bytes to compare.  No need to test\n\t for N == 0 in this alignment loop.  */\n      for (i = ALIGN_OFFSET(dst + n); i > 0; i--)\n\t{\n\t  n--;\n\t  dst[n] ^= src[n];\n\t}\n      offset = ALIGN_OFFSET(src + n);\n      nwords = n / sizeof (word_t);\n      n %= sizeof (word_t);\n\n      if (offset)\n\tmemxor_different_alignment ((word_t *) (dst+n), (src+n), nwords);\n      else\n\tmemxor_common_alignment ((word_t *) (dst+n),\n\t\t\t\t (const word_t *) (src+n), nwords);\n    }\n  while (n > 0)\n    {\n      n--;\n      dst[n] ^= src[n];\n    }\n\n  return dst;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void context_safe(struct cli_bc_ctx *ctx)\n{\n    /* make sure these are never NULL */\n    if (!ctx->hooks.kind)\n\tctx->hooks.kind = &nokind;\n    if (!ctx->hooks.match_counts)\n\tctx->hooks.match_counts = nomatch;\n    if (!ctx->hooks.match_offsets)\n\tctx->hooks.match_counts = nooffsets;\n    if (!ctx->hooks.filesize)\n\tctx->hooks.filesize = &nofilesize;\n    if (!ctx->hooks.pedata)\n\tctx->hooks.pedata = &nopedata;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static bool nl80211_valid_wpa_versions(u32 wpa_versions)\n{\n\treturn !(wpa_versions & ~(NL80211_WPA_VERSION_1 |\n\t\t\t\t  NL80211_WPA_VERSION_2));\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline void VectorReciprocal(const DDSVector4 value,\n  DDSVector4 *destination)\n{\n  destination->x = 1.0f / value.x;\n  destination->y = 1.0f / value.y;\n  destination->z = 1.0f / value.z;\n  destination->w = 1.0f / value.w;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "RedirectNotificationObserver::RedirectNotificationObserver(\n    int notification_type,\n    const NotificationSource& source)\n    : seen_(false),\n      running_(false),\n      source_(NotificationService::AllSources()) {\n  registrar_.Add(this, notification_type, source);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n\t\t\t       const pj_uint8_t *pkt, const pj_uint8_t *start,\n\t\t\t       const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Allocate memory for the name */\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    p = (start + name_part_len);\n\n    /* Get the type */\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n\n    /* Get the class */\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n\n    *parsed_len = (int)(p - start);\n\n    return PJ_SUCCESS;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "sec_reset_state(void)\n{\n\tg_server_rdp_version = 0;\n\tg_sec_encrypt_use_count = 0;\n\tg_sec_decrypt_use_count = 0;\n\tg_licence_issued = 0;\n\tg_licence_error_result = 0;\n\tmcs_reset_state();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID)\n{\n\tCNetChunk Packet;\n\tif(!pMsg)\n\t\treturn -1;\n\n\t// drop packet to dummy client\n\tif(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID))\n\t\treturn 0;\n\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\tPacket.m_ClientID = ClientID;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\n\t// write message to demo recorder\n\tif(!(Flags&MSGFLAG_NORECORD))\n\t\tm_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size());\n\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t{\n\t\tif(ClientID == -1)\n\t\t{\n\t\t\t// broadcast\n\t\t\tint i;\n\t\t\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t\t\t\tif(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting)\n\t\t\t\t{\n\t\t\t\t\tPacket.m_ClientID = i;\n\t\t\t\t\tm_NetServer.Send(&Packet);\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tm_NetServer.Send(&Packet);\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "DetectLeftRecursion(const std::string &name) : name_(name) {}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "rend_service_use_direct_connection_node(const or_options_t* options,\n                                        const node_t* node)\n{\n  /* We'll connect directly all reachable addresses, whether preferred or not.\n   */\n  return (rend_service_allow_non_anonymous_connection(options) &&\n          fascist_firewall_allows_node(node, FIREWALL_OR_CONNECTION, 0));\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int hci_conn_check_link_mode(struct hci_conn *conn)\n{\n\tBT_DBG(\"hcon %p\", conn);\n\n\t/* In Secure Connections Only mode, it is required that Secure\n\t * Connections is used and the link is encrypted with AES-CCM\n\t * using a P-256 authenticated combination key.\n\t */\n\tif (hci_dev_test_flag(conn->hdev, HCI_SC_ONLY)) {\n\t\tif (!hci_conn_sc_enabled(conn) ||\n\t\t    !test_bit(HCI_CONN_AES_CCM, &conn->flags) ||\n\t\t    conn->key_type != HCI_LK_AUTH_COMBINATION_P256)\n\t\t\treturn 0;\n\t}\n\n\tif (hci_conn_ssp_enabled(conn) &&\n\t    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int rsvp_dump(struct tcf_proto *tp, unsigned long fh,\n\t\t     struct sk_buff *skb, struct tcmsg *t)\n{\n\tstruct rsvp_filter *f = (struct rsvp_filter*)fh;\n\tstruct rsvp_session *s;\n\tunsigned char\t *b = skb->tail;\n\tstruct rtattr *rta;\n\tstruct tc_rsvp_pinfo pinfo;\n\n\tif (f == NULL)\n\t\treturn skb->len;\n\ts = f->sess;\n\n\tt->tcm_handle = f->handle;\n\n\n\trta = (struct rtattr*)b;\n\tRTA_PUT(skb, TCA_OPTIONS, 0, NULL);\n\n\tRTA_PUT(skb, TCA_RSVP_DST, sizeof(s->dst), &s->dst);\n\tpinfo.dpi = s->dpi;\n\tpinfo.spi = f->spi;\n\tpinfo.protocol = s->protocol;\n\tpinfo.tunnelid = s->tunnelid;\n\tpinfo.tunnelhdr = f->tunnelhdr;\n\tRTA_PUT(skb, TCA_RSVP_PINFO, sizeof(pinfo), &pinfo);\n\tif (f->res.classid)\n\t\tRTA_PUT(skb, TCA_RSVP_CLASSID, 4, &f->res.classid);\n\tif (((f->handle>>8)&0xFF) != 16)\n\t\tRTA_PUT(skb, TCA_RSVP_SRC, sizeof(f->src), f->src);\n\n\tif (tcf_exts_dump(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\n\trta->rta_len = skb->tail - b;\n\n\tif (tcf_exts_dump_stats(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static struct pneigh_entry *pneigh_get_first(struct seq_file *seq)\n{\n\tstruct neigh_seq_state *state = seq->private;\n\tstruct neigh_table *tbl = state->tbl;\n\tstruct pneigh_entry *pn = NULL;\n\tint bucket = state->bucket;\n\n\tstate->flags |= NEIGH_SEQ_IS_PNEIGH;\n\tfor (bucket = 0; bucket <= PNEIGH_HASHMASK; bucket++) {\n\t\tpn = tbl->phash_buckets[bucket];\n\t\tif (pn)\n\t\t\tbreak;\n\t}\n\tstate->bucket = bucket;\n\n\treturn pn;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "decompileIMPLEMENTS(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *nparam;\n\tint i;\n\tINDENT;\n\tputs(getName(pop()));\n\tprintf(\" implements \");\n\tnparam=pop();\n\tfor(i=0;i<nparam->p.Integer;i++) \n\t{\n\t\tputs(getName(pop()));\n\t}\n\tprintln(\" ;\");\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "Clipboard::~Clipboard() {\n  gtk_clipboard_store(clipboard_);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void pxa2xx_screen_dump(void *opaque, const char *filename)\n\n{\n\n    /* TODO */\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int put_chars(u32 vtermno, const char *buf, int count)\n {\n \tstruct port *port;\n \tstruct scatterlist sg[1];\n \n \tif (unlikely(early_put_chars))\n \t\treturn early_put_chars(vtermno, buf, count);\n\n\tport = find_port_by_vtermno(vtermno);\n \tif (!port)\n \t\treturn -EPIPE;\n \n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n }",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "content::ColorChooser* DevToolsWindow::OpenColorChooser(\n    content::WebContents* web_contents,\n    SkColor initial_color) {\n  return chrome::ShowColorChooser(web_contents, initial_color);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "base::string16 ServiceWorkerPaymentInstrument::GetMissingInfoLabel() const {\n  NOTREACHED();\n  return base::string16();\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static ut8 getsib(const ut8 sib) {\n\tif (!sib) {\n\t\treturn 0;\n\t}\n\treturn (sib & 0x8) ? 3 : getsib ((sib << 1) | 1) - 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n*/\n\tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n\tif (ctxt) {\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "hfs_attr_walk_zlib_rsrc(const TSK_FS_ATTR * fs_attr,\n    int flags, TSK_FS_FILE_WALK_CB a_action, void *ptr)\n{\n    return hfs_attr_walk_compressed_rsrc(\n      fs_attr, flags, a_action, ptr,\n      hfs_read_zlib_block_table,\n      hfs_decompress_zlib_block\n    );\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "PolyStrchr(string, class)\n    register char *string;\n    register char class;\n{\n    while (*string)\n    {\n\tif (MatchClass(class, *string))\n\t{\n\t    return (string);\n\t}\n\tstring++;\n    }\n    return NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) {\n  auto it = idInfoMap.find(id);\n  if (it == idInfoMap.end()) {\n    STFATAL << \" Tried to read from an id that no longer exists\";\n  }\n  return it->second;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "PPC_OP(neg)\n\n{\n\n    if (T0 != 0x80000000) {\n\n        T0 = -Ts0;\n\n    }\n\n    RETURN();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int sctp_transport_walk_start(struct rhashtable_iter *iter)\n{\n\tint err;\n\n\trhltable_walk_enter(&sctp_transport_hashtable, iter);\n\n\terr = rhashtable_walk_start(iter);\n\tif (err && err != -EAGAIN) {\n\t\trhashtable_walk_stop(iter);\n\t\trhashtable_walk_exit(iter);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "EntropyParser::EntropyParser(class Frame *frame,class Scan *scan)\n  : JKeeper(scan->EnvironOf()), m_pScan(scan), m_pFrame(frame)\n{\n  m_ucCount = scan->ComponentsInScan();\n\n  // The residual scan uses all components here, not just for, but\n  // it does not require the component count either.\n  for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    JPG_TRY {\n      m_pComponent[i] = scan->ComponentOf(i);\n    } JPG_CATCH {\n      m_pComponent[i] = NULL;\n    } JPG_ENDTRY;\n  }\n\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n  m_bSegmentIsValid     = true;\n  m_bScanForDNL         = (m_pFrame->HeightOf() == 0)?true:false;\n  m_bDNLFound           = false;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static BROTLI_INLINE uint32_t GetCopyBase(uint16_t copycode) {\n  return kCopyBase[copycode];\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static mongo_message *mongo_message_create( int len , int id , int responseTo , int op ) {\n    mongo_message *mm = ( mongo_message * )bson_malloc( len );\n\n    if ( !id )\n        id = rand();\n\n    /* native endian (converted on send) */\n    mm->head.len = len;\n    mm->head.id = id;\n    mm->head.responseTo = responseTo;\n    mm->head.op = op;\n\n    return mm;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void qmp_xen_save_devices_state(const char *filename, Error **errp)\n\n{\n\n    QEMUFile *f;\n\n    QIOChannelFile *ioc;\n\n    int saved_vm_running;\n\n    int ret;\n\n\n\n    saved_vm_running = runstate_is_running();\n\n    vm_stop(RUN_STATE_SAVE_VM);\n\n    global_state_store_running();\n\n\n\n    ioc = qio_channel_file_new_path(filename, O_WRONLY | O_CREAT, 0660, errp);\n\n    if (!ioc) {\n\n        goto the_end;\n\n    }\n\n    qio_channel_set_name(QIO_CHANNEL(ioc), \"migration-xen-save-state\");\n\n    f = qemu_fopen_channel_output(QIO_CHANNEL(ioc));\n\n    ret = qemu_save_device_state(f);\n\n    qemu_fclose(f);\n\n    if (ret < 0) {\n\n        error_setg(errp, QERR_IO_ERROR);\n\n    }\n\n\n\n the_end:\n\n    if (saved_vm_running) {\n\n        vm_start();\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Opal::Call::OnReleased (OpalConnection & connection)\n{\n  parse_info (connection);\n\n  OpalCall::OnReleased (connection);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void _set_link(RRBNode *parent, RRBNode *child, const int dir) {\n\tif (parent) {\n\t\tparent->link[dir] = child;\n\t}\n\tif (child) {\n\t\tchild->parent = parent;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int count_commas(char *s)\n{\n\tint n = 0;\n\twhile (*s)\n\t{\n\t\tif (*s == ',')\n\t\t\tn ++;\n\t\ts ++;\n\t}\n\treturn n;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void cryptd_hash_update(struct crypto_async_request *req_async, int err)\n{\n\tstruct ahash_request *req = ahash_request_cast(req_async);\n\tstruct cryptd_hash_request_ctx *rctx;\n\n\trctx = ahash_request_ctx(req);\n\n\tif (unlikely(err == -EINPROGRESS))\n\t\tgoto out;\n\n\terr = shash_ahash_update(req, &rctx->desc);\n\n\treq->base.complete = rctx->complete;\n\nout:\n\tlocal_bh_disable();\n\trctx->complete(&req->base, err);\n\tlocal_bh_enable();\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)\n\n{\n\n    void **p = ptr;\n\n    if (min_size < *size)\n\n        return;\n\n    min_size= FFMAX(17*min_size/16 + 32, min_size);\n\n    av_free(*p);\n\n    *p = av_malloc(min_size);\n\n    if (!*p) min_size = 0;\n\n    *size= min_size;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void GrantPermissionsForFile(const FilePath& file, int permissions) {\n    FilePath stripped = file.StripTrailingSeparators();\n    file_permissions_[stripped] |= permissions;\n    UMA_HISTOGRAM_COUNTS(\"ChildProcessSecurityPolicy.FilePermissionPathLength\",\n                         stripped.value().size());\n  }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void Parser::UpdateOrCheckForDuplicateInFormals(IdentPtr pid, SList<IdentPtr> *formals)\n{\n    bool isStrictMode = IsStrictMode();\n    if (isStrictMode)\n    {\n        CheckStrictModeEvalArgumentsUsage(pid);\n    }\n\n    if (formals->Has(pid))\n    {\n        if (isStrictMode)\n        {\n            Error(ERRES5ArgSame);\n        }\n        else\n        {\n            Error(ERRFormalSame);\n        }\n    }\n    else\n    {\n        formals->Prepend(pid);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int index_from_key(const char *key)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; QKeyCode_lookup[i] != NULL; i++) {\n\n        if (!strcmp(key, QKeyCode_lookup[i])) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Return Q_KEY_CODE__MAX if the key is invalid */\n\n    return i;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "__global__ void UnsortedSegmentCustomKernel(const Index input_outer_dim_size,\n                                            const Index inner_dim_size,\n                                            const Index output_outer_dim_size,\n                                            const Index* segment_ids,\n                                            const T* input, T* output) {\n  const Index input_total_size = input_outer_dim_size * inner_dim_size;\n  const Index output_total_size = output_outer_dim_size * inner_dim_size;\n  for (int input_index : GpuGridRangeX(input_total_size)) {\n    const Index input_segment_index = input_index / inner_dim_size;\n    const Index segment_offset = input_index % inner_dim_size;\n    const Index output_segment_index = segment_ids[input_segment_index];\n    if (output_segment_index < 0 || output_segment_index >= output_total_size) {\n      continue;\n    }\n    const Index output_index =\n        output_segment_index * inner_dim_size + segment_offset;\n    KernelReductionFunctor()(output + output_index, ldg(input + input_index));\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void dp8393x_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);\n\n    dc->realize = dp8393x_realize;\n\n    dc->reset = dp8393x_reset;\n\n    dc->vmsd = &vmstate_dp8393x;\n\n    dc->props = dp8393x_properties;\n\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int cmp(const void *a, const void *b)\n\n{\n\n    const double va = *(const double *)a, vb = *(const double *)b;\n\n    return va < vb ? -1 : ( va > vb ? 1 : 0 );\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void build_guest_fsinfo_for_virtual_device(char const *syspath,\n\n                                                  GuestFilesystemInfo *fs,\n\n                                                  Error **errp)\n\n{\n\n    DIR *dir;\n\n    char *dirpath;\n\n    struct dirent entry, *result;\n\n\n\n    dirpath = g_strdup_printf(\"%s/slaves\", syspath);\n\n    dir = opendir(dirpath);\n\n    if (!dir) {\n\n        error_setg_errno(errp, errno, \"opendir(\\\"%s\\\")\", dirpath);\n\n        g_free(dirpath);\n\n        return;\n\n    }\n\n    g_free(dirpath);\n\n\n\n    for (;;) {\n\n        if (readdir_r(dir, &entry, &result) != 0) {\n\n            error_setg_errno(errp, errno, \"readdir_r(\\\"%s\\\")\", dirpath);\n\n            break;\n\n        }\n\n        if (!result) {\n\n            break;\n\n        }\n\n\n\n        if (entry.d_type == DT_LNK) {\n\n            g_debug(\" slave device '%s'\", entry.d_name);\n\n            dirpath = g_strdup_printf(\"%s/slaves/%s\", syspath, entry.d_name);\n\n            build_guest_fsinfo_for_device(dirpath, fs, errp);\n\n            g_free(dirpath);\n\n\n\n            if (*errp) {\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    closedir(dir);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void ok_jpg_idct_16x8(const int16_t *input, uint8_t *output) {\n    int temp[8 * 8];\n    ok_jpg_idct_1d_col_8(input, temp);\n    ok_jpg_idct_1d_row_16(8, temp, output);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n\n    for (i = 0; i < probe_packet->buf_size; i++) {\n        temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if ((temp_buffer & 0xffffff00) != 0x100)\n            continue;\n\n        if (temp_buffer == VOP_START_CODE)\n            VOP++;\n        else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n            VISO++;\n        else if (temp_buffer < 0x120)\n            VO++;\n        else if (temp_buffer < 0x130)\n            VOL++;\n        else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                 !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "PHPAPI int php_hash_environment(TSRMLS_D)\n{\n\tmemset(PG(http_globals), 0, sizeof(PG(http_globals)));\n\tzend_activate_auto_globals(TSRMLS_C);\n\tif (PG(register_argc_argv)) {\n\t\tphp_build_argv(SG(request_info).query_string, PG(http_globals)[TRACK_VARS_SERVER] TSRMLS_CC);\n\t}\n\treturn SUCCESS;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "hufUncompress (const char compressed[],\n\t       int nCompressed,\n\t       unsigned short raw[],\n\t       int nRaw)\n{\n    //\n    // need at least 20 bytes for header\n    //\n    if (nCompressed < 20 )\n    {\n\tif (nRaw != 0)\n\t    notEnoughData();\n\n\treturn;\n    }\n\n    int im = readUInt (compressed);\n    int iM = readUInt (compressed + 4);\n    // int tableLength = readUInt (compressed + 8);\n    int nBits = readUInt (compressed + 12);\n\n    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)\n\tinvalidTableSize();\n\n    const char *ptr = compressed + 20;\n\n    if ( ptr + (nBits+7 )/8 > compressed+nCompressed)\n    {\n        notEnoughData();\n        return;\n    }\n\n    // \n    // Fast decoder needs at least 2x64-bits of compressed data, and\n    // needs to be run-able on this platform. Otherwise, fall back\n    // to the original decoder\n    //\n\n    if (FastHufDecoder::enabled() && nBits > 128)\n    {\n        FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);\n        fhd.decode ((unsigned char*)ptr, nBits, raw, nRaw);\n    }\n    else\n    {\n        AutoArray <Int64, HUF_ENCSIZE> freq;\n        AutoArray <HufDec, HUF_DECSIZE> hdec;\n\n        hufClearDecTable (hdec);\n\n        hufUnpackEncTable (&ptr,\n                           nCompressed - (ptr - compressed),\n                           im,\n                           iM,\n                           freq);\n\n        try\n        {\n            if (nBits > 8 * (nCompressed - (ptr - compressed)))\n                invalidNBits();\n\n            hufBuildDecTable (freq, im, iM, hdec);\n            hufDecode (freq, hdec, ptr, nBits, iM, nRaw, raw);\n        }\n        catch (...)\n        {\n            hufFreeDecTable (hdec);\n            throw;\n        }\n\n        hufFreeDecTable (hdec);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void FrameFocusedObserver::Wait() {\n  impl_->Run();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline uint32_t htx_get_blk_pos(const struct htx *htx, const struct htx_blk *blk)\n{\n\treturn ((htx->blocks + htx->size - (char *)blk) / sizeof(struct htx_blk) - 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void *nr_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &nr_list, pos);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void FrameView::removeFromAXObjectCache()\n{\n    if (AXObjectCache* cache = axObjectCache())\n        cache->remove(this);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int unix_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    ssize_t len;\n\n\n\n    for (;;) {\n\n        len = read(s->fd, buf, size);\n\n        if (len != -1) {\n\n            break;\n\n        }\n\n        if (errno == EAGAIN) {\n\n            yield_until_fd_readable(s->fd);\n\n        } else if (errno != EINTR) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (len == -1) {\n\n        len = -errno;\n\n    }\n\n    return len;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "virtual ~HttpProxyClientSocketPoolSpdy3Test() {\n  }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "AnimationClock& Document::animationClock()\n{\n    ASSERT(page());\n    return page()->animator().clock();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "failed(const char *s)\n{\n    perror(s);\n    ExitProgram(EXIT_FAILURE);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "PHP_HASH_API void PHP_HAVAL256Final(unsigned char *digest, PHP_HAVAL_CTX * context)\n{\n\tunsigned char bits[10];\n\tunsigned int index, padLen;\n\n\t/* Version, Passes, and Digest Length */\n\tbits[0] =\t(PHP_HASH_HAVAL_VERSION & 0x07) |\n\t\t\t\t((context->passes & 0x07) << 3) |\n\t\t\t\t((context->output & 0x03) << 6);\n\tbits[1] = (context->output >> 2);\n\n\t/* Save number of bits */\n\tEncode(bits + 2, context->count, 8);\n\n\t/* Pad out to 118 mod 128.\n\t */\n\tindex = (unsigned int) ((context->count[0] >> 3) & 0x3f);\n\tpadLen = (index < 118) ? (118 - index) : (246 - index);\n\tPHP_HAVALUpdate(context, PADDING, padLen);\n\n\t/* Append version, passes, digest length, and message length */\n\tPHP_HAVALUpdate(context, bits, 10);\n\n\t/* Store state in digest */\n\tEncode(digest, context->state, 32);\n\n\t/* Zeroize sensitive information.\n\t */\n\tmemset((unsigned char*) context, 0, sizeof(*context));\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n \n \tBT_DBG(\"sock %p, sk %p\", sock, sk);\n \n \tsa->rc_family  = AF_BLUETOOTH;\n \tsa->rc_channel = rfcomm_pi(sk)->channel;\n \tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->src);\n\n\t*len = sizeof(struct sockaddr_rc);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int whiteheat_firmware_download(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tint response;\n\n\tresponse = ezusb_fx1_ihex_firmware_download(serial->dev, \"whiteheat_loader.fw\");\n\tif (response >= 0) {\n\t\tresponse = ezusb_fx1_ihex_firmware_download(serial->dev, \"whiteheat.fw\");\n\t\tif (response >= 0)\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void doubleBoxSize(QPDFObjectHandle& page, char const* box_name)\n{\n    // If there is a box of this name, replace it with a new box whose\n    // elements are double the values of the original box.\n    QPDFObjectHandle box = page.getKey(box_name);\n    if (box.isNull())\n    {\n\treturn;\n    }\n    if (! (box.isArray() && (box.getArrayNItems() == 4)))\n    {\n\tthrow std::runtime_error(std::string(\"box \") + box_name +\n\t\t\t\t \" is not an array of four elements\");\n    }\n    std::vector<QPDFObjectHandle> doubled;\n    for (unsigned int i = 0; i < 4; ++i)\n    {\n\tdoubled.push_back(\n\t    QPDFObjectHandle::newReal(\n                box.getArrayItem(i).getNumericValue() * 2.0, 2));\n    }\n    page.replaceKey(box_name, QPDFObjectHandle::newArray(doubled));\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "    std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc)\n    {\n        alloc = \"\";\n\n        size_t len = 0;\n        nc_inq_attlen(ncid, varId, attrName, &len);\n        \n        if(len < 1)\n        {\n            return alloc;\n        }\n\n        char attr_vals[NC_MAX_NAME + 1];\n        memset(attr_vals, 0, NC_MAX_NAME + 1);\n\n        // Now look through this variable for the attribute\n        if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)\n        {\n            return alloc;\n        }\n\n        alloc = std::string(attr_vals);\n        return alloc;\n    }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void gen_slbie(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_slbie(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "INST_HANDLER (std) {\t// ST Y, Rr\tST Z, Rr\n\tESIL_A (\"r%d,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\tbuf[0] & 0x8 ? 'y' : 'z',\t// index register Y/Z\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t!(buf[1] & 0x10)\n\t\t\t? 0\t\t\t// no increment\n\t\t\t: buf[0] & 0x1\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: -1,\t\t// pre decremented\n\t\t!(buf[1] & 0x10)\n\t\t\t? (buf[1] & 0x20)\t// offset\n\t\t\t| ((buf[1] & 0xc) << 1)\n\t\t\t| (buf[0] & 0x7)\n\t\t\t: 0,\t\t\t// no offset\n\t\t1);\t\t\t\t// load operation (!st)\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "sec_process_srv_info(STREAM s)\n{\n\tin_uint16_le(s, g_server_rdp_version);\n\tDEBUG_RDP5((\"Server RDP version is %d\\n\", g_server_rdp_version));\n\tif (1 == g_server_rdp_version)\n\t{\n\t\tg_rdp_version = RDP_V4;\n\t\tg_server_depth = 8;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int ldb_handler_fold(struct ldb_context *ldb, void *mem_ctx,\n\t\t\t    const struct ldb_val *in, struct ldb_val *out)\n{\n\tchar *s, *t;\n\tsize_t l;\n\n\tif (!in || !out || !(in->data)) {\n\t\treturn -1;\n\t}\n\n\tout->data = (uint8_t *)ldb_casefold(ldb, mem_ctx, (const char *)(in->data), in->length);\n\tif (out->data == NULL) {\n\t\tldb_debug(ldb, LDB_DEBUG_ERROR, \"ldb_handler_fold: unable to casefold string [%.*s]\", (int)in->length, (const char *)in->data);\n\t\treturn -1;\n\t}\n\n\ts = (char *)(out->data);\n\t\n\t/* remove trailing spaces if any */\n\tl = strlen(s);\n\twhile (l > 0 && s[l - 1] == ' ') l--;\n\ts[l] = '\\0';\n\t\n\t/* remove leading spaces if any */\n\tif (*s == ' ') {\n\t\tfor (t = s; *s == ' '; s++) ;\n\n\t\t/* remove leading spaces by moving down the string */\n\t\tmemmove(t, s, l);\n\n\t\ts = t;\n\t}\n\n\t/* check middle spaces */\n\twhile ((t = strchr(s, ' ')) != NULL) {\n\t\tfor (s = t; *s == ' '; s++) ;\n\n\t\tif ((s - t) > 1) {\n\t\t\tl = strlen(s);\n\n\t\t\t/* remove all spaces but one by moving down the string */\n\t\t\tmemmove(t + 1, s, l);\n\t\t}\n\t}\n\n\tout->length = strlen((char *)out->data);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "GetFileNameFromFid (\r\n  IN   UDF_FILE_IDENTIFIER_DESCRIPTOR  *FileIdentifierDesc,\r\n  OUT  CHAR16                          *FileName\r\n  )\r\n{\r\n  UINT8 *OstaCompressed;\r\n  UINT8 CompressionId;\r\n  UINT8 Length;\r\n  UINTN Index;\r\n\r\n  OstaCompressed =\r\n    (UINT8 *)(\r\n      (UINT8 *)FileIdentifierDesc->Data +\r\n      FileIdentifierDesc->LengthOfImplementationUse\r\n      );\r\n\r\n  CompressionId = OstaCompressed[0];\r\n  if (!IS_VALID_COMPRESSION_ID (CompressionId)) {\r\n    return EFI_VOLUME_CORRUPTED;\r\n  }\r\n\r\n  //\r\n  // Decode filename.\r\n  //\r\n  Length = FileIdentifierDesc->LengthOfFileIdentifier;\r\n  for (Index = 1; Index < Length; Index++) {\r\n    if (CompressionId == 16) {\r\n      *FileName = OstaCompressed[Index++] << 8;\r\n    } else {\r\n      *FileName = 0;\r\n    }\r\n\r\n    if (Index < Length) {\r\n      *FileName |= (CHAR16)(OstaCompressed[Index]);\r\n    }\r\n\r\n    FileName++;\r\n  }\r\n\r\n  *FileName = L'\\0';\r\n\r\n  return EFI_SUCCESS;\r\n}\r",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int mce_default_notifier(struct notifier_block *nb, unsigned long val,\n\t\t\t\tvoid *data)\n{\n\tstruct mce *m = (struct mce *)data;\n\n\tif (!m)\n\t\treturn NOTIFY_DONE;\n\n\tif (atomic_read(&num_notifiers) > NUM_DEFAULT_NOTIFIERS)\n\t\treturn NOTIFY_DONE;\n\n\t__print_mce(m);\n\n\treturn NOTIFY_DONE;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void isdn_ppp_mp_free_skb(ippp_bundle *mp, struct sk_buff *skb)\n{\n\tdev_kfree_skb(skb);\n\tmp->frames--;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int32_t PepperFlashRendererHost::OnIsRectTopmost(\n    ppapi::host::HostMessageContext* host_context,\n    const PP_Rect& rect) {\n  content::PepperPluginInstance* plugin_instance =\n      host_->GetPluginInstance(pp_instance());\n  if (plugin_instance && plugin_instance->IsRectTopmost(\n      gfx::Rect(rect.point.x, rect.point.y,rect.size.width, rect.size.height)))\n    return PP_OK;\n  return PP_ERROR_FAILED;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void reset(LoginUtils* ptr) {\n    ptr_.reset(ptr);\n  }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int node_is_equal_ex(xmlNodePtr node, char *name, char *ns)\n{\n\tif (name == NULL || strcmp((char*)node->name, name) == 0) {\n\t\tif (ns) {\n\t\t\txmlNsPtr nsPtr = node_find_ns(node);\n\t\t\tif (nsPtr) {\n\t\t\t\treturn (strcmp((char*)nsPtr->href, ns) == 0);\n\t\t\t} else {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static off_t read_off(BlockDriverState *bs, int64_t offset)\n\n{\n\n\tuint64_t buffer;\n\n\tif (bdrv_pread(bs->file, offset, &buffer, 8) < 8)\n\n\t\treturn 0;\n\n\treturn be64_to_cpu(buffer);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "TEST_P(AltsIntegrationTestClientInvalidPeer, ClientValidationFail) {\n  initialize();\n  codec_client_ = makeRawHttpConnection(makeAltsConnection());\n  EXPECT_FALSE(codec_client_->connected());\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void giveup_all(struct task_struct *tsk)\n{\n\tunsigned long usermsr;\n\n\tif (!tsk->thread.regs)\n\t\treturn;\n\n\tusermsr = tsk->thread.regs->msr;\n\n\tif ((usermsr & msr_all_available) == 0)\n\t\treturn;\n\n\tmsr_check_and_set(msr_all_available);\n\tcheck_if_tm_restore_required(tsk);\n\n\tWARN_ON((usermsr & MSR_VSX) && !((usermsr & MSR_FP) && (usermsr & MSR_VEC)));\n\n#ifdef CONFIG_PPC_FPU\n\tif (usermsr & MSR_FP)\n\t\t__giveup_fpu(tsk);\n#endif\n#ifdef CONFIG_ALTIVEC\n\tif (usermsr & MSR_VEC)\n\t\t__giveup_altivec(tsk);\n#endif\n#ifdef CONFIG_SPE\n\tif (usermsr & MSR_SPE)\n\t\t__giveup_spe(tsk);\n#endif\n\n\tmsr_check_and_clear(msr_all_available);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "_TIFFmalloc(tmsize_t s)\n {\n \treturn (malloc((size_t) s));\n }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "reallocWrapper (void *address, size_t size)\n{\n  if (!(address = realloc (address, size)) && size)\n    outOfMemory ();\n  return address;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "snmpDecodePacket(SnmpRequest * rq)\n{\n    struct snmp_pdu *PDU;\n    u_char *Community;\n    u_char *buf = rq->buf;\n    int len = rq->len;\n\n    if (!Config.accessList.snmp) {\n        debugs(49, DBG_IMPORTANT, \"WARNING: snmp_access not configured. agent query DENIED from : \" << rq->from);\n        return;\n    }\n\n    debugs(49, 5, HERE << \"Called.\");\n    PDU = snmp_pdu_create(0);\n    /* Allways answer on SNMPv1 */\n    rq->session.Version = SNMP_VERSION_1;\n    Community = snmp_parse(&rq->session, PDU, buf, len);\n\n    /* Check if we have explicit permission to access SNMP data.\n     * default (set above) is to deny all */\n    if (Community) {\n        ACLFilledChecklist checklist(Config.accessList.snmp, NULL, NULL);\n        checklist.src_addr = rq->from;\n        checklist.snmp_community = (char *) Community;\n\n        if (checklist.fastCheck().allowed() && (snmp_coexist_V2toV1(PDU))) {\n            rq->community = Community;\n            rq->PDU = PDU;\n            debugs(49, 5, \"snmpAgentParse: reqid=[\" << PDU->reqid << \"]\");\n            snmpConstructReponse(rq);\n        } else {\n            debugs(49, DBG_IMPORTANT, \"WARNING: SNMP agent query DENIED from : \" << rq->from);\n        }\n        xfree(Community);\n\n    } else {\n        debugs(49, DBG_IMPORTANT, \"WARNING: Failed SNMP agent query from : \" << rq->from);\n        snmp_free_pdu(PDU);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int security_read_policy(void **data, size_t *len)\n{\n\tint rc;\n\tstruct policy_file fp;\n\n\tif (!ss_initialized)\n\t\treturn -EINVAL;\n\n\t*len = security_policydb_len();\n\n\t*data = vmalloc_user(*len);\n\tif (!*data)\n\t\treturn -ENOMEM;\n\n\tfp.data = *data;\n\tfp.len = *len;\n\n\tread_lock(&policy_rwlock);\n\trc = policydb_write(&policydb, &fp);\n\tread_unlock(&policy_rwlock);\n\n\tif (rc)\n\t\treturn rc;\n\n\t*len = (unsigned long)fp.data - (unsigned long)*data;\n\treturn 0;\n\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "ArgType(const T &arg) : type(make_type(arg)) {}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bool FrameLoader::shouldEnforceStrictMixedContentChecking() const\n{\n    Frame* parentFrame = m_frame->tree().parent();\n    if (!parentFrame)\n        return false;\n\n    return parentFrame->securityContext()->shouldEnforceStrictMixedContentChecking();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int cin_read_frame_header(CinDemuxContext *cin, AVIOContext *pb) {\n\n    CinFrameHeader *hdr = &cin->frame_header;\n\n\n\n    hdr->video_frame_type = avio_r8(pb);\n\n    hdr->audio_frame_type = avio_r8(pb);\n\n    hdr->pal_colors_count = avio_rl16(pb);\n\n    hdr->video_frame_size = avio_rl32(pb);\n\n    hdr->audio_frame_size = avio_rl32(pb);\n\n\n\n    if (pb->eof_reached || pb->error)\n\n        return AVERROR(EIO);\n\n\n\n    if (avio_rl32(pb) != 0xAA55AA55)\n\n\n\n\n\n\n    return 0;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bool GetTensorFromConstNode(const string& node_name_or_input,\n                              Tensor* tensor) {\n    const NodeDef* node = ctx().node_map->GetNode(node_name_or_input);\n    return node != nullptr && IsReallyConstant(*node) &&\n           CheckAttrExists(*node, \"value\").ok() &&\n           tensor->FromProto(node->attr().at(\"value\").tensor());\n  }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "IntSize PaintLayerScrollableArea::ScrollOffsetInt() const {\n  return FlooredIntSize(scroll_offset_);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "virtual status_t destroyPlugin() {\n Parcel data, reply;\n        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());\n        remote()->transact(DESTROY_PLUGIN, data, &reply);\n\n return reply.readInt32();\n }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void error_callback(const char *msg, void *client_data)\n{\n    FILE *stream = (FILE*)client_data;\n    fprintf(stream, \"[ERROR] %s\", msg);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void tw5864_video_input_fini(struct tw5864_input *dev)\n{\n\tvideo_unregister_device(&dev->vdev);\n\tv4l2_ctrl_handler_free(&dev->hdl);\n\tvb2_queue_release(&dev->vidq);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "zzip_mem_disk_new(void)\n{\n    return calloc(1, sizeof(ZZIP_MEM_DISK)); \n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static byte parseHexByte(const char * &str) {\n     byte b = parseHexChar(str[0]);\n    if (str[1] == ':' || str[1] == '\\0') {\n        str += 2;\n        return b;\n     } else {\n         b = b << 4 | parseHexChar(str[1]);\n        str += 3;\n        return b;\n     }\n }",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "hook_process_child (struct t_hook *hook_process)\n{\n    char *exec_args[4] = { \"sh\", \"-c\", NULL, NULL };\n    const char *ptr_url;\n    int rc;\n\n    /*\n     * close stdin, so that process will fail to read stdin (process reading\n     * stdin should not be run inside WeeChat!)\n     */\n    close (STDIN_FILENO);\n\n    /* redirect stdout/stderr to pipe (so that father process can read them) */\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDOUT]));\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDERR]));\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDOUT]),\n              STDOUT_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDERR]),\n              STDERR_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n\n    rc = EXIT_SUCCESS;\n\n    if (strncmp (HOOK_PROCESS(hook_process, command), \"url:\", 4) == 0)\n    {\n        /* get URL output (on stdout or file, depending on options) */\n        ptr_url = HOOK_PROCESS(hook_process, command) + 4;\n        while (ptr_url[0] == ' ')\n        {\n            ptr_url++;\n        }\n        rc = weeurl_download (ptr_url, HOOK_PROCESS(hook_process, options));\n        if (rc != 0)\n            fprintf (stderr, \"Error with URL '%s'\\n\", ptr_url);\n    }\n    else\n    {\n        /* launch command */\n        exec_args[2] = HOOK_PROCESS(hook_process, command);\n        execvp (exec_args[0], exec_args);\n\n        /* should not be executed if execvp was ok */\n        fprintf (stderr, \"Error with command '%s'\\n\",\n                 HOOK_PROCESS(hook_process, command));\n        rc = EXIT_FAILURE;\n    }\n\n    fflush (stdout);\n    fflush (stderr);\n\n    _exit (rc);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void cli_session_setup_gensec_remote_done(struct tevent_req *subreq)\n{\n\tstruct tevent_req *req =\n\t\ttevent_req_callback_data(subreq,\n\t\tstruct tevent_req);\n\tstruct cli_session_setup_gensec_state *state =\n\t\ttevent_req_data(req,\n\t\tstruct cli_session_setup_gensec_state);\n\tNTSTATUS status;\n\n\tTALLOC_FREE(state->inbuf);\n\tTALLOC_FREE(state->recv_iov);\n\n\tstatus = cli_sesssetup_blob_recv(subreq, state, &state->blob_in,\n\t\t\t\t\t &state->inbuf, &state->recv_iov);\n\tTALLOC_FREE(subreq);\n\tdata_blob_free(&state->blob_out);\n\tif (!NT_STATUS_IS_OK(status) &&\n\t    !NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED))\n\t{\n\t\ttevent_req_nterror(req, status);\n\t\treturn;\n\t}\n\n\tif (NT_STATUS_IS_OK(status)) {\n\t\tstruct smbXcli_session *session = NULL;\n\t\tbool is_guest = false;\n\n\t\tif (smbXcli_conn_protocol(state->cli->conn) >= PROTOCOL_SMB2_02) {\n\t\t\tsession = state->cli->smb2.session;\n\t\t} else {\n\t\t\tsession = state->cli->smb1.session;\n\t\t}\n\n\t\tis_guest = smbXcli_session_is_guest(session);\n\t\tif (is_guest) {\n\t\t\t/*\n\t\t\t * We can't finish the gensec handshake, we don't\n\t\t\t * have a negotiated session key.\n\t\t\t *\n\t\t\t * So just pretend we are completely done.\n\t\t\t */\n\t\t\tstate->blob_in = data_blob_null;\n\t\t\tstate->local_ready = true;\n\t\t}\n\n\t\tstate->remote_ready = true;\n\t}\n\n\tif (state->local_ready && state->remote_ready) {\n\t\tcli_session_setup_gensec_ready(req);\n\t\treturn;\n\t}\n\n\tcli_session_setup_gensec_local_next(req);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int ram_save_host_page(RAMState *rs, PageSearchStatus *pss,\n\n                              bool last_stage)\n\n{\n\n    int tmppages, pages = 0;\n\n    size_t pagesize_bits =\n\n        qemu_ram_pagesize(pss->block) >> TARGET_PAGE_BITS;\n\n\n\n    do {\n\n        tmppages = ram_save_target_page(rs, pss, last_stage);\n\n        if (tmppages < 0) {\n\n            return tmppages;\n\n        }\n\n\n\n        pages += tmppages;\n\n        pss->page++;\n\n    } while (pss->page & (pagesize_bits - 1));\n\n\n\n    /* The offset we leave with is the last one we looked at */\n\n    pss->page--;\n\n    return pages;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static u8 BS_ReadByte(GF_BitStream *bs)\n{\n\tBool is_eos;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {\n\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\tres = bs->original[bs->position++];\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tis_eos = gf_feof(bs->stream);\n\n\t/*we are in FILE mode, test for end of file*/\n\tif (!is_eos || bs->cache_read) {\n\t\tu8 res;\n\t\tBool loc_eos=GF_FALSE;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\n\t\tres = gf_bs_load_byte(bs, &loc_eos);\n\t\tif (loc_eos) goto bs_eof;\n\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {\n\t\t\t\tu8 next = gf_bs_load_byte(bs, &loc_eos);\n\t\t\t\tif (next < 0x04) {\n\t\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\t\tres = next;\n\t\t\t\t\tbs->position++;\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_seek(bs, bs->position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\nbs_eof:\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "String Ogg::XiphComment::genre() const\n{\n  if(d->fieldListMap[\"GENRE\"].isEmpty())\n    return String::null;\n  return d->fieldListMap[\"GENRE\"].front();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "START_TEST(test_tm_adopt_ispidowner)\n  {\n  /* we are the owner of this pid so should return true */\n  fail_unless(TRUE == ispidowner(getpid()));\n\n  /* assuming the unit test is not run as root, owner */\n  /* owner of this pid is not the owner of pid 1 (init) */\n  fail_unless(FALSE == ispidowner(1));\n  }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int kvm_irqchip_get_virq(KVMState *s)\n\n{\n\n    uint32_t *word = s->used_gsi_bitmap;\n\n    int max_words = ALIGN(s->gsi_count, 32) / 32;\n\n    int i, zeroes;\n\n    bool retry = true;\n\n\n\nagain:\n\n    /* Return the lowest unused GSI in the bitmap */\n\n    for (i = 0; i < max_words; i++) {\n\n        zeroes = ctz32(~word[i]);\n\n        if (zeroes == 32) {\n\n            continue;\n\n        }\n\n\n\n        return zeroes + i * 32;\n\n    }\n\n    if (!s->direct_msi && retry) {\n\n        retry = false;\n\n        kvm_flush_dynamic_msi_routes(s);\n\n        goto again;\n\n    }\n\n    return -ENOSPC;\n\n\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void gen_spr_power5p_lpar(CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* Logical partitionning */\n\n    spr_register_kvm(env, SPR_LPCR, \"LPCR\",\n\n\n                     &spr_read_generic, &spr_write_lpcr,\n\n                     KVM_REG_PPC_LPCR, LPCR_LPES0 | LPCR_LPES1);\n\n\n\n\n\n#endif\n\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int tmff_init(struct hid_device *hid, const signed short *ff_bits)\n{\n\tstruct tmff_device *tmff;\n\tstruct hid_report *report;\n\tstruct list_head *report_list;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *input_dev = hidinput->input;\n\tint error;\n\tint i;\n\n\ttmff = kzalloc(sizeof(struct tmff_device), GFP_KERNEL);\n\tif (!tmff)\n\t\treturn -ENOMEM;\n\n\t/* Find the report to use */\n\treport_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tlist_for_each_entry(report, report_list, list) {\n\t\tint fieldnum;\n\n\t\tfor (fieldnum = 0; fieldnum < report->maxfield; ++fieldnum) {\n\t\t\tstruct hid_field *field = report->field[fieldnum];\n\n\t\t\tif (field->maxusage <= 0)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (field->usage[0].hid) {\n\t\t\tcase THRUSTMASTER_USAGE_FF:\n\t\t\t\tif (field->report_count < 2) {\n\t\t\t\t\thid_warn(hid, \"ignoring FF field with report_count < 2\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (field->logical_maximum ==\n\t\t\t\t\t\tfield->logical_minimum) {\n\t\t\t\t\thid_warn(hid, \"ignoring FF field with logical_maximum == logical_minimum\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (tmff->report && tmff->report != report) {\n\t\t\t\t\thid_warn(hid, \"ignoring FF field in other report\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (tmff->ff_field && tmff->ff_field != field) {\n\t\t\t\t\thid_warn(hid, \"ignoring duplicate FF field\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttmff->report = report;\n\t\t\t\ttmff->ff_field = field;\n\n\t\t\t\tfor (i = 0; ff_bits[i] >= 0; i++)\n\t\t\t\t\tset_bit(ff_bits[i], input_dev->ffbit);\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\thid_warn(hid, \"ignoring unknown output usage %08x\\n\",\n\t\t\t\t\t field->usage[0].hid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!tmff->report) {\n\t\thid_err(hid, \"can't find FF field in output reports\\n\");\n\t\terror = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\terror = input_ff_create_memless(input_dev, tmff, tmff_play);\n\tif (error)\n\t\tgoto fail;\n\n\thid_info(hid, \"force feedback for ThrustMaster devices by Zinx Verituse <zinx@epicsol.org>\\n\");\n\treturn 0;\n\nfail:\n\tkfree(tmff);\n\treturn error;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void pci_cmd646_ide_init(PCIBus *bus, DriveInfo **hd_table,\n\n                         int secondary_ide_enabled)\n\n{\n\n    PCIDevice *dev;\n\n\n\n    dev = pci_create(bus, -1, \"CMD646 IDE\");\n\n    qdev_prop_set_uint32(&dev->qdev, \"secondary\", secondary_ide_enabled);\n\n    qdev_init(&dev->qdev);\n\n\n\n    pci_ide_create_devs(dev, hd_table);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "PS_DESTROY_FUNC(files)\n{\n\tchar buf[MAXPATHLEN];\n\tPS_FILES_DATA;\n\n\tif (!ps_files_path_create(buf, sizeof(buf), data, key)) {\n\t\treturn FAILURE;\n\t}\n\n\tif (data->fd != -1) {\n\t\tps_files_close(data);\n\n\t\tif (VCWD_UNLINK(buf) == -1) {\n\t\t\t/* This is a little safety check for instances when we are dealing with a regenerated session\n\t\t\t * that was not yet written to disk. */\n\t\t\tif (!VCWD_ACCESS(buf, F_OK)) {\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int git_delta_read_header(\n\tsize_t *base_out,\n\tsize_t *result_out,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tif ((hdr_sz(base_out, &delta, delta_end) < 0) ||\n\t\t(hdr_sz(result_out, &delta, delta_end) < 0))\n\t\treturn -1;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bool ValidateSalsa()\r\n{\r\n\tstd::cout << \"\\nSalsa validation suite running...\\n\";\r\n\r\n\treturn RunTestDataFile(CRYPTOPP_DATA_DIR \"TestVectors/salsa.txt\");\r\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void pmsav5_data_ap_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                                 uint64_t value)\n\n{\n\n    env->cp15.c5_data = extended_mpu_ap_bits(value);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void qp_table_remove(void *p, uint32_t h, void *up)\n{\n    g_free(p);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void crypto_rfc4106_free(struct crypto_instance *inst)\n{\n\tcrypto_drop_spawn(crypto_instance_ctx(inst));\n\tkfree(inst);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool Jsi_NumberIsNormal(Jsi_Number a) { return (fpclassify(a) == FP_ZERO || isnormal(a)); }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "ExifData::const_iterator serialNumber(const ExifData& ed)\n    {\n        static const char* keys[] = {\n            \"Exif.Image.CameraSerialNumber\",\n            \"Exif.Canon.SerialNumber\",\n            \"Exif.Nikon3.SerialNumber\",\n            \"Exif.Nikon3.SerialNO\",\n            \"Exif.Fujifilm.SerialNumber\",\n            \"Exif.Olympus.SerialNumber2\",\n            \"Exif.Sigma.SerialNumber\"\n        };\n        return findMetadatum(ed, keys, EXV_COUNTOF(keys));\n    }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int dummy_file_mmap (struct file *file, unsigned long reqprot,\n\t\t\t    unsigned long prot,\n\t\t\t    unsigned long flags,\n\t\t\t    unsigned long addr,\n\t\t\t    unsigned long addr_only)\n{\n\tif (addr < mmap_min_addr)\n\t\treturn -EACCES;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void php_session_track_init(TSRMLS_D) /* {{{ */\n{\n\tzval *session_vars = NULL;\n\n\t/* Unconditionally destroy existing array -- possible dirty data */\n\tzend_delete_global_variable(\"_SESSION\", sizeof(\"_SESSION\")-1 TSRMLS_CC);\n\n\tif (PS(http_session_vars)) {\n\t\tzval_ptr_dtor(&PS(http_session_vars));\n\t}\n\n\tMAKE_STD_ZVAL(session_vars);\n\tarray_init(session_vars);\n\tPS(http_session_vars) = session_vars;\n\n\tZEND_SET_GLOBAL_VAR_WITH_LENGTH(\"_SESSION\", sizeof(\"_SESSION\"), PS(http_session_vars), 2, 1);\n}\n/* }}} */",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int rfcomm_get_dev_list(void __user *arg)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dev_list_req *dl;\n\tstruct rfcomm_dev_info *di;\n\tint n = 0, size, err;\n\tu16 dev_num;\n\n\tBT_DBG(\"\");\n\n\tif (get_user(dev_num, (u16 __user *) arg))\n\t\treturn -EFAULT;\n\n\tif (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))\n\t\treturn -EINVAL;\n \n \tsize = sizeof(*dl) + dev_num * sizeof(*di);\n \n\tdl = kmalloc(size, GFP_KERNEL);\n \tif (!dl)\n \t\treturn -ENOMEM;\n \n\tdi = dl->dev_info;\n\n\tspin_lock(&rfcomm_dev_lock);\n\n\tlist_for_each_entry(dev, &rfcomm_dev_list, list) {\n\t\tif (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))\n\t\t\tcontinue;\n\t\t(di + n)->id      = dev->id;\n\t\t(di + n)->flags   = dev->flags;\n\t\t(di + n)->state   = dev->dlc->state;\n\t\t(di + n)->channel = dev->channel;\n\t\tbacpy(&(di + n)->src, &dev->src);\n\t\tbacpy(&(di + n)->dst, &dev->dst);\n\t\tif (++n >= dev_num)\n\t\t\tbreak;\n\t}\n\n\tspin_unlock(&rfcomm_dev_lock);\n\n\tdl->dev_num = n;\n\tsize = sizeof(*dl) + n * sizeof(*di);\n\n\terr = copy_to_user(arg, dl, size);\n\tkfree(dl);\n\n\treturn err ? -EFAULT : 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "CompositeDeepScanLine::setCompositing(DeepCompositing* c)\n{\n  _Data->_comp=c;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "pci_lintr_request(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint bestpin, bestcount, pin;\n\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\n\t/*\n\t * Just allocate a pin from our slot.  The pin will be\n\t * assigned IRQs later when interrupts are routed.\n\t */\n\tsi = &bi->slotinfo[dev->slot];\n\tbestpin = 0;\n\tbestcount = si->si_intpins[0].ii_count;\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tif (si->si_intpins[pin].ii_count < bestcount) {\n\t\t\tbestpin = pin;\n\t\t\tbestcount = si->si_intpins[pin].ii_count;\n\t\t}\n\t}\n\n\tsi->si_intpins[bestpin].ii_count++;\n\tdev->lintr.pin = bestpin + 1;\n\tpci_set_cfgdata8(dev, PCIR_INTPIN, bestpin + 1);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline struct sk_buff *__skb_dequeue(struct sk_buff_head *list)\n{\n\tstruct sk_buff *skb = skb_peek(list);\n\tif (skb)\n\t\t__skb_unlink(skb, list);\n\treturn skb;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void set_ta_ctx_ops(struct tee_ta_ctx *ctx)\n{\n\tctx->ops = _user_ta_ops;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "std::string GetDocumentOrigin(FrameTreeNode* ftn) {\n  std::string origin;\n  EXPECT_TRUE(ExecuteScriptAndExtractString(\n      ftn, \"domAutomationController.send(document.origin)\", &origin));\n  return origin;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static bool startsSingleLineCommentAt(const String& string, size_t start)\n{\n    return (start + 1 < string.length() && string[start] == '/' && string[start+1] == '/');\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "_nc_free_tparm(void)\n{\n    if (TPS(out_buff) != 0) {\n\tFreeAndNull(TPS(out_buff));\n\tTPS(out_size) = 0;\n\tTPS(out_used) = 0;\n\tFreeAndNull(TPS(fmt_buff));\n\tTPS(fmt_size) = 0;\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void msg_init_ns(struct ipc_namespace *ns)\n{\n\tns->msg_ctlmax = MSGMAX;\n\tns->msg_ctlmnb = MSGMNB;\n\tns->msg_ctlmni = MSGMNI;\n\n\tatomic_set(&ns->msg_bytes, 0);\n\tatomic_set(&ns->msg_hdrs, 0);\n\tipc_init_ids(&ns->ids[IPC_MSG_IDS]);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int activate(AVFilterContext *ctx)\n\n{\n\n    PreMultiplyContext *s = ctx->priv;\n\n\n\n    if (s->inplace) {\n\n        AVFrame *frame = NULL;\n\n        AVFrame *out = NULL;\n\n        int ret, status;\n\n        int64_t pts;\n\n\n\n        if ((ret = ff_inlink_consume_frame(ctx->inputs[0], &frame)) > 0) {\n\n            if ((ret = filter_frame(ctx, &out, frame, frame)) < 0)\n\n                return ret;\n\n            av_frame_free(&frame);\n\n            ret = ff_filter_frame(ctx->outputs[0], out);\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ff_inlink_acknowledge_status(ctx->inputs[0], &status, &pts)) {\n\n            ff_outlink_set_status(ctx->outputs[0], status, pts);\n\n            return 0;\n\n        } else {\n\n            if (ff_outlink_frame_wanted(ctx->outputs[0]))\n\n                ff_inlink_request_frame(ctx->inputs[0]);\n\n            return 0;\n\n        }\n\n    } else {\n\n        return ff_framesync_activate(&s->fs);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void TCGetDosNameFromNumber (LPWSTR dosname,int cbDosName, int nDriveNo, DeviceNamespaceType namespaceType)\n{\n\tWCHAR tmp[3] =\n\t{0, ':', 0};\n\tint j = nDriveNo + (WCHAR) 'A';\n\n\ttmp[0] = (short) j;\n\n\tif (DeviceNamespaceGlobal == namespaceType)\n\t{\n\t\tRtlStringCbCopyW (dosname, cbDosName, (LPWSTR) DOS_MOUNT_PREFIX_GLOBAL);\n\t}\n\telse\n\t{\n\t\tRtlStringCbCopyW (dosname, cbDosName, (LPWSTR) DOS_MOUNT_PREFIX_DEFAULT);\n\t}\n\n\tRtlStringCbCatW (dosname, cbDosName, tmp);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int rom_add_vga(const char *file)\n{\n    return rom_add_file(file, \"vgaroms\", 0, -1, true, NULL, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void Shell::ShowAppList(aura::Window* window) {\n  if (!window)\n    window = GetTargetRootWindow();\n  if (!app_list_controller_)\n    app_list_controller_.reset(new AppListController);\n  app_list_controller_->Show(window);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void LayerTilerChromium::reset()\n{\n    m_tiles.clear();\n    m_unusedTiles.clear();\n\n    m_layerSize = IntSize();\n    m_layerTileSize = IntSize();\n    m_lastUpdateLayerRect = IntRect();\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void UncompressElementOp::Compute(OpKernelContext* ctx) {\n  Tensor tensor = ctx->input(0);\n  const Variant& variant = tensor.scalar<Variant>()();\n  const CompressedElement* compressed = variant.get<CompressedElement>();\n\n  std::vector<Tensor> components;\n  OP_REQUIRES_OK(ctx, UncompressElement(*compressed, &components));\n  OP_REQUIRES(ctx, components.size() == output_types_.size(),\n              errors::FailedPrecondition(\"Expected \", output_types_.size(),\n                                         \" outputs from uncompress, but got \",\n                                         components.size()));\n  for (int i = 0; i < components.size(); ++i) {\n    OP_REQUIRES(\n        ctx, components[i].dtype() == output_types_[i],\n        errors::FailedPrecondition(\"Expected a tensor of type \",\n                                   DataTypeString(output_types_[i]),\n                                   \" but got a tensor of type \",\n                                   DataTypeString(components[i].dtype())));\n    ctx->set_output(i, components[i]);\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "long ExifData::count() const { return static_cast<long>(exifMetadata_.size()); }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "String Location::hostname() const {\n  return DOMURLUtilsReadOnly::hostname(Url());\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)\n\t{\n\tconst u_char* data_start = data;\n\n\tif ( len <= 0 )\n\t\treturn 0;\n\n\tfor ( ; len > 0; --len, ++data )\n\t\t{\n\t\tif ( offset >= buf_len )\n\t\t\tInitBuffer(buf_len * 2);\n\n\t\tint c = data[0];\n\n#define EMIT_LINE \\\n\t{ \\\n\tbuf[offset] = '\\0'; \\\n\tint seq_len = data + 1 - data_start; \\\n\tseq_delivered_in_lines = seq + seq_len; \\\n\tlast_char = c; \\\n\tForwardStream(offset, buf, IsOrig()); \\\n\toffset = 0; \\\n\treturn seq_len; \\\n\t}\n\n\t\tswitch ( c ) {\n\t\tcase '\\r':\n\t\t\t// Look ahead for '\\n'.\n\t\t\tif ( len > 1 && data[1] == '\\n' )\n\t\t\t\t{\n\t\t\t\t--len; ++data;\n\t\t\t\tlast_char = c;\n\t\t\t\tc = data[0];\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\n\t\t\telse if ( CR_LF_as_EOL & CR_as_EOL )\n\t\t\t\tEMIT_LINE\n\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\n\t\tcase '\\n':\n\t\t\tif ( last_char == '\\r' )\n\t\t\t\t{\n\t\t\t\t--offset; // remove '\\r'\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\n\t\t\telse if ( CR_LF_as_EOL & LF_as_EOL )\n\t\t\t\tEMIT_LINE\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_LF) )\n\t\t\t\t\tConn()->Weird(\"line_terminated_with_single_LF\");\n\t\t\t\tbuf[offset++] = c;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '\\0':\n\t\t\tif ( flag_NULs )\n\t\t\t\tCheckNUL();\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( last_char == '\\r' )\n\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_CR) )\n\t\t\t\tConn()->Weird(\"line_terminated_with_single_CR\");\n\n\t\tlast_char = c;\n\t\t}\n\n\treturn data - data_start;\n\t}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void exit_lmode(struct kvm_vcpu *vcpu)\n{\n\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\tvmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "char *BN_bn2dec(const BIGNUM *a)\n{\n    int i = 0, num, ok = 0;\n    char *buf = NULL;\n    char *p;\n    BIGNUM *t = NULL;\n    BN_ULONG *bn_data = NULL, *lp;\n\n    /*-\n     * get an upper bound for the length of the decimal integer\n     * num <= (BN_num_bits(a) + 1) * log(2)\n     *     <= 3 * BN_num_bits(a) * 0.1001 + log(2) + 1     (rounding error)\n     *     <= BN_num_bits(a)/10 + BN_num_bits/1000 + 1 + 1\n     */\n    i = BN_num_bits(a) * 3;\n    num = (i / 10 + i / 1000 + 1) + 1;\n    bn_data = OPENSSL_malloc((num / BN_DEC_NUM + 1) * sizeof(BN_ULONG));\n    buf = OPENSSL_malloc(num + 3);\n    if ((buf == NULL) || (bn_data == NULL)) {\n        BNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((t = BN_dup(a)) == NULL)\n        goto err;\n\n#define BUF_REMAIN (num+3 - (size_t)(p - buf))\n    p = buf;\n    lp = bn_data;\n    if (BN_is_zero(t)) {\n        *(p++) = '0';\n        *(p++) = '\\0';\n    } else {\n        if (BN_is_negative(t))\n            *p++ = '-';\n\n        i = 0;\n        while (!BN_is_zero(t)) {\n            *lp = BN_div_word(t, BN_DEC_CONV);\n            lp++;\n        }\n        lp--;\n        /*\n         * We now have a series of blocks, BN_DEC_NUM chars in length, where\n         * the last one needs truncation. The blocks need to be reversed in\n         * order.\n         */\n        BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT1, *lp);\n        while (*p)\n            p++;\n        while (lp != bn_data) {\n            lp--;\n            BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT2, *lp);\n            while (*p)\n                p++;\n        }\n    }\n    ok = 1;\n err:\n    OPENSSL_free(bn_data);\n    BN_free(t);\n    if (ok)\n        return buf;\n    OPENSSL_free(buf);\n    return NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static bool ShouldAutofocus(const HTMLFormControlElement* element) {\n  if (!element->isConnected())\n    return false;\n  if (!element->IsAutofocusable())\n    return false;\n\n\n\n   Document& doc = element->GetDocument();\n \n \n  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {\n    doc.AddConsoleMessage(ConsoleMessage::Create(\n        mojom::ConsoleMessageSource::kSecurity,\n        mojom::ConsoleMessageLevel::kError,\n        \"Blocked autofocusing on a form control because the form's frame is \"\n        \"sandboxed and the 'allow-scripts' permission is not set.\"));\n    return false;\n  }\n\n  if (!doc.IsInMainFrame() &&\n      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {\n    doc.AddConsoleMessage(ConsoleMessage::Create(\n        mojom::ConsoleMessageSource::kSecurity,\n        mojom::ConsoleMessageLevel::kError,\n        \"Blocked autofocusing on a form control in a cross-origin subframe.\"));\n    return false;\n  }\n\n  return true;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "bool ShouldEnableServerPushCancelation(\n    const VariationParameters& quic_trial_params) {\n  return base::LowerCaseEqualsASCII(\n      GetVariationParam(quic_trial_params, \"enable_server_push_cancellation\"),\n      \"true\");\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\t/* Find first missing device */\n\t\tlist_for_each_entry(device, &fs_info->fs_devices->devices,\n\t\t\t\t    dev_list) {\n\t\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t     &device->dev_state) && !device->bdev)\n\t\t\t\treturn device;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn btrfs_find_device_by_path(fs_info, device_path);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void testParseUrl()\n        {\n            cxxtools::QueryParams q;\n            q.parse_url(\"p2=value2&value3&p1=value1\");\n            CXXTOOLS_UNIT_ASSERT(q.has(\"p1\"));\n            CXXTOOLS_UNIT_ASSERT(q.has(\"p2\"));\n            CXXTOOLS_UNIT_ASSERT(!q.has(\"p3\"));\n            CXXTOOLS_UNIT_ASSERT_EQUALS(q[\"p1\"], \"value1\");\n            CXXTOOLS_UNIT_ASSERT_EQUALS(q[\"p2\"], \"value2\");\n            CXXTOOLS_UNIT_ASSERT_EQUALS(q[0], \"value3\");\n        }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\treturn selinux_nlmsg_perm(sk, skb);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int fx_init(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\n\terr = fpu_alloc(&vcpu->arch.guest_fpu);\n\tif (err)\n\t\treturn err;\n\n\tfpu_finit(&vcpu->arch.guest_fpu);\n\n\t/*\n\t * Ensure guest xcr0 is valid for loading\n\t */\n\tvcpu->arch.xcr0 = XSTATE_FP;\n\n\tvcpu->arch.cr0 |= X86_CR0_ET;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline void timer_stats_account_hrtimer(struct hrtimer *timer)\n{\n#ifdef CONFIG_TIMER_STATS\n\tif (likely(!timer_stats_active))\n\t\treturn;\n\ttimer_stats_update_stats(timer, timer->start_pid, timer->start_site,\n\t\t\t\t timer->function, timer->start_comm, 0);\n#endif\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "Item_decimal::Item_decimal(const uchar *bin, int precision, int scale)\n{\n  binary2my_decimal(E_DEC_FATAL_ERROR, bin,\n                    &decimal_value, precision, scale);\n  decimals= (uint8) decimal_value.frac;\n  fixed= 1;\n  max_length= my_decimal_precision_to_length_no_truncation(precision, decimals,\n                                                           unsigned_flag);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline long div_ll_X_l_rem(long long divs, long div, long *rem)\n{\n\tlong dum2;\n\tasm(\"divl %2\":\"=a\"(dum2), \"=d\"(*rem)\n\t    : \"rm\"(div), \"A\"(divs));\n\n\treturn dum2;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Inspect::operator()(Compound_Selector_Ptr s)\n  {\n    for (size_t i = 0, L = s->length(); i < L; ++i) {\n      (*s)[i]->perform(this);\n    }\n    if (s->has_line_break()) {\n      if (output_style() != COMPACT) {\n        append_optional_linefeed();\n      }\n    }\n  }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void rtmsg_ifinfo_send(struct sk_buff *skb, struct net_device *dev, gfp_t flags)\n{\n\tstruct net *net = dev_net(dev);\n\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Add(RenderWidgetHost* host) {\n    hosts_.push_back(RenderWidgetHostID(host->GetProcess()->GetID(),\n                                        host->GetRoutingID()));\n  }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void FrameView::setScrollPositionNonProgrammatically(const IntPoint& scrollPoint)\n{\n    IntPoint newScrollPosition = adjustScrollPositionWithinRange(scrollPoint);\n\n    if (newScrollPosition == scrollPosition())\n        return;\n\n    TemporaryChange<bool> changeInProgrammaticScroll(m_inProgrammaticScroll, false);\n    notifyScrollPositionChanged(newScrollPosition);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "BlockJobInfoList *qmp_query_block_jobs(Error **errp)\n\n{\n\n    BlockJobInfoList *head = NULL, **p_next = &head;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while ((it = bdrv_next(it, &bs))) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n\n\n        if (bs->job) {\n\n            BlockJobInfoList *elem = g_new0(BlockJobInfoList, 1);\n\n            elem->value = block_job_query(bs->job);\n\n            *p_next = elem;\n\n            p_next = &elem->next;\n\n        }\n\n\n\n        aio_context_release(aio_context);\n\n    }\n\n\n\n    return head;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static char *shell_name_generator(const char *text, int state)\n{\n\tstatic size_t len;\n\tchar *s;\n\n\tif (!state) {\n\t\tsetusershell();\n\t\tlen = strlen(text);\n\t}\n\n\twhile ((s = getusershell())) {\n\t\tif (strncmp(s, text, len) == 0)\n\t\t\treturn xstrdup(s);\n\t}\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void test_yield(void)\n\n{\n\n    Coroutine *coroutine;\n\n    bool done = false;\n\n    int i = -1; /* one extra time to return from coroutine */\n\n\n\n    coroutine = qemu_coroutine_create(yield_5_times);\n\n    while (!done) {\n\n        qemu_coroutine_enter(coroutine, &done);\n\n        i++;\n\n    }\n\n    g_assert_cmpint(i, ==, 5); /* coroutine must yield 5 times */\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek (ifp, -sizeof tail, SEEK_END);\n  fread (tail, 1, sizeof tail, ifp);\n  for (nz=i=0; i < (int) sizeof tail; i++)\n    if (tail[i]) nz++;\n  return nz > 20;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline void htx_skip_msg_payload(struct htx *htx)\n{\n\tstruct htx_blk *blk = htx_get_first_blk(htx);\n\n\twhile (blk) {\n\t\tenum htx_blk_type type = htx_get_blk_type(blk);\n\n\t\tblk = ((type > HTX_BLK_EOH)\n\t\t       ? htx_remove_blk(htx, blk)\n\t\t       : htx_get_next_blk(htx, blk));\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "ofproto_set_sflow(struct ofproto *ofproto,\n                  const struct ofproto_sflow_options *oso)\n{\n    if (oso && sset_is_empty(&oso->targets)) {\n        oso = NULL;\n    }\n\n    if (ofproto->ofproto_class->set_sflow) {\n        return ofproto->ofproto_class->set_sflow(ofproto, oso);\n    } else {\n        return oso ? EOPNOTSUPP : 0;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void ieee80211_clear_tx_pending(struct ieee80211_local *local)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < local->hw.queues; i++) {\n\t\twhile ((skb = skb_dequeue(&local->pending[i])) != NULL)\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "DLLEXPORT tjhandle tjInitDecompress(void)\n{\n  tjinstance *this;\n\n  if ((this = (tjinstance *)malloc(sizeof(tjinstance))) == NULL) {\n    snprintf(errStr, JMSG_LENGTH_MAX,\n             \"tjInitDecompress(): Memory allocation failure\");\n    return NULL;\n  }\n  MEMZERO(this, sizeof(tjinstance));\n  snprintf(this->errStr, JMSG_LENGTH_MAX, \"No error\");\n  return _tjInitDecompress(this);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int xfrm_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t     const struct xfrm_migrate *m, int num_migrate,\n\t\t\t     const struct xfrm_kmaddress *k)\n{\n\tstruct net *net = &init_net;\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_migrate_msgsize(num_migrate, !!k), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\t/* build migrate */\n\tif (build_migrate(skb, m, num_migrate, k, sel, dir, type) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_MIGRATE);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void virtio_balloon_to_target(void *opaque, ram_addr_t target,\n\n                                     MonitorCompletion cb, void *cb_data)\n\n{\n\n    VirtIOBalloon *dev = opaque;\n\n\n\n    if (target > ram_size) {\n\n        target = ram_size;\n\n    }\n\n    if (target) {\n\n        dev->num_pages = (ram_size - target) >> VIRTIO_BALLOON_PFN_SHIFT;\n\n        virtio_notify_config(&dev->vdev);\n\n    } else {\n\n        virtio_balloon_stat(opaque, cb, cb_data);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "rdpsnd_queue_write(STREAM s, uint16 tick, uint8 index)\n{\n\tstruct audio_packet *packet = &packet_queue[queue_hi];\n\tunsigned int next_hi = (queue_hi + 1) % MAX_QUEUE;\n\n\tif (next_hi == queue_pending)\n\t{\n\t\tlogger(Sound, Error, \"rdpsnd_queue_write(), no space to queue audio packet\");\n\t\treturn;\n\t}\n\n\tqueue_hi = next_hi;\n\n\tpacket->s = *s;\n\tpacket->tick = tick;\n\tpacket->index = index;\n\n\tgettimeofday(&packet->arrive_tv, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void Document::DispatchEventsForPrinting() {\n  if (!scripted_animation_controller_)\n    return;\n  scripted_animation_controller_->DispatchEventsAndCallbacksForPrinting();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Clipboard::InsertMapping(const char* key,\n                              char* data,\n                              size_t data_len) {\n  DCHECK(clipboard_data_->find(key) == clipboard_data_->end());\n  (*clipboard_data_)[key] = std::make_pair(data, data_len);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "AvahiSDNSServerBrowser *avahi_s_dns_server_browser_new(\n    AvahiServer *server,\n    AvahiIfIndex interface,\n    AvahiProtocol protocol,\n    const char *domain,\n    AvahiDNSServerType type,\n    AvahiProtocol aprotocol,\n    AvahiLookupFlags flags,\n    AvahiSDNSServerBrowserCallback callback,\n    void* userdata) {\n        AvahiSDNSServerBrowser* b;\n\n        b = avahi_s_dns_server_browser_prepare(server, interface, protocol, domain, type, aprotocol, flags, callback, userdata);\n        avahi_s_dns_server_browser_start(b);\n\n        return b;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void __net_exit igmp_net_exit(struct net *net)\n{\n\tremove_proc_entry(\"mcfilter\", net->proc_net);\n\tremove_proc_entry(\"igmp\", net->proc_net);\n\tinet_ctl_sock_destroy(net->ipv4.mc_autojoin_sk);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static EHCIPacket *ehci_alloc_packet(EHCIQueue *q)\n{\n    EHCIPacket *p;\n\n    p = g_new0(EHCIPacket, 1);\n    p->queue = q;\n    usb_packet_init(&p->packet);\n    QTAILQ_INSERT_TAIL(&q->packets, p, next);\n    trace_usb_ehci_packet_action(p->queue, p, \"alloc\");\n    return p;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void php_zip_free_dir(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tzip_rsrc * zip_int = (zip_rsrc *) rsrc->ptr;\n\n\tif (zip_int) {\n\t\tif (zip_int->za) {\n\t\t\tif (zip_close(zip_int->za) != 0) {\n\t\t\t\t_zip_free(zip_int->za);\n\t\t\t}\n\t\t\tzip_int->za = NULL;\n\t\t}\n\n\t\tefree(rsrc->ptr);\n\n\t\trsrc->ptr = NULL;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline void f2fs_change_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\t*addr ^= mask;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void dothecall (lua_State *L, void *ud) {\n  UNUSED(ud);\n  luaD_callnoyield(L, L->top - 2, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "Locale& Document::getCachedLocale(const AtomicString& locale)\n{\n    AtomicString localeKey = locale;\n    if (locale.isEmpty() || !RuntimeEnabledFeatures::langAttributeAwareFormControlUIEnabled())\n        return Locale::defaultLocale();\n    LocaleIdentifierToLocaleMap::AddResult result = m_localeCache.add(localeKey, nullptr);\n    if (result.isNewEntry)\n        result.storedValue->value = Locale::create(localeKey);\n    return *(result.storedValue->value);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static Visitor *validate_test_init_internal(TestInputVisitorData *data,\n                                            const char *json_string,\n                                            va_list *ap)\n{\n    Visitor *v;\n    data->obj = qobject_from_jsonv(json_string, ap);\n    g_assert(data->obj);\n    data->qiv = qmp_input_visitor_new_strict(data->obj);\n    g_assert(data->qiv);\n    v = qmp_input_get_visitor(data->qiv);\n    g_assert(v);\n    return v;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void net_rx_pkt_attach_iovec(struct NetRxPkt *pkt,\n\n                                const struct iovec *iov, int iovcnt,\n\n                                size_t iovoff, bool strip_vlan)\n\n{\n\n    uint16_t tci = 0;\n\n    uint16_t ploff = iovoff;\n\n    assert(pkt);\n\n    pkt->vlan_stripped = false;\n\n\n\n    if (strip_vlan) {\n\n        pkt->vlan_stripped = eth_strip_vlan(iov, iovcnt, iovoff, pkt->ehdr_buf,\n\n                                            &ploff, &tci);\n\n    }\n\n\n\n    pkt->tci = tci;\n\n\n\n    net_rx_pkt_pull_data(pkt, iov, iovcnt, ploff);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "trigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%i\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int mp_get_lsr_info(struct sb_uart_state *state, unsigned int *value)\n{\n\tstruct sb_uart_port *port = state->port;\n\tunsigned int result;\n\n\tresult = port->ops->tx_empty(port);\n\n\tif (port->x_char ||\n\t\t\t((uart_circ_chars_pending(&state->info->xmit) > 0) &&\n\t\t\t\t!state->info->tty->stopped && !state->info->tty->hw_stopped))\n\t\tresult &= ~TIOCSER_TEMT;\n\n\treturn put_user(result, value);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void tipc_sk_respond(struct sock *sk, struct sk_buff *skb, int err)\n{\n\tu32 selector;\n\tu32 dnode;\n\tu32 onode = tipc_own_addr(sock_net(sk));\n\n\tif (!tipc_msg_reverse(onode, &skb, err))\n\t\treturn;\n\n\tdnode = msg_destnode(buf_msg(skb));\n\tselector = msg_origport(buf_msg(skb));\n\ttipc_node_xmit_skb(sock_net(sk), skb, dnode, selector);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool V4L2JpegEncodeAccelerator::EncodedInstance::CreateBuffers(\n    gfx::Size coded_size,\n    size_t output_buffer_size) {\n  DCHECK(parent_->encoder_task_runner_->BelongsToCurrentThread());\n\n  if (!SetOutputBufferFormat(coded_size, output_buffer_size)) {\n    return false;\n  }\n\n  if (!SetInputBufferFormat(coded_size)) {\n    return false;\n  }\n\n  if (!RequestInputBuffers()) {\n    return false;\n  }\n\n  if (!RequestOutputBuffers()) {\n    return false;\n  }\n\n  return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void InstanceKlass::remove_dependent_nmethod(nmethod* nm) {\n  dependencies().remove_dependent_nmethod(nm);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int ber_write_contextual_tag(wStream* s, BYTE tag, int length, BOOL pc)\n{\n\tStream_Write_UINT8(s, (BER_CLASS_CTXT | BER_PC(pc)) | (BER_TAG_MASK & tag));\n\treturn ber_write_length(s, length) + 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void cb_retire(struct i915_active *base)\n{\n\tstruct context_barrier_task *cb = container_of(base, typeof(*cb), base);\n\n\tif (cb->task)\n\t\tcb->task(cb->data);\n\n\ti915_active_fini(&cb->base);\n\tkfree(cb);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "impl_get_app_bus(DBusConnection *bus, DBusMessage *msg, void *data)\n{\nDBusMessage *reply;\n\n  if (bus == spi_global_app_data->bus)\n    spi_atk_add_client (dbus_message_get_sender (msg));\n\nreply = dbus_message_new_method_return(msg);\nif (reply)\n    {\n      const char *retval = (g_getenv (\"AT_SPI_CLIENT\") ?\n                            \"\":\n                            spi_global_app_data->app_bus_addr);\n      dbus_message_append_args(reply, DBUS_TYPE_STRING, &retval, DBUS_TYPE_INVALID);\n    }\n\nreturn reply;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t   u16 selector, int seg)\n {\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n \treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n \t\t\t\t\t X86_TRANSFER_NONE, NULL);\n }",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint32 *wp = (uint32*) cp0;\n\ttmsize_t wc = cc/4;\n\n\tassert((cc%(4*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] -= wp[0]; wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void rgb15tobgr32(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tconst uint16_t *end;\n\n\tuint8_t *d = (uint8_t *)dst;\n\n\tconst uint16_t *s = (const uint16_t *)src;\n\n\tend = s + src_size/2;\n\n\twhile(s < end)\n\n\t{\n\n\t\tregister uint16_t bgr;\n\n\t\tbgr = *s++;\n\n\t\t#ifdef WORDS_BIGENDIAN\n\n\t\t\t*d++ = 0;\n\n\t\t\t*d++ = (bgr&0x1F)<<3;\n\n\t\t\t*d++ = (bgr&0x3E0)>>2;\n\n\t\t\t*d++ = (bgr&0x7C00)>>7;\n\n\t\t#else\n\n\t\t\t*d++ = (bgr&0x7C00)>>7;\n\n\t\t\t*d++ = (bgr&0x3E0)>>2;\n\n\t\t\t*d++ = (bgr&0x1F)<<3;\n\n\t\t\t*d++ = 0;\n\n\t\t#endif\n\n\t}\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int ff_wma_end(AVCodecContext *avctx)\n\n{\n\n    WMACodecContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    for(i = 0; i < s->nb_block_sizes; i++)\n\n        ff_mdct_end(&s->mdct_ctx[i]);\n\n    for(i = 0; i < s->nb_block_sizes; i++)\n\n        av_free(s->windows[i]);\n\n\n\n    if (s->use_exp_vlc) {\n\n        free_vlc(&s->exp_vlc);\n\n    }\n\n    if (s->use_noise_coding) {\n\n        free_vlc(&s->hgain_vlc);\n\n    }\n\n    for(i = 0;i < 2; i++) {\n\n        free_vlc(&s->coef_vlc[i]);\n\n        av_free(s->run_table[i]);\n\n        av_free(s->level_table[i]);\n\n\n    }\n\n\n\n    return 0;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static double Welch(const double x,\n  const ResizeFilter *magick_unused(resize_filter))\n{\n  magick_unreferenced(resize_filter);\n\n  /*\n    Welch parabolic windowing filter.\n  */\n  if (x < 1.0)\n    return(1.0-x*x);\n  return(0.0);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "const AtomicString& Performance::InterfaceName() const {\n  return EventTargetNames::Performance;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void migration_set_outgoing_channel(MigrationState *s,\n\n                                    QIOChannel *ioc)\n\n{\n\n    QEMUFile *f = qemu_fopen_channel_output(ioc);\n\n\n\n    s->to_dst_file = f;\n\n\n\n    migrate_fd_connect(s);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int huff_build12(VLC *vlc, uint8_t *len)\n\n{\n\n    HuffEntry he[4096];\n\n    uint32_t codes[4096];\n\n    uint8_t bits[4096];\n\n    uint16_t syms[4096];\n\n    uint32_t code;\n\n    int i;\n\n\n\n    for (i = 0; i < 4096; i++) {\n\n        he[i].sym = 4095 - i;\n\n        he[i].len = len[i];\n\n        if (len[i] == 0)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n    AV_QSORT(he, 4096, HuffEntry, huff_cmp_len12);\n\n\n\n    code = 1;\n\n    for (i = 4095; i >= 0; i--) {\n\n        codes[i] = code >> (32 - he[i].len);\n\n        bits[i]  = he[i].len;\n\n        syms[i]  = he[i].sym;\n\n        code += 0x80000000u >> (he[i].len - 1);\n\n    }\n\n\n\n    ff_free_vlc(vlc);\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[4095].len, 14), 4096,\n\n                              bits,  sizeof(*bits),  sizeof(*bits),\n\n                              codes, sizeof(*codes), sizeof(*codes),\n\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "addr_policy_get_canonical_entry(addr_policy_t *e)\n{\n  policy_map_ent_t search, *found;\n  if (e->is_canonical)\n    return e;\n\n  search.policy = e;\n  found = HT_FIND(policy_map, &policy_root, &search);\n  if (!found) {\n    found = tor_malloc_zero(sizeof(policy_map_ent_t));\n    found->policy = tor_memdup(e, sizeof(addr_policy_t));\n    found->policy->is_canonical = 1;\n    found->policy->refcnt = 0;\n    HT_INSERT(policy_map, &policy_root, found);\n  }\n\n  tor_assert(!cmp_single_addr_policy(found->policy, e));\n  ++found->policy->refcnt;\n  return found->policy;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int StreamInfoWrapper::luaDynamicMetadata(lua_State* state) {\n  if (dynamic_metadata_wrapper_.get() != nullptr) {\n    dynamic_metadata_wrapper_.pushStack();\n  } else {\n    dynamic_metadata_wrapper_.reset(DynamicMetadataMapWrapper::create(state, *this), true);\n  }\n  return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n{\n\tint\t  ret;\n\n\tstatic uint32_t\t\tlen = 0;\n\tstatic char\t\tlen_buf[4];\n\tstatic int\t\tlen_buf_pos = 0;\n\tstatic char *\t\ttmpbuf = 0;\n\tstatic int\t\ttmpbuf_pos = 0;\n\n\tif (first) {\n\t\tlen_buf_pos = 0;\n\t\treturn -2;\n\t}\n\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n \t\t\t\treturn -2;\n \n \t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\treturn -1;\n \t\t}\n \n \t\tif (ret == 0) {\t\t/* EOF */\n\t\t\t/* Failure to read ANY length just means we're done */\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Otherwise, we got EOF mid-length, and that's\n \t\t\t * a protocol error.\n \t\t\t */\n \t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\treturn -1;\n \t\t}\n \n \t\tlen_buf_pos += ret;\n\t}\n\n\t/* Not done reading the length? */\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\n\t/* We have the complete length */\n\tlen = ntohl(*(uint32_t *)len_buf);\n\n\t/*\n\t * We make sure recvd length is reasonable, allowing for some\n\t * slop in enc overhead, beyond the actual maximum number of\n\t * bytes of decrypted payload.\n \t */\n \tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n \t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\treturn -1;\n \t}\n \n \tif (!tmpbuf) {\n \t\tif ((tmpbuf = malloc(len)) == NULL) {\n \t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\treturn -1;\n \t\t}\n \t}\n \n \tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n \tif (ret == -1) {\n \t\tif (errno == EINTR || errno == EAGAIN)\n \t\t\treturn -2;\n \n \t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\treturn -1;\n \t}\n \n \tif (ret == 0) {\n \t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\treturn -1;\n \t}\n \n \ttmpbuf_pos += ret;\n\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n \t}\n \n \treturn -2;\n }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static char *strip_spaces(char *name)\n{\n    char *p, *q;\n    /* Skip over leading spaces */\n    p = name;\n    while (*p && ossl_isspace(*p))\n        p++;\n    if (!*p)\n        return NULL;\n    q = p + strlen(p) - 1;\n    while ((q != p) && ossl_isspace(*q))\n        q--;\n    if (p != q)\n        q[1] = 0;\n    if (!*p)\n        return NULL;\n    return p;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "AddTrustedKey(keyid_t keyno)\n{\n\t/*\n\t * We need to add a MD5-key in addition to setting the\n\t * trust, because authhavekey() requires type != 0.\n\t */\n\tMD5auth_setkey(keyno, KEYTYPE, NULL, 0);\n\n\tauthtrust(keyno, TRUE);\n\n\treturn;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (JAS_CAST(uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void do_fctiwz (void)\n\n{\n\n    union {\n\n        double d;\n\n        uint64_t i;\n\n    } p;\n\n\n\n    /* XXX: higher bits are not supposed to be significant.\n\n     *      to make tests easier, return the same as a real PowerPC 750 (aka G3)\n\n     */\n\n    p.i = float64_to_int32_round_to_zero(FT0, &env->fp_status);\n\n    p.i |= 0xFFF80000ULL << 32;\n\n    FT0 = p.d;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "Status TensorSliceReader::GetTensor(\n    const string& name, std::unique_ptr<tensorflow::Tensor>* out_tensor) const {\n  DataType type;\n  TensorShape shape;\n  TensorSlice slice;\n  {\n    mutex_lock l(mu_);\n    const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);\n    if (tss == nullptr) {\n      return errors::NotFound(name, \" not found in checkpoint file\");\n    }\n\n    if (tss->Slices().size() > 1) {\n      // TODO(sherrym): Support multi-slice checkpoints.\n      return errors::Unimplemented(\"Sliced checkpoints are not supported\");\n    }\n\n    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor(type, shape));\n  bool success = false;\n\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\\n                            t->flat<EnumToDataType<dt>::Type>().data()); \\\n    break;\n\n  switch (type) {\n    READER_COPY(DT_FLOAT);\n    READER_COPY(DT_DOUBLE);\n    READER_COPY(DT_INT32);\n    READER_COPY(DT_UINT8);\n    READER_COPY(DT_INT16);\n    READER_COPY(DT_INT8);\n    READER_COPY(DT_INT64);\n    READER_COPY(DT_STRING);\n    default:\n      return errors::Unimplemented(\"Data type not supported\");\n  }\n#undef READER_COPY\n\n  if (!success) {\n    return errors::NotFound(name, \" not found in checkpoint file\");\n  }\n  std::swap(*out_tensor, t);\n\n  return Status::OK();\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "u64 gf_sys_clock_high_res()\n{\n\tstruct timeval now;\n\tgettimeofday(&now, NULL);\n\treturn (now.tv_sec)*1000000 + (now.tv_usec) - sys_start_time_hr;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "layer_resize(int layer, int x_size, int y_size)\n{\n\tint                 old_height;\n\tint                 old_width;\n\tstruct map_tile*    tile;\n\tint                 tile_width;\n\tint                 tile_height;\n \tstruct map_tile*    tilemap;\n \tstruct map_trigger* trigger;\n \tstruct map_zone*    zone;\n \n \tint x, y, i;\n \n\told_width = s_map->layers[layer].width;\n\told_height = s_map->layers[layer].height;\n \n\tif (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))\n \t\treturn false;\n \tfor (x = 0; x < x_size; ++x) {\n \t\tfor (y = 0; y < y_size; ++y) {\n\t\t\tif (x < old_width && y < old_height) {\n\t\t\t\ttilemap[x + y * x_size] = s_map->layers[layer].tilemap[x + y * old_width];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttile = &tilemap[x + y * x_size];\n\t\t\t\ttile->frames_left = tileset_get_delay(s_map->tileset, 0);\n\t\t\t\ttile->tile_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(s_map->layers[layer].tilemap);\n\ts_map->layers[layer].tilemap = tilemap;\n\ts_map->layers[layer].width = x_size;\n\ts_map->layers[layer].height = y_size;\n\n\ttileset_get_size(s_map->tileset, &tile_width, &tile_height);\n\ts_map->width = 0;\n\ts_map->height = 0;\n\tfor (i = 0; i < s_map->num_layers; ++i) {\n\t\tif (!s_map->layers[i].is_parallax) {\n\t\t\ts_map->width = fmax(s_map->width, s_map->layers[i].width * tile_width);\n\t\t\ts_map->height = fmax(s_map->height, s_map->layers[i].height * tile_height);\n\t\t}\n\t}\n\n\tfor (i = (int)vector_len(s_map->zones) - 1; i >= 0; --i) {\n\t\tzone = vector_get(s_map->zones, i);\n\t\tif (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height)\n\t\t\tvector_remove(s_map->zones, i);\n\t\telse {\n\t\t\tif (zone->bounds.x2 > s_map->width)\n\t\t\t\tzone->bounds.x2 = s_map->width;\n\t\t\tif (zone->bounds.y2 > s_map->height)\n\t\t\t\tzone->bounds.y2 = s_map->height;\n\t\t}\n\t}\n\tfor (i = (int)vector_len(s_map->triggers) - 1; i >= 0; --i) {\n\t\ttrigger = vector_get(s_map->triggers, i);\n\t\tif (trigger->x >= s_map->width || trigger->y >= s_map->height)\n\t\t\tvector_remove(s_map->triggers, i);\n\t}\n\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "parse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\n\t/* Set the default value for *ret_username */\n\t*ret_username = NULL;\n\n\t/*\n\t * Set the initial value for username - this is a buffer holds\n\t * the user name.\n\t */\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\n\t/*\n\t * The user_input is guaranteed to be terminated by a null character.\n\t */\n\tptr = user_input;\n\n\t/* Skip all the leading whitespaces if there are any. */\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\n\tif (*ptr == '\\0') {\n\t\t/*\n\t\t * We should never get here since the user_input we got\n\t\t * in pam_get_user() is not all whitespaces nor just \"\\0\".\n\t\t */\n\t\treturn (PAM_BUF_ERR);\n\t}\n\n\t/*\n\t * username will be the first string we get from user_input\n\t * - we skip leading whitespaces and ignore trailing whitespaces\n\t */\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t'))\n\t\t\tbreak;\n\t\telse {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\n\t/* ret_username will be freed in pam_get_user(). */\n\tif ((*ret_username = malloc(index + 1)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\t(void) strcpy(*ret_username, username);\n\treturn (PAM_SUCCESS);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n*/\n */\n        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n        if (ctxt) {\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int64_t pva_read_timestamp(struct AVFormatContext *s, int stream_index,\n\n                                          int64_t *pos, int64_t pos_limit) {\n\n    ByteIOContext *pb = s->pb;\n\n    PVAContext *pvactx = s->priv_data;\n\n    int length, streamid;\n\n    int64_t res;\n\n\n\n    pos_limit = FFMIN(*pos+PVA_MAX_PAYLOAD_LENGTH*8, (uint64_t)*pos+pos_limit);\n\n\n\n    while (*pos < pos_limit) {\n\n        res = AV_NOPTS_VALUE;\n\n        url_fseek(pb, *pos, SEEK_SET);\n\n\n\n        pvactx->continue_pes = 0;\n\n        if (read_part_of_packet(s, &res, &length, &streamid, 0)) {\n\n            (*pos)++;\n\n            continue;\n\n        }\n\n        if (streamid - 1 != stream_index || res == AV_NOPTS_VALUE) {\n\n            *pos = url_ftell(pb) + length;\n\n            continue;\n\n        }\n\n        break;\n\n    }\n\n\n\n    pvactx->continue_pes = 0;\n\n    return res;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int crypto_has_alg(const char *name, u32 type, u32 mask)\n{\n\tint ret = 0;\n\tstruct crypto_alg *alg = crypto_alg_mod_lookup(name, type, mask);\n\n\tif (!IS_ERR(alg)) {\n\t\tcrypto_mod_put(alg);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "__releases(rcu)\n{\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\tif (likely(state->im != NULL)) {\n\t\tspin_unlock_bh(&state->im->lock);\n\t\tstate->im = NULL;\n\t}\n\tstate->idev = NULL;\n\tstate->dev = NULL;\n\trcu_read_unlock();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "virgl_cmd_get_capset_info(VuGpu *g,\n                          struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_get_capset_info info;\n    struct virtio_gpu_resp_capset_info resp;\n\n    VUGPU_FILL_CMD(info);\n\n    if (info.capset_index == 0) {\n        resp.capset_id = VIRTIO_GPU_CAPSET_VIRGL;\n        virgl_renderer_get_cap_set(resp.capset_id,\n                                   &resp.capset_max_version,\n                                   &resp.capset_max_size);\n    } else if (info.capset_index == 1) {\n        resp.capset_id = VIRTIO_GPU_CAPSET_VIRGL2;\n        virgl_renderer_get_cap_set(resp.capset_id,\n                                   &resp.capset_max_version,\n                                   &resp.capset_max_size);\n    } else {\n        resp.capset_max_version = 0;\n        resp.capset_max_size = 0;\n    }\n    resp.hdr.type = VIRTIO_GPU_RESP_OK_CAPSET_INFO;\n    vg_ctrl_response(g, cmd, &resp.hdr, sizeof(resp));\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int main(int argc, char **argv)\n{\n    g_test_init(&argc, &argv, NULL);\n\n    qtest_add_func(\"fuzz/lsi53c895a/lsi_do_dma_empty_queue\",\n                   test_lsi_do_dma_empty_queue);\n\n    return g_test_run();\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "png_handle_as_unknown(png_structp png_ptr, png_bytep chunk_name)\n{\n   /* Check chunk_name and return \"keep\" value if it's on the list, else 0 */\n   int i;\n   png_bytep p;\n   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list<=0)\n      return 0;\n   p = png_ptr->chunk_list + png_ptr->num_chunk_list*5 - 5;\n   for (i = png_ptr->num_chunk_list; i; i--, p -= 5)\n      if (!png_memcmp(chunk_name, p, 4))\n        return ((int)*(p + 4));\n   return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int ntop_interface_reset_counters(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool only_drops = true;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TBOOLEAN)\n    only_drops = lua_toboolean(vm, 1) ? true : false;\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  ntop_interface->checkPointCounters(only_drops);\n  return(CONST_LUA_OK);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void AudioHandler::SetNodeType(NodeType type) {\n  DCHECK_EQ(node_type_, kNodeTypeUnknown);\n  DCHECK_NE(type, kNodeTypeUnknown);\n  DCHECK_NE(type, kNodeTypeEnd);\n\n  node_type_ = type;\n\n#if DEBUG_AUDIONODE_REFERENCES\n  ++node_count_[type];\n  fprintf(stderr, \"[%16p]: %16p: %2d: AudioHandler::AudioHandler [%3d]\\n\",\n          Context(), this, GetNodeType(), node_count_[GetNodeType()]);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int nfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tret = nfs_writepage_locked(page, wbc);\n\tunlock_page(page);\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void dec_load(DisasContext *dc)\n\n{\n\n    TCGv t, *addr;\n\n    unsigned int size;\n\n\n\n    size = 1 << (dc->opcode & 3);\n\n\n\n\n\n\n\n\n\n    LOG_DIS(\"l %x %d\\n\", dc->opcode, size);\n\n    t_sync_flags(dc);\n\n    addr = compute_ldst_addr(dc, &t);\n\n\n\n    /* If we get a fault on a dslot, the jmpstate better be in sync.  */\n\n    sync_jmpstate(dc);\n\n\n\n    /* Verify alignment if needed.  */\n\n    if ((dc->env->pvr.regs[2] & PVR2_UNALIGNED_EXC_MASK) && size > 1) {\n\n        gen_helper_memalign(*addr, tcg_const_tl(dc->rd),\n\n                            tcg_const_tl(0), tcg_const_tl(size - 1));\n\n\n\n\n    if (dc->rd) {\n\n        gen_load(dc, cpu_R[dc->rd], *addr, size);\n\n    } else {\n\n        gen_load(dc, env_imm, *addr, size);\n\n\n\n\n    if (addr == &t)\n\n        tcg_temp_free(t);\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool kvm_para_available(void)\n{\n\treturn kvm_cpuid_base() != 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void CameraService::playSound(sound_kind kind) {\n    LOG1(\"playSound(%d)\", kind);\n Mutex::Autolock lock(mSoundLock);\n    sp<MediaPlayer> player = mSoundPlayer[kind];\n if (player != 0) {\n        player->seekTo(0);\n        player->start();\n }\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static ssize_t queue_poll_delay_show(struct request_queue *q, char *page)\n{\n\tint val;\n\n\tif (q->poll_nsec == BLK_MQ_POLL_CLASSIC)\n\t\tval = BLK_MQ_POLL_CLASSIC;\n\telse\n\t\tval = q->poll_nsec / 1000;\n\n\treturn sprintf(page, \"%d\\n\", val);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "v8::Persistent<v8::FunctionTemplate>* V8ClassIndex::GetCache(V8WrapperType type)\n{\n    switch (type) {\n#define MAKE_CASE(type, name)\\\n    case V8ClassIndex::type: return &name##_cache_;\n    ALL_WRAPPER_TYPES(MAKE_CASE)\n#undef MAKE_CASE\n    default:\n        ASSERT(false);\n        return NULL;\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline u64 xgetbv(u32 index)\n{\n\tu32 eax, edx;\n\n\tasm volatile(\".byte 0x0f,0x01,0xd0\" /* xgetbv */\n\t\t     : \"=a\" (eax), \"=d\" (edx)\n\t\t     : \"c\" (index));\n\treturn eax + ((u64)edx << 32);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\n\t/*\n\t * Ensure irq/preemption can't change debugctl in between.\n\t * Note also that both TIF_BLOCKSTEP and debugctl should\n\t * be changed atomically wrt preemption.\n\t * FIXME: this means that set/clear TIF_BLOCKSTEP is simply\n\t * wrong if task != current, SIGKILL can wakeup the stopped\n\t * tracee and set/clear can play with the running task, this\n\t * can confuse the next __switch_to_xtra().\n\t */\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}\n\tif (task == current)\n\t\tupdate_debugctlmsr(debugctl);\n\tlocal_irq_enable();\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int64_t OutputFile::readImpl(char* /*buffer*/, int64_t /*length*/) {\n  raise_warning(\"cannot read from a php://output stream\");\n  return -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "  bool has_capacity() const TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    return capacity_ > 0;\n  }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n {\n\tstruct request *rq = tags->rqs[tag];\n\t/* mq_ctx of flush rq is always cloned from the corresponding req */\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n }",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "get_schema_version(const char *name)\n{\n    int lpc = 0;\n\n    if(name == NULL) {\n        name = \"none\";\n    }\n    for (; lpc < xml_schema_max; lpc++) {\n        if (safe_str_eq(name, known_schemas[lpc].name)) {\n            return lpc;\n        }\n    }\n    return -1;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void pfkey_sock_destruct(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tpfkey_terminate_dump(pfkey_sk(sk));\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive pfkey socket: %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\n\tatomic_dec(&net_pfkey->socks_nr);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void mptsas_scsi_uninit(PCIDevice *dev)\n{\n    MPTSASState *s = MPT_SAS(dev);\n\n    qemu_bh_delete(s->request_bh);\n    if (s->msi_in_use) {\n        msi_uninit(dev);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n\n    wpc->version_five = 1;      // just having this block signals version 5.0\n\n    wpc->file_format = wpc->config.qmode = wpc->channel_layout = 0;\n\n    if (wpc->channel_reordering) {\n        free (wpc->channel_reordering);\n        wpc->channel_reordering = NULL;\n    }\n\n    // if there's any data, the first two bytes are file_format and qmode flags\n\n    if (bytecnt) {\n        wpc->file_format = *byteptr++;\n        wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n        bytecnt -= 2;\n\n        // another byte indicates a channel layout\n\n        if (bytecnt) {\n            int nchans, i;\n\n            wpc->channel_layout = (int32_t) *byteptr++ << 16;\n            bytecnt--;\n\n            // another byte means we have a channel count for the layout and maybe a reordering\n\n            if (bytecnt) {\n                wpc->channel_layout += nchans = *byteptr++;\n                bytecnt--;\n\n                // any more means there's a reordering string\n\n                if (bytecnt) {\n                    if (bytecnt > nchans)\n                        return FALSE;\n\n                    wpc->channel_reordering = malloc (nchans);\n\n                    // note that redundant reordering info is not stored, so we fill in the rest\n\n                    if (wpc->channel_reordering) {\n                        for (i = 0; i < nchans; ++i)\n                            if (bytecnt) {\n                                wpc->channel_reordering [i] = *byteptr++;\n                                bytecnt--;\n                            }\n                            else\n                                wpc->channel_reordering [i] = i;\n                    }\n                }\n            }\n            else\n                wpc->channel_layout += wpc->config.num_channels;\n        }\n    }\n\n    return TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int nested_vmx_failInvalid(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_PF | X86_EFLAGS_AF | X86_EFLAGS_ZF |\n\t\t\t    X86_EFLAGS_SF | X86_EFLAGS_OF))\n\t\t\t| X86_EFLAGS_CF);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "xfs_fs_sync_fs(\n\tstruct super_block\t*sb,\n\tint\t\t\twait)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\t/*\n\t * Doing anything during the async pass would be counterproductive.\n\t */\n\tif (!wait)\n\t\treturn 0;\n\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\tif (laptop_mode) {\n\t\t/*\n\t\t * The disk must be active because we're syncing.\n\t\t * We schedule log work now (now that the disk is\n\t\t * active) instead of later (when it might not be).\n\t\t */\n\t\tflush_delayed_work(&mp->m_log->l_work);\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline int get_symbol(RangeCoder *c, uint8_t *state, int is_signed){\n\n    if(get_rac(c, state+0))\n\n        return 0;\n\n    else{\n\n        int i, e, a;\n\n        e= 0;\n\n        while(get_rac(c, state+1 + e)){ //1..10\n\n            e++;\n\n        }\n\n        assert(e<=9);\n\n\n\n        a= 1;\n\n        for(i=e-1; i>=0; i--){\n\n            a += a + get_rac(c, state+22 + i); //22..31\n\n        }\n\n\n\n        if(is_signed && get_rac(c, state+11 + e)) //11..21\n\n            return -a;\n\n        else\n\n            return a;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void pc_dimm_unplug(HotplugHandler *hotplug_dev,\n\n                           DeviceState *dev, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(hotplug_dev);\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);\n\n    MemoryRegion *mr = ddc->get_memory_region(dimm);\n\n    HotplugHandlerClass *hhc;\n\n    Error *local_err = NULL;\n\n\n\n    hhc = HOTPLUG_HANDLER_GET_CLASS(pcms->acpi_dev);\n\n    hhc->unplug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, &local_err);\n\n\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    pc_dimm_memory_unplug(dev, &pcms->hotplug_memory, mr);\n\n    object_unparent(OBJECT(dev));\n\n\n\n out:\n\n    error_propagate(errp, local_err);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void vrend_bind_vertex_elements_state(struct vrend_context *ctx,\n                                      uint32_t handle)\n{\n   struct vrend_vertex_element_array *v;\n\n   if (!handle) {\n      ctx->sub->ve = NULL;\n      return;\n   }\n   v = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_VERTEX_ELEMENTS);\n   if (!v) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_HANDLE, handle);\n      return;\n   }\n\n   if (ctx->sub->ve != v)\n      ctx->sub->vbo_dirty = true;\n   ctx->sub->ve = v;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline void pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tbuf->ops->get(pipe, buf);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void ServerWrapper::Close(int connection_id) {\n  server_->Close(connection_id);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void flush_stack(struct sock **stack, unsigned int count,\n\t\t\tstruct sk_buff *skb, unsigned int final)\n{\n\tunsigned int i;\n\tstruct sock *sk;\n\tstruct sk_buff *skb1;\n\n\tfor (i = 0; i < count; i++) {\n\t\tskb1 = (i == final) ? skb : skb_clone(skb, GFP_ATOMIC);\n\n\t\tsk = stack[i];\n\t\tif (skb1) {\n\t\t\tbh_lock_sock(sk);\n\t\t\tif (!sock_owned_by_user(sk))\n\t\t\t\tudpv6_queue_rcv_skb(sk, skb1);\n\t\t\telse if (sk_add_backlog(sk, skb1)) {\n\t\t\t\tkfree_skb(skb1);\n\t\t\t\tbh_unlock_sock(sk);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\ndrop:\n\t\tatomic_inc(&sk->sk_drops);\n\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\tUDP_MIB_RCVBUFERRORS, IS_UDPLITE(sk));\n\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\tUDP_MIB_INERRORS, IS_UDPLITE(sk));\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void __exit aac_exit(void)\n{\n\tif (aac_cfg_major > -1)\n\t\tunregister_chrdev(aac_cfg_major, \"aac\");\n\tpci_unregister_driver(&aac_pci_driver);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "MockOverscrollController* MockOverscrollController::Create(\n    RenderWidgetHostView* rwhv) {\n  std::unique_ptr<MockOverscrollControllerImpl> mock =\n      std::make_unique<MockOverscrollControllerImpl>();\n  MockOverscrollController* raw_mock = mock.get();\n\n  RenderWidgetHostViewAura* rwhva =\n      static_cast<RenderWidgetHostViewAura*>(rwhv);\n  rwhva->SetOverscrollControllerForTesting(std::move(mock));\n\n  return raw_mock;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "git_commit_list *git_commit_list_insert(git_commit_list_node *item, git_commit_list **list_p)\n{\n\tgit_commit_list *new_list = git__malloc(sizeof(git_commit_list));\n\tif (new_list != NULL) {\n\t\tnew_list->item = item;\n\t\tnew_list->next = *list_p;\n\t}\n\t*list_p = new_list;\n\treturn new_list;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "bool AuthenticatorBlePinEntrySheetModel::IsAcceptButtonEnabled() const {\n  return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void metx_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tif (ptr->config) gf_isom_box_del((GF_Box *)ptr->config);\n\tgf_free(ptr);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_False;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "cleanup_backslash_2(wchar_t *p)\n{\n\n\t/* Convert a path-separator from '\\' to  '/' */\n\twhile (*p != L'\\0') {\n\t\tif (*p == L'\\\\')\n\t\t\t*p = L'/';\n\t\tp++;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "Item_int::Item_int(const char *str_arg, uint length)\n{\n  char *end_ptr= (char*) str_arg + length;\n  int error;\n  value= my_strtoll10(str_arg, &end_ptr, &error);\n  max_length= (uint) (end_ptr - str_arg);\n  name= (char*) str_arg;\n  fixed= 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void Document::didRemoveText(Node* text, unsigned offset, unsigned length)\n{\n    for (Range* range : m_ranges)\n        range->didRemoveText(text, offset, length);\n\n    m_markers->removeMarkers(text, offset, length);\n    m_markers->shiftMarkers(text, offset + length, 0 - length);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int ptrace_setxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct thread_info *ti = task_thread_info(child);\n\tstruct pt_regs *regs = task_pt_regs(child);\n\telf_xtregs_t *xtregs = uregs;\n\tint ret = 0;\n\n#if XTENSA_HAVE_COPROCESSORS\n\t/* Flush all coprocessors before we overwrite them. */\n\tcoprocessor_flush_all(ti);\n\tcoprocessor_release_all(ti);\n\n\tret |= __copy_from_user(&ti->xtregs_cp, &xtregs->cp0, \n\t\t\t\tsizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_from_user(&regs->xtregs_opt, &xtregs->opt,\n\t\t\t\tsizeof(xtregs->opt));\n\tret |= __copy_from_user(&ti->xtregs_user, &xtregs->user,\n\t\t\t\tsizeof(xtregs->user));\n\n\treturn ret ? -EFAULT : 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void kvm_init_msr_list(void)\n{\n\tu32 dummy[2];\n\tunsigned i, j;\n\n\t/* skip the first msrs in the list. KVM-specific */\n\tfor (i = j = KVM_SAVE_MSRS_BEGIN; i < ARRAY_SIZE(msrs_to_save); i++) {\n\t\tif (rdmsr_safe(msrs_to_save[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\t\tif (j < i)\n\t\t\tmsrs_to_save[j] = msrs_to_save[i];\n\t\tj++;\n\t}\n\tnum_msrs_to_save = j;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "utf8_str (const gchar *utf8,\n          gchar       *buf)\n{\n  char_str (g_utf8_get_char (utf8), buf);\n  return buf;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int bnx2x_cnic_ctl_send_bh(struct bnx2x *bp, struct cnic_ctl_info *ctl)\n{\n\tstruct cnic_ops *c_ops;\n\tint rc = 0;\n\n\trcu_read_lock();\n\tc_ops = rcu_dereference(bp->cnic_ops);\n\tif (c_ops)\n\t\trc = c_ops->cnic_ctl(bp->cnic_data, ctl);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "PHP_FUNCTION(imagewbmp)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, \"WBMP\", gdImageWBMPCtx);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void qemu_input_queue_rel(QemuConsole *src, InputAxis axis, int value)\n{\n    InputEvent *evt;\n    evt = qemu_input_event_new_move(INPUT_EVENT_KIND_REL, axis, value);\n    qemu_input_event_send(src, evt);\n    qapi_free_InputEvent(evt);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "ieee802154_match_sock(__le64 hw_addr, __le16 pan_id, __le16 short_addr,\n\t\t      struct dgram_sock *ro)\n{\n\tif (!ro->bound)\n\t\treturn true;\n\n\tif (ro->src_addr.mode == IEEE802154_ADDR_LONG &&\n\t    hw_addr == ro->src_addr.extended_addr)\n\t\treturn true;\n\n\tif (ro->src_addr.mode == IEEE802154_ADDR_SHORT &&\n\t    pan_id == ro->src_addr.pan_id &&\n\t    short_addr == ro->src_addr.short_addr)\n\t\treturn true;\n\n\treturn false;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\n\twait_for_completion(&fcomp.comp);\n\n\t/* Fill the fc_host_statistics structure */\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\n\tkfree(fcstats);\n\treturn hstats;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "PHP_FUNCTION(pcntl_alarm)\n{\n\tlong seconds;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &seconds) == FAILURE)\n\t\treturn;\n\t\n\tRETURN_LONG ((long) alarm(seconds));\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void RootWindow::PostNativeEvent(const base::NativeEvent& native_event) {\n#if !defined(OS_MACOSX)\n  host_->PostNativeEvent(native_event);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "//! Compute the logarithm of each pixel value \\newinstance.\n    CImg<Tfloat> get_log() const {\n      return CImg<Tfloat>(*this,false).log();",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void ff_h264_direct_dist_scale_factor(H264Context * const h){\n\n    const int poc = h->cur_pic_ptr->field_poc[h->picture_structure == PICT_BOTTOM_FIELD];\n\n    const int poc1 = h->ref_list[1][0].poc;\n\n    int i, field;\n\n\n\n    if (FRAME_MBAFF(h))\n\n        for (field = 0; field < 2; field++){\n\n            const int poc  = h->cur_pic_ptr->field_poc[field];\n\n            const int poc1 = h->ref_list[1][0].field_poc[field];\n\n            for (i = 0; i < 2 * h->ref_count[0]; i++)\n\n                h->dist_scale_factor_field[field][i^field] =\n\n                    get_scale_factor(h, poc, poc1, i+16);\n\n        }\n\n\n\n    for (i = 0; i < h->ref_count[0]; i++){\n\n        h->dist_scale_factor[i] = get_scale_factor(h, poc, poc1, i);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int i2r_pci(X509V3_EXT_METHOD *method, PROXY_CERT_INFO_EXTENSION *pci,\n                   BIO *out, int indent)\n{\n    BIO_printf(out, \"%*sPath Length Constraint: \", indent, \"\");\n    if (pci->pcPathLengthConstraint)\n        i2a_ASN1_INTEGER(out, pci->pcPathLengthConstraint);\n    else\n        BIO_printf(out, \"infinite\");\n    BIO_puts(out, \"\\n\");\n    BIO_printf(out, \"%*sPolicy Language: \", indent, \"\");\n    i2a_ASN1_OBJECT(out, pci->proxyPolicy->policyLanguage);\n    BIO_puts(out, \"\\n\");\n    if (pci->proxyPolicy->policy && pci->proxyPolicy->policy->data)\n        BIO_printf(out, \"%*sPolicy Text: %s\\n\", indent, \"\",\n                   pci->proxyPolicy->policy->data);\n    return 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\tev->type   = LLC_SAP_EV_TYPE_PDU;\n\tev->reason = 0;\n\tskb->sk = sk;\n\tllc_sap_state_process(sap, skb);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int usb_wacom_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBWacomState *s = (USBWacomState *) dev;\n\n    int ret = 0;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_IN:\n\n        if (p->devep == 1) {\n\n            if (!(s->changed || s->idle))\n\n                return USB_RET_NAK;\n\n            s->changed = 0;\n\n            if (s->mode == WACOM_MODE_HID)\n\n                ret = usb_mouse_poll(s, p->data, p->len);\n\n            else if (s->mode == WACOM_MODE_WACOM)\n\n                ret = usb_wacom_poll(s, p->data, p->len);\n\n            break;\n\n        }\n\n        /* Fall through.  */\n\n    case USB_TOKEN_OUT:\n\n    default:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static struct clock_source *dce120_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(*clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\t\t     regs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int reqs_reencrypt_online(uint32_t reqs)\n{\n\treturn reqs & CRYPT_REQUIREMENT_ONLINE_REENCRYPT;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void ClearLineRegion(int from, int to)\n{\n\tint y = curr->w_y;\n\tLClearArea(&curr->w_layer, from, y, to, y, curr->w_rend.colorbg, 1);\n\tMClearArea(curr, from, y, to, y, curr->w_rend.colorbg);\n\tRestorePosRendition();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void *alloc_one_pg_vec_page(unsigned long order)\n{\n\tvoid *buffer;\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_COMP | __GFP_ZERO |\n\t\t\t  __GFP_NOWARN | __GFP_NORETRY;\n\n\tbuffer = (void *)__get_free_pages(gfp_flags, order);\n\tif (buffer != NULL)\n\t\treturn buffer;\n\n\tbuffer = vzalloc((1 << order) * PAGE_SIZE);\n\tif (buffer != NULL)\n\t\treturn buffer;\n\n\tgfp_flags &= ~__GFP_NORETRY;\n\treturn (void *)__get_free_pages(gfp_flags, order);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "bgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)\n{\n  bgp_notify_send (peer, \n\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t   BGP_NOTIFY_OPEN_AUTH_FAILURE); \n  return -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    // No need to create native event if we do not need to send reply.\n    event = CreateEvent(isolate);\n  }\n\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  // Should always set frameId even when callback is null.\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void RenderFrameSubmissionObserver::OnRenderFrameMetadataChanged() {\n  Quit();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tdemangled[strlen(demangled) - 1] = 0;\n\treturn demangled;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "_dbus_close_socket (int               fd,\n                    DBusError        *error)\n{\n  return _dbus_close (fd, error);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "TEST_F(Http1ServerConnectionImplTest, ManyTrailersIgnored) {\n  // Send a request with 101 headers.\n  testTrailersExceedLimit(createHeaderFragment(101), false);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int kvm_dirty_pages_log_change(target_phys_addr_t phys_addr, target_phys_addr_t end_addr,\n\n                                      unsigned flags,\n\n                                      unsigned mask)\n\n{\n\n    KVMState *s = kvm_state;\n\n    KVMSlot *mem = kvm_lookup_slot(s, phys_addr);\n\n    if (mem == NULL)  {\n\n            dprintf(\"invalid parameters %llx-%llx\\n\", phys_addr, end_addr);\n\n            return -EINVAL;\n\n    }\n\n\n\n    flags = (mem->flags & ~mask) | flags;\n\n    /* Nothing changed, no need to issue ioctl */\n\n    if (flags == mem->flags)\n\n            return 0;\n\n\n\n    mem->flags = flags;\n\n\n\n    return kvm_set_user_memory_region(s, mem);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void CustomButton::SetAnimationDuration(int duration) {\n  hover_animation_->SetSlideDuration(duration);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void ElectronBrowserHandlerImpl::Create(\n    content::RenderFrameHost* frame_host,\n    mojo::PendingAssociatedReceiver<mojom::ElectronBrowser> receiver) {\n  new ElectronBrowserHandlerImpl(frame_host, std::move(receiver));\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int mov_read_chan(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n\n\n    if (atom.size < 16)\n\n        return 0;\n\n\n\n    ff_mov_read_chan(c->fc, st, atom.size - 4);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void option_export_pack_edges(const char *edges)\n{\n\tif (pack_edges)\n\t\tfclose(pack_edges);\n\tpack_edges = fopen(edges, \"a\");\n\tif (!pack_edges)\n\t\tdie_errno(\"Cannot open '%s'\", edges);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "\nstatic inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\tino == EXT4_USR_QUOTA_INO ||\n\t\tino == EXT4_GRP_QUOTA_INO ||\n\t\tino == EXT4_BOOT_LOADER_INO ||\n\t\tino == EXT4_JOURNAL_INO ||\n\t\tino == EXT4_RESIZE_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void t_cpp_generator::generate_serialize_list_element(ofstream& out, t_list* tlist, string iter) {\n  t_field efield(tlist->get_elem_type(), \"(*\" + iter + \")\");\n  generate_serialize_field(out, &efield, \"\");\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int enumgrp(int index, char *group) {\n   if (index < n_lb_config) {\n      strcpy(group, lb_config[index].section_name);\n      return 1;\n   }\n\n   return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void fw_cfg_add_i16(FWCfgState *s, uint16_t key, uint16_t value)\n\n{\n\n    uint16_t *copy;\n\n\n\n    copy = g_malloc(sizeof(value));\n\n    *copy = cpu_to_le16(value);\n\n    fw_cfg_add_bytes(s, key, (uint8_t *)copy, sizeof(value));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void PaintLayerScrollableArea::DeregisterForAnimation() {\n  if (HasBeenDisposed())\n    return;\n  if (LocalFrame* frame = GetLayoutBox()->GetFrame()) {\n    if (LocalFrameView* frame_view = frame->View())\n      frame_view->RemoveAnimatingScrollableArea(this);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline int unserialize_allowed_class(zend_string *class_name, HashTable *classes)\n{\n\tzend_string *lcname;\n\tint res;\n\tALLOCA_FLAG(use_heap)\n\n\tif(classes == NULL) {\n\t\treturn 1;\n\t}\n\tif(!zend_hash_num_elements(classes)) {\n\t\treturn 0;\n\t}\n\n\tZSTR_ALLOCA_ALLOC(lcname, ZSTR_LEN(class_name), use_heap);\n\tzend_str_tolower_copy(ZSTR_VAL(lcname), ZSTR_VAL(class_name), ZSTR_LEN(class_name));\n\tres = zend_hash_exists(classes, lcname);\n\tZSTR_ALLOCA_FREE(lcname, use_heap);\n\treturn res;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "    int MemIo::seek(int64 offset, Position pos )\n    {\n        int64 newIdx = 0;\n\n        switch (pos) {\n            case BasicIo::cur:\n                newIdx = p_->idx_ + offset;\n                break;\n            case BasicIo::beg:\n                newIdx = offset;\n                break;\n            case BasicIo::end:\n                newIdx = p_->size_ + offset;\n                break;\n        }\n\n        if (newIdx < 0)\n            return 1;\n\n        p_->idx_ = static_cast<long>(newIdx);   //not very sure about this. need more test!!    - note by Shawn  fly2xj@gmail.com //TODO\n        p_->eof_ = false;\n        return 0;\n    }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "ssize_t tpm_store_cancel(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tif (chip == NULL)\n\t\treturn 0;\n\n\tchip->vendor.cancel(chip);\n\treturn count;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int cli_bytecode_context_getresult_file(struct cli_bc_ctx *ctx, char **tempfilename)\n{\n    int fd;\n    *tempfilename = ctx->tempfile;\n    fd  = ctx->outfd;\n    ctx->tempfile = NULL;\n    ctx->outfd = 0;\n    return fd;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "cpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\n\t*len = sizeof(*addr);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "check_offset(char *memory, int total_size, char *name, void *offset, int size)\n{\n\tint need_size = (int) ((char *) offset - memory + size);\n\n\t/*debug(\"check_offset: size=%x vs %x offset=%x size=%x\\n\",\n\t\tneed_size, total_size, (char *) offset - memory, size);*/\n\n\tif (need_size < 0 || need_size > total_size) {\n\t\twarn(_(\"%s: premature end\"), name);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void WebURLLoaderImpl::Context::SetDefersLoading(bool value) {\n  if (bridge_)\n    bridge_->SetDefersLoading(value);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int64_t mmsh_seek(URLContext *h, int64_t pos, int whence)\n\n{\n\n    MMSHContext *mmsh = h->priv_data;\n\n    MMSContext *mms   = &mmsh->mms;\n\n\n\n    if(pos == 0 && whence == SEEK_CUR)\n\n        return mms->asf_header_read_size + mms->remaining_in_len + mmsh->chunk_seq * mms->asf_packet_len;\n\n    return AVERROR(ENOSYS);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void dvb_usb_device_exit(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = \"generic DVB-USB module\";\n\n\tusb_set_intfdata(intf, NULL);\n\tif (d != NULL && d->desc != NULL) {\n\t\tname = d->desc->name;\n\t\tdvb_usb_exit(d);\n\t}\n\tinfo(\"%s successfully deinitialized and disconnected.\", name);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void redo_bmc_reg(struct work_struct *work)\n{\n\tstruct ipmi_smi *intf = container_of(work, struct ipmi_smi,\n\t\t\t\t\t     bmc_reg_work);\n\n\tif (!intf->in_shutdown)\n\t\tbmc_get_device_id(intf, NULL, NULL, NULL, NULL);\n\n\tkref_put(&intf->refcount, intf_free);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "_gcry_mpi_point_free_parts (mpi_point_t p)\n{\n  mpi_free (p->x); p->x = NULL;\n  mpi_free (p->y); p->y = NULL;\n  mpi_free (p->z); p->z = NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static long get_nr_dentry(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_dentry, i);\n\treturn sum < 0 ? 0 : sum;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void qemu_tcg_init_cpu_signals(void)\n\n{\n\n#ifdef CONFIG_IOTHREAD\n\n    sigset_t set;\n\n    struct sigaction sigact;\n\n\n\n    memset(&sigact, 0, sizeof(sigact));\n\n    sigact.sa_handler = cpu_signal;\n\n    sigaction(SIG_IPI, &sigact, NULL);\n\n\n\n    sigemptyset(&set);\n\n    sigaddset(&set, SIG_IPI);\n\n    pthread_sigmask(SIG_UNBLOCK, &set, NULL);\n\n#endif\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "g_file_enumerate_children_finish (GFile         *file,\n                                  GAsyncResult  *res,\n                                  GError       **error)\n{\n  GFileIface *iface;\n\n  g_return_val_if_fail (G_IS_FILE (file), NULL);\n  g_return_val_if_fail (G_IS_ASYNC_RESULT (res), NULL);\n\n  if (g_async_result_legacy_propagate_error (res, error))\n    return NULL;\n\n  iface = G_FILE_GET_IFACE (file);\n  return (* iface->enumerate_children_finish) (file, res, error);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void virtio_mmio_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = virtio_mmio_realizefn;\n\n    dc->reset = virtio_mmio_reset;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->props = virtio_mmio_properties;\n\n\n\n\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "virtio_gpu_find_resource(VirtIOGPU *g, uint32_t resource_id)\n{\n    struct virtio_gpu_simple_resource *res;\n\n    QTAILQ_FOREACH(res, &g->reslist, next) {\n        if (res->resource_id == resource_id) {\n            return res;\n        }\n    }\n    return NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "unsuppress_huff_table (JPEGState* sp, int tblno)\n{\n\tJHUFF_TBL* htbl;\n\n\tif ((htbl = sp->cinfo.c.dc_huff_tbl_ptrs[tblno]) != NULL)\n\t\thtbl->sent_table = FALSE;\n\tif ((htbl = sp->cinfo.c.ac_huff_tbl_ptrs[tblno]) != NULL)\n\t\thtbl->sent_table = FALSE;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new ();\n\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif /* HAVE_GNOME */\n\n\t/* Log all libsoup traffic if debugging's turned on */\n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\n\t\tg_object_unref (logger);\n\t}\n\n\treturn session;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int qemu_thread_is_self(QemuThread *thread)\n\n{\n\n    QemuThread *this_thread = TlsGetValue(qemu_thread_tls_index);\n\n    return this_thread->thread == thread->thread;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void qpci_io_writew(QPCIDevice *dev, void *data, uint16_t value)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    if (addr < QPCI_PIO_LIMIT) {\n\n        dev->bus->pio_writew(dev->bus, addr, value);\n\n    } else {\n\n        value = cpu_to_le16(value);\n\n        dev->bus->memwrite(dev->bus, addr, &value, sizeof(value));\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void sum_update(const char *p, int32 len)\n{\n\tswitch (cursum_type) {\n\t  case CSUM_MD5:\n\t\tmd5_update(&md, (uchar *)p, len);\n\t\tbreak;\n\t  case CSUM_MD4:\n\t  case CSUM_MD4_OLD:\n\t  case CSUM_MD4_BUSTED:\n\t\tif (len + sumresidue < CSUM_CHUNK) {\n\t\t\tmemcpy(md.buffer + sumresidue, p, len);\n\t\t\tsumresidue += len;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sumresidue) {\n\t\t\tint32 i = CSUM_CHUNK - sumresidue;\n\t\t\tmemcpy(md.buffer + sumresidue, p, i);\n\t\t\tmdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);\n\t\t\tlen -= i;\n\t\t\tp += i;\n\t\t}\n\n\t\twhile (len >= CSUM_CHUNK) {\n\t\t\tmdfour_update(&md, (uchar *)p, CSUM_CHUNK);\n\t\t\tlen -= CSUM_CHUNK;\n\t\t\tp += CSUM_CHUNK;\n\t\t}\n\n\t\tsumresidue = len;\n\t\tif (sumresidue)\n\t\t\tmemcpy(md.buffer, p, sumresidue);\n\t\tbreak;\n\t  case CSUM_NONE:\n\t\tbreak;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "virtio_gpu_resource_attach_backing(VirtIOGPU *g,\n                                   struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_attach_backing ab;\n    int ret;\n    VIRTIO_GPU_FILL_CMD(ab);\n    trace_virtio_gpu_cmd_res_back_attach(ab.resource_id);\n    res = virtio_gpu_find_resource(g, ab.resource_id);\n    if (!res) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",\n                      __func__, ab.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n    ret = virtio_gpu_create_mapping_iov(&ab, cmd, &res->addrs, &res->iov);\n    if (ret != 0) {\n    res->iov_cnt = ab.nr_entries;",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int parse_audio_var(AVFormatContext *avctx, AVStream *st, const char *name, int size)\n\n{\n\n    AVIOContext *pb = avctx->pb;\n\n    if (!strcmp(name, \"__DIR_COUNT\")) {\n\n        st->nb_frames = var_read_int(pb, size);\n\n    } else if (!strcmp(name, \"AUDIO_FORMAT\")) {\n\n        st->codec->codec_id = var_read_int(pb, size);\n\n    } else if (!strcmp(name, \"COMPRESSION\")) {\n\n        st->codec->codec_tag = var_read_int(pb, size);\n\n    } else if (!strcmp(name, \"DEFAULT_VOL\")) {\n\n        var_read_metadata(avctx, name, size);\n\n    } else if (!strcmp(name, \"NUM_CHANNELS\")) {\n\n        st->codec->channels = var_read_int(pb, size);\n\n        st->codec->channel_layout = (st->codec->channels == 1) ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO;\n\n    } else if (!strcmp(name, \"SAMPLE_RATE\")) {\n\n        st->codec->sample_rate = var_read_int(pb, size);\n\n        avpriv_set_pts_info(st, 33, 1, st->codec->sample_rate);\n\n    } else if (!strcmp(name, \"SAMPLE_WIDTH\")) {\n\n        st->codec->bits_per_coded_sample = var_read_int(pb, size) * 8;\n\n    } else\n\n        return -1;\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "person_set_frame_delay(person_t* person, int num_frames)\n{\n\tperson->anim_frames = num_frames;\n\tperson->revert_frames = person->revert_delay;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void BaseAudioContext::ReleaseActiveSourceNodes() {\n  DCHECK(IsMainThread());\n  for (auto& source_node : active_source_nodes_)\n    source_node->Handler().BreakConnection();\n\n  active_source_nodes_.clear();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void add_partial(struct kmem_cache_node *n,\n\t\t\t\tstruct page *page, int tail)\n{\n\tspin_lock(&n->list_lock);\n\tn->nr_partial++;\n\tif (tail)\n\t\tlist_add_tail(&page->lru, &n->partial);\n\telse\n\t\tlist_add(&page->lru, &n->partial);\n\tspin_unlock(&n->list_lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "MagickExport void ConvertRGBToHSV(const Quantum red,const Quantum green,\n  const Quantum blue,double *hue,double *saturation,double *value)\n{\n  double\n    c,\n    max,\n    min;\n\n  /*\n    Convert RGB to HSV colorspace.\n  */\n  assert(hue != (double *) NULL);\n  assert(saturation != (double *) NULL);\n  assert(value != (double *) NULL);\n  max=MagickMax(QuantumScale*red,MagickMax(QuantumScale*green,\n    QuantumScale*blue));\n  min=MagickMin(QuantumScale*red,MagickMin(QuantumScale*green,\n    QuantumScale*blue));\n  c=max-min;\n  *value=max;\n  if (c <= 0.0)\n    {\n      *hue=0.0;\n      *saturation=0.0;\n      return;\n    }\n  if (fabs(max-QuantumScale*red) < MagickEpsilon)\n    {\n      *hue=(QuantumScale*green-QuantumScale*blue)/c;\n      if ((QuantumScale*green) < (QuantumScale*blue))\n        *hue+=6.0;\n    }\n  else\n    if (fabs(max-QuantumScale*green) < MagickEpsilon)\n      *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c;\n    else\n      *hue=4.0+(QuantumScale*red-QuantumScale*green)/c;\n  *hue*=60.0/360.0;\n  *saturation=c/max;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret <= 0 ? ret : -EIO;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "GF_Box *trex_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtendsBox, GF_ISOM_BOX_TYPE_TREX);\n\treturn (GF_Box *)tmp;",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "proto_registrar_get_ftype(const int n)\n{\n\theader_field_info *hfinfo;\n\n\tPROTO_REGISTRAR_GET_NTH(n, hfinfo);\n\treturn hfinfo->type;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\t/* unprotected vars, we dont care of overwrites */\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\n\t/* First check our per-socket dupack rate limit. */\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\n\t/* Then check the check host-wide RFC 5961 rate limit. */\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline void __set_fixmap(unsigned /* enum fixed_addresses */ idx,\n\t\t\t\tphys_addr_t phys, pgprot_t flags)\n{\n\tpv_ops.mmu.set_fixmap(idx, phys, flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static rsRetVal qAddDirect(qqueue_t *pThis, void* pUsr)\n{\n\tbatch_t singleBatch;\n\tbatch_obj_t batchObj;\n\tDEFiRet;\n\n\t//TODO: init batchObj (states _OK and new fields -- CHECK)\n\tASSERT(pThis != NULL);\n\n\t/* calling the consumer is quite different here than it is from a worker thread */\n\t/* we need to provide the consumer's return value back to the caller because in direct\n\t * mode the consumer probably has a lot to convey (which get's lost in the other modes\n\t * because they are asynchronous. But direct mode is deliberately synchronous.\n\t * rgerhards, 2008-02-12\n\t * We use our knowledge about the batch_t structure below, but without that, we\n\t * pay a too-large performance toll... -- rgerhards, 2009-04-22\n\t */\n\tmemset(&batchObj, 0, sizeof(batch_obj_t));\n\tmemset(&singleBatch, 0, sizeof(batch_t));\n\tbatchObj.state = BATCH_STATE_RDY;\n\tbatchObj.pUsrp = (obj_t*) pUsr;\n\tbatchObj.bFilterOK = 1;\n\tsingleBatch.nElem = 1; /* there always is only one in direct mode */\n\tsingleBatch.pElem = &batchObj;\n\tiRet = pThis->pConsumer(pThis->pUsr, &singleBatch, &pThis->bShutdownImmediate);\n\tobjDestruct(pUsr);\n\n\tRETiRet;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "if (iTask.task != NULL) {\n        scsi_free_scsi_task(iTask.task);\n        iTask.task = NULL;\n    }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int sldns_str2wire_str_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tuint8_t ch = 0;\n\tsize_t sl = 0;\n\tconst char* s = str;\n\t/* skip length byte */\n\tif(*len < 1)\n\t\treturn LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL;\n\n\t/* read characters */\n\twhile(sldns_parse_char(&ch, &s)) {\n\t\tif(sl >= 255)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_INVALID_STR, s-str);\n\t\tif(*len < sl+1)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL,\n\t\t\t\ts-str);\n\t\trd[++sl] = ch;\n\t}\n\tif(!s)\n\t\treturn LDNS_WIREPARSE_ERR_SYNTAX_BAD_ESCAPE;\n\trd[0] = (uint8_t)sl;\n\t*len = sl+1;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int *sockaddr_len, int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n \t\treturn -ENOTCONN;\n \t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n \taddr = (struct sockaddr_atmpvc *)sockaddr;\n \taddr->sap_family = AF_ATMPVC;\n \taddr->sap_addr.itf = vcc->dev->number;\n \taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void php_free_shutdown_functions(TSRMLS_D) /* {{{ */\n{\n\tif (BG(user_shutdown_function_names))\n\t\tzend_try {\n\t\t\tzend_hash_destroy(BG(user_shutdown_function_names));\n\t\t\tFREE_HASHTABLE(BG(user_shutdown_function_names));\n\t\t\tBG(user_shutdown_function_names) = NULL;\n\t\t} zend_catch {\n\t\t\t/* maybe shutdown method call exit, we just ignore it */\n\t\t\tFREE_HASHTABLE(BG(user_shutdown_function_names));\n\t\t\tBG(user_shutdown_function_names) = NULL;\n\t\t} zend_end_try();\n}\n/* }}} */",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void mehd_del(GF_Box *s)\n{\n\tgf_free(s);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int drff_init(struct hid_device *hid)\n{\n\tstruct drff_device *drff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_first_entry(&hid->inputs,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treport = list_first_entry(report_list, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdrff = kzalloc(sizeof(struct drff_device), GFP_KERNEL);\n\tif (!drff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, drff, drff_play);\n\tif (error) {\n\t\tkfree(drff);\n\t\treturn error;\n\t}\n\n\tdrff->report = report;\n\tdrff->report->field[0]->value[0] = 0xf3;\n\tdrff->report->field[0]->value[1] = 0x00;\n\tdrff->report->field[0]->value[2] = 0x00;\n\tdrff->report->field[0]->value[3] = 0x00;\n\tdrff->report->field[0]->value[4] = 0x00;\n\tdrff->report->field[0]->value[5] = 0x00;\n\tdrff->report->field[0]->value[6] = 0x00;\n\thid_hw_request(hid, drff->report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"Force Feedback for DragonRise Inc. \"\n\t\t \"game controllers by Richard Walmsley <richwalm@gmail.com>\\n\");\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "js_grisu2(double v, char *buffer, int *K)\n{\n\tint length, mk;\n\tdiy_fp_t w_m, w_p, c_mk, Wp, Wm, delta;\n\tint q = 64, alpha = -59, gamma = -56;\n\tnormalized_boundaries(v, &w_m, &w_p);\n\tmk = k_comp(w_p.e + q, alpha, gamma);\n\tc_mk = cached_power(mk);\n\tWp = multiply(w_p, c_mk);\n\tWm = multiply(w_m, c_mk);\n\tWm.f++; Wp.f--;\n\tdelta = minus(Wp, Wm);\n\t*K = -mk;\n\tdigit_gen(Wp, delta, buffer, &length, K);\n\treturn length;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "TPMI_ALG_SYM_MODE_Unmarshal(TPMI_ALG_SYM_MODE *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n#if ALG_CTR\t\n\t  case TPM_ALG_CTR:\n#endif\n#if ALG_OFB\t\n\t  case TPM_ALG_OFB:\n#endif\n#if ALG_CBC\n\t  case TPM_ALG_CBC:\n#endif\n#if ALG_CFB\t\n\t  case TPM_ALG_CFB:\n#endif\n#if ALG_ECB\t\n\t  case TPM_ALG_ECB:\n#endif\n#if ALG_CMAC\n\t  case TPM_ALG_CMAC:\n#endif\n\t    break;\n\t  case TPM_ALG_NULL:\n\t    if (allowNull) {\n\t\tbreak;\n\t    }\n\t  default:\n\t    rc = TPM_RC_MODE;\n\t}\n    }\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "XSetClassHint(\n\tDisplay *dpy,\n\tWindow w,\n\tXClassHint *classhint)\n{\n\tchar *class_string;\n\tchar *s;\n\tsize_t len_nm, len_cl;\n\n\tlen_nm = safestrlen(classhint->res_name);\n\tlen_cl = safestrlen(classhint->res_class);\n\tif ((class_string = s = Xmalloc(len_nm + len_cl + 2))) {\n\t    if (len_nm) {\n\t\tstrcpy(s, classhint->res_name);\n\t\ts += len_nm + 1;\n\t    }\n\t    else\n\t\t*s++ = '\\0';\n\t    if (len_cl)\n\t\tstrcpy(s, classhint->res_class);\n\t    else\n\t\t*s = '\\0';\n\t    XChangeProperty(dpy, w, XA_WM_CLASS, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *) class_string,\n\t\t\t    len_nm+len_cl+2);\n\t    Xfree(class_string);\n\t}\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "  void initialize() override {\n    allow_metadata_ = true;\n    http2OptionsFromTuple(client_http2_options_, client_settings_);\n    http2OptionsFromTuple(server_http2_options_, server_settings_);\n    client_ = std::make_unique<MetadataTestClientConnectionImpl>(\n        client_connection_, client_callbacks_, stats_store_, client_http2_options_,\n        max_request_headers_kb_, max_response_headers_count_, http2_session_factory_);\n    server_ = std::make_unique<TestServerConnectionImpl>(\n        server_connection_, server_callbacks_, stats_store_, server_http2_options_,\n        max_request_headers_kb_, max_request_headers_count_, headers_with_underscores_action_);\n    ON_CALL(client_connection_, write(_, _))\n        .WillByDefault(Invoke([&](Buffer::Instance& data, bool) -> void {\n          ASSERT_TRUE(server_wrapper_.dispatch(data, *server_).ok());\n        }));\n    ON_CALL(server_connection_, write(_, _))\n        .WillByDefault(Invoke([&](Buffer::Instance& data, bool) -> void {\n          ASSERT_TRUE(client_wrapper_.dispatch(data, *client_).ok());\n        }));\n  }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "TPMI_ECC_KEY_EXCHANGE_Unmarshal(TPMI_ECC_KEY_EXCHANGE *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n#if ALG_ECDH\n\t  case TPM_ALG_ECDH:\n#endif\n#if ALG_ECMQV\n\t  case TPM_ALG_ECMQV:\n#endif\n#if ALG_SM2\n\t  case TPM_ALG_SM2:\n#endif\n\t    break;\n\t  case TPM_ALG_NULL:\n\t    if (allowNull) {\n\t\tbreak;\n\t    }\n\t  default:\n\t    rc = TPM_RC_SCHEME;\n\t}\n    }\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void sctp_unhash(struct sock *sk)\n{\n\t/* STUB */\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "class_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_CLASS);\n  return mrb_class_ptr(c);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "xfs_inumbers_fmt(\n\tstruct xfs_ibulk\t\t*breq,\n\tconst struct xfs_inumbers\t*igrp)\n{\n\tif (copy_to_user(breq->ubuffer, igrp, sizeof(struct xfs_inumbers)))\n\t\treturn -EFAULT;\n\treturn xfs_ibulk_advance(breq, sizeof(struct xfs_inumbers));\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int ib_update_cm_av(struct ib_cm_id *id, const u8 *smac, const u8 *alt_smac)\n{\n\tstruct cm_id_private *cm_id_priv;\n\n\tcm_id_priv = container_of(id, struct cm_id_private, id);\n\n\tif (smac != NULL)\n\t\tmemcpy(cm_id_priv->av.smac, smac, sizeof(cm_id_priv->av.smac));\n\n\tif (alt_smac != NULL)\n\t\tmemcpy(cm_id_priv->alt_av.smac, alt_smac,\n\t\t       sizeof(cm_id_priv->alt_av.smac));\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "_zip_cdir_new(int nentry, struct zip_error *error)\n{\n    struct zip_cdir *cd;\n    \n    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n        return NULL;\n     }\n \n    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))\n        == NULL) {\n        _zip_error_set(error, ZIP_ER_MEMORY, 0);\n        free(cd);\n\treturn NULL;\n    }\n\n    /* entries must be initialized by caller */\n\n    cd->nentry = nentry;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->comment_len = 0;\n\n    return cd;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "~AutoLock()\n        {\n            if (xmpLockFct_) xmpLockFct_(pLockData_, false);\n        }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void __exit usbnet_exit(void)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "spnego_gss_inquire_context(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tgss_name_t\t*src_name,\n\t\t\tgss_name_t\t*targ_name,\n\t\t\tOM_uint32\t*lifetime_rec,\n\t\t\tgss_OID\t\t*mech_type,\n\t\t\tOM_uint32\t*ctx_flags,\n\t\t\tint\t\t*locally_initiated,\n\t\t\tint\t\t*opened)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\n\tret = gss_inquire_context(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tsrc_name,\n\t\t\t\ttarg_name,\n\t\t\t\tlifetime_rec,\n\t\t\t\tmech_type,\n\t\t\t\tctx_flags,\n\t\t\t\tlocally_initiated,\n\t\t\t\topened);\n\n\treturn (ret);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->smin_value;\n\tu32 umin_val = src_reg->umin_value;\n\n\t/* Assuming scalar64_min_max_or will be called so it is safe\n\t * to skip updating register for known case.\n\t */\n\tif (src_known && dst_known)\n\t\treturn;\n\n\t/* We get our maximum from the var_off, and our minimum is the\n\t * maximum of the operands' minima\n\t */\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t * ain't nobody got time for that.\n\t\t */\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\t/* ORing two positives gives a positive, so safe to\n\t\t * cast result into s64.\n\t\t */\n\t\tdst_reg->s32_min_value = dst_reg->umin_value;\n\t\tdst_reg->s32_max_value = dst_reg->umax_value;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "name_find(regex_t* reg, const UChar* name, const UChar* name_end)\n{\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  e = (NameEntry* )NULL;\n  if (IS_NOT_NULL(t)) {\n    onig_st_lookup_strend(t, name, name_end, (HashDataType* )((void* )(&e)));\n  }\n  return e;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int vmci_transport_shutdown(struct vsock_sock *vsk, int mode)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\t\t&vsk->sk,\n\t\t\t\t\tVMCI_TRANSPORT_PACKET_TYPE_SHUTDOWN,\n\t\t\t\t\t0, mode, NULL,\n\t\t\t\t\tVSOCK_PROTO_INVALID,\n\t\t\t\t\tVMCI_INVALID_HANDLE);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void throttle_get_config(ThrottleState *ts, ThrottleConfig *cfg)\n{\n    *cfg = ts->cfg;",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int skcipher_prepare_alg(struct skcipher_alg *alg)\n{\n\tstruct crypto_alg *base = &alg->base;\n\n\tif (alg->ivsize > PAGE_SIZE / 8 || alg->chunksize > PAGE_SIZE / 8 ||\n\t    alg->walksize > PAGE_SIZE / 8)\n\t\treturn -EINVAL;\n\n\tif (!alg->chunksize)\n\t\talg->chunksize = base->cra_blocksize;\n\tif (!alg->walksize)\n\t\talg->walksize = alg->chunksize;\n\n\tbase->cra_type = &crypto_skcipher_type2;\n\tbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\n\tbase->cra_flags |= CRYPTO_ALG_TYPE_SKCIPHER;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "status_t BnSoundTriggerHwService::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n\n         case LIST_MODULES: {\n             CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n             unsigned int numModulesReq = data.readInt32();\n             unsigned int numModules = numModulesReq;\n             struct sound_trigger_module_descriptor *modules =\n                     (struct sound_trigger_module_descriptor *)calloc(numModulesReq,\n                                                    sizeof(struct sound_trigger_module_descriptor));\n             status_t status = listModules(modules, &numModules);\n             reply->writeInt32(status);\n             reply->writeInt32(numModules);\n            ALOGV(\"LIST_MODULES status %d got numModules %d\", status, numModules);\n\n if (status == NO_ERROR) {\n if (numModulesReq > numModules) {\n                    numModulesReq = numModules;\n }\n                reply->write(modules,\n                             numModulesReq * sizeof(struct sound_trigger_module_descriptor));\n }\n            free(modules);\n return NO_ERROR;\n }\n\n case ATTACH: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n sound_trigger_module_handle_t handle;\n            data.read(&handle, sizeof(sound_trigger_module_handle_t));\n            sp<ISoundTriggerClient> client =\n                    interface_cast<ISoundTriggerClient>(data.readStrongBinder());\n            sp<ISoundTrigger> module;\n status_t status = attach(handle, client, module);\n            reply->writeInt32(status);\n if (module != 0) {\n                reply->writeInt32(1);\n                reply->writeStrongBinder(IInterface::asBinder(module));\n } else {\n                reply->writeInt32(0);\n }\n return NO_ERROR;\n } break;\n\n case SET_CAPTURE_STATE: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n            reply->writeInt32(setCaptureState((bool)data.readInt32()));\n return NO_ERROR;\n } break;\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "runarg(gs_main_instance * minst, const char *pre, const char *arg,\n       const char *post, int options)\n{\n    int len = strlen(pre) + esc_strlen(arg) + strlen(post) + 1;\n    int code;\n    char *line;\n\n    if (options & runInit) {\n        code = gs_main_init2(minst);    /* Finish initialization */\n\n        if (code < 0)\n            return code;\n    }\n    line = (char *)gs_alloc_bytes(minst->heap, len, \"runarg\");\n    if (line == 0) {\n        lprintf(\"Out of memory!\\n\");\n        return_error(e_VMerror);\n    }\n    strcpy(line, pre);\n    esc_strcat(line, arg);\n    strcat(line, post);\n    minst->i_ctx_p->starting_arg_file = true;\n    code = run_string(minst, line, options);\n    minst->i_ctx_p->starting_arg_file = false;\n    gs_free_object(minst->heap, line, \"runarg\");\n    return code;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void event_receiver_fetcher(struct ipmi_smi *intf,\n\t\t\t\t   struct ipmi_recv_msg *msg)\n{\n\tif ((msg->addr.addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\n\t    && (msg->msg.netfn == IPMI_NETFN_SENSOR_EVENT_RESPONSE)\n\t    && (msg->msg.cmd == IPMI_GET_EVENT_RECEIVER_CMD)\n\t    && (msg->msg.data[0] == IPMI_CC_NO_ERROR)) {\n\t\t/* A get event receiver command, save it. */\n\t\tintf->event_receiver = msg->msg.data[1];\n\t\tintf->event_receiver_lun = msg->msg.data[2] & 0x3;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "explicit DidStartNavigationObserver(content::WebContents* web_contents)\n      : content::WebContentsObserver(web_contents),\n        message_loop_runner_(new content::MessageLoopRunner) {}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "iscsi_aio_cancel(BlockDriverAIOCB *blockacb)\n\n{\n\n    IscsiAIOCB *acb = (IscsiAIOCB *)blockacb;\n\n    IscsiLun *iscsilun = acb->iscsilun;\n\n\n\n    acb->common.cb(acb->common.opaque, -ECANCELED);\n\n    acb->canceled = 1;\n\n\n\n    /* send a task mgmt call to the target to cancel the task on the target */\n\n    iscsi_task_mgmt_abort_task_async(iscsilun->iscsi, acb->task,\n\n                                     iscsi_abort_task_cb, NULL);\n\n\n\n    /* then also cancel the task locally in libiscsi */\n\n    iscsi_scsi_task_cancel(iscsilun->iscsi, acb->task);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void blkverify_refresh_filename(BlockDriverState *bs, QDict *options)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n\n\n    /* bs->file->bs has already been refreshed */\n\n    bdrv_refresh_filename(s->test_file->bs);\n\n\n\n    if (bs->file->bs->full_open_options\n\n        && s->test_file->bs->full_open_options)\n\n    {\n\n        QDict *opts = qdict_new();\n\n        qdict_put_str(opts, \"driver\", \"blkverify\");\n\n\n\n        QINCREF(bs->file->bs->full_open_options);\n\n        qdict_put(opts, \"raw\", bs->file->bs->full_open_options);\n\n        QINCREF(s->test_file->bs->full_open_options);\n\n        qdict_put(opts, \"test\", s->test_file->bs->full_open_options);\n\n\n\n        bs->full_open_options = opts;\n\n    }\n\n\n\n    if (bs->file->bs->exact_filename[0]\n\n        && s->test_file->bs->exact_filename[0])\n\n    {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"blkverify:%s:%s\",\n\n                 bs->file->bs->exact_filename,\n\n                 s->test_file->bs->exact_filename);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "TEST_F(LuaHeaderMapWrapperTest, Methods) {\n  const std::string SCRIPT{R\"EOF(\n    function callMe(object)\n      object:add(\"HELLO\", \"WORLD\")\n      testPrint(object:get(\"hELLo\"))\n\n      object:add(\"header1\", \"\")\n      object:add(\"header2\", \"foo\")\n\n      for key, value in pairs(object) do\n        testPrint(string.format(\"'%s' '%s'\", key, value))\n      end\n\n      object:remove(\"header1\")\n      for key, value in pairs(object) do\n        testPrint(string.format(\"'%s' '%s'\", key, value))\n      end\n    end\n  )EOF\"};\n\n  InSequence s;\n  setup(SCRIPT);\n\n  Http::TestRequestHeaderMapImpl headers;\n  HeaderMapWrapper::create(coroutine_->luaState(), headers, []() { return true; });\n  EXPECT_CALL(printer_, testPrint(\"WORLD\"));\n  EXPECT_CALL(printer_, testPrint(\"'hello' 'WORLD'\"));\n  EXPECT_CALL(printer_, testPrint(\"'header1' ''\"));\n  EXPECT_CALL(printer_, testPrint(\"'header2' 'foo'\"));\n  EXPECT_CALL(printer_, testPrint(\"'hello' 'WORLD'\"));\n  EXPECT_CALL(printer_, testPrint(\"'header2' 'foo'\"));\n  start(\"callMe\");\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static av_cold int avui_encode_init(AVCodecContext *avctx)\n\n{\n\n    avctx->coded_frame = av_frame_alloc();\n\n\n\n    if (avctx->width != 720 || avctx->height != 486 && avctx->height != 576) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 720x486 and 720x576 are supported.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if (!avctx->coded_frame) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not allocate frame.\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    if (!(avctx->extradata = av_mallocz(24 + FF_INPUT_BUFFER_PADDING_SIZE)))\n\n        return AVERROR(ENOMEM);\n\n    avctx->extradata_size = 24;\n\n    memcpy(avctx->extradata, \"\\0\\0\\0\\x18\"\"APRGAPRG0001\", 16);\n\n    if (avctx->field_order > AV_FIELD_PROGRESSIVE) {\n\n        avctx->extradata[19] = 2;\n\n    } else {\n\n        avctx->extradata[19] = 1;\n\n    }\n\n\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void prealloc_destroy(struct bpf_htab *htab)\n{\n\thtab_free_elems(htab);\n\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_destroy(&htab->lru);\n\telse\n\t\tpcpu_freelist_destroy(&htab->freelist);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int network_config_set_interface (const oconfig_item_t *ci, /* {{{ */\n    int *interface)\n{\n  if ((ci->values_num != 1)\n      || (ci->values[0].type != OCONFIG_TYPE_STRING))\n  {\n    WARNING (\"network plugin: The `Interface' config option needs exactly \"\n        \"one string argument.\");\n    return (-1);\n  }\n\n  if (interface == NULL)\n    return (-1);\n\n  *interface = if_nametoindex (ci->values[0].value.string);\n\n  return (0);\n} /* }}} int network_config_set_interface */",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool ByteVector::isNull() const\n{\n  return d == null.d;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {\n  DCHECK(!defer_page_unload_);\n  defer_page_unload_ = true;\n  bool rv = false;\n  switch (event.GetType()) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n      rv = OnMouseDown(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n      rv = OnMouseUp(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n      rv = OnMouseMove(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYDOWN:\n      rv = OnKeyDown(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYUP:\n      rv = OnKeyUp(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_CHAR:\n      rv = OnChar(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHSTART: {\n      KillTouchTimer(next_touch_timer_id_);\n\n      pp::TouchInputEvent touch_event(event);\n      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)\n        ScheduleTouchTimer(touch_event);\n      break;\n    }\n    case PP_INPUTEVENT_TYPE_TOUCHEND:\n      KillTouchTimer(next_touch_timer_id_);\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHMOVE:\n      KillTouchTimer(next_touch_timer_id_);\n    default:\n      break;\n  }\n \n   DCHECK(defer_page_unload_);\n   defer_page_unload_ = false;\n  for (int page_index : deferred_page_unloads_)\n     pages_[page_index]->Unload();\n  deferred_page_unloads_.clear();\n   return rv;\n }",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->dev);\n\n    assert(!bs->job);\n\n    assert(bdrv_op_blocker_is_empty(bs));\n\n    assert(!bs->refcnt);\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    bdrv_close(bs);\n\n\n\n    /* remove from list, if necessary */\n\n    bdrv_make_anon(bs);\n\n\n\n\n    g_free(bs);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int mov_read_close(AVFormatContext *s)\n\n{\n\n    int i;\n\n    MOVContext *mov = s->priv_data;\n\n    for(i=0; i<mov->total_streams; i++)\n\n        mov_free_stream_context(mov->streams[i]);\n\n    for(i=0; i<s->nb_streams; i++)\n\n        av_free(s->streams[i]);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void vmci_transport_release(struct vsock_sock *vsk)\n{\n\tif (!vmci_handle_is_invalid(vmci_trans(vsk)->dg_handle)) {\n\t\tvmci_datagram_destroy_handle(vmci_trans(vsk)->dg_handle);\n\t\tvmci_trans(vsk)->dg_handle = VMCI_INVALID_HANDLE;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void ati_cursor_define(ATIVGAState *s)\n{\n    uint8_t data[1024];\n    uint8_t *src;\n    int i, j, idx = 0;\n\n    if ((s->regs.cur_offset & BIT(31)) || s->cursor_guest_mode) {\n        return; /* Do not update cursor if locked or rendered by guest */\n    }\n    /* FIXME handle cur_hv_offs correctly */\n    src = s->vga.vram_ptr + s->regs.cur_offset -\n          (s->regs.cur_hv_offs >> 16) - (s->regs.cur_hv_offs & 0xffff) * 16;\n    for (i = 0; i < 64; i++) {\n        for (j = 0; j < 8; j++, idx++) {\n            data[idx] = src[i * 16 + j];\n            data[512 + idx] = src[i * 16 + j + 8];\n        }\n    }\n    if (!s->cursor) {\n        s->cursor = cursor_alloc(64, 64);\n    }\n    cursor_set_mono(s->cursor, s->regs.cur_color1, s->regs.cur_color0,\n                    &data[512], 1, &data[0]);\n    dpy_cursor_define(s->vga.con, s->cursor);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "SYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,\n\t\tint __user *, upeer_addrlen, int, flags)\n{\n\treturn __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void qbus_free(BusState *bus)\n\n{\n\n    DeviceState *dev;\n\n\n\n    while ((dev = QLIST_FIRST(&bus->children)) != NULL) {\n\n        qdev_free(dev);\n\n    }\n\n    if (bus->parent) {\n\n        QLIST_REMOVE(bus, sibling);\n\n        bus->parent->num_child_bus--;\n\n    }\n\n\n    if (bus->qdev_allocated) {\n\n        qemu_free(bus);\n\n    }\n\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "virtual ~PowerTrayView() {\n  }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline unsigned long get_desc_base(const struct desc_struct *desc)\n{\n\treturn desc->base0 | ((desc->base1) << 16) | ((desc->base2) << 24);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void jas_icclut16_destroy(jas_iccattrval_t *attrval)\n{\n\tjas_icclut16_t *lut16 = &attrval->data.lut16;\n\tif (lut16->clut)\n\t\tjas_free(lut16->clut);\n\tif (lut16->intabs)\n\t\tjas_free(lut16->intabs);\n\tif (lut16->intabsbuf)\n\t\tjas_free(lut16->intabsbuf);\n\tif (lut16->outtabs)\n\t\tjas_free(lut16->outtabs);\n\tif (lut16->outtabsbuf)\n\t\tjas_free(lut16->outtabsbuf);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int warn(const char *fmt, ...) {\n    static char buf[1024];\n    va_list args;\n\n    va_start(args, fmt);\n    vsprintf(buf, fmt, args);\n    va_end(args);\n    return(message(LOG_WARNING, buf));\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "virtual ~Buffer() {}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "TiffIfdMakernote::~TiffIfdMakernote()\n    {\n        delete pHeader_;\n    }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "PyParser_ParseFileObject(FILE *fp, PyObject *filename,\n                         const char *enc, grammar *g, int start,\n                         const char *ps1, const char *ps2,\n                         perrdetail *err_ret, int *flags)\n{\n    struct tok_state *tok;\n\n    if (initerr(err_ret, filename) < 0)\n        return NULL;\n\n    if ((tok = PyTokenizer_FromFile(fp, enc, ps1, ps2)) == NULL) {\n        err_ret->error = E_NOMEM;\n        return NULL;\n    }\n#ifndef PGEN\n    Py_INCREF(err_ret->filename);\n    tok->filename = err_ret->filename;\n#endif\n    return parsetok(tok, g, start, err_ret, flags);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "gsdll_stdin(void *instance, char *buf, int len)\n{\n    struct stdin_buf input;\n    gint input_tag;\n\n    input.len = len;\n    input.buf = buf;\n    input.count = -1;\n\n    input_tag = gdk_input_add(fileno(stdin),\n        (GdkInputCondition)(GDK_INPUT_READ | GDK_INPUT_EXCEPTION),\n        read_stdin_handler, &input);\n    while (input.count < 0)\n        gtk_main_iteration_do(TRUE);\n    gdk_input_remove(input_tag);\n\n    return input.count;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "Element* Document::pointerLockElement() const\n{\n    if (!page() || page()->pointerLockController().lockPending())\n        return 0;\n    if (Element* element = page()->pointerLockController().element()) {\n        if (element->document() == this)\n            return element;\n    }\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool SVGElement::IsPresentationAttribute(const QualifiedName& name) const {\n  if (const SVGAnimatedPropertyBase* property = PropertyFromAttribute(name))\n    return property->HasPresentationAttributeMapping();\n  return CssPropertyIdForSVGAttributeName(name) > 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "__nlmsg_put(struct sk_buff *skb, u32 portid, u32 seq, int type, int len, int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tint size = nlmsg_msg_size(len);\n\n\tnlh = (struct nlmsghdr *)skb_put(skb, NLMSG_ALIGN(size));\n\tnlh->nlmsg_type = type;\n\tnlh->nlmsg_len = size;\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_pid = portid;\n\tnlh->nlmsg_seq = seq;\n\tif (!__builtin_constant_p(size) || NLMSG_ALIGN(size) - size != 0)\n\t\tmemset(nlmsg_data(nlh) + len, 0, NLMSG_ALIGN(size) - size);\n\treturn nlh;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "_put_anchor_news(Buffer *buf, char *p1, char *p2, int line, int pos)\n{\n    Str tmp;\n\n    if (*p1 == '<') {\n\tp1++;\n\tif (*(p2 - 1) == '>')\n\t    p2--;\n    }\n    tmp = Strnew_charp(\"news:\");\n    Strcat_charp_n(tmp, p1, p2 - p1);\n    return registerHref(buf, url_encode(tmp->ptr, baseURL(buf),\n\t\t\t\t\tbuf->document_charset),\n\t\t\tNULL, NO_REFERER, NULL, '\\0', line,\n\t\t\tpos);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void nfs4_init_opendata_res(struct nfs4_opendata *p)\n{\n\tp->o_res.f_attr = &p->f_attr;\n\tp->o_res.dir_attr = &p->dir_attr;\n\tp->o_res.seqid = p->o_arg.seqid;\n\tp->c_res.seqid = p->c_arg.seqid;\n\tp->o_res.server = p->o_arg.server;\n\tnfs_fattr_init(&p->f_attr);\n\tnfs_fattr_init(&p->dir_attr);\n }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static bool pmu_access_cycle_counter_el0_disabled(struct kvm_vcpu *vcpu)\n{\n\tu64 reg = vcpu_sys_reg(vcpu, PMUSERENR_EL0);\n\n\treturn !((reg & (ARMV8_PMU_USERENR_CR | ARMV8_PMU_USERENR_EN))\n\t\t || vcpu_mode_priv(vcpu));\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void x86_amd_ssb_disable(void)\n{\n\tu64 msrval = x86_amd_ls_cfg_base | x86_amd_ls_cfg_ssbd_mask;\n\n\tif (boot_cpu_has(X86_FEATURE_VIRT_SSBD))\n\t\twrmsrl(MSR_AMD64_VIRT_SPEC_CTRL, SPEC_CTRL_SSBD);\n\telse if (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD))\n\t\twrmsrl(MSR_AMD64_LS_CFG, msrval);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int blkid_partition_get_type(blkid_partition par)\n{\n\treturn par->type;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void gen_rfe(DisasContext *s, TCGv pc, TCGv cpsr)\n\n{\n\n    gen_set_cpsr(cpsr, 0xffffffff);\n\n    dead_tmp(cpsr);\n\n    store_reg(s, 15, pc);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(s->sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\trelease_sock(s->sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\n\t\t\t/* The entry could have been deleted from the\n\t\t\t * list meanwhile and thus the next pointer is\n\t\t\t * no longer valid.  Play it safe and restart\n\t\t\t * the scan.  Forward progress is ensured\n\t\t\t * because we set s->ax25_dev to NULL and we\n\t\t\t * are never passed a NULL 'dev' argument.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n \t\t\tstrcpy(buf, \"????\");\n \t\t\tbreak;\n \t\t}\n\t\tstrcat(line, buf);\n\t\tstrcat(line, \" \");\n \t\te = e->next;\n \t}\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "InlineBoxPosition ComputeInlineBoxPosition(const VisiblePosition& position) {\n  DCHECK(position.IsValid()) << position;\n  return ComputeInlineBoxPosition(position.DeepEquivalent(),\n                                  position.Affinity());\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "cmsBool ReadOneElem(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, cmsUInt32Number BaseOffset)\n{\n    if (!_cmsReadUInt32Number(io, &e->Offsets[i])) return FALSE;\n    if (!_cmsReadUInt32Number(io, &e ->Sizes[i])) return FALSE;\n\n    if (e ->Offsets[i] > 0)\n        e ->Offsets[i] += BaseOffset;\n    return TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void qemu_fflush(QEMUFile *f)\n\n{\n\n    ssize_t ret = 0;\n\n\n\n    if (!qemu_file_is_writable(f)) {\n\n        return;\n\n    }\n\n\n\n    if (f->ops->writev_buffer) {\n\n        if (f->iovcnt > 0) {\n\n            ret = f->ops->writev_buffer(f->opaque, f->iov, f->iovcnt, f->pos);\n\n        }\n\n    } else {\n\n        if (f->buf_index > 0) {\n\n            ret = f->ops->put_buffer(f->opaque, f->buf, f->pos, f->buf_index);\n\n        }\n\n    }\n\n    if (ret >= 0) {\n\n        f->pos += ret;\n\n    }\n\n    f->buf_index = 0;\n\n    f->iovcnt = 0;\n\n    if (ret < 0) {\n\n        qemu_file_set_error(f, ret);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "TopSitesQuerier()\n      : number_of_callbacks_(0), waiting_(false), weak_ptr_factory_(this) {}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "PHP_IMAP_EXPORT void mm_login(NETMBX *mb, char *user, char *pwd, long trial)\n{\n\n\tif (*mb->user) {\n\t\tstrlcpy (user, mb->user, MAILTMPLEN);\n\t} else {\n\t\tstrlcpy (user, IMAPG(imap_user), MAILTMPLEN);\n\t}\n\tstrlcpy (pwd, IMAPG(imap_password), MAILTMPLEN);",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "TiffSizeEntry::~TiffSizeEntry()\n    {\n    }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static gint conv_utf8tojis(gchar *outbuf, gint outlen, const gchar *inbuf)\n{\n\tgchar *eucstr;\n\n\tXalloca(eucstr, outlen, return -1);\n\n\tif (conv_utf8toeuc(eucstr, outlen, inbuf) < 0)\n\t\treturn -1;\n\tif (conv_euctojis(outbuf, outlen, eucstr) < 0)\n\t\treturn -1;\n\t\t\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void vpb_sic_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = vpb_sic_init;\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_vpb_sic;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void GraphicsContext::setPlatformCompositeOperation(CompositeOperator op)\n{\n    if (paintingDisabled())\n        return;\n\n    platformContext()->setXfermodeMode(WebCoreCompositeToSkiaComposite(op));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void do_mulldo (void)\n\n{\n\n    int64_t th;\n\n    uint64_t tl;\n\n\n\n    muls64(&tl, &th, T0, T1);\n\n    if (likely(th == 0)) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_ov = 1;\n\n        xer_so = 1;\n\n    }\n\n    T0 = (int64_t)tl;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "rsvg_filter_store_result (GString * name,\n                          cairo_surface_t *surface,\n                          RsvgFilterContext * ctx)\n{\n    RsvgFilterPrimitiveOutput output;\n    output.bounds.x0 = 0;\n    output.bounds.y0 = 0;\n    output.bounds.x1 = ctx->width;\n    output.bounds.y1 = ctx->height;\n    output.surface = surface;\n\n    rsvg_filter_store_output (name, output, ctx);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "ves_icall_Type_get_IsGenericInstance (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->type->byref)\n\t\treturn FALSE;\n\n\tklass = mono_class_from_mono_type (type->type);\n\treturn klass->generic_class != NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "    TEST(BSONValidate, MuckingData1) {\n\n        BSONObj theObject;\n        \n        {\n            BSONObjBuilder b;\n            b.append( \"name\" , \"eliot was here\" );\n            b.append( \"yippee\" , \"asd\" );\n            BSONArrayBuilder a( b.subarrayStart( \"arr\" ) );\n            for ( int i=0; i<100; i++ ) {\n                a.append( BSON( \"x\" << i << \"who\" << \"me\" << \"asd\" << \"asd\" ) );\n            }\n            a.done();\n            b.done();\n            \n            theObject = b.obj();\n        }\n\n        int numValid = 0;\n        int numToRun = 1000;\n        long long jsonSize = 0;\n        \n        for ( int i=4; i<theObject.objsize()-1; i++ ) {\n            BSONObj mine = theObject.copy();\n            \n            char* data = const_cast<char*>(mine.objdata());\n            \n            data[ i ] = 200;\n\n            numToRun++;\n            if ( mine.valid() ) {\n                numValid++;\n                jsonSize += mine.jsonString().size();\n            }\n   \n        }\n\n\n        log() << \"MuckingData1: didn't crash valid/total: \" << numValid << \"/\" << numToRun << \" (want few valid ones) \" \n              << \" jsonSize: \" << jsonSize << endl;        \n    }",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "PHP_BZ2_API php_stream *_php_stream_bz2open_from_BZFILE(BZFILE *bz, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchar *mode, php_stream *innerstream STREAMS_DC TSRMLS_DC)\n{\n\tstruct php_bz2_stream_data_t *self;\n\t\n\tself = emalloc(sizeof(*self));\n\n\tself->stream = innerstream;\n\tself->bz_file = bz;\n\n\treturn php_stream_alloc_rel(&php_stream_bz2io_ops, self, 0, mode);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static ssize_t numa_node_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", dev_to_node(dev));\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool SyncManager::ReceivedExperimentalTypes(syncable::ModelTypeSet* to_add)\n    const {\n  ReadTransaction trans(FROM_HERE, GetUserShare());\n  ReadNode node(&trans);\n  if (!node.InitByTagLookup(kNigoriTag)) {\n    DVLOG(1) << \"Couldn't find Nigori node.\";\n    return false;\n  }\n  if (node.GetNigoriSpecifics().sync_tabs()) {\n    to_add->Put(syncable::SESSIONS);\n    return true;\n  }\n  return false;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void InferenceContext::PreInputInit(\n    const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,\n    const std::vector<ShapeHandle>& input_tensors_as_shapes) {\n  // TODO(mdan): This is also done at graph construction. Run only here instead?\n  const auto ret = full_type::SpecializeType(attrs_, op_def);\n  DCHECK(ret.status().ok()) << \"while instantiating types: \" << ret.status();\n  ret_types_ = ret.ValueOrDie();\n\n  input_tensors_ = input_tensors;\n  input_tensors_as_shapes_ = input_tensors_as_shapes;\n\n  construction_status_ =\n      NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_);\n  if (!construction_status_.ok()) return;\n\n  int num_outputs = 0;\n  for (const auto& e : output_name_map_) {\n    num_outputs = std::max(num_outputs, e.second.second);\n  }\n  outputs_.assign(num_outputs, nullptr);\n  output_handle_shapes_and_types_.resize(num_outputs);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  // out.indices\n  c->set_output(1, c->Vector(nvals));        // out.values\n  c->set_output(2, c->Vector(rank));         // out.dense_shape\n  return Status::OK();\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline quint32 swapBgrToRgb(quint32 pixel)\n {\n    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);\n }",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "WebKit::WebDeviceOrientationClient* RenderView::deviceOrientationClient() {\n  if (!device_orientation_dispatcher_.get())\n    device_orientation_dispatcher_.reset(new DeviceOrientationDispatcher(this));\n  return device_orientation_dispatcher_.get();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "TIFFjpeg_write_tables(JPEGState* sp)\n{\n\treturn CALLVJPEG(sp, jpeg_write_tables(&sp->cinfo.c));\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void check_ept_pointer_match(struct kvm *kvm)\n{\n\tstruct kvm_vcpu *vcpu;\n\tu64 tmp_eptp = INVALID_PAGE;\n\tint i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!VALID_PAGE(tmp_eptp)) {\n\t\t\ttmp_eptp = to_vmx(vcpu)->ept_pointer;\n\t\t} else if (tmp_eptp != to_vmx(vcpu)->ept_pointer) {\n\t\t\tto_kvm_vmx(kvm)->ept_pointers_match\n\t\t\t\t= EPT_POINTERS_MISMATCH;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tto_kvm_vmx(kvm)->ept_pointers_match = EPT_POINTERS_MATCH;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "log_open_or_close (session *sess)\n{\n\tif (sess->text_logging == SET_DEFAULT)\n\t{\n\t\tif (prefs.hex_irc_logging)\n\t\t\tlog_open (sess);\n\t\telse\n\t\t\tlog_close (sess);\n\t}\n\telse\n\t{\n\t\tif (sess->text_logging)\n\t\t\tlog_open (sess);\n\t\telse\n\t\t\tlog_close (sess);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "bool can_push(size_t count)\n\t\t\t{\n\t\t\t\treturn static_cast<size_t>(to_end - to_next) > count;\n\t\t\t}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "if(pRcvBuf != NULL) {\n\t\tfree(pRcvBuf);\n\t\tpRcvBuf = NULL;\n\t}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void PaintPatcher::DerefPatch() {\n  DCHECK(begin_paint_.is_patched());\n  DCHECK(end_paint_.is_patched());\n  --refcount_;\n  if (refcount_ == 0) {\n    begin_paint_.Unpatch();\n    end_paint_.Unpatch();\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void tty_device_create_release(struct device *dev)\n{\n\tdev_dbg(dev, \"releasing...\\n\");\n\tkfree(dev);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "dane_verification_status_print (unsigned int status,\n                       gnutls_datum_t * out, unsigned int flags)\n{\n  gnutls_buffer_st str;\n  int ret;\n\n  _gnutls_buffer_init (&str);\n\n  if (status == 0)\n    _gnutls_buffer_append_str (&str, _(\"Certificate matches. \"));\n  else\n    _gnutls_buffer_append_str (&str, _(\"Verification failed. \"));\n\n  if (status & DANE_VERIFY_CA_CONSTRAINTS_VIOLATED)\n    _gnutls_buffer_append_str (&str, _(\"CA constrains were violated. \"));\n\n  if (status & DANE_VERIFY_CERT_DIFFERS)\n    _gnutls_buffer_append_str (&str, _(\"The certificate differs. \"));\n\n  if (status & DANE_VERIFY_NO_DANE_INFO)\n    _gnutls_buffer_append_str (&str, _(\"There were no DANE information. \"));\n\n  ret = _gnutls_buffer_to_datum( &str, out);\n  if (out->size > 0) out->size--;\n      \n  return ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "nfsd4_secinfo_release(union nfsd4_op_u *u)\n{\n\tif (u->secinfo.si_exp)\n\t\texp_put(u->secinfo.si_exp);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static u8 __init acpi_table_checksum(u8 *buffer, u32 length)\n{\n\tu8 sum = 0;\n\tu8 *end = buffer + length;\n\n\twhile (buffer < end)\n\t\tsum = (u8) (sum + *(buffer++));\n\treturn sum;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static uint8_t lag_calc_zero_run(int8_t x)\n\n{\n\n    return (x << 1) ^ (x >> 7);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline struct io_wqe_acct *io_get_acct(struct io_wqe *wqe, bool bound)\n{\n\treturn &wqe->acct[bound ? IO_WQ_ACCT_BOUND : IO_WQ_ACCT_UNBOUND];\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "gdk_pixbuf_loader_close (GdkPixbufLoader *loader,\n                         GError         **error)\n{\n  GdkPixbufLoaderPrivate *priv;\n  gboolean retval = TRUE;\n  \n  g_return_val_if_fail (loader != NULL, TRUE);\n  g_return_val_if_fail (GDK_IS_PIXBUF_LOADER (loader), TRUE);\n  \n  priv = loader->priv;\n  \n  /* we expect it's not closed */\n  g_return_val_if_fail (priv->closed == FALSE, TRUE);\n  \n  /* We have less the 128 bytes in the image.  Flush it, and keep going. */\n  if (priv->image_module == NULL)\n    gdk_pixbuf_loader_load_module (loader, NULL, NULL);\n  \n  if (priv->image_module && priv->image_module->stop_load)\n    retval = priv->image_module->stop_load (priv->context, error);\n  \n  priv->closed = TRUE;\n  \n  g_signal_emit (G_OBJECT (loader), pixbuf_loader_signals[CLOSED], 0);\n\n  return retval;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct sock *ssk)\n{\n\tint ret;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\n\tret = -ECONNREFUSED;\n\tif (nlk->netlink_rcv != NULL) {\n\t\tret = skb->len;\n\t\tnetlink_skb_set_owner_r(skb, sk);\n\t\tNETLINK_CB(skb).sk = ssk;\n\t\tnetlink_deliver_tap_kernel(sk, ssk, skb);\n\t\tnlk->netlink_rcv(skb);\n\t\tconsume_skb(skb);\n\t} else {\n\t\tkfree_skb(skb);\n\t}\n\tsock_put(sk);\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int virtio_queue_get_num(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].vring.num;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int usage() {\n    ERROR(\"usage: sdcard [OPTIONS] <source_path> <label>\\n\"\n \"    -u: specify UID to run as\\n\"\n \"    -g: specify GID to run as\\n\"\n \"    -U: specify user ID that owns device\\n\"\n \"    -m: source_path is multi-user\\n\"\n \"    -w: runtime write mount has full write access\\n\"\n \"\\n\");\n return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void network_to_register(RDMARegister *reg)\n\n{\n\n    reg->key.current_addr = ntohll(reg->key.current_addr);\n\n    reg->current_index = ntohl(reg->current_index);\n\n    reg->chunks = ntohll(reg->chunks);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,\n                    unsigned int len, unsigned int idx)\n{\n    VRingUsedElem uelem;\n    trace_virtqueue_fill(vq, elem, len, idx);\n    virtqueue_unmap_sg(vq, elem, len);\n    idx = (idx + vq->used_idx) % vq->vring.num;\n    uelem.id = elem->index;\n    uelem.len = len;\n    vring_used_write(vq, &uelem, idx);",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "SPL_METHOD(Array, hasChildren)\n{\n\tzval *object = getThis(), **entry;\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tHashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (spl_array_object_verify_pos(intern, aht TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_hash_get_current_data_ex(aht, (void **) &entry, &intern->pos) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(Z_TYPE_PP(entry) == IS_ARRAY || (Z_TYPE_PP(entry) == IS_OBJECT && (intern->ar_flags & SPL_ARRAY_CHILD_ARRAYS_ONLY) == 0));\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void InputMethodBase::Init(bool focused) {\n  if (focused)\n    OnFocus();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int64_t alloc_clusters_noref(BlockDriverState *bs, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int i, nb_clusters, refcount;\n\n\n\n    nb_clusters = size_to_clusters(s, size);\n\nretry:\n\n    for(i = 0; i < nb_clusters; i++) {\n\n        int64_t next_cluster_index = s->free_cluster_index++;\n\n        refcount = get_refcount(bs, next_cluster_index);\n\n\n\n        if (refcount < 0) {\n\n            return refcount;\n\n        } else if (refcount != 0) {\n\n            goto retry;\n\n        }\n\n    }\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"alloc_clusters: size=%\" PRId64 \" -> %\" PRId64 \"\\n\",\n\n            size,\n\n            (s->free_cluster_index - nb_clusters) << s->cluster_bits);\n\n#endif\n\n    return (s->free_cluster_index - nb_clusters) << s->cluster_bits;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void qmp_migrate_set_cache_size(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n    int64_t new_size;\n\n\n\n    /* Check for truncation */\n\n    if (value != (size_t)value) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"exceeding address space\");\n\n        return;\n\n    }\n\n\n\n    /* Cache should not be larger than guest ram size */\n\n    if (value > ram_bytes_total()) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"exceeds guest ram size \");\n\n        return;\n\n    }\n\n\n\n    new_size = xbzrle_cache_resize(value);\n\n    if (new_size < 0) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"is smaller than page size\");\n\n        return;\n\n    }\n\n\n\n    s->xbzrle_cache_size = new_size;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int nft_parse_register_store(const struct nft_ctx *ctx,\n\t\t\t     const struct nlattr *attr, u8 *dreg,\n\t\t\t     const struct nft_data *data,\n\t\t\t     enum nft_data_types type, unsigned int len)\n{\n\tint err;\n\tu32 reg;\n\n\treg = nft_parse_register(attr);\n\terr = nft_validate_register_store(ctx, reg, data, type, len);\n\tif (err < 0)\n\t\treturn err;\n\n\t*dreg = reg;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void media_device_kpad_to_upad(const struct media_pad *kpad,\n\t\t\t\t      struct media_pad_desc *upad)\n{\n\tupad->entity = kpad->entity->id;\n\tupad->index = kpad->index;\n\tupad->flags = kpad->flags;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n \tgpio_dev = platform_get_drvdata(pdev);\n \n \tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n \n \treturn 0;\n }",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void sparc_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    SPARCCPU *cpu = SPARC_CPU(obj);\n\n    CPUSPARCState *env = &cpu->env;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled()) {\n\n        gen_intermediate_code_init(env);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int vmdk_write(BlockDriverState *bs, int64_t sector_num, \n\n                     const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVmdkState *s = bs->opaque;\n\n    int index_in_cluster, n;\n\n    uint64_t cluster_offset;\n\n    static int cid_update = 0;\n\n\n\n    while (nb_sectors > 0) {\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors)\n\n            n = nb_sectors;\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9, 1);\n\n        if (!cluster_offset)\n\n            return -1;\n\n        if (bdrv_pwrite(s->hd, cluster_offset + index_in_cluster * 512, buf, n * 512) != n * 512)\n\n            return -1;\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n\n\n        // update CID on the first write every time the virtual disk is opened\n\n        if (!cid_update) {\n\n            vmdk_write_cid(bs, time(NULL));\n\n            cid_update++;\n\n        }\n\n    }\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline int cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t\t      const struct cipso_v4_doi *doi_def,\n\t\t\t\t      const struct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOSYS;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\t/* need write permission on the key to update it */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\t/* updating a negative key instantiates it */\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\n\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline int __udp_lib_lport_inuse(__u16 num, struct hlist_head udptable[])\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\n\tsk_for_each(sk, node, &udptable[num & (UDP_HTABLE_SIZE - 1)])\n\t\tif (sk->sk_hash == num)\n\t\t\treturn 1;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static double mp_log2(_cimg_math_parser& mp) {\n        return cimg::log2(_mp_arg(2));",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "TPM2B_IV_Marshal(TPM2B_IV *source, BYTE **buffer, INT32 *size)\n{\n    UINT16 written = 0;\n    written += TPM2B_Marshal(&source->b, buffer, size);\n    return written;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "SRP_VBASE *SRP_VBASE_new(char *seed_key)\n {\n     SRP_VBASE *vb = (SRP_VBASE *)OPENSSL_malloc(sizeof(SRP_VBASE));\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "_rsa_sec_compute_root_tr(const struct rsa_public_key *pub,\n\t\t\t const struct rsa_private_key *key,\n\t\t\t void *random_ctx, nettle_random_func *random,\n\t\t\t mp_limb_t *x, const mp_limb_t *m, size_t mn)\n{\n  mpz_t mz;\n  mpz_t xz;\n  int res;\n\n  mpz_init(mz);\n  mpz_init(xz);\n\n  mpn_copyi(mpz_limbs_write(mz, mn), m, mn);\n  mpz_limbs_finish(mz, mn);\n\n  res = rsa_compute_root_tr(pub, key, random_ctx, random, xz, mz);\n\n  if (res)\n    mpz_limbs_copy(x, xz, mpz_size(pub->n));\n\n  mpz_clear(mz);\n  mpz_clear(xz);\n  return res;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int manager_set_default_rlimits(Manager *m, struct rlimit **default_rlimit) {\n        int i;\n\n        assert(m);\n\n        for (i = 0; i < _RLIMIT_MAX; i++) {\n                m->rlimit[i] = mfree(m->rlimit[i]);\n\n                if (!default_rlimit[i])\n                        continue;\n\n                m->rlimit[i] = newdup(struct rlimit, default_rlimit[i], 1);\n                if (!m->rlimit[i])\n                        return -ENOMEM;\n        }\n\n        return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void phys_page_compact_all(AddressSpaceDispatch *d, int nodes_nb)\n{\n    DECLARE_BITMAP(compacted, nodes_nb);\n\n    if (d->phys_map.skip) {\n        phys_page_compact(&d->phys_map, d->map.nodes, compacted);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "absl::optional<CelValue> operator[](CelValue key) const override {\n    if (value_ == nullptr || !key.IsString()) {\n      return {};\n    }\n    auto str = std::string(key.StringOrDie().value());\n    if (!Http::validHeaderString(str)) {\n      // Reject key if it is an invalid header string\n      return {};\n    }\n    return convertHeaderEntry(\n        arena_, Http::HeaderUtility::getAllOfHeaderAsString(*value_, Http::LowerCaseString(str)));\n  }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline void phar_set_inode(phar_entry_info *entry TSRMLS_DC) /* {{{ */\n{\n\tchar tmp[MAXPATHLEN];\n\tint tmp_len;\n\n\ttmp_len = entry->filename_len + entry->phar->fname_len;\n\tmemcpy(tmp, entry->phar->fname, entry->phar->fname_len);\n\tmemcpy(tmp + entry->phar->fname_len, entry->filename, entry->filename_len);\n\tentry->inode = (unsigned short)zend_get_hash_value(tmp, tmp_len);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS(s);\n\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n       }\n       s++;\n       ptmp = tmp;\n      while (*s && *s != '\\\"')\n         *ptmp++ = *s++;\n       if (*s != '\\\"')\n         return -1;\n      s++; /* skip past the trailing \" */\n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n       s += 11;\n       SKIPWS(s);\n       ptmp = tmp;\n      while (isdigit((unsigned char) *s))\n         *ptmp++ = *s++;\n       *ptmp = '\\0';\n       if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      /* handle above, in msg_fetch_header */\n      return -2;\n    }\n    else if (*s == ')')\n      s++; /* end of request */\n    else if (*s)\n    {\n      /* got something i don't understand */\n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n\n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void sas_device_set_phy(struct domain_device *dev, struct sas_port *port)\n{\n\tstruct sas_ha_struct *ha;\n\tstruct sas_phy *new_phy;\n\n\tif (!dev)\n\t\treturn;\n\n\tha = dev->port->ha;\n\tnew_phy = sas_port_get_phy(port);\n\n\t/* pin and record last seen phy */\n\tspin_lock_irq(&ha->phy_port_lock);\n\tif (new_phy) {\n\t\tsas_port_put_phy(dev->phy);\n\t\tdev->phy = new_phy;\n\t}\n\tspin_unlock_irq(&ha->phy_port_lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void ssh_pkt_addstring_start(struct Packet *pkt)\n{\n    ssh_pkt_adduint32(pkt, 0);\n    pkt->savedpos = pkt->length;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int irq_cpu_hotplug_init(SCLPEvent *event)\n\n{\n\n    irq_cpu_hotplug = *qemu_allocate_irqs(trigger_signal, event, 1);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "hfs_file_read_zlib_rsrc(const TSK_FS_ATTR * a_fs_attr,\n    TSK_OFF_T a_offset, char *a_buf, size_t a_len)\n{\n    return hfs_file_read_compressed_rsrc(\n        a_fs_attr, a_offset, a_buf, a_len,\n        hfs_read_zlib_block_table,\n        hfs_decompress_zlib_block\n    );\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void buffer_release(struct videobuf_queue *vq,\n\t\t\t   struct videobuf_buffer *vb)\n{\n\tstruct zr364xx_buffer *buf = container_of(vb, struct zr364xx_buffer,\n\t\t\t\t\t\t  vb);\n\n\t_DBG(\"%s\\n\", __func__);\n\tfree_buffer(vq, buf);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "ffi_prep_closure_loc (ffi_closure *closure,\n                      ffi_cif* cif,\n                      void (*fun)(ffi_cif*,void*,void**,void*),\n                      void *user_data,\n                      void *codeloc)\n{\n  if (cif->abi != FFI_SYSV)\n    return FFI_BAD_ABI;\n\n  void (*start)(void);\n  \n  if (cif->flags & AARCH64_FLAG_ARG_V)\n    start = ffi_closure_SYSV_V;\n  else\n    start = ffi_closure_SYSV;\n\n#if FFI_EXEC_TRAMPOLINE_TABLE\n#ifdef __MACH__\n  void **config = (void **)((uint8_t *)codeloc - PAGE_MAX_SIZE);\n  config[0] = closure;\n  config[1] = start;\n#endif\n#else\n  static const unsigned char trampoline[16] = {\n    0x90, 0x00, 0x00, 0x58,\t/* ldr\tx16, tramp+16\t*/\n    0xf1, 0xff, 0xff, 0x10,\t/* adr\tx17, tramp+0\t*/\n    0x00, 0x02, 0x1f, 0xd6\t/* br\tx16\t\t*/\n  };\n  char *tramp = closure->tramp;\n  \n  memcpy (tramp, trampoline, sizeof(trampoline));\n  \n  *(UINT64 *)(tramp + 16) = (uintptr_t)start;\n\n  ffi_clear_cache(tramp, tramp + FFI_TRAMPOLINE_SIZE);\n#endif\n\n  closure->cif = cif;\n  closure->fun = fun;\n  closure->user_data = user_data;\n\n  return FFI_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\n\tif (!conn)\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %d\", conn, skb->len);\n\n\tif (skb->len) {\n\t\tsco_recv_frame(conn, skb);\n\t\treturn 0;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int xen_evtchn_cpu_prepare(unsigned int cpu)\n{\n\tint ret = 0;\n\n\tif (evtchn_ops->percpu_init)\n\t\tret = evtchn_ops->percpu_init(cpu);\n\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "grub_username_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  grub_printf (\"\\b\");\n\t  continue;\n\t}\n\n      if (!grub_isprint (key))\n\tcontinue;\n\n      if (cur_len + 2 < buf_size)\n\t{\n\t  buf[cur_len++] = key;\n\t  grub_printf (\"%c\", key);\n\t}\n    }\n\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n\n  return (key != '\\e');\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void OPPROTO op_idivb_AL_T0(void)\n\n{\n\n    int num, den, q, r;\n\n\n\n    num = (int16_t)EAX;\n\n    den = (int8_t)T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n    q = (num / den) & 0xff;\n\n    r = (num % den) & 0xff;\n\n    EAX = (EAX & ~0xffff) | (r << 8) | q;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "TEST( BSONValidateFast, Empty ) {\n        BSONObj x;\n        ASSERT_OK( validateBSON( x.objdata(), x.objsize() ) );\n    }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void js_dup(js_State *J)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP] = STACK[TOP-1];\n\t++TOP;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void GrpcHealthCheckerImpl::GrpcActiveHealthCheckSession::onGoAway(\n    Http::GoAwayErrorCode error_code) {\n  ENVOY_CONN_LOG(debug, \"connection going away health_flags={}\", *client_,\n                 HostUtility::healthFlagsToString(*host_));\n  // If we have an active health check probe and receive a GOAWAY indicating\n  // graceful shutdown, allow the probe to complete before closing the connection.\n  // The connection will be closed when the active check completes or another\n  // terminal condition occurs, such as a timeout or stream reset.\n  if (request_encoder_ && error_code == Http::GoAwayErrorCode::NoError) {\n    received_no_error_goaway_ = true;\n    return;\n  }\n\n  // Even if we have active health check probe, fail it on GOAWAY and schedule new one.\n  if (request_encoder_) {\n    handleFailure(envoy::data::core::v3::NETWORK);\n    expect_reset_ = true;\n    request_encoder_->getStream().resetStream(Http::StreamResetReason::LocalReset);\n  }\n  client_->close();\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n {\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n     double rounded;\n \n     if (code == gs_error_undefinedresult) {\n         /* The CTM is degenerate.\n            Can't know the distance in user space.\n    } else if (code < 0)\n        return code;\n    /* If the distance is very close to integers, round it. */\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void select_all_activities(struct activity *act[])\n{\n\tint i;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tact[i]->options |= AO_SELECTED;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void disable_config(void) {\n\tEUID_USER();\n#ifndef HAVE_ONLY_SYSCFG_PROFILES\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n#endif\n\n\t// disable run time information\n\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_PROFILE_DIR);\n\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n\tEUID_ROOT();\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void ConnectDialog::OnSortChanged(int logicalIndex, Qt::SortOrder) {\n\tif (logicalIndex != 2) {\n\t\treturn;\n\t}\n\n\tforeach(ServerItem *si, qlItems) {\n\t\tif (si->uiPing && (si->uiPing != si->uiPingSort)) {\n\t\t\tsi->uiPingSort = si->uiPing;\n\t\t\tsi->setDatas();\n\t\t}\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "gdm_session_start_reauthentication (GdmSession *session,\n                                    GPid        pid_of_caller,\n                                    uid_t       uid_of_caller)\n{\n        GdmSessionConversation *conversation = session->priv->session_conversation;\n\n        g_return_if_fail (conversation != NULL);\n\n        conversation->reauth_pid_of_caller = pid_of_caller;\n\n        gdm_dbus_worker_call_start_reauthentication (conversation->worker_proxy,\n                                                     (int) pid_of_caller,\n                                                     (int) uid_of_caller,\n                                                     NULL,\n                                                     (GAsyncReadyCallback) on_reauthentication_started_cb,\n                                                     conversation);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "gx_default_composite_is_friendly(const gs_composite_t *this, byte cmd0, byte cmd1)\n{\n    return false;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "OPJ_BOOL opj_j2k_end_compress(  opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager)\n{\n        /* customization of the encoding */\n        opj_j2k_setup_end_compress(p_j2k);\n\n        if (! opj_j2k_exec (p_j2k, p_j2k->m_procedure_list, p_stream, p_manager))\n        {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\n\t/* Init keys */\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\n\t/* Init periph */\n\tat91_aes_init();\n\n\t/* Check signature if required */\n\tif (is_signed) {\n\t\t/* Compute the CMAC */\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\n\t\t/* Check the CMAC */\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\n\t/* Decrypt the whole file */\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\n\trc = 0;\nexit:\n\t/* Reset periph */\n\tat91_aes_cleanup();\n\n\t/* Reset keys */\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {\n\tRConfigNode *node = NULL;\n\tchar *ov = NULL;\n\tut64 oi;\n\tif (!cfg || STRNULL (name)) {\n\t\treturn NULL;\n\t}\n\tnode = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->flags & CN_RO) {\n\t\t\teprintf (\"(error: '%s' config key is read only)\\n\", name);\n\t\t\treturn node;\n\t\t}\n\t\toi = node->i_value;\n\t\tif (node->value) {\n\t\t\tov = strdup (node->value);\n\t\t\tif (!ov) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (\"\");\n\t\t}\n\t\tif (node->flags & CN_BOOL) {\n\t\t\tbool b = is_true (value);\n\t\t\tnode->i_value = (ut64) b? 1: 0;\n\t\t\tchar *value = strdup (r_str_bool (b));\n\t\t\tif (value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = value;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = strdup (\"\");\n\t\t\t\tnode->i_value = 0;\n\t\t\t} else {\n \t\t\t\tif (node->value == value) {\n \t\t\t\t\tgoto beach;\n \t\t\t\t}\n\t\t\t\tfree (node->value);\n \t\t\t\tnode->value = strdup (value);\n \t\t\t\tif (IS_DIGIT (*value)) {\n \t\t\t\t\tif (strchr (value, '/')) {\n \t\t\t\t\t\tnode->i_value = r_num_get (cfg->num, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode->i_value = r_num_math (cfg->num, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnode->i_value = 0;\n\t\t\t\t}\n\t\t\t\tnode->flags |= CN_INT;\n\t\t\t}\n\t\t}\n\t} else { // Create a new RConfigNode\n\t\toi = UT64_MAX;\n\t\tif (!cfg->lock) {\n\t\t\tnode = r_config_node_new (name, value);\n\t\t\tif (node) {\n\t\t\t\tif (value && is_bool (value)) {\n\t\t\t\t\tnode->flags |= CN_BOOL;\n\t\t\t\t\tnode->i_value = is_true (value)? 1: 0;\n\t\t\t\t}\n\t\t\t\tif (cfg->ht) {\n\t\t\t\t\tht_insert (cfg->ht, node->name, node);\n\t\t\t\t\tr_list_append (cfg->nodes, node);\n\t\t\t\t\tcfg->n_nodes++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teprintf (\"r_config_set: unable to create a new RConfigNode\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"r_config_set: variable '%s' not found\\n\", name);\n\t\t}\n\t}\n\n\tif (node && node->setter) {\n\t\tint ret = node->setter (cfg->user, node);\n\t\tif (ret == false) {\n\t\t\tif (oi != UT64_MAX) {\n\t\t\t\tnode->i_value = oi;\n\t\t\t}\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (ov? ov: \"\");\n\t\t}\n\t}\nbeach:\n\tfree (ov);\n\treturn node;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void md_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct mddev *mddev = v;\n\n\tif (mddev && v != (void*)1 && v != (void*)2)\n\t\tmddev_put(mddev);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n {\n\tstruct list_head *tmp;\n \tstruct cifsSesInfo *ses;\n \n \twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n \t\t++ses->ses_count;\n \t\twrite_unlock(&cifs_tcp_ses_lock);\n \t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "**/\n    CImgDisplay& resize(const CImgDisplay& disp, const bool force_redraw=true) {\n      return resize(disp.width(),disp.height(),force_redraw);",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "bool HHVM_FUNCTION(hash_update, const Resource& context, const String& data) {\n  HashContext *hash = context.getTyped<HashContext>();\n  hash->ops->hash_update(hash->context, (unsigned char *)data.data(),\n                         data.size());\n  return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline int netlink_capable(const struct socket *sock, unsigned int flag)\n{\n\treturn (nl_table[sock->sk->sk_protocol].flags & flag) ||\n\t\tns_capable(sock_net(sock->sk)->user_ns, CAP_NET_ADMIN);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void tell_sector(void)\n{\n\tpr_cont(\": track %d, head %d, sector %d, size %d\",\n\t\tR_TRACK, R_HEAD, R_SECTOR, R_SIZECODE);\n}\t\t\t\t/* tell_sector */",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "long keyctl_revoke_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, 0, KEY_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey_revoke(key_ref_to_ptr(key_ref));\n\tret = 0;\n\n\tkey_ref_put(key_ref);\n error:\n\treturn ret;\n\n} /* end keyctl_revoke_key() */",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // There are two ways in which the 'output' can be made dynamic: it could be\n  // a string tensor, or its shape cannot be calculated during Prepare(). In\n  // either case, we now have all the information to calculate its shape.\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(context, ResizeOutput(context, node));\n  }\n\n  // Note that string tensors are always \"dynamic\" in the sense that their size\n  // is not known until we have all the content. This applies even when their\n  // shape is known ahead of time. As a result, a string tensor is never given\n  // any memory by ResizeOutput(), and we need to do it manually here. Since\n  // reshape doesn't change the data, the output tensor needs exactly as many\n  // bytes as the input tensor.\n  if (output->type == kTfLiteString) {\n    auto bytes_required = input->bytes;\n    TfLiteTensorRealloc(bytes_required, output);\n    output->bytes = bytes_required;\n  }\n\n  memcpy(output->data.raw, input->data.raw, input->bytes);\n\n  return kTfLiteOk;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "AuthenticatorClientPinTapAgainSheetModel(\n        AuthenticatorRequestDialogModel* dialog_model)\n    : AuthenticatorSheetModelBase(dialog_model) {}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int GetBlockForJpeg(void* param,\n                    unsigned long pos,\n                    unsigned char* buf,\n                    unsigned long size) {\n  std::vector<uint8_t>* data_vector = static_cast<std::vector<uint8_t>*>(param);\n  if (pos + size < pos || pos + size > data_vector->size())\n    return 0;\n  memcpy(buf, data_vector->data() + pos, size);\n  return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void contexts_free(struct drm_i915_private *i915)\n{\n\tstruct llist_node *freed = llist_del_all(&i915->contexts.free_list);\n\tstruct i915_gem_context *ctx, *cn;\n\n\tlockdep_assert_held(&i915->drm.struct_mutex);\n\n\tllist_for_each_entry_safe(ctx, cn, freed, free_link)\n\t\ti915_gem_context_free(ctx);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int ogg_read_close(AVFormatContext *s)\n\n{\n\n    struct ogg *ogg = s->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < ogg->nstreams; i++) {\n\n        av_free(ogg->streams[i].buf);\n\n        av_free(ogg->streams[i].private);\n\n    }\n\n    av_free(ogg->streams);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "GF_Err mfra_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, mfra_AddBox);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int tipc_sendmsg(struct socket *sock,\n\t\t\tstruct msghdr *m, size_t dsz)\n{\n\tstruct sock *sk = sock->sk;\n\tint ret;\n\n\tlock_sock(sk);\n\tret = __tipc_sendmsg(sock, m, dsz);\n\trelease_sock(sk);\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int chap_gen_challenge(\n\tstruct iscsi_conn *conn,\n\tint caller,\n\tchar *c_str,\n\tunsigned int *c_len)\n{\n\tint ret;\n\tunsigned char challenge_asciihex[CHAP_CHALLENGE_LENGTH * 2 + 1];\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\n\tmemset(challenge_asciihex, 0, CHAP_CHALLENGE_LENGTH * 2 + 1);\n\n\tret = get_random_bytes_wait(chap->challenge, CHAP_CHALLENGE_LENGTH);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tchap_binaryhex_to_asciihex(challenge_asciihex, chap->challenge,\n\t\t\t\tCHAP_CHALLENGE_LENGTH);\n\t/*\n\t * Set CHAP_C, and copy the generated challenge into c_str.\n\t */\n\t*c_len += sprintf(c_str + *c_len, \"CHAP_C=0x%s\", challenge_asciihex);\n\t*c_len += 1;\n\n\tpr_debug(\"[%s] Sending CHAP_C=0x%s\\n\\n\", (caller) ? \"server\" : \"client\",\n\t\t\tchallenge_asciihex);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void DetectFlow(ThreadVars *tv,\n                        DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,\n                        Packet *p)\n {\n    /* No need to perform any detection on this packet, if the the given flag is set.*/\n    if ((p->flags & PKT_NOPACKET_INSPECTION) ||\n        (PACKET_TEST_ACTION(p, ACTION_DROP)))\n    {\n         /* hack: if we are in pass the entire flow mode, we need to still\n          * update the inspect_id forward. So test for the condition here,\n          * and call the update code if necessary. */\n        const int pass = ((p->flow->flags & FLOW_NOPACKET_INSPECTION));\n        const AppProto alproto = FlowGetAppProtocol(p->flow);\n        if (pass && AppLayerParserProtocolSupportsTxs(p->proto, alproto)) {\n            uint8_t flags;\n            if (p->flowflags & FLOW_PKT_TOSERVER) {\n                flags = STREAM_TOSERVER;\n            } else {\n                flags = STREAM_TOCLIENT;\n            }\n             flags = FlowGetDisruptionFlags(p->flow, flags);\n             DeStateUpdateInspectTransactionId(p->flow, flags, true);\n         }\n         return;\n     }\n \n    /* see if the packet matches one or more of the sigs */\n    (void)DetectRun(tv, de_ctx, det_ctx, p);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int assigned_device_enable_guest_msi(struct kvm *kvm,\n\t\t\tstruct kvm_assigned_dev_kernel *dev,\n\t\t\tstruct kvm_assigned_irq *irq)\n{\n\tdev->guest_irq = irq->guest_irq;\n\tdev->ack_notifier.gsi = -1;\n\tdev->host_irq_disabled = false;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void RendererSchedulerImpl::PauseRendererImpl() {\n  helper_.CheckOnValidThread();\n  if (helper_.IsShutdown())\n    return;\n\n  ++main_thread_only().renderer_pause_count;\n  UpdatePolicy();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long start,\n\t\t\t\t\t unsigned long end,\n\t\t\t\t\t long adjust_next)\n{\n\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n\t\treturn;\n\t__vma_adjust_trans_huge(vma, start, end, adjust_next);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int try_rshrink_left(MAIN_WINDOW_REC *window, int count)\n{\n\tMAIN_WINDOW_REC *shrink_win;\n\n\tshrink_win = mainwindows_find_left(window, FALSE);\n\tif (shrink_win != NULL) {\n\t\tif (MAIN_WINDOW_TEXT_WIDTH(shrink_win)-count < NEW_WINDOW_WIDTH) {\n\t\t\treturn FALSE;\n\t\t}\n\t\twindow->first_column -= count;\n\t\tshrink_win->last_column -= count;\n\n\t\tmainwindows_rresize_two(window, shrink_win, count);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "struct hd_struct *disk_get_part(struct gendisk *disk, int partno)\n{\n\tstruct hd_struct *part = NULL;\n\tstruct disk_part_tbl *ptbl;\n\n\tif (unlikely(partno < 0))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\n\tptbl = rcu_dereference(disk->part_tbl);\n\tif (likely(partno < ptbl->len)) {\n\t\tpart = rcu_dereference(ptbl->part[partno]);\n\t\tif (part)\n\t\t\tget_device(part_to_dev(part));\n\t}\n\n\trcu_read_unlock();\n\n\treturn part;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void MD5::encodeDataIncrementally(char const* data, int len)\n{\n    update(QUtil::unsigned_char_pointer(data), len);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void sum_init(int csum_type, int seed)\n{\n\tchar s[4];\n\n\tif (csum_type < 0)\n\t\tcsum_type = parse_csum_name(NULL, 0);\n\tcursum_type = csum_type;\n\n\tswitch (csum_type) {\n\t  case CSUM_MD5:\n\t\tmd5_begin(&md);\n\t\tbreak;\n\t  case CSUM_MD4:\n\t\tmdfour_begin(&md);\n\t\tsumresidue = 0;\n\t\tbreak;\n\t  case CSUM_MD4_OLD:\n\t  case CSUM_MD4_BUSTED:\n\t\tmdfour_begin(&md);\n\t\tsumresidue = 0;\n\t\tSIVAL(s, 0, seed);\n\t\tsum_update(s, 4);\n\t\tbreak;\n\t  case CSUM_NONE:\n\t\tbreak;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i;\n\n\tvcpu_load(vcpu);\n\n\tdown_read(&vcpu->kvm->slots_lock);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tup_read(&vcpu->kvm->slots_lock);\n\n\tvcpu_put(vcpu);\n\n\treturn i;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void vmx_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tunsigned long guest_cr3;\n\tu64 eptp;\n\n\tguest_cr3 = cr3;\n\tif (vm_need_ept()) {\n\t\teptp = construct_eptp(cr3);\n\t\tvmcs_write64(EPT_POINTER, eptp);\n\t\tept_sync_context(eptp);\n\t\tept_load_pdptrs(vcpu);\n\t\tguest_cr3 = is_paging(vcpu) ? vcpu->arch.cr3 :\n\t\t\tVMX_EPT_IDENTITY_PAGETABLE_ADDR;\n\t}\n\n\tvmx_flush_tlb(vcpu);\n\tvmcs_writel(GUEST_CR3, guest_cr3);\n\tif (vcpu->arch.cr0 & X86_CR0_PE)\n\t\tvmx_fpu_deactivate(vcpu);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int acpi_gsi_to_irq(u32 gsi, unsigned int *irqp)\n{\n\tint rc, irq, trigger, polarity;\n\n\tif (acpi_irq_model == ACPI_IRQ_MODEL_PIC) {\n\t\t*irqp = gsi;\n\t\treturn 0;\n\t}\n\n\trc = acpi_get_override_irq(gsi, &trigger, &polarity);\n\tif (rc == 0) {\n\t\ttrigger = trigger ? ACPI_LEVEL_SENSITIVE : ACPI_EDGE_SENSITIVE;\n\t\tpolarity = polarity ? ACPI_ACTIVE_LOW : ACPI_ACTIVE_HIGH;\n\t\tirq = acpi_register_gsi(NULL, gsi, trigger, polarity);\n\t\tif (irq >= 0) {\n\t\t\t*irqp = irq;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void __exit wanxl_cleanup_module(void)\n{\n\tpci_unregister_driver(&wanxl_pci_driver);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int max_sectors_bytes(struct request_queue *q)\n{\n\tunsigned int max_sectors = queue_max_sectors(q);\n\n\tmax_sectors = min_t(unsigned int, max_sectors, INT_MAX >> 9);\n\n\treturn max_sectors << 9;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void DelegatedFrameHost::ResetCompositor() {\n  if (!compositor_)\n    return;\n  resize_lock_.reset();\n  if (compositor_->HasObserver(this))\n    compositor_->RemoveObserver(this);\n  if (vsync_manager_) {\n    vsync_manager_->RemoveObserver(this);\n    vsync_manager_ = nullptr;\n  }\n\n  compositor_->RemoveFrameSink(frame_sink_id_);\n  compositor_ = nullptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\n\t/* check the quota and attach the new data */\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attach the new data, displacing the old */\n\tkey->expiry = prep->expiry;\n\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "fbCombineDisjointInC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    fbCombineDisjointGeneralC (dest, src, mask, width, CombineAIn);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek (ifp, 0, SEEK_SET);\n  for (i=0; i < 1024; i++) {\n    fread (t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4\n\t& t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline void pfkey_hdr_dup(struct sadb_msg *new,\n\t\t\t\t const struct sadb_msg *orig)\n{\n\t*new = *orig;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void HTMLMediaElement::SetSrcObject(MediaStreamDescriptor* src_object) {\n  BLINK_MEDIA_LOG << \"setSrcObject(\" << (void*)this << \")\";\n  src_object_ = src_object;\n  InvokeLoadAlgorithm();\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int dib7070_tuner_reset(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\treturn state->dib7000p_ops.set_gpio(fe, 8, 0, !onoff);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "struct resource_pool *dce112_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "XdmcpGenerateKey (XdmAuthKeyPtr key)\n{\n #ifndef HAVE_ARC4RANDOM_BUF\n     long    lowbits, highbits;\n \n     srandom ((int)getpid() ^ time((Time_t *)0));\n    highbits = random ();\n     highbits = random ();\n     getbits (lowbits, key->data);\n     getbits (highbits, key->data + 4);\n#else\n     arc4random_buf(key->data, 8);\n#endif\n }",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "inline unsigned int openmp_mode(const unsigned int mode) {\n      return openmp_mode(mode,true);\n    }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void pcpu_map_extend_workfn(struct work_struct *work)\n{\n\tstruct pcpu_chunk *chunk = container_of(work, struct pcpu_chunk,\n\t\t\t\t\t\tmap_extend_work);\n\tint new_alloc;\n\n\tspin_lock_irq(&pcpu_lock);\n\tnew_alloc = pcpu_need_to_extend(chunk, false);\n\tspin_unlock_irq(&pcpu_lock);\n\n\tif (new_alloc)\n\t\tpcpu_extend_area_map(chunk, new_alloc);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "nm_wildcard_match_check(const char *str, const char *const *patterns, guint num_patterns)\n{\n    gboolean has_optional     = FALSE;\n    gboolean has_any_optional = FALSE;\n    guint    i;\n\n    for (i = 0; i < num_patterns; i++) {\n        gboolean    is_inverted;\n        gboolean    is_mandatory;\n        gboolean    match;\n        const char *p;\n\n        _pattern_parse(patterns[i], &p, &is_inverted, &is_mandatory);\n\n        match = (fnmatch(p, str, 0) == 0);\n        if (is_inverted)\n            match = !match;\n\n        if (is_mandatory) {\n            if (!match)\n                return FALSE;\n        } else {\n            has_any_optional = TRUE;\n            if (match)\n                has_optional = TRUE;\n        }\n    }\n\n    return has_optional || !has_any_optional;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "sp<IMediaCodecList> MediaPlayerService::getCodecList() const {\n return MediaCodecList::getLocalInstance();\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline void store_cpu_offset(TCGv var, int offset)\n\n{\n\n    tcg_gen_st_i32(var, cpu_env, offset);\n\n    dead_tmp(var);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ofproto_get_ipfix_stats(struct ofproto *ofproto,\n                        bool bridge_ipfix,\n                        struct ovs_list *replies)\n{\n    int error;\n\n    if (ofproto->ofproto_class->get_ipfix_stats) {\n        error = ofproto->ofproto_class->get_ipfix_stats(ofproto,\n                                                          bridge_ipfix,\n                                                          replies);\n    } else {\n        error = EOPNOTSUPP;\n    }\n\n    return error;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "ByteOrder Casio2MnHeader::byteOrder() const\n    {\n        return byteOrder_;\n    }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int normalize_samples(AC3EncodeContext *s)\n\n{\n\n    int v = 14 - log2_tab(s, s->windowed_samples, AC3_WINDOW_SIZE);\n\n    lshift_tab(s->windowed_samples, AC3_WINDOW_SIZE, v);\n\n    return v - 9;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)\n{\n\tstruct rtattr *rta;\n\tint size = RTA_LENGTH(attrlen);\n\n\trta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));\n\trta->rta_type = attrtype;\n\trta->rta_len = size;\n\tmemcpy(RTA_DATA(rta), data, attrlen);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "ModuleExport void UnregisterRLAImage(void)\n{\n  (void) UnregisterMagickInfo(\"RLA\");\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void bpf_iter_fini_hash_map(void *priv_data)\n{\n\tstruct bpf_iter_seq_hash_map_info *seq_info = priv_data;\n\n\tkfree(seq_info->percpu_value_buf);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "TiffBinaryElement::~TiffBinaryElement()\n    {\n    }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "encode_STACK_op(const struct ofpact_stack *stack_action,\n                struct nx_action_stack *nasp)\n{\n    struct ofpbuf b;\n    ovs_be16 n_bits;\n\n    nasp->offset = htons(stack_action->subfield.ofs);\n\n    ofpbuf_use_stack(&b, nasp, ntohs(nasp->len));\n    ofpbuf_put_uninit(&b, OBJECT_OFFSETOF(nasp, pad));\n    nx_put_mff_header(&b, stack_action->subfield.field, 0, false);\n    n_bits = htons(stack_action->subfield.n_bits);\n    ofpbuf_put(&b, &n_bits, sizeof n_bits);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int get_debug_info(struct PE_(r_bin_pe_obj_t)* bin, PE_(image_debug_directory_entry)* dbg_dir_entry, ut8* dbg_data, int dbg_data_len, SDebugInfo* res) {\n\t#define SIZEOF_FILE_NAME 255\n\tint i = 0;\n\tconst char* basename;\n\tif (!dbg_data) {\n\t\treturn 0;\n\t}\n\tswitch (dbg_dir_entry->Type) {\n\tcase IMAGE_DEBUG_TYPE_CODEVIEW:\n\t\tif (!strncmp ((char*) dbg_data, \"RSDS\", 4)) {\n\t\t\tSCV_RSDS_HEADER rsds_hdr;\n\t\t\tinit_rsdr_hdr (&rsds_hdr);\n\t\t\tif (!get_rsds (dbg_data, dbg_data_len, &rsds_hdr)) {\n\t\t\t\tbprintf (\"Warning: Cannot read PE debug info\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsnprintf (res->guidstr, GUIDSTR_LEN,\n\t\t\t\t\"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x\",\n\t\t\t\trsds_hdr.guid.data1,\n\t\t\t\trsds_hdr.guid.data2,\n\t\t\t\trsds_hdr.guid.data3,\n\t\t\t\trsds_hdr.guid.data4[0],\n\t\t\t\trsds_hdr.guid.data4[1],\n\t\t\t\trsds_hdr.guid.data4[2],\n\t\t\t\trsds_hdr.guid.data4[3],\n\t\t\t\trsds_hdr.guid.data4[4],\n\t\t\t\trsds_hdr.guid.data4[5],\n\t\t\t\trsds_hdr.guid.data4[6],\n\t\t\t\trsds_hdr.guid.data4[7],\n\t\t\t\trsds_hdr.age);\n\t\t\tbasename = r_file_basename ((char*) rsds_hdr.file_name);\n\t\t\tstrncpy (res->file_name, (const char*)\n\t\t\t\tbasename, sizeof (res->file_name));\n \t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n \t\t\trsds_hdr.free ((struct SCV_RSDS_HEADER*) &rsds_hdr);\n \t\t} else if (strncmp ((const char*) dbg_data, \"NB10\", 4) == 0) {\n\t\t\tSCV_NB10_HEADER nb10_hdr;\n \t\t\tinit_cv_nb10_header (&nb10_hdr);\n \t\t\tget_nb10 (dbg_data, &nb10_hdr);\n \t\t\tsnprintf (res->guidstr, sizeof (res->guidstr),\n \t\t\t\t\"%x%x\", nb10_hdr.timestamp, nb10_hdr.age);\n\t\t\tstrncpy (res->file_name, (const char*)\n\t\t\t\tnb10_hdr.file_name, sizeof(res->file_name) - 1);\n \t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n \t\t\tnb10_hdr.free ((struct SCV_NB10_HEADER*) &nb10_hdr);\n \t\t} else {\n\t\t\tbprintf (\"CodeView section not NB10 or RSDS\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\twhile (i < 33) {\n\t\tres->guidstr[i] = toupper ((int) res->guidstr[i]);\n\t\ti++;\n\t}\n\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ofputil_bucket_clone_list(struct ovs_list *dest, const struct ovs_list *src,\n                          const struct ofputil_bucket *skip)\n{\n    struct ofputil_bucket *bucket;\n\n    LIST_FOR_EACH (bucket, list_node, src) {\n        struct ofputil_bucket *new_bucket;\n\n        if (bucket == skip) {\n            continue;\n        }\n\n        new_bucket = ofputil_bucket_clone_data(bucket);\n        ovs_list_push_back(dest, &new_bucket->list_node);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline int drff_init(struct hid_device *hid)\n{\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void __fastcall TSCPFileSystem::ClearCaches()\r\n{\r\n  // noop\r\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "GBool CharCodeToUnicode::match(GString *tagA) {\n  return tag && !tag->cmp(tagA);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "DeepScanLineInputFile::DeepScanLineInputFile(InputPartData* part)\n    \n{\n\n    _data = new Data(part->numThreads);\n    _data->_deleteStream=false;\n    _data->_streamData = part->mutex;\n    _data->memoryMapped = _data->_streamData->is->isMemoryMapped();\n    _data->version = part->version;\n\n    initialize(part->header);\n\n    _data->lineOffsets = part->chunkOffsets;\n\n    _data->partNumber = part->partNumber;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void __exit cast6_mod_fini(void)\n{\n\tcrypto_unregister_alg(&alg);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void helper_idivq_EAX_T0(void)\n\n{\n\n    uint64_t r0, r1;\n\n    if (T0 == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n    r0 = EAX;\n\n    r1 = EDX;\n\n    idiv64(&r0, &r1, T0);\n\n    EAX = r0;\n\n    EDX = r1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int shash_finup_unaligned(struct shash_desc *desc, const u8 *data,\n\t\t\t\t unsigned int len, u8 *out)\n{\n\treturn crypto_shash_update(desc, data, len) ?:\n\t       crypto_shash_final(desc, out);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\n\t/* Serialize all requests */\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "dma_addr_t map_descbuffer(struct b43_dmaring *ring,\n\t\t\t      unsigned char *buf, size_t len, int tx)\n{\n\tdma_addr_t dmaaddr;\n\n\tif (tx) {\n\t\tdmaaddr = dma_map_single(ring->dev->dev->dma_dev,\n\t\t\t\t\t buf, len, DMA_TO_DEVICE);\n\t} else {\n\t\tdmaaddr = dma_map_single(ring->dev->dev->dma_dev,\n\t\t\t\t\t buf, len, DMA_FROM_DEVICE);\n\t}\n\n\treturn dmaaddr;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void onRssiThresholdbreached(wifi_request_id id, u8 *cur_bssid, s8 cur_rssi) {\n\n    ALOGD(\"RSSI threshold breached, cur RSSI - %d!!\\n\", cur_rssi);\n    ALOGD(\"BSSID %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n            cur_bssid[0], cur_bssid[1], cur_bssid[2],\n            cur_bssid[3], cur_bssid[4], cur_bssid[5]);\n JNIHelper helper(mVM);\n    helper.reportEvent(mCls, \"onRssiThresholdBreached\", \"(IB)V\", id, cur_rssi);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int regulator_register_notifier(struct regulator *regulator,\n\t\t\t      struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&regulator->rdev->notifier,\n\t\t\t\t\t\tnb);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "BPF_CALL_1(bpf_get_hash_recalc, struct sk_buff *, skb)\n{\n\t/* If skb_clear_hash() was called due to mangling, we can\n\t * trigger SW recalculation here. Later access to hash\n\t * can then use the inline skb->hash via context directly\n\t * instead of calling this helper again.\n\t */\n\treturn skb_get_hash(skb);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int32_t ByteArray::Get(int32_t index) {\n  return InternalGet(index) & 0xff;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "bool IsOnTheSameDevice(const OptimizedNodesGroup& group,\n                         const NodeDef& node) const {\n    return group.root_node->device() == node.device();\n  }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xff) == cJSON_True;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "MagickExport MagickBooleanType GetDelegateThreadSupport(\n  const DelegateInfo *delegate_info)\n{\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n\n  assert(delegate_info != (DelegateInfo *) NULL);\n  assert(delegate_info->signature == MagickCoreSignature);\n  return(delegate_info->thread_support);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "box_right(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPgt(box1->low.x, box2->high.x));\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "lspci_process(STREAM s)\n{\n \tunsigned int pkglen;\n \tstatic char *rest = NULL;\n \tchar *buf;\n \n \tpkglen = s->end - s->p;\n \t/* str_handle_lines requires null terminated strings */\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &rest, lspci_process_line, NULL);\n\txfree(buf);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static bool is_ctx_reg(struct bpf_verifier_env *env, int regno)\n{\n\tconst struct bpf_reg_state *reg = cur_regs(env) + regno;\n\n\treturn reg->type == PTR_TO_CTX;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "MODRET set_allowchrootsymlinks(cmd_rec *cmd) {\n  int b = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  b = get_boolean(cmd, 1);\n  if (b == -1) {\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n  }\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(int));\n  *((int *) c->argv[0]) = b;\n\n  return PR_HANDLED(cmd);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "sshpkt_put_u64(struct ssh *ssh, u_int64_t val)\n{\n\treturn sshbuf_put_u64(ssh->state->outgoing_packet, val);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void QueryManager::StartTracking(QueryManager::Query* /* query */) {\n  ++query_count_;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "netdutils::Status XfrmController::flushPolicyDb(const XfrmSocket& s) {\n    std::vector<iovec> iov = {{NULL, 0}}; // reserved for the eventual addition of a NLMSG_HDR\n return s.sendMessage(XFRM_MSG_FLUSHPOLICY, NETLINK_REQUEST_FLAGS, 0, &iov);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void TrayPower::OnPowerStatusChanged(const PowerSupplyStatus& status) {\n  if (power_tray_.get())\n    power_tray_->UpdatePowerStatus(status);\n  if (power_.get())\n    power_->UpdatePowerStatus(status);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int rsa_pkcs1_sign( rsa_context *ctx,\n                    int (*f_rng)(void *, unsigned char *, size_t),\n                    void *p_rng,\n                    int mode,\n                    int hash_id,\n                    unsigned int hashlen,\n                    const unsigned char *hash,\n                    unsigned char *sig )\n{\n    switch( ctx->padding )\n    {\n        case RSA_PKCS_V15:\n            return rsa_rsassa_pkcs1_v15_sign( ctx, mode, hash_id,\n                                              hashlen, hash, sig );\n\n#if defined(POLARSSL_PKCS1_V21)\n        case RSA_PKCS_V21:\n            return rsa_rsassa_pss_sign( ctx, f_rng, p_rng, mode, hash_id,\n                                        hashlen, hash, sig );\n#endif\n\n        default:\n            return( POLARSSL_ERR_RSA_INVALID_PADDING );\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static struct dirent *local_readdir(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    struct dirent *entry;\n\nagain:\n    entry = readdir(fs->dir.stream);\n    if (!entry) {\n        return NULL;\n    }\n\n    if (ctx->export_flags & V9FS_SM_MAPPED) {\n        entry->d_type = DT_UNKNOWN;\n    } else if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n        if (!strcmp(entry->d_name, VIRTFS_META_DIR)) {\n            /* skp the meta data directory */\n            goto again;\n        }\n        entry->d_type = DT_UNKNOWN;\n    }\n\n    return entry;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "gpgsm_clear_fd (engine_gpgsm_t gpgsm, fd_type_t fd_type)\n{\n#if !USE_DESCRIPTOR_PASSING\n  switch (fd_type)\n    {\n    case INPUT_FD:\n      _gpgme_io_close (gpgsm->input_cb.fd);\n      break;\n    case OUTPUT_FD:\n      _gpgme_io_close (gpgsm->output_cb.fd);\n      break;\n    case MESSAGE_FD:\n      _gpgme_io_close (gpgsm->message_cb.fd);\n      break;\n    }\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "table_map Item_direct_view_ref::not_null_tables() const\n{\n  return get_depended_from() ?\n         0 :\n         ((view->is_merged_derived() || view->merged || !view->table) ?\n          (*ref)->not_null_tables() :\n          view->table->map);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "explicit RemoveLogicalNotStage(const GraphOptimizerContext& ctx,\n                                 const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"RemoveLogicalNot\", ctx, ctx_ext) {}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void testPervertedQueryString() {\n\t\thelperTestQueryString(\"http://example.org/?&&=&&&=&&&&==&===&====\", 5);\n\t}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "rsvg_new_filter_primitive_blend (void)\n{\n    RsvgFilterPrimitiveBlend *filter;\n    filter = g_new (RsvgFilterPrimitiveBlend, 1);\n    _rsvg_node_init (&filter->super.super);\n    filter->mode = normal;\n    filter->super.in = g_string_new (\"none\");\n    filter->in2 = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =\n        filter->super.height.factor = 'n';\n    filter->super.render = &rsvg_filter_primitive_blend_render;\n    filter->super.super.free = &rsvg_filter_primitive_blend_free;\n    filter->super.super.set_atts = rsvg_filter_primitive_blend_set_atts;\n    return (RsvgNode *) filter;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void Sp_match(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint len;\n\tconst char *a, *b, *c, *e;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\n\tre = js_toregexp(J, -1);\n\tif (!(re->flags & JS_REGEXP_G)) {\n\t\tjs_RegExp_prototype_exec(J, re, text);\n\t\treturn;\n\t}\n\n\tre->last = 0;\n\n\tjs_newarray(J);\n\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a <= e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\n\t\tjs_pushlstring(J, b, c - b);\n\t\tjs_setindex(J, -2, len++);\n\n\t\ta = c;\n\t\tif (c - b == 0)\n\t\t\t++a;\n\t}\n\n\tif (len == 0) {\n\t\tjs_pop(J, 1);\n\t\tjs_pushnull(J);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void ahci_start_dma(IDEDMA *dma, IDEState *s,\n\n                           BlockCompletionFunc *dma_cb)\n\n{\n\n#ifdef DEBUG_AHCI\n\n    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n\n#endif\n\n    DPRINTF(ad->port_no, \"\\n\");\n\n    s->io_buffer_offset = 0;\n\n    dma_cb(s, 0);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "CMD_FUNC(m_authenticate)\n{\n\taClient *agent_p = NULL;\n\n\t/* Failing to use CAP REQ for sasl is a protocol violation. */\n\tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))\n\t\treturn 0;\n\n\tif (sptr->local->sasl_complete)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n \t\treturn 0;\n \t}\n \n \tif (strlen(parv[1]) > 400)\n \t{\n \t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\n\tif (*sptr->local->sasl_agent)\n\t\tagent_p = find_client(sptr->local->sasl_agent, NULL);\n\n\tif (agent_p == NULL)\n\t{\n\t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;\n\t\tchar *certfp = moddata_client_get(sptr, \"certfp\");\n\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",\n\t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);\n\n\t\tif (certfp)\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);\n\t\telse\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);\n\t}\n\telse\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",\n\t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);\n\n\tsptr->local->sasl_out++;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "template<typename tp, typename tc, typename to>\n    CImg<T>& CImg3dtoobject3d(CImgList<tp>& primitives,\n                              CImgList<tc>& colors,\n                              CImgList<to>& opacities,\n                              const bool full_check=true) {\n      return get_CImg3dtoobject3d(primitives,colors,opacities,full_check).move_to(*this);",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool DebuggerFunction::InitClientHost() {\n  if (!InitAgentHost())\n    return false;\n\n  client_host_ = FindClientHost();\n  if (!client_host_) {\n    FormatErrorMessage(debugger_api_constants::kNotAttachedError);\n    return false;\n  }\n\n  return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static Token *zap_white(Token *x)\n{\n    while (tok_white(x))\n        x = delete_Token(x);\n\n    return x;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n \tint ret;\n \tint chk_addr_ret;\n \n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n \tif (addr_len < sizeof(struct sockaddr_l2tpip))\n \t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\n \tread_unlock_bh(&l2tp_ip_lock);\n \n \tlock_sock(sk);\n \tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n \t\tgoto out;\n \n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  /* Use device */\n\tsk_dst_reset(sk);\n\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn ret;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void sysbus_esp_mem_write(void *opaque, hwaddr addr,\n                                 uint64_t val, unsigned int size)\n{\n    SysBusESPState *sysbus = opaque;\n    ESPState *s = ESP(&sysbus->esp);\n    uint32_t saddr;\n\n    saddr = addr >> sysbus->it_shift;\n    esp_reg_write(s, saddr, val);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static always_inline void gen_op_subfco (void)\n\n{\n\n    gen_op_move_T2_T0();\n\n    gen_op_subf();\n\n    gen_op_check_subfc();\n\n    gen_op_check_subfo();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void usb_msd_cancel_io(USBPacket *p, void *opaque)\n\n{\n\n    MSDState *s = opaque;\n\n    s->scsi_dev->info->cancel_io(s->scsi_dev, s->tag);\n\n    s->packet = NULL;\n\n    s->scsi_len = 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "error_white_both(char_u *op, int len)\n{\n    char_u\tbuf[10];\n\n    vim_strncpy(buf, op, len);\n    semsg(_(e_white_space_required_before_and_after_str_at_str), buf, op);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "EbmlUnicodeString::EbmlUnicodeString()\n  :EbmlElement(0, false)\n{\n  SetDefaultSize(0);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static MagickBooleanType ConcatenateImages(int argc,char **argv,\n     ExceptionInfo *exception )\n {\n   FILE\n     *input,\n     *output;\n \n   int\n     c;\n \n  register ssize_t\n    i;\n \n   if (ExpandFilenames(&argc,&argv) == MagickFalse)\n     ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n         GetExceptionMessage(errno));\n   output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL) {\n    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n    return(MagickFalse);\n  }\n  for (i=2; i < (ssize_t) (argc-1); i++) {\n#if 0\n    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n#endif\n     input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL) {\n         ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n         continue;\n       }\n     for (c=fgetc(input); c != EOF; c=fgetc(input))\n      (void) fputc((char) c,output);\n     (void) fclose(input);\n     (void) remove_utf8(argv[i]);\n   }\n   (void) fclose(output);\n  return(MagickTrue);\n }",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int32_t ide_nop_int32(IDEDMA *dma, int x)\n\n{\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\n\tkfree(old);\n\n\treturn count;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "PackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    if (s < t || file_size < (off_t)s\n    ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)\n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int ConnectionImpl::onFrameSend(const nghttp2_frame* frame) {\n  // The nghttp2 library does not cleanly give us a way to determine whether we received invalid\n  // data from our peer. Sometimes it raises the invalid frame callback, and sometimes it does not.\n  // In all cases however it will attempt to send a GOAWAY frame with an error status. If we see\n  // an outgoing frame of this type, we will return an error code so that we can abort execution.\n  ENVOY_CONN_LOG(trace, \"sent frame type={}\", connection_, static_cast<uint64_t>(frame->hd.type));\n  switch (frame->hd.type) {\n  case NGHTTP2_GOAWAY: {\n    ENVOY_CONN_LOG(debug, \"sent goaway code={}\", connection_, frame->goaway.error_code);\n    if (frame->goaway.error_code != NGHTTP2_NO_ERROR) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    break;\n  }\n\n  case NGHTTP2_RST_STREAM: {\n    ENVOY_CONN_LOG(debug, \"sent reset code={}\", connection_, frame->rst_stream.error_code);\n    stats_.tx_reset_.inc();\n    break;\n  }\n\n  case NGHTTP2_HEADERS:\n  case NGHTTP2_DATA: {\n    StreamImpl* stream = getStream(frame->hd.stream_id);\n    stream->local_end_stream_sent_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n    break;\n  }\n  }\n\n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void qmp_input_type_any(Visitor *v, const char *name, QObject **obj,\n                               Error **errp)\n{\n    QmpInputVisitor *qiv = to_qiv(v);\n    QObject *qobj = qmp_input_get_object(qiv, name, true);\n    qobject_incref(qobj);\n    *obj = qobj;",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "Magick::PixelInterpolateMethod Magick::Image::interpolate(void) const\n{\n  return constImage()->interpolate;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void Curl_polarssl_cleanup(void)\n{\n  (void)Curl_polarsslthreadlock_thread_cleanup();\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static cycle_t kvm_clock_read(void)\n{\n\tstruct pvclock_vcpu_time_info *src;\n\tcycle_t ret;\n\tint cpu;\n\n\tpreempt_disable_notrace();\n\tcpu = smp_processor_id();\n\tsrc = &hv_clock[cpu].pvti;\n\tret = pvclock_clocksource_read(src);\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "im_vips2dz( IMAGE *in, const char *filename )\n{\n\tchar *p, *q;\n\tchar name[FILENAME_MAX];\n\tchar mode[FILENAME_MAX];\n\tchar buf[FILENAME_MAX];\n\n\tint i;\n\tVipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; \n\tchar *suffix = \".jpeg\";\n\tint overlap = 0;\n\tint tile_size = 256;\n\tVipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; \n\tgboolean centre = FALSE;\n\tVipsAngle angle = VIPS_ANGLE_D0; \n\n\t/* We can't use im_filename_split() --- it assumes that we have a\n\t * filename with an extension before the ':', and filename here is\n\t * actually a dirname.\n\t *\n\t * Just split on the first ':'.\n\t */\n\tim_strncpy( name, filename, FILENAME_MAX ); \n\tif( (p = strchr( name, ':' )) ) {\n\t\t*p = '\\0';\n\t\tim_strncpy( mode, p + 1, FILENAME_MAX ); \n\t}\n\n\tstrcpy( buf, mode ); \n\tp = &buf[0];\n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_LAYOUT, q )) < 0 ) \n\t\t\treturn( -1 );\n\t\tlayout = i;\n\t}\n\n\tif( (q = im_getnextoption( &p )) ) \n\t\tsuffix = g_strdup( q );\n\tif( (q = im_getnextoption( &p )) ) \n\t\toverlap = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) \n\t\ttile_size = atoi( q ); \n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_DEPTH, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tdepth = i;\n\t}\n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( im_isprefix( \"cen\", q ) ) \n\t\t\tcentre = TRUE;\n\t}\n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_ANGLE, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tangle = i;\n\t}\n\n\tif( vips_dzsave( in, name,\n\t\t\"layout\", layout,\n\t\t\"suffix\", suffix,\n\t\t\"overlap\", overlap,\n\t\t\"tile_size\", tile_size,\n\t\t\"depth\", depth,\n\t\t\"centre\", centre,\n\t\t\"angle\", angle,\n\t\tNULL ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "status_t Parcel::writeUtf8VectorAsUtf16Vector(const std::vector<std::string>& val) {\n return writeTypedVector(val, &Parcel::writeUtf8AsUtf16);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int phar_file_type(HashTable *mimes, char *file, char **mime_type) /* {{{ */\n{\n\tchar *ext;\n\tphar_mime_type *mime;\n\text = strrchr(file, '.');\n\tif (!ext) {\n\t\t*mime_type = \"text/plain\";\n\t\t/* no file extension = assume text/plain */\n\t\treturn PHAR_MIME_OTHER;\n\t}\n\t++ext;\n\tif (NULL == (mime = zend_hash_str_find_ptr(mimes, ext, strlen(ext)))) {\n\t\t*mime_type = \"application/octet-stream\";\n\t\treturn PHAR_MIME_OTHER;\n\t}\n\t*mime_type = mime->mime;\n\treturn mime->type;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "R_API void r_bin_java_bootstrap_method_argument_free(void /*RBinJavaBootStrapArgument*/ *b) {\n\tRBinJavaBootStrapArgument *bsm_arg = b;\n\tif (bsm_arg) {\n\t\tif (bsm_arg->argument_info_cp_obj) {\n\t\t\t((RBinJavaCPTypeMetas *) bsm_arg->argument_info_cp_obj)->allocs->delete_obj (bsm_arg->argument_info_cp_obj);\n\t\t\tbsm_arg->argument_info_cp_obj = NULL;\n\t\t}\n\t\tfree (bsm_arg);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\tmemcpy(val, vcpu->mmio_data, bytes);\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_phys_addr, *(u64 *)val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int dsdb_user_obj_set_primary_group_id(struct ldb_context *ldb, struct ldb_message *usr_obj,\n\t\t\t\t       uint32_t user_account_control, uint32_t *group_rid_p)\n{\n\tint ret;\n\tuint32_t rid;\n\tstruct ldb_message_element *el;\n\n\trid = ds_uf2prim_group_rid(user_account_control);\n\n\tret = samdb_msg_add_uint(ldb, usr_obj, usr_obj,\n\t\t\t\t \"primaryGroupID\", rid);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tel = ldb_msg_find_element(usr_obj, \"primaryGroupID\");\n\tel->flags = LDB_FLAG_MOD_REPLACE;\n\n\tif (group_rid_p) {\n\t\t*group_rid_p = rid;\n\t}\n\n\treturn LDB_SUCCESS;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void uhci_queue_free(UHCIQueue *queue)\n\n{\n\n    UHCIState *s = queue->uhci;\n\n    UHCIAsync *async;\n\n\n\n    while (!QTAILQ_EMPTY(&queue->asyncs)) {\n\n        async = QTAILQ_FIRST(&queue->asyncs);\n\n        uhci_async_cancel(async);\n\n    }\n\n\n\n    trace_usb_uhci_queue_del(queue->token);\n\n    QTAILQ_REMOVE(&s->queues, queue, next);\n\n    g_free(queue);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "QPDFWriter::setOutputPipeline(Pipeline* p)\n{\n    this->filename = \"custom pipeline\";\n    initializePipelineStack(p);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "string PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++);\n  return ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)\n{\n\tstruct evtchn_fifo_control_block *control_block;\n\tunsigned long ready;\n\tunsigned q;\n\n\tcontrol_block = per_cpu(cpu_control_block, cpu);\n\n\tready = xchg(&control_block->ready, 0);\n\n\twhile (ready) {\n\t\tq = find_first_bit(&ready, EVTCHN_FIFO_MAX_QUEUES);\n\t\tconsume_one_event(cpu, control_block, q, &ready, drop);\n\t\tready |= xchg(&control_block->ready, 0);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "boost::system::error_code make_error_code(error_code_enum e)\n\t\t{\n\t\t\treturn boost::system::error_code(e, bdecode_category());\n\t\t}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "WebURLError WebURLLoaderImpl::CreateError(const WebURL& unreachable_url,\n                                          int reason) {\n  WebURLError error;\n  error.domain = WebString::fromUTF8(net::kErrorDomain);\n  error.reason = reason;\n  error.unreachableURL = unreachable_url;\n  if (reason == net::ERR_ABORTED) {\n    error.isCancellation = true;\n  } else if (reason == net::ERR_TEMPORARILY_THROTTLED) {\n    error.localizedDescription = WebString::fromUTF8(\n        kThrottledErrorDescription);\n  }\n  return error;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "cr_input_destroy (CRInput * a_this)\n{\n        if (a_this == NULL)\n                return;\n\n        if (PRIVATE (a_this)) {\n                if (PRIVATE (a_this)->in_buf && PRIVATE (a_this)->free_in_buf) {\n                        g_free (PRIVATE (a_this)->in_buf);\n                        PRIVATE (a_this)->in_buf = NULL;\n                }\n\n                g_free (PRIVATE (a_this));\n                PRIVATE (a_this) = NULL;\n        }\n\n        g_free (a_this);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "TPMI_ALG_ECC_SCHEME_Unmarshal(TPMI_ALG_ECC_SCHEME *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n#if ALG_ECDSA\n\t  case TPM_ALG_ECDSA:\n#endif\n#if ALG_SM2\n\t  case TPM_ALG_SM2:\n#endif\n#if ALG_ECDAA\n\t  case TPM_ALG_ECDAA:\n#endif\n#if ALG_ECSCHNORR\n\t  case TPM_ALG_ECSCHNORR:\n#endif\n#if ALG_ECDH\n\t  case TPM_ALG_ECDH:\n#endif\n#if ALG_ECMQV\n\t  case TPM_ALG_ECMQV:\n#endif\n\t    break;\n\t  case TPM_ALG_NULL:\n\t    if (allowNull) {\n\t\tbreak;\n\t    }\n\t  default:\n\t    rc = TPM_RC_SCHEME;\n\t}\n    }\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static u8 secs_to_retrans(int seconds, int timeout, int rto_max)\n{\n\tu8 res = 0;\n\n\tif (seconds > 0) {\n\t\tint period = timeout;\n\n\t\tres = 1;\n\t\twhile (seconds > period && res < 255) {\n\t\t\tres++;\n\t\t\ttimeout <<= 1;\n\t\t\tif (timeout > rto_max)\n\t\t\t\ttimeout = rto_max;\n\t\t\tperiod += timeout;\n\t\t}\n\t}\n\treturn res;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=0; col < width; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse hpred[col & 1] += diff;\n\timage[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline struct htx_blk *htx_get_next_blk(const struct htx *htx,\n\t\t\t\t\t       const struct htx_blk *blk)\n{\n\tint32_t pos;\n\n\tpos = htx_get_next(htx, htx_get_blk_pos(htx, blk));\n\treturn ((pos == -1) ? NULL : htx_get_blk(htx, pos));\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void set_task_comm(struct task_struct *tsk, char *buf)\n{\n\ttask_lock(tsk);\n\n\ttrace_task_rename(tsk, buf);\n\n\t/*\n\t * Threads may access current->comm without holding\n\t * the task lock, so write the string carefully.\n\t * Readers without a lock may see incomplete new\n\t * names but are safe from non-terminating string reads.\n\t */\n\tmemset(tsk->comm, 0, TASK_COMM_LEN);\n\twmb();\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\tperf_event_comm(tsk);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "PHP_FUNCTION(linkinfo)\n {\n \tchar *link;\n \tsize_t link_len;\n \tzend_stat_t sb;\n \tint ret;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &link, &link_len) == FAILURE) {\n \t\treturn;\n \t}\n \n \tret = VCWD_STAT(link, &sb);\n \tif (ret == -1) {\n \t\tphp_error_docref(NULL, E_WARNING, \"%s\", strerror(errno));\n \t\tRETURN_LONG(Z_L(-1));\n \t}\n \n \tRETURN_LONG((zend_long) sb.st_dev);\n }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int btrfs_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct btrfs_iget_args *args = opaque;\n\treturn args->location->objectid == BTRFS_I(inode)->location.objectid &&\n\t\targs->root == BTRFS_I(inode)->root;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline void free_reserved_page(struct page *page)\n{\n\t__free_reserved_page(page);\n\tadjust_managed_page_count(page, 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void put_swf_matrix(ByteIOContext *pb,\n\n                           int a, int b, int c, int d, int tx, int ty)\n\n{\n\n    PutBitContext p;\n\n    uint8_t buf[256];\n\n\n\n    init_put_bits(&p, buf, sizeof(buf));\n\n    \n\n    put_bits(&p, 1, 1); /* a, d present */\n\n    put_bits(&p, 5, 20); /* nb bits */\n\n    put_bits(&p, 20, a);\n\n    put_bits(&p, 20, d);\n\n    \n\n    put_bits(&p, 1, 1); /* b, c present */\n\n    put_bits(&p, 5, 20); /* nb bits */\n\n    put_bits(&p, 20, c);\n\n    put_bits(&p, 20, b);\n\n\n\n    put_bits(&p, 5, 20); /* nb bits */\n\n    put_bits(&p, 20, tx);\n\n    put_bits(&p, 20, ty);\n\n\n\n    flush_put_bits(&p);\n\n    put_buffer(pb, buf, pbBufPtr(&p) - p.buf);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "isdn_unexclusive_channel(int di, int ch)\n{\n\tint i;\n\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++)\n\t\tif ((dev->drvmap[i] == di) &&\n\t\t    (dev->chanmap[i] == ch)) {\n\t\t\tdev->usage[i] &= ~ISDN_USAGE_EXCLUSIVE;\n\t\t\tisdn_info_update();\n\t\t\treturn;\n\t\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void vnc_tls_handshake_done(QIOTask *task,\n\n                                   gpointer user_data)\n\n{\n\n    VncState *vs = user_data;\n\n    Error *err = NULL;\n\n\n\n    if (qio_task_propagate_error(task, &err)) {\n\n        VNC_DEBUG(\"Handshake failed %s\\n\",\n\n                  error_get_pretty(err));\n\n        vnc_client_error(vs);\n\n        error_free(err);\n\n    } else {\n\n        vs->ioc_tag = qio_channel_add_watch(\n\n            vs->ioc, G_IO_IN | G_IO_OUT, vnc_client_io, vs, NULL);\n\n        start_auth_vencrypt_subauth(vs);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void Magick::Image::sparseColor(const ChannelType channel_,\n  const SparseColorMethod method_,const size_t numberArguments_,\n  const double *arguments_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  GetAndSetPPChannelMask(channel_);\n  newImage=SparseColorImage(constImage(),method_,numberArguments_,arguments_,\n    exceptionInfo);\n  RestorePPChannelMask;\n  replaceImage(newImage);\n  ThrowImageException;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "node_new_option(OnigOptionType option)\n{\n  Node* node = node_new_bag(BAG_OPTION);\n  CHECK_NULL_RETURN(node);\n  BAG_(node)->o.options = option;\n  return node;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void virtio_queue_aio_set_host_notifier_handler(VirtQueue *vq, AioContext *ctx,\n\n                                                bool assign, bool set_handler)\n\n{\n\n    if (assign && set_handler) {\n\n        aio_set_event_notifier(ctx, &vq->host_notifier, true,\n\n                               virtio_queue_host_notifier_read);\n\n    } else {\n\n        aio_set_event_notifier(ctx, &vq->host_notifier, true, NULL);\n\n    }\n\n    if (!assign) {\n\n        /* Test and clear notifier before after disabling event,\n\n         * in case poll callback didn't have time to run. */\n\n        virtio_queue_host_notifier_read(&vq->host_notifier);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "_isBidi (const uint32_t *label, size_t llen)\n{\n  while (llen-- > 0) {\n    int bc = uc_bidi_category (*label++);\n\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n\n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "rb_commit_index(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\treturn rb_page_commit(cpu_buffer->commit_page);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void qemu_chr_free_common(CharDriverState *chr)\n\n{\n\n\n\n\n    g_free(chr->filename);\n\n    g_free(chr->label);\n\n    if (chr->logfd != -1) {\n\n        close(chr->logfd);\n\n\n    qemu_mutex_destroy(&chr->chr_write_lock);\n\n    g_free(chr);\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "date_s__rfc2822(VALUE klass, VALUE str)\n{\n    return date__rfc2822(str);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static bool is_legal_file(const std::string &filename)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn false;\n\t}\n\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn false;\n\t}\n\n\tif (ends_with(filename, \".pbl\")) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "long f2fs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase F2FS_IOC32_GETFLAGS:\n\t\tcmd = F2FS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase F2FS_IOC32_SETFLAGS:\n\t\tcmd = F2FS_IOC_SETFLAGS;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn f2fs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "mrb_module_get(mrb_state *mrb, const char *name)\n{\n  return mrb_class_get(mrb, name);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int proc_sys_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error;\n\n\tif (attr->ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\n\t\treturn -EPERM;\n\n\terror = setattr_prepare(dentry, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void\nmysql_ssl_free(MYSQL *mysql __attribute__((unused)))\n{\n  struct st_VioSSLFd *ssl_fd= (struct st_VioSSLFd*) mysql->connector_fd;\n  DBUG_ENTER(\"mysql_ssl_free\");\n\n  my_free(mysql->options.ssl_key);\n  my_free(mysql->options.ssl_cert);\n  my_free(mysql->options.ssl_ca);\n  my_free(mysql->options.ssl_capath);\n  my_free(mysql->options.ssl_cipher);\n  if (ssl_fd)\n    SSL_CTX_free(ssl_fd->ssl_context);\n  my_free(mysql->connector_fd);\n  mysql->options.ssl_key = 0;\n  mysql->options.ssl_cert = 0;\n  mysql->options.ssl_ca = 0;\n  mysql->options.ssl_capath = 0;\n  mysql->options.ssl_cipher= 0;\n  mysql->options.use_ssl = FALSE;\n  mysql->connector_fd = 0;\n  DBUG_VOID_RETURN;",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void usb_serial_console_disconnect(struct usb_serial *serial)\n {\n\tif (serial->port[0] == usbcons_info.port) {\n \t\tusb_serial_console_exit();\n \t\tusb_serial_put(serial);\n \t}\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void comedi_cleanup_legacy_minors(void)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < comedi_num_legacy_minors; i++)\n\t\tcomedi_free_board_minor(i);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void dccp_rcv_reset(struct sock *sk, struct sk_buff *skb)\n{\n\tu16 err = dccp_reset_code_convert(dccp_hdr_reset(skb)->dccph_reset_code);\n\n\tsk->sk_err = err;\n\n\t/* Queue the equivalent of TCP fin so that dccp_recvmsg exits the loop */\n\tdccp_fin(sk, skb);\n\n\tif (err && !sock_flag(sk, SOCK_DEAD))\n\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_ERR);\n\tdccp_time_wait(sk, DCCP_TIME_WAIT, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void SSL_SESSION_get0_ticket(const SSL_SESSION *s, unsigned char **tick,\n                            size_t *len)\n{\n    *len = s->tlsext_ticklen;\n    if (tick != NULL)\n        *tick = s->tlsext_tick;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static double mp_tanh(_cimg_math_parser& mp) {\n        return std::tanh(_mp_arg(2));",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void fsl_imx25_class_init(ObjectClass *oc, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    dc->realize = fsl_imx25_realize;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "WandExport DecorationType DrawGetTextDecoration(const DrawingWand *wand)\n{\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  return(CurrentContext->decorate);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "gen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n\n    if (is_splat || n > limit || cursp() >= slimit) { /* flush stack */\n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  /* variable length */\n  }\n  return n;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void ccid_hc_rx_delete(struct ccid *ccid, struct sock *sk)\n{\n\tif (ccid != NULL) {\n\t\tif (ccid->ccid_ops->ccid_hc_rx_exit != NULL)\n\t\t\tccid->ccid_ops->ccid_hc_rx_exit(sk);\n\t\tkmem_cache_free(ccid->ccid_ops->ccid_hc_rx_slab, ccid);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int date_from_ISO8601 (const char *text, time_t * value) {\n   struct tm tm;\n   int n;\n   int i;\n   char buf[30];\n\t\n\n\tif (strchr (text, '-')) {\n\t\tchar *p = (char *) text, *p2 = buf;\n\t\twhile (p && *p) {\n\t\t\tif (*p != '-') {\n\t\t\t\t*p2 = *p;\n\t\t\t\tp2++;\n\t\t\t\tif (p2-buf >= sizeof(buf)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\t\ttext = buf;\n\t}\n\n\n   tm.tm_isdst = -1;\n\n#define XMLRPC_IS_NUMBER(x) if (x < '0' || x > '9') return -1;\n\n   n = 1000;\n   tm.tm_year = 0;\n   for(i = 0; i < 4; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_year += (text[i]-'0')*n;\n      n /= 10;\n   }\n   n = 10;\n   tm.tm_mon = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_mon += (text[i+4]-'0')*n;\n      n /= 10;\n   }\n   tm.tm_mon --;\n\n   n = 10;\n   tm.tm_mday = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_mday += (text[i+6]-'0')*n;\n      n /= 10;\n   }\n\n   n = 10;\n   tm.tm_hour = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_hour += (text[i+9]-'0')*n;\n      n /= 10;\n   }\n\n   n = 10;\n   tm.tm_min = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_min += (text[i+12]-'0')*n;\n      n /= 10;\n   }\n\n   n = 10;\n   tm.tm_sec = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_sec += (text[i+15]-'0')*n;\n      n /= 10;\n   }\n\n   tm.tm_year -= 1900;\n\n   *value = mkgmtime(&tm);\n\n   return 0;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "ref_array_param_requested(const iparam_list *iplist, gs_param_name pkey,\n                          ref *pvalue, uint size, client_name_t cname)\n{\n    int code;\n\n    if (!ref_param_requested((const gs_param_list *)iplist, pkey))\n        return 0;\n    code = gs_alloc_ref_array(iplist->ref_memory, pvalue, a_all, size, cname);\n    return (code < 0 ? code : 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "data_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_DGRAM)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\n\tsock->ops = &data_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&data_sockets, sk);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "//! Loadimage from an Ascii file \\newinstance.\n    static CImg<T> get_load_ascii(std::FILE *const file) {\n      return CImg<T>().load_ascii(file);",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    for (; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;\n        if (0==strcmp(symnam, \"__libc_start_main\")  // glibc\n        ||  0==strcmp(symnam, \"__libc_init\")  // Android\n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void setSerifFontFamilyWrapper(WebSettings* settings,\n                               const string16& font,\n                               UScriptCode script) {\n  settings->setSerifFontFamily(font, script);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n \t}\n \n retry:\n\t/* Prepare to wait on uaddr. */\n \tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n \tif (ret)\n \t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n \n \t/* If we were woken (and unqueued), we succeeded, whatever. */\n \tret = 0;\n \tif (!unqueue_me(&q))\n\t\tgoto out_put_key;\n \tret = -ETIMEDOUT;\n \tif (to && !to->task)\n\t\tgoto out_put_key;\n \n \t/*\n \t * We expect signal_pending(current), but we might be the\n \t * victim of a spurious wakeup as well.\n \t */\n\tif (!signal_pending(current)) {\n\t\tput_futex_key(fshared, &q.key);\n \t\tgoto retry;\n\t}\n \n \tret = -ERESTARTSYS;\n \tif (!abs_time)\n\t\tgoto out_put_key;\n \n \trestart = &current_thread_info()->restart_block;\n \trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n \n \tret = -ERESTART_RESTARTBLOCK;\n \nout_put_key:\n\tput_futex_key(fshared, &q.key);\n out:\n \tif (to) {\n \t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    data->num_of_part++;\n\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void perf_remove_from_owner(struct perf_event *event)\n{\n\tstruct task_struct *owner;\n\n\trcu_read_lock();\n\towner = ACCESS_ONCE(event->owner);\n\t/*\n\t * Matches the smp_wmb() in perf_event_exit_task(). If we observe\n\t * !owner it means the list deletion is complete and we can indeed\n\t * free this event, otherwise we need to serialize on\n\t * owner->perf_event_mutex.\n\t */\n\tsmp_read_barrier_depends();\n\tif (owner) {\n\t\t/*\n\t\t * Since delayed_put_task_struct() also drops the last\n\t\t * task reference we can safely take a new reference\n\t\t * while holding the rcu_read_lock().\n\t\t */\n\t\tget_task_struct(owner);\n\t}\n\trcu_read_unlock();\n\n\tif (owner) {\n\t\tmutex_lock(&owner->perf_event_mutex);\n\t\t/*\n\t\t * We have to re-check the event->owner field, if it is cleared\n\t\t * we raced with perf_event_exit_task(), acquiring the mutex\n\t\t * ensured they're done, and we can proceed with freeing the\n\t\t * event.\n\t\t */\n\t\tif (event->owner)\n\t\t\tlist_del_init(&event->owner_entry);\n\t\tmutex_unlock(&owner->perf_event_mutex);\n\t\tput_task_struct(owner);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_decode_complete_; }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\t/* this rphy never saw sas_rphy_add */\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t\tsas_discover_event(dev->port, DISCE_DESTRUCT);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static uint32_t get_elf_hwcap(void)\n\n{\n\n    CPUState *e = thread_env;\n\n    uint32_t features = 0;\n\n\n\n    /* We don't have to be terribly complete here; the high points are\n\n       Altivec/FP/SPE support.  Anything else is just a bonus.  */\n\n#define GET_FEATURE(flag, feature)              \\\n\n    do {if (e->insns_flags & flag) features |= feature; } while(0)\n\n    GET_FEATURE(PPC_64B, PPC_FEATURE_64);\n\n    GET_FEATURE(PPC_FLOAT, PPC_FEATURE_HAS_FPU);\n\n    GET_FEATURE(PPC_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC);\n\n    GET_FEATURE(PPC_SPE, PPC_FEATURE_HAS_SPE);\n\n    GET_FEATURE(PPC_SPE_SINGLE, PPC_FEATURE_HAS_EFP_SINGLE);\n\n    GET_FEATURE(PPC_SPE_DOUBLE, PPC_FEATURE_HAS_EFP_DOUBLE);\n\n    GET_FEATURE(PPC_BOOKE, PPC_FEATURE_BOOKE);\n\n    GET_FEATURE(PPC_405_MAC, PPC_FEATURE_HAS_4xxMAC);\n\n#undef GET_FEATURE\n\n\n\n    return features;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline unsigned int ScaleQuantumToMap(const Quantum quantum)\n{\n  if (quantum < 0.0)\n    return(0UL);\n  if ((quantum/65537) >= (Quantum) MaxMap)\n    return((unsigned int) MaxMap);\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((unsigned int) ((quantum+MagickULLConstant(32768))/\n    MagickULLConstant(65537)));\n#else\n  return((unsigned int) (quantum/65537.0+0.5));\n#endif\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "inconsistent_match(enum ofputil_protocol *usable_protocols)\n{\n    *usable_protocols &= OFPUTIL_P_OF10_ANY;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline u32 nfsd4_copy_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* wr_callback */ +\n\t\top_encode_stateid_maxsz /* wr_callback */ +\n\t\t2 /* wr_count */ +\n\t\t1 /* wr_committed */ +\n\t\top_encode_verifier_maxsz +\n\t\t1 /* cr_consecutive */ +\n\t\t1 /* cr_synchronous */) * sizeof(__be32);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void handle_one_reflog_commit(unsigned char *sha1, void *cb_data)\n{\n\tstruct all_refs_cb *cb = cb_data;\n\tif (!is_null_sha1(sha1)) {\n\t\tstruct object *o = parse_object(sha1);\n\t\tif (o) {\n\t\t\to->flags |= cb->all_flags;\n\t\t\tadd_pending_object(cb->all_revs, o, \"\");\n\t\t}\n\t\telse if (!cb->warned_bad_reflog) {\n\t\t\twarning(\"reflog of '%s' references pruned commits\",\n\t\t\t\tcb->name_for_errormsg);\n\t\t\tcb->warned_bad_reflog = 1;\n\t\t}\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "pdf_nextlinestart(const char *ptr, size_t len)\n{\n\twhile(strchr(\"\\r\\n\", *ptr) == NULL) {\n\t\tif(--len == 0L)\n\t\t\treturn NULL;\n\t\tptr++;\n\t}\n\twhile(strchr(\"\\r\\n\", *ptr) != NULL) {\n\t\tif(--len == 0L)\n\t\t\treturn NULL;\n\t\tptr++;\n\t}\n\treturn ptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "linux_md_create_data_new (DBusGMethodInvocation *context,\n                          Daemon *daemon,\n                          const char *first_component_objpath)\n{\n  LinuxMdCreateData *data;\n\n  data = g_new0 (LinuxMdCreateData, 1);\n  data->refcount = 1;\n\n  data->context = context;\n  data->daemon = g_object_ref (daemon);\n  data->first_component_objpath = g_strdup (first_component_objpath);\n  return data;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static av_cold int mss1_decode_init(AVCodecContext *avctx)\n\n{\n\n    MSS1Context * const c = avctx->priv_data;\n\n    int ret;\n\n\n\n    c->ctx.avctx       = avctx;\n\n\n\n    c->pic = av_frame_alloc();\n\n    if (!c->pic)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ret = ff_mss12_decode_init(&c->ctx, 0, &c->sc, NULL);\n\n\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n\n\n    return ret;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "QCryptoHmac *qcrypto_hmac_new(QCryptoHashAlgorithm alg,\n\n                              const uint8_t *key, size_t nkey,\n\n                              Error **errp)\n\n{\n\n    QCryptoHmac *hmac;\n\n    void *ctx = NULL;\n\n    Error *err2 = NULL;\n\n    QCryptoHmacDriver *drv = NULL;\n\n\n\n#ifdef CONFIG_AF_ALG\n\n    ctx = qcrypto_afalg_hmac_ctx_new(alg, key, nkey, &err2);\n\n    if (ctx) {\n\n        drv = &qcrypto_hmac_afalg_driver;\n\n    }\n\n#endif\n\n\n\n    if (!ctx) {\n\n        ctx = qcrypto_hmac_ctx_new(alg, key, nkey, errp);\n\n        if (!ctx) {\n\n            return NULL;\n\n        }\n\n\n\n        drv = &qcrypto_hmac_lib_driver;\n\n        error_free(err2);\n\n    }\n\n\n\n    hmac = g_new0(QCryptoHmac, 1);\n\n    hmac->alg = alg;\n\n    hmac->opaque = ctx;\n\n    hmac->driver = (void *)drv;\n\n\n\n    return hmac;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "t1_parse_font_matrix( T1_Face    face,\n                        T1_Loader  loader )\n  {\n    T1_Parser   parser = &loader->parser;\n    FT_Matrix*  matrix = &face->type1.font_matrix;\n    FT_Vector*  offset = &face->type1.font_offset;\n    FT_Face     root   = (FT_Face)&face->root;\n    FT_Fixed    temp[6];\n    FT_Fixed    temp_scale;\n    FT_Int      result;\n\n \n     result = T1_ToFixedArray( parser, 6, temp, 3 );\n \n    if ( result < 0 )\n     {\n       parser->root.error = FT_THROW( Invalid_File_Format );\n       return;\n    }\n\n    temp_scale = FT_ABS( temp[3] );\n\n    if ( temp_scale == 0 )\n    {\n      FT_ERROR(( \"t1_parse_font_matrix: invalid font matrix\\n\" ));\n      parser->root.error = FT_THROW( Invalid_File_Format );\n      return;\n    }\n\n    /* Set Units per EM based on FontMatrix values.  We set the value to */\n    /* 1000 / temp_scale, because temp_scale was already multiplied by   */\n    /* 1000 (in t1_tofixed, from psobjs.c).                              */\n\n    root->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );\n\n    /* we need to scale the values by 1.0/temp_scale */\n    if ( temp_scale != 0x10000L )\n    {\n      temp[0] = FT_DivFix( temp[0], temp_scale );\n      temp[1] = FT_DivFix( temp[1], temp_scale );\n      temp[2] = FT_DivFix( temp[2], temp_scale );\n      temp[4] = FT_DivFix( temp[4], temp_scale );\n      temp[5] = FT_DivFix( temp[5], temp_scale );\n      temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;\n    }\n\n    matrix->xx = temp[0];\n    matrix->yx = temp[1];\n    matrix->xy = temp[2];\n    matrix->yy = temp[3];\n\n    /* note that the offsets must be expressed in integer font units */\n    offset->x = temp[4] >> 16;\n    offset->y = temp[5] >> 16;\n  }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "CNF_ReadFile(const char *filename)\n{\n  FILE *in;\n  char line[2048];\n  int i;\n\n  in = fopen(filename, \"r\");\n  if (!in) {\n    LOG_FATAL(\"Could not open configuration file %s : %s\",\n              filename, strerror(errno));\n    return;\n  }\n\n  DEBUG_LOG(\"Reading %s\", filename);\n\n  for (i = 1; fgets(line, sizeof(line), in); i++) {\n    CNF_ParseLine(filename, i, line);\n  }\n\n  fclose(in);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline int onenand_prog_spare(OneNANDState *s, int sec, int secn,\n\n                void *src)\n\n{\n\n    int result = 0;\n\n    if (secn > 0) {\n\n        const uint8_t *sp = (const uint8_t *)src;\n\n        uint8_t *dp = 0, *dpp = 0;\n\n        if (s->blk_cur) {\n\n            dp = g_malloc(512);\n\n            if (!dp\n\n                || blk_read(s->blk_cur, s->secs_cur + (sec >> 5), dp, 1) < 0) {\n\n                result = 1;\n\n            } else {\n\n                dpp = dp + ((sec & 31) << 4);\n\n            }\n\n        } else {\n\n            if (sec + secn > s->secs_cur) {\n\n                result = 1;\n\n            } else {\n\n                dpp = s->current + (s->secs_cur << 9) + (sec << 4);\n\n            }\n\n        }\n\n        if (!result) {\n\n            uint32_t i;\n\n            for (i = 0; i < (secn << 4); i++) {\n\n                dpp[i] &= sp[i];\n\n            }\n\n            if (s->blk_cur) {\n\n                result = blk_write(s->blk_cur, s->secs_cur + (sec >> 5),\n\n                                   dp, 1) < 0;\n\n            }\n\n        }\n\n        g_free(dp);\n\n    }\n\n    return result;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "template<> struct type<bool> {",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void ACodec::LoadedToIdleState::stateEntered() {\n    ALOGV(\"[%s] Now Loaded->Idle\", mCodec->mComponentName.c_str());\n\n status_t err;\n if ((err = allocateBuffers()) != OK) {\n        ALOGE(\"Failed to allocate buffers after transitioning to IDLE state \"\n \"(error 0x%08x)\",\n             err);\n\n        mCodec->signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));\n\n        mCodec->changeState(mCodec->mLoadedState);\n }\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void Element::clearHasPendingResources()\n{\n    ensureElementRareData()->setHasPendingResources(false);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = READ_ONCE(rmem->size);\n\n\treturn TEE_SUCCESS;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void TensorSlice::AsProto(TensorSliceProto* proto) const {\n  for (int d = 0; d < dims(); ++d) {\n    TensorSliceProto::Extent* e = proto->add_extent();\n    // We only need to record the explicit slice for non-full slices\n    if (!IsFullAt(d)) {\n      e->set_start(starts_[d]);\n      e->set_length(lengths_[d]);\n    }\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "struct dce_aux *dce110_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void LZWStream::getRawChars(int nChars, int *buffer) {\n  for (int i = 0; i < nChars; ++i)\n    buffer[i] = doGetRawChar();\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "test_bson_append_binary_deprecated (void)\n{\n   const static uint8_t binary[] = {'1', '2', '3', '4'};\n   bson_t *b;\n   bson_t *b2;\n\n   b = bson_new ();\n   BSON_ASSERT (bson_append_binary (\n      b, \"binary\", -1, BSON_SUBTYPE_BINARY_DEPRECATED, binary, 4));\n   b2 = get_bson (\"binary_deprecated.bson\");\n   BSON_ASSERT_BSON_EQUAL (b, b2);\n   bson_destroy (b);\n   bson_destroy (b2);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\n\t/* We don't need a base pointer in the /proc filesystem */\n\tpath_put(&nd->path);\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "SYSCALL_DEFINE2(munmap, unsigned long, addr, size_t, len)\n{\n\tprofile_munmap(addr);\n\treturn __vm_munmap(addr, len, true);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "png_get_user_height_max (png_structp png_ptr)\n{\n    return (png_ptr? png_ptr->user_height_max : 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void check_cmd(AHCIState *s, int port)\n{\n    AHCIPortRegs *pr = &s->dev[port].port_regs;\n    uint8_t slot;\n\n    if ((pr->cmd & PORT_CMD_START) && pr->cmd_issue) {\n        for (slot = 0; (slot < 32) && pr->cmd_issue; slot++) {\n            if ((pr->cmd_issue & (1U << slot)) &&\n                !handle_cmd(s, port, slot)) {\n                pr->cmd_issue &= ~(1U << slot);\n            }\n        }\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void GetMetadataForSnapshot(\n    const FileSystemOperationInterface::SnapshotFileCallback& callback,\n    base::PlatformFileError result,\n    const base::PlatformFileInfo& file_info,\n    const FilePath& platform_path) {\n  callback.Run(result, file_info, platform_path, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm, unsigned long *rmapp,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static pmd_t *get_old_pmd(struct mm_struct *mm, unsigned long addr)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (pgd_none_or_clear_bad(pgd))\n\t\treturn NULL;\n\n\tpud = pud_offset(pgd, addr);\n\tif (pud_none_or_clear_bad(pud))\n\t\treturn NULL;\n\n\tpmd = pmd_offset(pud, addr);\n\tsplit_huge_page_pmd(mm, pmd);\n\tif (pmd_none_or_clear_bad(pmd))\n\t\treturn NULL;\n\n\treturn pmd;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static char *utf2char(utf16_t *str, char *buffer)\n{\n  char *b = buffer;\n\n  while (*str != 0x00) {\n    char *chr = (char *)str;\n    *b++ = *chr;\n    str++;\n  }\n  *b = 0;\n  return buffer;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int fib6_dump_node(struct fib6_walker_t *w)\n{\n\tint res;\n\tstruct rt6_info *rt;\n\n\tfor (rt = w->leaf; rt; rt = rt->dst.rt6_next) {\n\t\tres = rt6_dump_route(rt, w->args);\n\t\tif (res < 0) {\n\t\t\t/* Frame is full, suspend walking */\n\t\t\tw->leaf = rt;\n\t\t\treturn 1;\n\t\t}\n\t\tWARN_ON(res == 0);\n\t}\n\tw->leaf = NULL;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "TaskFactory::TaskFactory()\n        : registry_{\n              {adjust, new Adjust}, {print, new Print},     {rename, new Rename},\n              {erase, new Erase},   {extract, new Extract}, {insert, new Insert},\n              {modify, new Modify}, {fixiso, new FixIso},   {fixcom, new FixCom},\n          }\n    {\n    }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline void nf_bridge_get(struct nf_bridge_info *nf_bridge)\n{\n\tif (nf_bridge)\n\t\tatomic_inc(&nf_bridge->use);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void rgb32tobgr24(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tlong i;\n\n\tlong num_pixels = src_size >> 2;\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t#ifdef WORDS_BIGENDIAN\n\n\t\t\t/* RGB32 (= A,B,G,R) -> BGR24 (= B,G,R) */\n\n\t\t\tdst[3*i + 0] = src[4*i + 1];\n\n\t\t\tdst[3*i + 1] = src[4*i + 2];\n\n\t\t\tdst[3*i + 2] = src[4*i + 3];\n\n\t\t#else\n\n\t\t\tdst[3*i + 0] = src[4*i + 2];\n\n\t\t\tdst[3*i + 1] = src[4*i + 1];\n\n\t\t\tdst[3*i + 2] = src[4*i + 0];\n\n\t\t#endif\n\n\t}\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int ipx_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tint rc;\n\n\tlock_sock(sk);\n\trc = __ipx_bind(sock, uaddr, addr_len);\n\trelease_sock(sk);\n\n\treturn rc;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "//! Return the sinc of a given value.\n    inline double sinc(const double x) {\n      return x?std::sin(x)/x:1;",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void PDFDoc::init()\n{\n  ok = false;\n  errCode = errNone;\n  fileName = nullptr;\n  file = nullptr;\n  str = nullptr;\n  xref = nullptr;\n  linearization = nullptr;\n  catalog = nullptr;\n  hints = nullptr;\n  outline = nullptr;\n  startXRefPos = -1;\n  secHdlr = nullptr;\n  pageCache = nullptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int vmx_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (unlikely(vmx->rmode.vm86_active))\n\t\treturn 0;\n\telse {\n\t\tint ar = vmx_read_guest_seg_ar(vmx, VCPU_SREG_SS);\n\t\treturn AR_DPL(ar);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "bool ImageInputType::shouldRespectHeightAndWidthAttributes()\n{\n    return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "envlist_unsetenv(envlist_t *envlist, const char *env)\n\n{\n\n\tstruct envlist_entry *entry;\n\n\tsize_t envname_len;\n\n\n\n\tif ((envlist == NULL) || (env == NULL))\n\n\t\treturn (EINVAL);\n\n\n\n\t/* env is not allowed to contain '=' */\n\n\tif (strchr(env, '=') != NULL)\n\n\t\treturn (EINVAL);\n\n\n\n\t/*\n\n\t * Find out the requested entry and remove\n\n\t * it from the list.\n\n\t */\n\n\tenvname_len = strlen(env);\n\n\tfor (entry = envlist->el_entries.lh_first; entry != NULL;\n\n\t    entry = entry->ev_link.le_next) {\n\n\t\tif (strncmp(entry->ev_var, env, envname_len) == 0)\n\n\t\t\tbreak;\n\n\t}\n\n\tif (entry != NULL) {\n\n\t\tQLIST_REMOVE(entry, ev_link);\n\n\t\tfree((char *)entry->ev_var);\n\n\t\tfree(entry);\n\n\n\n\t\tenvlist->el_count--;\n\n\t}\n\n\treturn (0);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "Ins_GETVARIATION( TT_ExecContext  exc,\n                    FT_Long*        args )\n  {\n    FT_UInt    num_axes = exc->face->blend->num_axis;\n    FT_Fixed*  coords   = exc->face->blend->normalizedcoords;\n\n    FT_UInt  i;\n\n\n    if ( BOUNDS( num_axes, exc->stackSize + 1 - exc->top ) )\n    {\n      exc->error = FT_THROW( Stack_Overflow );\n       return;\n     }\n \n    for ( i = 0; i < num_axes; i++ )\n      args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */\n   }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline bool nested_cpu_has_virtual_nmis(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_VIRTUAL_NMIS;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "viz::SurfaceId surface_id() const {\n    return GetDelegatedFrameHost()->GetCurrentSurfaceId();\n  }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\two = (rbuf == NULL || rlen == 0); /* write-only */\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void add_error(Scanner *s, char *error)\n{\n\ts->errors->error_count++;\n\ts->errors->error_messages = timelib_realloc(s->errors->error_messages, s->errors->error_count * sizeof(timelib_error_message));\n\ts->errors->error_messages[s->errors->error_count - 1].position = s->tok ? s->tok - s->str : 0;\n\ts->errors->error_messages[s->errors->error_count - 1].character = s->tok ? *s->tok : 0;\n\ts->errors->error_messages[s->errors->error_count - 1].message = timelib_strdup(error);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void _cmd_window_show_opt(const char *data, int right)\n{\n\tMAIN_WINDOW_REC *parent;\n\tWINDOW_REC *window;\n\n\tif (*data == '\\0') cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS);\n\n\tif (is_numeric(data, '\\0')) {\n\t\twindow = window_find_refnum(atoi(data));\n\t\tif (window == NULL) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_REFNUM_NOT_FOUND, data);\n\t\t}\n\t} else {\n\t\twindow = window_find_item(active_win->active_server, data);\n\t}\n\n\tif (window == NULL || is_window_visible(window))\n\t\treturn;\n\n\tif (WINDOW_GUI(window)->sticky) {\n\t\tif (!settings_get_bool(\"autounstick_windows\")) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_CANT_SHOW_STICKY_WINDOWS);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tparent = mainwindow_create(right);\n\tparent->active = window;\n\tgui_window_reparent(window, parent);\n\n\tif (settings_get_bool(\"autostick_split_windows\"))\n\t\tgui_window_set_sticky(window);\n\n\tactive_mainwin = NULL;\n\twindow_set_active(window);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n \terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n \tset_fs(old_fs);\n \tif (!err)\n\t\terr = compat_put_timeval(up, &ktv);\n \n \treturn err;\n }",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int __init sysenter_setup(void)\n{\n\tsyscall_page = (void *)get_zeroed_page(GFP_ATOMIC);\n\n#ifdef CONFIG_COMPAT_VDSO\n\t__set_fixmap(FIX_VDSO, __pa(syscall_page), PAGE_READONLY);\n\tprintk(\"Compat vDSO mapped to %08lx.\\n\", __fix_to_virt(FIX_VDSO));\n#endif\n\n\tif (!boot_cpu_has(X86_FEATURE_SEP)) {\n\t\tmemcpy(syscall_page,\n\t\t       &vsyscall_int80_start,\n\t\t       &vsyscall_int80_end - &vsyscall_int80_start);\n\t\treturn 0;\n\t}\n\n\tmemcpy(syscall_page,\n\t       &vsyscall_sysenter_start,\n\t       &vsyscall_sysenter_end - &vsyscall_sysenter_start);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\n\tif (!rt)\n\t\treturn false;\n\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\n\t/* do not accept result if the route does\n\t * not meet the required prefix length\n\t */\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\n\t/* do not accept result if the route uses a device\n\t * belonging to a forbidden interface group\n\t */\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\n\treturn false;\n\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "uint32_t virtio_config_modern_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = ldub_p(vdev->config + addr);\n    return val;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "Ta3Tokenizer_FromString(const char *str, int exec_input)\n{\n    struct tok_state *tok = tok_new();\n    if (tok == NULL)\n        return NULL;\n    str = decode_str(str, exec_input, tok);\n    if (str == NULL) {\n        Ta3Tokenizer_Free(tok);\n        return NULL;\n    }\n\n    /* XXX: constify members. */\n    tok->buf = tok->cur = tok->end = tok->inp = (char*)str;\n    return tok;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int nfs4_xdr_dec_setattr(struct rpc_rqst *rqstp,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tstruct nfs_setattrres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_setattr(xdr);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "GF_Err dvcC_Size(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\tptr->size += sizeof(GF_DOVIDecoderConfigurationRecord);\n\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int syslog_action_restricted(int type)\n{\n\tif (dmesg_restrict)\n\t\treturn 1;\n\t/* Unless restricted, we allow \"read all\" and \"get buffer size\" for everybody */\n\treturn type != SYSLOG_ACTION_READ_ALL && type != SYSLOG_ACTION_SIZE_BUFFER;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLocalResponseNormParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32) {\n#define TF_LITE_LOCAL_RESPONSE_NORM(type)                            \\\n  tflite::LocalResponseNormalizationParams op_params;                \\\n  op_params.range = params->radius;                                  \\\n  op_params.bias = params->bias;                                     \\\n  op_params.alpha = params->alpha;                                   \\\n  op_params.beta = params->beta;                                     \\\n  type::LocalResponseNormalization(                                  \\\n      op_params, GetTensorShape(input), GetTensorData<float>(input), \\\n      GetTensorShape(output), GetTensorData<float>(output))\n    if (kernel_type == kReference) {\n      TF_LITE_LOCAL_RESPONSE_NORM(reference_ops);\n    }\n    if (kernel_type == kGenericOptimized) {\n      TF_LITE_LOCAL_RESPONSE_NORM(optimized_ops);\n    }\n#undef TF_LITE_LOCAL_RESPONSE_NORM\n  } else {\n    context->ReportError(context, \"Output type is %d, requires float.\",\n                         output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "PHP_FUNCTION(imagecreatefromxpm)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XPM, \"XPM\", gdImageCreateFromXpm, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void mg_timer_init(struct mg_timer *t, int64_t ms, unsigned flags,\n                   void (*fn)(void *), void *arg) {\n  struct mg_timer tmp = {ms, 0UL, flags, fn, arg, g_timers};\n  *t = tmp;\n  g_timers = t;\n  if (flags & MG_TIMER_RUN_NOW) fn(arg);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "GLvoid StubGLBlendColor(GLclampf red, GLclampf green, GLclampf blue,\n                        GLclampf alpha) {\n  glBlendColor(red, green, blue, alpha);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void kvm_s390_flic_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    S390FLICStateClass *fsc = S390_FLIC_COMMON_CLASS(oc);\n\n\n\n\n    dc->realize = kvm_s390_flic_realize;\n\n    dc->vmsd = &kvm_s390_flic_vmstate;\n\n    dc->reset = kvm_s390_flic_reset;\n\n    fsc->register_io_adapter = kvm_s390_register_io_adapter;\n\n    fsc->io_adapter_map = kvm_s390_io_adapter_map;\n\n    fsc->add_adapter_routes = kvm_s390_add_adapter_routes;\n\n    fsc->release_adapter_routes = kvm_s390_release_adapter_routes;\n\n    fsc->clear_io_irq = kvm_s390_clear_io_flic;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "CString GetLocalDCCIP() {\n\t\treturn m_pUser->GetLocalDCCIP();\n\t}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int dxva2_mpeg2_end_frame(AVCodecContext *avctx)\n\n{\n\n    struct MpegEncContext *s = avctx->priv_data;\n\n    struct dxva2_picture_context *ctx_pic =\n\n        s->current_picture_ptr->hwaccel_picture_private;\n\n    int ret;\n\n\n\n    if (ctx_pic->slice_count <= 0 || ctx_pic->bitstream_size <= 0)\n\n        return -1;\n\n    ret = ff_dxva2_common_end_frame(avctx, &s->current_picture_ptr->f,\n\n                                    &ctx_pic->pp, sizeof(ctx_pic->pp),\n\n                                    &ctx_pic->qm, sizeof(ctx_pic->qm),\n\n                                    commit_bitstream_and_slice_buffer);\n\n    if (!ret)\n\n        ff_mpeg_draw_horiz_band(s, 0, avctx->height);\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct vhu_msg_context *ctx)\n{\n\tuint32_t vring_idx;\n\n\tswitch (ctx->msg.request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_GET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = ctx->msg.payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = ctx->msg.payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid vring index: %u\\n\", dev->ifname, vring_idx);\n\t\treturn -1;\n\t}\n\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\n\treturn alloc_vring_queue(dev, vring_idx);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void ZipTest::testDecompressZip64()\n{\n\tstd::map<std::string, Poco::UInt64> files;\n\tfiles[\"data1.bin\"] = static_cast<Poco::UInt64>(KB)*4096+1;\n\tfiles[\"data2.bin\"] = static_cast<Poco::UInt64>(KB)*16;\n\tfiles[\"data3.bin\"] = static_cast<Poco::UInt64>(KB)*4096-1;\n\n\tfor(std::map<std::string, Poco::UInt64>::const_iterator it = files.begin(); it != files.end(); it++)\n\t{\n\t\tPoco::File file(it->first);\n\t\tif(file.exists())\n\t\t\tfile.remove();\n\t}\n\tstd::ifstream in(\"zip64.zip\", std::ios::binary);\n\tDecompress c(in, \".\");\n\tc.decompressAllFiles();\n\tfor(std::map<std::string, Poco::UInt64>::const_iterator it = files.begin(); it != files.end(); it++)\n\t{\n\t\tverifyDataFile(it->first, it->second);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void dec_scall(DisasContext *dc)\n\n{\n\n    if (dc->imm5 == 7) {\n\n        LOG_DIS(\"scall\\n\");\n\n    } else if (dc->imm5 == 2) {\n\n        LOG_DIS(\"break\\n\");\n\n    } else {\n\n        cpu_abort(dc->env, \"invalid opcode\\n\");\n\n    }\n\n\n\n    if (dc->imm5 == 7) {\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n        t_gen_raise_exception(dc, EXCP_SYSTEMCALL);\n\n    } else {\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n        t_gen_raise_exception(dc, EXCP_BREAKPOINT);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  /* ignore white spaces */\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \"alignment %d is not a power of 2\", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \"invalid format option '%c'\", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void coroutine_fn nest(void *opaque)\n\n{\n\n    NestData *nd = opaque;\n\n\n\n    nd->n_enter++;\n\n\n\n    if (nd->n_enter < nd->max) {\n\n        Coroutine *child;\n\n\n\n        child = qemu_coroutine_create(nest);\n\n        qemu_coroutine_enter(child, nd);\n\n    }\n\n\n\n    nd->n_return++;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void http_log(char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    va_start(ap, fmt);\n\n    \n\n    if (logfile)\n\n        vfprintf(logfile, fmt, ap);\n\n    va_end(ap);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int arc4_set_key(struct crypto_tfm *tfm, const u8 *in_key,\n\t\t\tunsigned int key_len)\n{\n\tstruct arc4_ctx *ctx = crypto_tfm_ctx(tfm);\n\tint i, j = 0, k = 0;\n\n\tctx->x = 1;\n\tctx->y = 0;\n\n\tfor (i = 0; i < 256; i++)\n\t\tctx->S[i] = i;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tu32 a = ctx->S[i];\n\t\tj = (j + in_key[k] + a) & 0xff;\n\t\tctx->S[i] = ctx->S[j];\n\t\tctx->S[j] = a;\n\t\tif (++k >= key_len)\n\t\t\tk = 0;\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Compute(OpKernelContext* context) override {\n    FusedBatchNormOpBase<Device, T, U>::ComputeWithReservedSpace(context,\n                                                                 false);\n  }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void digic_uart_write(void *opaque, hwaddr addr, uint64_t value,\n\n                             unsigned size)\n\n{\n\n    DigicUartState *s = opaque;\n\n    unsigned char ch = value;\n\n\n\n    addr >>= 2;\n\n\n\n    switch (addr) {\n\n    case R_TX:\n\n        if (s->chr) {\n\n\n\n            qemu_chr_fe_write_all(s->chr, &ch, 1);\n\n        }\n\n        break;\n\n\n\n    case R_ST:\n\n        /*\n\n         * Ignore write to R_ST.\n\n         *\n\n         * The point is that this register is actively used\n\n         * during receiving and transmitting symbols,\n\n         * but we don't know the function of most of bits.\n\n         *\n\n         * Ignoring writes to R_ST is only a simplification\n\n         * of the model. It has no perceptible side effects\n\n         * for existing guests.\n\n         */\n\n        break;\n\n\n\n    default:\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"digic-uart: write access to unknown register 0x\"\n\n                      TARGET_FMT_plx, addr << 2);\n\n    }\n\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "poppler_color_free (PopplerColor *color)\n{\n  g_free (color);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "}\n      static double nan() {\n#ifdef NAN\n        return (double)NAN;\n#else\n        const double val_nan = -std::sqrt(-1.0); return val_nan;\n#endif",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void host_memory_backend_set_prealloc(Object *obj, bool value,\n\n                                             Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    HostMemoryBackend *backend = MEMORY_BACKEND(obj);\n\n\n\n    if (backend->force_prealloc) {\n\n        if (value) {\n\n            error_setg(errp,\n\n                       \"remove -mem-prealloc to use the prealloc property\");\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (!memory_region_size(&backend->mr)) {\n\n        backend->prealloc = value;\n\n        return;\n\n    }\n\n\n\n    if (value && !backend->prealloc) {\n\n        int fd = memory_region_get_fd(&backend->mr);\n\n        void *ptr = memory_region_get_ram_ptr(&backend->mr);\n\n        uint64_t sz = memory_region_size(&backend->mr);\n\n\n\n        os_mem_prealloc(fd, ptr, sz, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        backend->prealloc = true;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int usb_dev_restore(struct device *dev)\n{\n\treturn usb_resume(dev, PMSG_RESTORE);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Http::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "xfs_vm_page_mkwrite(\n\tstruct vm_area_struct\t*vma,\n\tstruct vm_fault\t\t*vmf)\n{\n\treturn block_page_mkwrite(vma, vmf, xfs_get_blocks);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void __lock_sock(struct sock *sk)\n{\n\tDEFINE_WAIT(wait);\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&sk->sk_lock.wq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock_bh(&sk->sk_lock.slock);\n\t\tschedule();\n\t\tspin_lock_bh(&sk->sk_lock.slock);\n\t\tif (!sock_owned_by_user(sk))\n\t\t\tbreak;\n\t}\n\tfinish_wait(&sk->sk_lock.wq, &wait);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "emit_S(codegen_scope *s, int pc, uint16_t i)\n{\n  uint8_t hi = i>>8;\n  uint8_t lo = i&0xff;\n\n  emit_B(s, pc,   hi);\n  emit_B(s, pc+1, lo);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "explicit SimpleBinaryOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "const CLSID& GetToastActivatorClsid() {\n  return InstallDetails::Get().toast_activator_clsid();\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static ram_addr_t find_ram_offset(ram_addr_t size)\n\n{\n\n    RAMBlock *block, *next_block;\n\n    ram_addr_t offset, mingap = ULONG_MAX;\n\n\n\n    if (QLIST_EMPTY(&ram_list.blocks))\n\n        return 0;\n\n\n\n    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n        ram_addr_t end, next = ULONG_MAX;\n\n\n\n        end = block->offset + block->length;\n\n\n\n        QLIST_FOREACH(next_block, &ram_list.blocks, next) {\n\n            if (next_block->offset >= end) {\n\n                next = MIN(next, next_block->offset);\n\n            }\n\n        }\n\n        if (next - end >= size && next - end < mingap) {\n\n            offset =  end;\n\n            mingap = next - end;\n\n        }\n\n    }\n\n    return offset;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static ssize_t firmware_revision_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\n\treturn snprintf(buf, 20, \"%u.%x\\n\", id.firmware_revision_1,\n\t\t\tid.firmware_revision_2);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\n\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\n\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\tcomp_dir = attribute->string.content;\n\t\t}\n\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t}\n\t\t}\n\t\tdie->count++;\n\t}\n\n\t// If this is a compilation unit dir attribute, we want to cache it so the line info parsing\n\t// which will need this info can quickly look it up.\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buf;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "Item *Item_cache::safe_charset_converter(CHARSET_INFO *tocs)\n{\n  if (!example)\n    return Item::safe_charset_converter(tocs);\n  Item *conv= example->safe_charset_converter(tocs);\n  if (conv == example)\n    return this;\n  Item_cache *cache;\n  if (!conv || conv->fix_fields(current_thd, (Item **) NULL) ||\n      !(cache= new Item_cache_str(conv)))\n    return NULL; // Safe conversion is not possible, or OEM\n  cache->setup(conv);\n  cache->fixed= false; // Make Item::fix_fields() happy\n  return cache;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void bnx2x_set_reset_global(struct bnx2x *bp)\n{\n\tu32 val;\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n\tval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\tREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val | BNX2X_GLOBAL_RESET_BIT);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void __mcheck_cpu_init_early(struct cpuinfo_x86 *c)\n{\n\tif (c->x86_vendor == X86_VENDOR_AMD) {\n\t\tmce_flags.overflow_recov = !!cpu_has(c, X86_FEATURE_OVERFLOW_RECOV);\n\t\tmce_flags.succor\t = !!cpu_has(c, X86_FEATURE_SUCCOR);\n\t\tmce_flags.smca\t\t = !!cpu_has(c, X86_FEATURE_SMCA);\n\n\t\tif (mce_flags.smca) {\n\t\t\tmsr_ops.ctl\t= smca_ctl_reg;\n\t\t\tmsr_ops.status\t= smca_status_reg;\n\t\t\tmsr_ops.addr\t= smca_addr_reg;\n\t\t\tmsr_ops.misc\t= smca_misc_reg;\n\t\t}\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "//! Return a reference to an empty display \\const.\n    static const CImgDisplay& const_empty() {\n      static const CImgDisplay _empty;\n      return _empty;",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)\n    : saml2md::DynamicMetadataProvider(e),\n         m_verifyHost(XMLHelper::getAttrBool(e, true, verifyHost)),\n         m_ignoreTransport(XMLHelper::getAttrBool(e, false, ignoreTransport)),\n         m_encoded(true), m_trust(nullptr)\n{\n    const DOMElement* child = XMLHelper::getFirstChildElement(e, Subst);\n    if (child && child->hasChildNodes()) {\n        auto_ptr_char s(child->getFirstChild()->getNodeValue());\n        if (s.get() && *s.get()) {\n            m_subst = s.get();\n            m_encoded = XMLHelper::getAttrBool(child, true, encoded);\n            m_hashed = XMLHelper::getAttrString(child, nullptr, hashed);\n        }\n    }\n\n    if (m_subst.empty()) {\n        child = XMLHelper::getFirstChildElement(e, Regex);\n        if (child && child->hasChildNodes() && child->hasAttributeNS(nullptr, match)) {\n            m_match = XMLHelper::getAttrString(child, nullptr, match);\n            auto_ptr_char repl(child->getFirstChild()->getNodeValue());\n            if (repl.get() && *repl.get())\n                m_regex = repl.get();\n        }\n    }\n\n    if (!m_ignoreTransport) {\n        child = XMLHelper::getFirstChildElement(e, _TrustEngine);\n        string t = XMLHelper::getAttrString(child, nullptr, _type);\n        if (!t.empty()) {\n            TrustEngine* trust = XMLToolingConfig::getConfig().TrustEngineManager.newPlugin(t.c_str(), child);\n            if (!dynamic_cast<X509TrustEngine*>(trust)) {\n                delete trust;\n                throw ConfigurationException(\"DynamicMetadataProvider requires an X509TrustEngine plugin.\");\n            }\n            m_trust.reset(dynamic_cast<X509TrustEngine*>(trust));\n            m_dummyCR.reset(XMLToolingConfig::getConfig().CredentialResolverManager.newPlugin(DUMMY_CREDENTIAL_RESOLVER, nullptr));\n        }\n\n        if (!m_trust.get() || !m_dummyCR.get())\n            throw ConfigurationException(\"DynamicMetadataProvider requires an X509TrustEngine plugin unless ignoreTransport is true.\");\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "zzip_mem_disk_findnext(ZZIP_MEM_DISK* dir, ZZIP_DISK_ENTRY* entry) {\n    return zzip_mem_disk_findnext(dir->disk, entry);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void blk_set_queue_dying(struct request_queue *q)\n{\n\tblk_queue_flag_set(QUEUE_FLAG_DYING, q);\n\n\t/*\n\t * When queue DYING flag is set, we need to block new req\n\t * entering queue, so we call blk_freeze_queue_start() to\n\t * prevent I/O from crossing blk_queue_enter().\n\t */\n\tblk_freeze_queue_start(q);\n\n\tif (queue_is_mq(q))\n\t\tblk_mq_wake_waiters(q);\n\n\t/* Make blk_queue_enter() reexamine the DYING flag. */\n\twake_up_all(&q->mq_freeze_wq);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "  void compareHeaders(Headers&& headers, ExpectedHeaders& expected_headers) {\n    headers.remove(Envoy::Http::LowerCaseString{\"content-length\"});\n    headers.remove(Envoy::Http::LowerCaseString{\"date\"});\n    if (!routerSuppressEnvoyHeaders()) {\n      headers.remove(Envoy::Http::LowerCaseString{\"x-envoy-expected-rq-timeout-ms\"});\n      headers.remove(Envoy::Http::LowerCaseString{\"x-envoy-upstream-service-time\"});\n    }\n    headers.remove(Envoy::Http::LowerCaseString{\"x-forwarded-proto\"});\n    headers.remove(Envoy::Http::LowerCaseString{\"x-request-id\"});\n    headers.remove(Envoy::Http::LowerCaseString{\"x-envoy-internal\"});\n\n    EXPECT_EQ(expected_headers, headers);\n  }",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "truncate_partial (GMarkupParseContext *context)\n{\n  if (context->partial_chunk != NULL)\n    string_blank (context->partial_chunk);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "TIFFReadDirEntryCheckRangeLongSlong8(int64 value)\n{\n\tif ((value < 0) || (value > (int64) TIFF_UINT32_MAX))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "ssize_t enc_untrusted_read(int fd, void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_read, fd, buf, count));\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "cJSON *cJSON_CreateObject( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_Object;\n\treturn item;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "pk_transaction_percentage_cb (PkBackendJob *job,\n\t\t\t      guint percentage,\n\t\t\t      PkTransaction *transaction)\n{\n\t/* emit */\n\ttransaction->priv->percentage = percentage;\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"Percentage\",\n\t\t\t\t\t      g_variant_new_uint32 (percentage));\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int io_async_buf_func(struct wait_queue_entry *wait, unsigned mode,\n\t\t\t     int sync, void *arg)\n{\n\tstruct wait_page_queue *wpq;\n\tstruct io_kiocb *req = wait->private;\n\tstruct wait_page_key *key = arg;\n\tint ret;\n\n\twpq = container_of(wait, struct wait_page_queue, wait);\n\n\tif (!wake_page_match(wpq, key))\n\t\treturn 0;\n\n\tlist_del_init(&wait->entry);\n\n\tinit_task_work(&req->task_work, io_req_task_submit);\n\t/* submit ref gets dropped, acquire a new one */\n\trefcount_inc(&req->refs);\n\tret = io_req_task_work_add(req, &req->task_work);\n\tif (unlikely(ret)) {\n\t\tstruct task_struct *tsk;\n\n\t\t/* queue just for cancelation */\n\t\tinit_task_work(&req->task_work, io_req_task_cancel);\n\t\ttsk = io_wq_get_task(req->ctx->io_wq);\n\t\ttask_work_add(tsk, &req->task_work, 0);\n\t\twake_up_process(tsk);\n\t}\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int ttm_tt_init(struct ttm_tt *ttm, struct ttm_buffer_object *bo,\n\t\tuint32_t page_flags)\n{\n\tttm_tt_init_fields(ttm, bo, page_flags);\n\n\tif (ttm_tt_alloc_page_directory(ttm)) {\n\t\tttm_tt_destroy(ttm);\n\t\tpr_err(\"Failed allocating page table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n \tchar *p2;\n \tstruct debug_data *d = f->private_data;\n \n\tpdata = kmalloc(cnt, GFP_KERNEL);\n \tif (pdata == NULL)\n \t\treturn 0;\n \n\tif (copy_from_user(pdata, buf, cnt)) {\n\t\tlbs_deb_debugfs(\"Copy from user failed\\n\");\n \t\tkfree(pdata);\n \t\treturn 0;\n \t}\n \n \tp0 = pdata;\n \tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\n\treturn (ssize_t)cnt;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "cdf_read_user_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, const char *name, cdf_stream_t *scn)\n{\n\tconst cdf_directory_t *d;\n\tint i = cdf_find_stream(dir, name, CDF_DIR_TYPE_USER_STREAM);\n\n\tif (i <= 0) {\n\t\tmemset(scn, 0, sizeof(*scn));\n\t\treturn -1;\n\t}\n\n\td = &dir->dir_tab[i - 1];\n\treturn cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t    d->d_stream_first_sector, d->d_size, scn);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static AVFrame *alloc_frame(enum AVPixelFormat pixfmt, int w, int h)\n\n{\n\n    AVFrame *frame = av_frame_alloc();\n\n    if (!frame)\n\n        return NULL;\n\n\n\n    frame->format = pixfmt;\n\n    frame->width  = w;\n\n    frame->height = h;\n\n\n\n    if (av_frame_get_buffer(frame, 32) < 0)\n\n        return NULL;\n\n\n\n    return frame;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void __exit llc2_exit(void)\n{\n\tllc_station_exit();\n\tllc_remove_pack(LLC_DEST_SAP);\n\tllc_remove_pack(LLC_DEST_CONN);\n\tsock_unregister(PF_LLC);\n\tllc_proc_exit();\n\tllc_sysctl_exit();\n\tproto_unregister(&llc_proto);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline void gen_addr_imm_index (DisasContext *ctx)\n\n{\n\n    target_long simm = SIMM(ctx->opcode);\n\n\n\n    if (rA(ctx->opcode) == 0) {\n\n        gen_op_set_T0(simm);\n\n    } else {\n\n        gen_op_load_gpr_T0(rA(ctx->opcode));\n\n        if (likely(simm != 0))\n\n            gen_op_addi(simm);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "initialize(int argc, VALUE argv[], VALUE self)\n{\n    ffi_cif * cif;\n    ffi_type **arg_types;\n    ffi_status result;\n    VALUE ptr, args, ret_type, abi, kwds;\n    long i;\n\n    rb_scan_args(argc, argv, \"31:\", &ptr, &args, &ret_type, &abi, &kwds);\n    if(NIL_P(abi)) abi = INT2NUM(FFI_DEFAULT_ABI);\n\n    Check_Type(args, T_ARRAY);\n    Check_Max_Args(\"args\", RARRAY_LENINT(args));\n\n    rb_iv_set(self, \"@ptr\", ptr);\n    rb_iv_set(self, \"@args\", args);\n    rb_iv_set(self, \"@return_type\", ret_type);\n    rb_iv_set(self, \"@abi\", abi);\n\n    if (!NIL_P(kwds)) rb_hash_foreach(kwds, parse_keyword_arg_i, self);\n\n    TypedData_Get_Struct(self, ffi_cif, &function_data_type, cif);\n\n    arg_types = xcalloc(RARRAY_LEN(args) + 1, sizeof(ffi_type *));\n\n    for (i = 0; i < RARRAY_LEN(args); i++) {\n\tint type = NUM2INT(RARRAY_AREF(args, i));\n\targ_types[i] = INT2FFI_TYPE(type);\n    }\n    arg_types[RARRAY_LEN(args)] = NULL;\n\n    result = ffi_prep_cif (\n\t    cif,\n\t    NUM2INT(abi),\n\t    RARRAY_LENINT(args),\n\t    INT2FFI_TYPE(NUM2INT(ret_type)),\n\t    arg_types);\n\n    if (result)\n\trb_raise(rb_eRuntimeError, \"error creating CIF %d\", result);\n\n    return self;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void tty_set_termios_ldisc(struct tty_struct *tty, int num)\n{\n \tdown_write(&tty->termios_rwsem);\n \ttty->termios.c_line = num;\n \tup_write(&tty->termios_rwsem);\n }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void parsePCPMAP_version2(const uint8_t *map_v2,\n\t\tpcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->is_map_op = 1;\n\tmemcpy(pcp_msg_info->nonce, map_v2, 12);\n\tpcp_msg_info->protocol = map_v2[12];\n\tpcp_msg_info->int_port = READNU16(map_v2 + 16);\n\tpcp_msg_info->ext_port = READNU16(map_v2 + 18);\n\n\tpcp_msg_info->ext_ip = (struct in6_addr *)(map_v2 + 20);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void qvirtio_pci_set_status(QVirtioDevice *d, uint8_t status)\n\n{\n\n    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;\n\n    qpci_io_writeb(dev->pdev, dev->addr + VIRTIO_PCI_STATUS, status);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void unzzip_cat_file(ZZIP_DIR* disk, char* name, FILE* out)\n{\n    ZZIP_FILE* file = zzip_file_open (disk, name, 0);\n    if (file) \n    {\n\tchar buffer[1024]; int len;\n\twhile ((len = zzip_file_read (file, buffer, 1024))) \n\t{\n\t    fwrite (buffer, 1, len, out);\n\t}\n\t\n\tzzip_file_close (file);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void ssl_set_extended_master_secret( ssl_context *ssl, char ems )\n{\n    ssl->extended_ms = ems;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "inline uint16 GetChallengeTime( SteamNetworkingMicroseconds usecNow )\n{\n\treturn uint16( usecNow >> 20 );\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void __generic_sub_update_flags_rr(RAnalOp *op, int d, int r, int carry) {\n\t__generic_sub_update_flags(op, 'r', d, 'r', r, carry);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int nfs4_lookup_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fsinfo *info, rpc_authflavor_t flavor)\n{\n\tstruct rpc_auth *auth;\n\tint ret;\n\n\tauth = rpcauth_create(flavor, server->client);\n\tif (IS_ERR(auth)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tret = nfs4_lookup_root(server, fhandle, info);\nout:\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void freeDebugCallbackArgs(int number, char **args) {\n for (int i = 0; i < number; i++) {\n if (args[i] != NULL) {\n            free(args[i]);\n }\n }\n    free(args);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void pcrb_del(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->pcr_values) gf_free(ptr->pcr_values);\n\tgf_free(ptr);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif (remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif (remain == 0) {\n\t\t\treturn EOF;\n\t\t}\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *) dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "ia64_patch_vtop (unsigned long start, unsigned long end)\n{\n\ts32 *offp = (s32 *) start;\n\tu64 ip;\n\n\twhile (offp < (s32 *) end) {\n\t\tip = (u64) offp + *offp;\n\n\t\t/* replace virtual address with corresponding physical address: */\n\t\tia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));\n\t\tia64_fc((void *) ip);\n\t\t++offp;\n\t}\n\tia64_sync_i();\n \tia64_srlz_i();\n }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int ath6kl_wmi_ratemask_reply_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\tif (len < sizeof(struct wmi_fix_rates_reply))\n\t\treturn -EINVAL;\n\n\tath6kl_wakeup_event(wmi->parent_dev);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static ssize_t proc_sessionid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_sessionid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline void tss_update_io_bitmap(void)\n{\n\tPVOP_VCALL0(cpu.update_io_bitmap);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int bio_copy_to_iter(struct bio *bio, struct iov_iter iter)\n{\n\tint i;\n\tstruct bio_vec *bvec;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tssize_t ret;\n\n\t\tret = copy_page_to_iter(bvec->bv_page,\n\t\t\t\t\tbvec->bv_offset,\n\t\t\t\t\tbvec->bv_len,\n\t\t\t\t\t&iter);\n\n\t\tif (!iov_iter_count(&iter))\n\t\t\tbreak;\n\n\t\tif (ret < bvec->bv_len)\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "gs_window_destroy (GSWindow *window)\n{\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        gs_window_cancel_unlock_request (window);\n\n        gtk_widget_destroy (GTK_WIDGET (window));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void Magick::Image::read(const Blob &blob_,const Geometry &size_)\n{\n  size(size_);\n  read(blob_);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int nf_tables_newexpr(const struct nft_ctx *ctx,\n\t\t\t     const struct nft_expr_info *info,\n\t\t\t     struct nft_expr *expr)\n{\n\tconst struct nft_expr_ops *ops = info->ops;\n\tint err;\n\n\texpr->ops = ops;\n\tif (ops->init) {\n\t\terr = ops->init(ctx, expr, (const struct nlattr **)info->tb);\n\t\tif (err < 0)\n\t\t\tgoto err1;\n\t}\n\n\treturn 0;\n\nerr1:\n\texpr->ops = NULL;\n\treturn err;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "EnvVarHolder( const std::string &name_, const Item &def_ ):\n      name( name_ ), def( def_ ) {}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "std_term_destination(j_compress_ptr cinfo)\n{\n\tJPEGState* sp = (JPEGState*) cinfo;\n\tTIFF* tif = sp->tif;\n\n\ttif->tif_rawcp = (uint8*) sp->dest.next_output_byte;\n\ttif->tif_rawcc =\n\t    tif->tif_rawdatasize - (tmsize_t) sp->dest.free_in_buffer;\n\t/* NB: libtiff does the final buffer flush */\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "AppendToRedobuff(char_u *s)\n{\n    if (!block_redo)\n\tadd_buff(&redobuff, s, -1L);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n\t\treturn 0;\n\n\treturn info_for_irq(irq)->evtchn;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int decode_rle(uint8_t *bitmap, int linesize, int w, int h,\n                      const uint8_t *buf, int start, int buf_size, int is_8bit)\n{\n    GetBitContext gb;\n    int bit_len;\n    int x, y, len, color;\n    uint8_t *d;\n    if (start >= buf_size)\n    bit_len = (buf_size - start) * 8;\n    init_get_bits(&gb, buf + start, bit_len);\n    x = 0;\n    y = 0;\n    d = bitmap;\n    for(;;) {\n        if (get_bits_count(&gb) > bit_len)\n        if (is_8bit)\n            len = decode_run_8bit(&gb, &color);\n        else\n            len = decode_run_2bit(&gb, &color);\n        len = FFMIN(len, w - x);\n        memset(d + x, color, len);\n        x += len;\n        if (x >= w) {\n            y++;\n            if (y >= h)\n                break;\n            d += linesize;\n            x = 0;\n            /* byte align */\n            align_get_bits(&gb);\n        }\n    }\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void *js_malloc(js_State *J, int size)\n{\n\tvoid *ptr = J->alloc(J->actx, NULL, size);\n\tif (!ptr)\n\t\tjs_outofmemory(J);\n\treturn ptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "R_API ut64 r_bin_java_do_nothing_calc_size(RBinJavaCPTypeObj *obj) {\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int mxf_timestamp_to_str(uint64_t timestamp, char **str)\n{\n    struct tm time = { 0 };\n    time.tm_year = (timestamp >> 48) - 1900;\n    time.tm_mon  = (timestamp >> 40 & 0xFF) - 1;\n    time.tm_mday = (timestamp >> 32 & 0xFF);\n    time.tm_hour = (timestamp >> 24 & 0xFF);\n    time.tm_min  = (timestamp >> 16 & 0xFF);\n    time.tm_sec  = (timestamp >> 8  & 0xFF);\n    *str = av_mallocz(32);\n    if (!*str)\n        return AVERROR(ENOMEM);\n    strftime(*str, 32, \"%Y-%m-%d %H:%M:%S\", &time);\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool ValidateCCM()\r\n{\r\n\tstd::cout << \"\\nAES/CCM validation suite running...\\n\";\r\n\treturn RunTestDataFile(CRYPTOPP_DATA_DIR \"TestVectors/ccm.txt\");\r\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void virtio_host_initfn(Object *obj)\n\n{\n\n    VirtIOInputHostPCI *dev = VIRTIO_INPUT_HOST_PCI(obj);\n\n\n\n    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),\n\n                                TYPE_VIRTIO_INPUT_HOST);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void op_addXopCC(MCInst *MI, int v)\n{\n\tif (MI->csh->detail) {\n\t\tMI->flat_insn->detail->x86.xop_cc = v;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2), void *arg, int *ret, int count, int size)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        int r = func(c, (char *)arg + i * size);\n        if (ret)\n            ret[i] = r;\n    }\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "guint8_to_hex(char *out, guint8 val)\n{\n\treturn byte_to_hex(out, val);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "Function_Call_Obj Parser::parse_function_call()\n  {\n    lex< identifier >();\n    std::string name(lexed);\n\n    if (Util::normalize_underscores(name) == \"content-exists\" && stack.back() != Scope::Mixin)\n    { error(\"Cannot call content-exists() except within a mixin.\"); }\n\n    ParserState call_pos = pstate;\n    Arguments_Obj args = parse_arguments();\n    return SASS_MEMORY_NEW(Function_Call, call_pos, name, args);\n  }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int match_server(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&vol->dstaddr;\n\n\tif ((server->vals != vol->vals) || (server->ops != vol->ops))\n\t\treturn 0;\n\n\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\treturn 0;\n\n\tif (!match_address(server, addr,\n\t\t\t   (struct sockaddr *)&vol->srcaddr))\n\t\treturn 0;\n\n\tif (!match_port(server, addr))\n\t\treturn 0;\n\n\tif (!match_security(server, vol))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void skb_coalesce_rx_frag(struct sk_buff *skb, int i, int size,\n\t\t\t  unsigned int truesize)\n{\n\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\tskb_frag_size_add(frag, size);\n\tskb->len += size;\n\tskb->data_len += size;\n\tskb->truesize += truesize;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,\n                         TensorHandle* tensor_handle, Device** result) {\n  Device* cpu_device = ctx.HostCPU();\n  string device_name;\n  if (tensor_handle->Type() != TensorHandle::LOCAL) {\n    Device* device = tensor_handle->device();\n    device_name = device != nullptr ? device->name() : cpu_device->name();\n    *result = (device == nullptr ? cpu_device : device);\n  } else if (tensor_handle->dtype == DT_RESOURCE) {\n    // Use the resource's actual device because it is the device that will\n    // influence partitioning the multi-device function.\n    const Tensor* tensor;\n    // TODO(fishx): Avoid blocking here.\n    TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));\n    const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);\n    device_name = handle.device();\n\n    Device* input_device;\n    TF_RETURN_IF_ERROR(\n        ctx.FindDeviceFromName(device_name.c_str(), &input_device));\n    *result = input_device;\n  } else {\n    Device* device = tensor_handle->device();\n    const bool is_tpu = device != nullptr && device->device_type() == \"TPU\";\n    // int32 return values can be placed on TPUs.\n    const bool use_host_memory =\n        is_tpu ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)\n               : MTypeFromDType(tensor_handle->dtype);\n    if (use_host_memory) {\n      *result = cpu_device;\n    } else {\n      // Eager ops executing as functions should have their preferred inputs set\n      // to the op's device. This allows us to avoid expensive D2H copies if a\n      // mirror of the tensor already exists on the op's device.\n      if (!op.is_function() && device != nullptr && device != cpu_device) {\n        device = absl::get<Device*>(op.Device());\n      }\n      *result = (device == nullptr ? cpu_device : device);\n    }\n  }\n  return Status::OK();\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; // should never happen, but just in case of overflow!\n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  // On linux, we set STACK_BASE from `main`.\n  char ptr; // this is on the stack\n  extern void *STACK_BASE;\n  uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  return 1000000 - count; // give it 1 megabyte of stack\n#else\n  // stack depth seems pretty platform-specific :( Default to a value that disables it\n  return 1000000; // no stack depth check on this platform\n#endif\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int parse_meter(DBEContext *s)\n\n{\n\n    if (s->meter_size)\n\n        skip_input(s, s->key_present + s->meter_size + 1);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void SharedMemory::Lock() {\n  Lock(INFINITE, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "IW_IMPL(unsigned int) iw_color_get_int_sample(struct iw_color *clr, int channel,\n\tunsigned int maxcolorcode)\n{\n\tint n;\n\tn = (int)(0.5+(clr->c[channel] * (double)maxcolorcode));\n\tif(n<0) n=0;\n\telse if(n>(int)maxcolorcode) n=(int)maxcolorcode;\n\treturn (unsigned int)n;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void smp_proc_enc_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n\n   uint8_t* p = p_data->p_data;\n \n   SMP_TRACE_DEBUG(\"%s\", __func__);\n\n  if (smp_command_has_invalid_parameters(p_cb)) {\n    tSMP_INT_DATA smp_int_data;\n    smp_int_data.status = SMP_INVALID_PARAMETERS;\n    android_errorWriteLog(0x534e4554, \"111937065\");\n    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n    return;\n  }\n\n   STREAM_TO_ARRAY(p_cb->ltk, p, BT_OCTET16_LEN);\n \n   smp_key_distribution(p_cb, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void virtio_balloon_save(QEMUFile *f, void *opaque)\n\n{\n\n    VirtIOBalloon *s = opaque;\n\n\n\n    virtio_save(&s->vdev, f);\n\n\n\n    qemu_put_be32(f, s->num_pages);\n\n    qemu_put_be32(f, s->actual);\n\n    qemu_put_buffer(f, (uint8_t *)&s->stats_vq_elem, sizeof(VirtQueueElement));\n\n    qemu_put_buffer(f, (uint8_t *)&s->stats_vq_offset, sizeof(size_t));\n\n    qemu_put_buffer(f, (uint8_t *)&s->stats_callback, sizeof(MonitorCompletion));\n\n    qemu_put_buffer(f, (uint8_t *)&s->stats_opaque_callback_data, sizeof(void));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "local void grow_space(struct space *space)\n{\n    size_t more;\n\n    /* compute next size up */\n    more = grow(space->size);\n    if (more == space->size)\n        bail(\"not enough memory\", \"\");\n\n    /* reallocate the buffer */\n    space->buf = REALLOC(space->buf, more);\n    if (space->buf == NULL)\n        bail(\"not enough memory\", \"\");\n    space->size = more;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void snd_usbmidi_emagic_finish_out(struct snd_usb_midi_out_endpoint *ep)\n{\n\tstatic const u8 finish_data[] = {\n\t\t/* switch to patch mode with last preset */\n\t\t0xf0,\n\t\t0x00, 0x20, 0x31,\t/* Emagic */\n\t\t0x64,\t\t\t/* Unitor8 */\n\t\t0x10,\t\t\t/* patch switch command */\n\t\t0x00,\t\t\t/* command version */\n\t\t0x7f,\t\t\t/* to all boxes */\n\t\t0x40,\t\t\t/* last preset in EEPROM */\n\t\t0xf7\n\t};\n\tsend_bulk_static_data(ep, finish_data, sizeof(finish_data));\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void mpegts_close_filter(MpegTSContext *ts, MpegTSFilter *filter)\n\n{\n\n    int pid;\n\n\n\n    pid = filter->pid;\n\n    if (filter->type == MPEGTS_SECTION)\n\n        av_freep(&filter->u.section_filter.section_buf);\n\n\n\n\n\n\n\n\n\n\n    av_free(filter);\n\n    ts->pids[pid] = NULL;\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "my_decimal *Item_ref::val_decimal_result(my_decimal *decimal_value)\n{\n  if (result_field)\n  {\n    if ((null_value= result_field->is_null()))\n      return 0;\n    return result_field->val_decimal(decimal_value);\n  }\n  return val_decimal(decimal_value);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int msg_compare_reverse(const void *m1, const void *m2) {\n   return strcoll(((MSG_LIST *) m2)->string, ((MSG_LIST *) m1)->string);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void vhost_scsi_port_unlink(struct se_portal_group *se_tpg,\n\t\t\t\t  struct se_lun *lun)\n{\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\n\tmutex_lock(&vhost_scsi_mutex);\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\ttpg->tv_tpg_port_count--;\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n\n\tvhost_scsi_hotunplug(tpg, lun);\n\n\tmutex_unlock(&vhost_scsi_mutex);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int mg_printf(struct mg_connection *c, const char *fmt, ...) {\n  int len = 0;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vprintf(c, fmt, ap);\n  va_end(ap);\n  return len;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void Opal::Call::set_reject_delay (unsigned delay)\n{\n  NoAnswerTimer.SetInterval (0, PMIN (delay, 60));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void filter_map_apply(zval *value, filter_map *map)\n{\n\tunsigned char *str;\n\tint   i, c;\n\tzend_string *buf;\n\n\tstr = (unsigned char *)Z_STRVAL_P(value);\n\tbuf = zend_string_alloc(Z_STRLEN_P(value) + 1, 0);\n\tc = 0;\n\tfor (i = 0; i < Z_STRLEN_P(value); i++) {\n\t\tif ((*map)[str[i]]) {\n\t\t\tZSTR_VAL(buf)[c] = str[i];\n\t\t\t++c;\n\t\t}\n\t}\n\t/* update zval string data */\n\tZSTR_VAL(buf)[c] = '\\0';\n\tZSTR_LEN(buf) = c;\n\tzval_ptr_dtor(value);\n\tZVAL_NEW_STR(value, buf);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static const uint8_t *pcx_rle_decode(const uint8_t *src,\n\n                                     const uint8_t *end,\n\n                                     uint8_t *dst,\n\n                                     unsigned int bytes_per_scanline,\n\n                                     int compressed)\n\n{\n\n    unsigned int i = 0;\n\n    unsigned char run, value;\n\n\n\n    if (compressed) {\n\n        while (i < bytes_per_scanline && src < end) {\n\n            run   = 1;\n\n            value = *src++;\n\n            if (value >= 0xc0 && src < end) {\n\n                run   = value & 0x3f;\n\n                value = *src++;\n\n            }\n\n            while (i < bytes_per_scanline && run--)\n\n                dst[i++] = value;\n\n        }\n\n    } else {\n\n        memcpy(dst, src, bytes_per_scanline);\n\n        src += bytes_per_scanline;\n\n    }\n\n\n\n    return src;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "xfs_attr_flags(\n\tu32\t\t\tioc_flags)\n{\n\tif (ioc_flags & XFS_IOC_ATTR_CREATE)\n\t\treturn XATTR_CREATE;\n\tif (ioc_flags & XFS_IOC_ATTR_REPLACE)\n\t\treturn XATTR_REPLACE;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "uint32_t PentaxMnHeader::ifdOffset() const\n    {\n        return sizeOfSignature();\n    }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ArgParser::argKeepFilesOpenThreshold(char* parameter)\n{\n    o.keep_files_open_threshold =\n        static_cast<size_t>(QUtil::string_to_int(parameter));\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline int vmsvga_fifo_length(struct vmsvga_state_s *s)\n\n{\n\n    int num;\n\n\n\n    if (!s->config || !s->enable) {\n\n        return 0;\n\n    }\n\n\n\n    /* Check range and alignment.  */\n\n    if ((CMD(min) | CMD(max) | CMD(next_cmd) | CMD(stop)) & 3) {\n\n        return 0;\n\n    }\n\n    if (CMD(min) < (uint8_t *) s->cmd->fifo - (uint8_t *) s->fifo) {\n\n        return 0;\n\n    }\n\n    if (CMD(max) > SVGA_FIFO_SIZE ||\n\n        CMD(min) >= SVGA_FIFO_SIZE ||\n\n        CMD(stop) >= SVGA_FIFO_SIZE ||\n\n        CMD(next_cmd) >= SVGA_FIFO_SIZE) {\n\n        return 0;\n\n    }\n\n    if (CMD(max) < CMD(min) + 10 * 1024) {\n\n        return 0;\n\n    }\n\n\n\n    num = CMD(next_cmd) - CMD(stop);\n\n    if (num < 0) {\n\n        num += CMD(max) - CMD(min);\n\n    }\n\n    return num >> 2;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void RenderView::OnReservePageIDRange(int size_of_range) {\n  next_page_id_ += size_of_range + 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void ff_thread_report_progress2(AVCodecContext *avctx, int field, int thread, int n)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "Exifdatum::Exifdatum(const ExifKey& key, const Value* pValue)\n        : key_(key.clone())\n    {\n        if (pValue) value_ = pValue->clone();\n    }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void __adjust_nat_entry_set(struct nat_entry_set *nes,\n\t\t\t\t\t\tstruct list_head *head, int max)\n{\n\tstruct nat_entry_set *cur;\n\n\tif (nes->entry_cnt >= max)\n\t\tgoto add_out;\n\n\tlist_for_each_entry(cur, head, set_list) {\n\t\tif (cur->entry_cnt >= nes->entry_cnt) {\n\t\t\tlist_add(&nes->set_list, cur->set_list.prev);\n\t\t\treturn;\n\t\t}\n\t}\nadd_out:\n\tlist_add_tail(&nes->set_list, head);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "set<rgw_zone_id> get_zone_ids_from_names(rgw::sal::RGWRadosStore *store,\n                                             const vector<string>& zone_names) const {\n      set<rgw_zone_id> ids;\n\n      for (auto& name : zone_names) {\n        rgw_zone_id id;\n        if (store->svc()->zone->find_zone_id_by_name(name, &id)) {\n          ids.insert(std::move(id));\n        }\n      }\n\n      return ids;\n    }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "GfxRadialShading::GfxRadialShading(double x0A, double y0A, double r0A,\n\t\t\t\t   double x1A, double y1A, double r1A,\n\t\t\t\t   double t0A, double t1A,\n\t\t\t\t   Function **funcsA, int nFuncsA,\n\t\t\t\t   GBool extend0A, GBool extend1A):\n  GfxShading(3)\n{\n  int i;\n\n  x0 = x0A;\n  y0 = y0A;\n  r0 = r0A;\n  x1 = x1A;\n  y1 = y1A;\n  r1 = r1A;\n  t0 = t0A;\n  t1 = t1A;\n  nFuncs = nFuncsA;\n  for (i = 0; i < nFuncs; ++i) {\n    funcs[i] = funcsA[i];\n  }\n  extend0 = extend0A;\n  extend1 = extend1A;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void pushGenericCommand(client *c, int where) {\n    int j, pushed = 0;\n    robj *lobj = lookupKeyWrite(c->db,c->argv[1]);\n\n    if (lobj && lobj->type != OBJ_LIST) {\n        addReply(c,shared.wrongtypeerr);\n        return;\n    }\n\n    for (j = 2; j < c->argc; j++) {\n        if (!lobj) {\n            lobj = createQuicklistObject();\n            quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,\n                                server.list_compress_depth);\n            dbAdd(c->db,c->argv[1],lobj);\n        }\n        listTypePush(lobj,c->argv[j],where);\n        pushed++;\n    }\n    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));\n    if (pushed) {\n        char *event = (where == LIST_HEAD) ? \"lpush\" : \"rpush\";\n\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);\n    }\n    server.dirty += pushed;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "  virtual uint32_t skip_virt(TType type) { return ::apache::thrift::protocol::skip(*this, type); }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "snmp_clone_pdu(netsnmp_pdu *pdu)\n{\n    return _clone_pdu(pdu, 0);  /* copies all variables */\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void llcp_sock_destruct(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_put_device(llcp_sock->dev);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tnfc_llcp_sock_free(llcp_sock);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC LLCP socket %p\\n\", sk);\n\t\treturn;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline void inc_slabs_node(struct kmem_cache *s, int node, int objects)\n{\n\tstruct kmem_cache_node *n = get_node(s, node);\n\n\t/*\n\t * May be called early in order to allocate a slab for the\n\t * kmem_cache_node structure. Solve the chicken-egg\n\t * dilemma by deferring the increment of the count during\n\t * bootstrap (see early_kmem_cache_node_alloc).\n\t */\n\tif (!NUMA_BUILD || n) {\n\t\tatomic_long_inc(&n->nr_slabs);\n\t\tatomic_long_add(objects, &n->total_objects);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bool operator()(const TrueTypeLoca &loca1, const TrueTypeLoca &loca2) {\n    if (loca1.origOffset == loca2.origOffset) {\n      return loca1.idx < loca2.idx;\n    }\n    return loca1.origOffset < loca2.origOffset;\n  }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int fic_decode_block(FICContext *ctx, GetBitContext *gb,\n\n                            uint8_t *dst, int stride, int16_t *block, int *is_p)\n\n{\n\n    int i, num_coeff;\n\n\n\n    /* Is it a skip block? */\n\n    if (get_bits1(gb)) {\n\n        *is_p = 1;\n\n        return 0;\n\n    }\n\n\n\n    memset(block, 0, sizeof(*block) * 64);\n\n\n\n    num_coeff = get_bits(gb, 7);\n\n    if (num_coeff > 64)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < num_coeff; i++)\n\n        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *\n\n                                     ctx->qmat[ff_zigzag_direct[i]];\n\n\n\n    fic_idct_put(dst, stride, block);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "[[noreturn]] void TProtocolException::throwExceededSizeLimit() {\n  throw TProtocolException(TProtocolException::SIZE_LIMIT);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void set_checkpoint_signal(void)\n{\n\tstruct sigaction sa;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = checkpoint_signal;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_RESTART;\n\tsigaction(SIGUSR1, &sa, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void kernel_fp_unavailable_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Unrecoverable FP Unavailable Exception \"\n\t\t\t  \"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable FP Unavailable Exception\", regs, SIGABRT);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int __dm_pr_register(struct dm_target *ti, struct dm_dev *dev,\n\t\t\t    sector_t start, sector_t len, void *data)\n{\n\tstruct dm_pr *pr = data;\n\tconst struct pr_ops *ops = dev->bdev->bd_disk->fops->pr_ops;\n\n\tif (!ops || !ops->pr_register)\n\t\treturn -EOPNOTSUPP;\n\treturn ops->pr_register(dev->bdev, pr->old_key, pr->new_key, pr->flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int vhost_net_init(void)\n{\n\tif (experimental_zcopytx)\n\t\tvhost_net_enable_zcopy(VHOST_NET_VQ_TX);\n\treturn misc_register(&vhost_net_misc);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void WriteFooterHTMLTable( SQLHSTMT hStmt )\n{\n    printf( \"</table>\\n\" );\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void PDFiumEngine::InvalidateAllPages() {\n  CancelPaints();\n  StopFind();\n  LoadPageInfo(true);\n  client_->Invalidate(pp::Rect(plugin_size_));\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "AP4_AudioSampleEntry::ToSampleDescription()\n{\n    // create a sample description\n    return new AP4_GenericAudioSampleDescription(\n        m_Type,\n        GetSampleRate(),\n        GetSampleSize(),\n        GetChannelCount(),\n        this);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "explicit GradientTape(bool persistent, bool watch_accessed_variables)\n      : tensorflow::eager::GradientTape<PyObject, PyBackwardFunction,\n                                        PyTapeTensor>(persistent),\n        watch_accessed_variables_(watch_accessed_variables) {}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void RenderWidgetHostImpl::DragTargetDragEnterWithMetaData(\n    const std::vector<DropData::Metadata>& metadata,\n    const gfx::PointF& client_pt,\n    const gfx::PointF& screen_pt,\n    WebDragOperationsMask operations_allowed,\n    int key_modifiers) {\n  Send(new DragMsg_TargetDragEnter(GetRoutingID(), metadata, client_pt,\n                                   screen_pt, operations_allowed,\n                                   key_modifiers));\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tsize_t size;\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\n\tif (size > UINT32_MAX)\n\t\treturn -1;\n\n\tchallenge->cbAvPairs = size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\n\tif (!challenge->AvPairs)\n\t\treturn -1;\n\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void Magick::Image::read(const std::string &imageSpec_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  options()->fileName(imageSpec_);\n  newImage=ReadImage(imageInfo(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "  void SendToHost(v8::Isolate* isolate,\n                  gin_helper::ErrorThrower thrower,\n                  const std::string& channel,\n                  v8::Local<v8::Value> arguments) {\n    if (!electron_browser_remote_) {\n      thrower.ThrowError(kIPCMethodCalledAfterContextReleasedError);\n      return;\n    }\n    blink::CloneableMessage message;\n    if (!electron::SerializeV8Value(isolate, arguments, &message)) {\n      return;\n    }\n    electron_browser_remote_->MessageHost(channel, std::move(message));\n  }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "inet_ip4tosockaddr(struct in_addr *sin_addr, struct sockaddr_storage *addr)\n{\n\tstruct sockaddr_in *addr4 = (struct sockaddr_in *) addr;\n\taddr4->sin_family = AF_INET;\n\taddr4->sin_addr = *sin_addr;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void CClient::SendReady()\n{\n\tCMsgPacker Msg(NETMSG_READY);\n\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "synth_cname(uint8_t* qname, size_t qnamelen, struct rrset_parse* dname_rrset, \n\tuint8_t* alias, size_t* aliaslen, sldns_buffer* pkt)\n{\n\t/* we already know that sname is a strict subdomain of DNAME owner */\n\tuint8_t* dtarg = NULL;\n\tsize_t dtarglen;\n\tif(!parse_get_cname_target(dname_rrset, &dtarg, &dtarglen))\n\t\treturn 0; \n\tif(qnamelen <= dname_rrset->dname_len)\n\t\treturn 0;\n\tif(qnamelen == 0)\n\t\treturn 0;\n\tlog_assert(qnamelen > dname_rrset->dname_len);\n\t/* DNAME from com. to net. with qname example.com. -> example.net. */\n\t/* so: \\3com\\0 to \\3net\\0 and qname \\7example\\3com\\0 */\n\t*aliaslen = qnamelen + dtarglen - dname_rrset->dname_len;\n\tif(*aliaslen > LDNS_MAX_DOMAINLEN)\n\t\treturn 0; /* should have been RCODE YXDOMAIN */\n\t/* decompress dnames into buffer, we know it fits */\n\tdname_pkt_copy(pkt, alias, qname);\n\tdname_pkt_copy(pkt, alias+(qnamelen-dname_rrset->dname_len), dtarg);\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "\tCmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tsize_t origin = parameters.size() > 1 ? 1 : 0;\n\t\tif (parameters[origin].empty())\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_NOORIGIN, \"No origin specified\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\n\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : \"\");\n\t\tuser->Send(ServerInstance->GetRFCEvents().pong, pong);\n\t\treturn CMD_SUCCESS;\n\t}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void qemu_cond_destroy(QemuCond *cond)\n\n{\n\n    BOOL result;\n\n    result = CloseHandle(cond->continue_event);\n\n    if (!result) {\n\n        error_exit(GetLastError(), __func__);\n\n    }\n\n    cond->continue_event = 0;\n\n    result = CloseHandle(cond->sema);\n\n    if (!result) {\n\n        error_exit(GetLastError(), __func__);\n\n    }\n\n    cond->sema = 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "set_foreground_color(NCURSES_SP_DCLx int fg, NCURSES_SP_OUTC outc)\n{\n#ifdef USE_TERM_DRIVER\n    CallDriver_3(SP_PARM, td_color, TRUE, fg, outc);\n#else\n    if (set_a_foreground) {\n\tTPUTS_TRACE(\"set_a_foreground\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(set_a_foreground, fg),\n\t\t\t\t1, outc);\n    } else {\n\tTPUTS_TRACE(\"set_foreground\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(set_foreground, toggled_colors(fg)),\n\t\t\t\t1, outc);\n    }\n#endif\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "opts_visitor_new(const QemuOpts *opts)\n\n{\n\n    OptsVisitor *ov;\n\n\n\n\n    ov = g_malloc0(sizeof *ov);\n\n\n\n    ov->visitor.type = VISITOR_INPUT;\n\n\n\n    ov->visitor.start_struct = &opts_start_struct;\n\n    ov->visitor.check_struct = &opts_check_struct;\n\n    ov->visitor.end_struct   = &opts_end_struct;\n\n\n\n    ov->visitor.start_list = &opts_start_list;\n\n    ov->visitor.next_list  = &opts_next_list;\n\n    ov->visitor.end_list   = &opts_end_list;\n\n\n\n    ov->visitor.type_int64  = &opts_type_int64;\n\n    ov->visitor.type_uint64 = &opts_type_uint64;\n\n    ov->visitor.type_size   = &opts_type_size;\n\n    ov->visitor.type_bool   = &opts_type_bool;\n\n    ov->visitor.type_str    = &opts_type_str;\n\n\n\n    /* type_number() is not filled in, but this is not the first visitor to\n\n     * skip some mandatory methods... */\n\n\n\n    ov->visitor.optional = &opts_optional;\n\n    ov->visitor.free = opts_free;\n\n\n\n    ov->opts_root = opts;\n\n\n\n    return &ov->visitor;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ModuleExport size_t RegisterOTBImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"OTB\");\n  entry->decoder=(DecodeImageHandler *) ReadOTBImage;\n  entry->encoder=(EncodeImageHandler *) WriteOTBImage;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(\"On-the-air bitmap\");\n  entry->module=ConstantString(\"OTB\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "TEST_P(Http2CodecImplTest, HeaderNameWithUnderscoreAreDropped) {\n  headers_with_underscores_action_ = envoy::config::core::v3::HttpProtocolOptions::DROP_HEADER;\n  initialize();\n\n  TestRequestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  TestRequestHeaderMapImpl expected_headers(request_headers);\n  request_headers.addCopy(\"bad_header\", \"something\");\n  EXPECT_CALL(request_decoder_, decodeHeaders_(HeaderMapEqual(&expected_headers), _));\n  request_encoder_->encodeHeaders(request_headers, false);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.dropped_headers_with_underscores\").value());\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void mptsas_free_request(MPTSASRequest *req)\n{\n    MPTSASState *s = req->dev;\n\n    if (req->sreq != NULL) {\n        req->sreq->hba_private = NULL;\n        scsi_req_unref(req->sreq);\n        req->sreq = NULL;\n        QTAILQ_REMOVE(&s->pending, req, next);\n    }\n    qemu_sglist_destroy(&req->qsg);\n    g_free(req);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void arc_emac_tx_clean(struct net_device *ndev)\n{\n\tstruct arc_emac_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tunsigned int i;\n\n\tfor (i = 0; i < TX_BD_NUM; i++) {\n\t\tunsigned int *txbd_dirty = &priv->txbd_dirty;\n\t\tstruct arc_emac_bd *txbd = &priv->txbd[*txbd_dirty];\n\t\tstruct buffer_state *tx_buff = &priv->tx_buff[*txbd_dirty];\n\t\tstruct sk_buff *skb = tx_buff->skb;\n\t\tunsigned int info = le32_to_cpu(txbd->info);\n\n\t\tif ((info & FOR_EMAC) || !txbd->data)\n\t\t\tbreak;\n\n\t\tif (unlikely(info & (DROP | DEFR | LTCL | UFLO))) {\n\t\t\tstats->tx_errors++;\n\t\t\tstats->tx_dropped++;\n\n\t\t\tif (info & DEFR)\n\t\t\t\tstats->tx_carrier_errors++;\n\n\t\t\tif (info & LTCL)\n\t\t\t\tstats->collisions++;\n\n\t\t\tif (info & UFLO)\n\t\t\t\tstats->tx_fifo_errors++;\n\t\t} else if (likely(info & FIRST_OR_LAST_MASK)) {\n\t\t\tstats->tx_packets++;\n\t\t\tstats->tx_bytes += skb->len;\n\t\t}\n\n\t\tdma_unmap_single(&ndev->dev, dma_unmap_addr(tx_buff, addr),\n\t\t\t\t dma_unmap_len(tx_buff, len), DMA_TO_DEVICE);\n\n\t\t/* return the sk_buff to system */\n\t\tdev_kfree_skb_irq(skb);\n\n\t\ttxbd->data = 0;\n\t\ttxbd->info = 0;\n\n\t\t*txbd_dirty = (*txbd_dirty + 1) % TX_BD_NUM;\n\t}\n\n\t/* Ensure that txbd_dirty is visible to tx() before checking\n\t * for queue stopped.\n\t */\n\tsmp_mb();\n\n\tif (netif_queue_stopped(ndev) && arc_emac_tx_avail(priv))\n\t\tnetif_wake_queue(ndev);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "/* extern */ x3f_return_t x3f_load_image_block(x3f_t *x3f,\n                                               x3f_directory_entry_t *DE)\n{\n  x3f_info_t *I = &x3f->info;\n\n  if (DE == NULL)\n    return X3F_ARGUMENT_ERROR;\n\n  switch (DE->header.identifier)\n  {\n  case X3F_SECi:\n    read_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n    x3f_load_image_verbatim(I, DE);\n    break;\n  default:\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    return X3F_INTERNAL_ERROR;\n  }\n\n  return X3F_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best)\n\t\treturn best->eax & 0xff;\n\treturn 36;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static const char *addr2str(target_phys_addr_t addr)\n\n{\n\n    return nr2str(ehci_mmio_names, ARRAY_SIZE(ehci_mmio_names), addr);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "long long Cluster::GetFirstTime() const {\n  const BlockEntry* pEntry;\n\n  const long status = GetFirst(pEntry);\n\n  if (status < 0)  // error\n    return status;\n\n  if (pEntry == NULL)  // empty cluster\n    return GetTime();\n\n  const Block* const pBlock = pEntry->GetBlock();\n  assert(pBlock);\n\n  return pBlock->GetTime(this);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "get_local_op_array(const gs_memory_t *mem)\n{\n    gs_main_instance *minst = get_minst_from_memory(mem);\n    return &minst->i_ctx_p->op_array_table_local;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void RGWPutBucketObjectLock_ObjStore_S3::send_response()\n{\n  if (op_ret) {\n    set_req_state_err(s, op_ret);\n  }\n  dump_errno(s);\n  end_header(s);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void MojoAudioOutputIPC::ReceivedDeviceAuthorization(\n    media::OutputDeviceStatus status,\n    const media::AudioParameters& params,\n    const std::string& device_id) const {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  DCHECK(delegate_);\n  delegate_->OnDeviceAuthorized(status, params, device_id);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void pc_init_isa(MachineState *machine)\n\n{\n\n    has_pci_info = false;\n\n    has_acpi_build = false;\n\n    smbios_defaults = false;\n\n\n\n\n\n\n    if (!machine->cpu_model) {\n\n        machine->cpu_model = \"486\";\n\n    }\n\n    x86_cpu_compat_disable_kvm_features(FEAT_KVM, KVM_FEATURE_PV_EOI);\n\n    enable_compat_apic_id_mode();\n\n    pc_init1(machine, 0, 1);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\n\thid_set_drvdata(hdev, priv);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\n\treturn 0;\nerr_free:\n\tkfree(priv);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "mrb_mod_const_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_bool inherit = TRUE;\n\n  mrb_get_args(mrb, \"n|b\", &id, &inherit);\n  check_const_name_sym(mrb, id);\n  return const_defined(mrb, mod, id, inherit);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "status_t Parcel::writeString16Vector(\n const std::unique_ptr<std::vector<std::unique_ptr<String16>>>& val)\n{\n return writeNullableTypedVector(val, &Parcel::writeString16);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int g2m_init_buffers(G2MContext *c)\n{\n     int aligned_height;\n \n     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n         av_free(c->framebuf);\n         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n         if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "TPMI_RSA_KEY_BITS_Unmarshal(TPMI_RSA_KEY_BITS *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_KEY_BITS_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n\t  case 1024:\n\t  case 2048:\n\t  case 3072:\n\t    break;\n\t  default:\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "SPL_METHOD(SplFileObject, setMaxLineLen)\n{\n\tlong max_len;\n\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &max_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (max_len < 0) {\n\t\tzend_throw_exception_ex(spl_ce_DomainException, 0 TSRMLS_CC, \"Maximum line length must be greater than or equal zero\");\n\t\treturn;\n\t}\n\t\n\tintern->u.file.max_line_len = max_len;\n} /* }}} */",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void TimeoutCallback(const std::string& timeout_message) {\n  FAIL() << timeout_message;\n  MessageLoop::current()->Quit();\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "SPL_METHOD(SplFileObject, rewind)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n} /* }}} */",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void test_validate_fail_union_flat(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefFlatUnion *tmp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string': 'c', 'integer': 41, 'boolean': true }\");\n\n\n\n    visit_type_UserDefFlatUnion(v, &tmp, NULL, &err);\n\n    g_assert(err);\n\n\n    qapi_free_UserDefFlatUnion(tmp);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void ocall_malloc(size_t size, uint8_t **ret) {\n  *ret = static_cast<uint8_t *>(malloc(size));\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * ->select_disc is a hook to allow a driver-specific way of\n\t * seleting disc.  However, since there is no equivalent hook for\n\t * cdrom_slot_status this may not actually be useful...\n\t */\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "TEST_F(OwnedImplTest, AddEmptyFragment) {\n  char input[] = \"hello world\";\n  BufferFragmentImpl frag1(input, 11, [](const void*, size_t, const BufferFragmentImpl*) {});\n  BufferFragmentImpl frag2(\"\", 0, [this](const void*, size_t, const BufferFragmentImpl*) {\n    release_callback_called_ = true;\n  });\n  Buffer::OwnedImpl buffer;\n  buffer.addBufferFragment(frag1);\n  EXPECT_EQ(11, buffer.length());\n\n  buffer.addBufferFragment(frag2);\n  EXPECT_EQ(11, buffer.length());\n\n  buffer.drain(11);\n  EXPECT_EQ(0, buffer.length());\n  EXPECT_TRUE(release_callback_called_);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ProcEstablishConnection(ClientPtr client)\n{\n    const char *reason;\n    char *auth_proto, *auth_string;\n    xConnClientPrefix *prefix;\n\n    REQUEST(xReq);\n\n     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);\n     auth_proto = (char *) prefix + sz_xConnClientPrefix;\n     auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);\n    if ((prefix->majorVersion != X_PROTOCOL) ||\n         (prefix->minorVersion != X_PROTOCOL_REVISION))\n         reason = \"Protocol version mismatch\";\n     else\n\n    return (SendConnSetup(client, reason));\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int tracing_bpf_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tif (attr->link_create.attach_type != prog->expected_attach_type)\n\t\treturn -EINVAL;\n\n\tif (prog->expected_attach_type == BPF_TRACE_ITER)\n\t\treturn bpf_iter_link_attach(attr, prog);\n\telse if (prog->type == BPF_PROG_TYPE_EXT)\n\t\treturn bpf_tracing_prog_attach(prog,\n\t\t\t\t\t       attr->link_create.target_fd,\n\t\t\t\t\t       attr->link_create.target_btf_id);\n\treturn -EINVAL;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "uint64 KaxInternalBlock::ClusterPosition() const\n{\n  assert(ParentCluster != NULL); // impossible otherwise\n  return ParentCluster->GetPosition();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int unimac_mdio_poll(void *wait_func_data)\n{\n\tstruct unimac_mdio_priv *priv = wait_func_data;\n\tunsigned int timeout = 1000;\n\n\tdo {\n\t\tif (!unimac_mdio_busy(priv))\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t} while (--timeout);\n\n\tif (!timeout)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void LodePNGText_cleanup(LodePNGInfo* info)\n{\n  size_t i;\n  for(i = 0; i < info->text_num; i++)\n  {\n    string_cleanup(&info->text_keys[i]);\n    string_cleanup(&info->text_strings[i]);\n  }\n  free(info->text_keys);\n  free(info->text_strings);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int vp8_alloc_frame(VP8Context *s, VP8Frame *f, int ref)\n{\n    int ret;\n    if ((ret = ff_thread_get_buffer(s->avctx, &f->tf,\n                                    ref ? AV_GET_BUFFER_FLAG_REF : 0)) < 0)\n        return ret;\n    if (!(f->seg_map = av_buffer_allocz(s->mb_width * s->mb_height))) {\n        ff_thread_release_buffer(s->avctx, &f->tf);\n        return AVERROR(ENOMEM);\n    }\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "e_util_strcmp0 (const gchar *str1,\n\t\tconst gchar *str2)\n{\n\tif (str1 && !*str1)\n\t\tstr1 = NULL;\n\n\tif (str2 && !*str2)\n\t\tstr2 = NULL;\n\n\treturn g_strcmp0 (str1, str2);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ofproto_set_netflow(struct ofproto *ofproto,\n                    const struct netflow_options *nf_options)\n{\n    if (nf_options && sset_is_empty(&nf_options->collectors)) {\n        nf_options = NULL;\n    }\n\n    if (ofproto->ofproto_class->set_netflow) {\n        return ofproto->ofproto_class->set_netflow(ofproto, nf_options);\n    } else {\n        return nf_options ? EOPNOTSUPP : 0;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s32 off_min = S16_MIN, off_max = S16_MAX;\n\ts32 off = insn->off;\n\n\tif (curr < pos && curr + off + 1 > pos)\n\t\toff += delta;\n\telse if (curr > pos + delta && curr + off + 1 <= pos + delta)\n\t\toff -= delta;\n\tif (off < off_min || off > off_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->off = off;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void HTMLFormControlElement::SetAutofillState(WebAutofillState autofill_state) {\n  if (autofill_state == autofill_state_)\n    return;\n\n  autofill_state_ = autofill_state;\n  PseudoStateChanged(CSSSelector::kPseudoAutofill);\n  PseudoStateChanged(CSSSelector::kPseudoAutofillSelected);\n  PseudoStateChanged(CSSSelector::kPseudoAutofillPreviewed);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int load_textfile(AVFilterContext *ctx)\n\n{\n\n    DrawTextContext *s = ctx->priv;\n\n    int err;\n\n    uint8_t *textbuf;\n\n    size_t textbuf_size;\n\n\n\n    if ((err = av_file_map(s->textfile, &textbuf, &textbuf_size, 0, ctx)) < 0) {\n\n        av_log(ctx, AV_LOG_ERROR,\n\n               \"The text file '%s' could not be read or is empty\\n\",\n\n               s->textfile);\n\n        return err;\n\n    }\n\n\n\n    if (!(s->text = av_realloc(s->text, textbuf_size + 1)))\n\n        return AVERROR(ENOMEM);\n\n    memcpy(s->text, textbuf, textbuf_size);\n\n    s->text[textbuf_size] = 0;\n\n    av_file_unmap(textbuf, textbuf_size);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void mmio_interface_realize(DeviceState *dev, Error **errp)\n\n{\n\n    MMIOInterface *s = MMIO_INTERFACE(dev);\n\n\n\n    DPRINTF(\"realize from 0x%\" PRIX64 \" to 0x%\" PRIX64 \" map host pointer\"\n\n            \" %p\\n\", s->start, s->end, s->host_ptr);\n\n\n\n    if (!s->host_ptr) {\n\n        error_setg(errp, \"host_ptr property must be set\");\n\n\n    }\n\n\n\n    if (!s->subregion) {\n\n        error_setg(errp, \"subregion property must be set\");\n\n\n    }\n\n\n\n    memory_region_init_ram_ptr(&s->ram_mem, OBJECT(s), \"ram\",\n\n                               s->end - s->start + 1, s->host_ptr);\n\n    memory_region_set_readonly(&s->ram_mem, s->ro);\n\n    memory_region_add_subregion(s->subregion, s->start, &s->ram_mem);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "char at(int index) const\n    {\n      return v.at(v.size() - index - 1);\n    }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos)\n{\n    if (pos <= AVCHROMA_LOC_UNSPECIFIED || pos >= AVCHROMA_LOC_NB)\n        return AVERROR(EINVAL);\n    pos--;\n\n    *xpos = (pos&1) * 128;\n    *ypos = ((pos>>1)^(pos<4)) * 128;\n\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */\n{\n\tconst char *p;\n\tchar *name;\n\tconst char *endptr = val + vallen;\n\tzval *current;\n\tint namelen;\n\tint has_value;\n\tphp_unserialize_data_t var_hash;\n\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\tfor (p = val; p < endptr; ) {\n\t\tzval **tmp;\n\t\tnamelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);\n\n\t\tif (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\thas_value = *p & PS_BIN_UNDEF ? 0 : 1;\n\n\t\tname = estrndup(p + 1, namelen);\n\n\t\tp += namelen + 1;\n\n\t\tif (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {\n\t\t\tif ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {\n\t\t\t\tefree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (has_value) {\n\t\t\tALLOC_INIT_ZVAL(current);\n\t\t\tif (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {\n\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tvar_push_dtor_no_addref(&var_hash, &current);\n\t\t}\n\t\tPS_ADD_VARL(name, namelen);\n\t\tefree(name);\n\t}\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\n\treturn SUCCESS;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void spr_write_hdecr(DisasContext *ctx, int sprn, int gprn)\n\n{\n\n    if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_store_hdecr(cpu_env, cpu_gpr[gprn]);\n\n    if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool is_uploaded_file(const std::string filename) {\n  std::set<std::string> &rfc1867UploadedFiles =\n    s_rfc1867_data->rfc1867UploadedFiles;\n  return rfc1867UploadedFiles.find(filename) != rfc1867UploadedFiles.end();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool WebContentsImpl::IsActiveEntry(int32 page_id) {\n  NavigationEntryImpl* active_entry =\n      NavigationEntryImpl::FromNavigationEntry(controller_.GetActiveEntry());\n  return (active_entry != NULL &&\n          active_entry->site_instance() == GetSiteInstance() &&\n          active_entry->GetPageID() == page_id);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void cdc_ncm_align_tail(struct sk_buff *skb, size_t modulus, size_t remainder, size_t max)\n{\n\tsize_t align = ALIGN(skb->len, modulus) - skb->len + remainder;\n\n\tif (skb->len + align > max)\n\t\talign = max - skb->len;\n\tif (align && skb_tailroom(skb) >= align)\n\t\tmemset(skb_put(skb, align), 0, align);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int clear_qf_name(struct super_block *sb, int qtype)\n{\n\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\tsbi->s_qf_names[qtype]) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\");\n\t\treturn 0;\n\t}\n\t/*\n\t * The space will be released later when all options are confirmed\n\t * to be correct\n\t */\n\tsbi->s_qf_names[qtype] = NULL;\n\treturn 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "vips_foreign_find_save_sub( VipsForeignSaveClass *save_class, \n\tconst char *filename )\n{\n\tVipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );\n\n\t/* The suffs might be defined on an abstract base class, make sure we\n\t * don't pick that.\n\t */\n\tif( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &&\n\t\tclass->suffs &&\n\t\tvips_filename_suffix_match( filename, class->suffs ) )\n\t\treturn( save_class );\n\n\treturn( NULL );\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int ldb_dn_escape_internal(char *dst, const char *src, int len)\n {\n       const char *p, *s;\n        char *d;\n       size_t l;\n       p = s = src;\n        d = dst;\n \n       while (p - src < len) {\n               p += strcspn(p, \",=\\n\\r+<>#;\\\\\\\" \");\n               if (p - src == len) /* found no escapable chars */\n                       break;\n               /* copy the part of the string before the stop */\n               memcpy(d, s, p - s);\n               d += (p - s); /* move to current position */\n               switch (*p) {\n                case ' ':\n                       if (p == src || (p-src)==(len-1)) {\n                                /* if at the beginning or end\n                                 * of the string then escape */\n                                *d++ = '\\\\';\n                               *d++ = *p++;                                     \n                        } else {\n                                /* otherwise don't escape */\n                               *d++ = *p++;\n                        }\n                        break;\n \n\t\t\t\t/* if at the beginning or end\n\t\t\t\t * of the string then escape */\n\t\t\t\t*d++ = '\\\\';\n\t\t\t\t*d++ = *p++;\t\t\t\t\t \n\t\t\t} else {\n\t\t\t\t/* otherwise don't escape */\n\t\t\t\t*d++ = *p++;\n\t\t\t}\n\t\t\tbreak;\n                case '?':\n                        /* these must be escaped using \\c form */\n                        *d++ = '\\\\';\n                       *d++ = *p++;\n                        break;\n \n               default: {\n                        /* any others get \\XX form */\n                        unsigned char v;\n                        const char *hexbytes = \"0123456789ABCDEF\";\n                       v = *(const unsigned char *)p;\n                        *d++ = '\\\\';\n                        *d++ = hexbytes[v>>4];\n                        *d++ = hexbytes[v&0xF];\n                       p++;\n                        break;\n                }\n                }\n               s = p; /* move forward */\n        }",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline void cond_local_irq_disable(struct pt_regs *regs)\n{\n\tif (regs->flags & X86_EFLAGS_IF)\n\t\tlocal_irq_disable();\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int register_queue_kobjects(struct net_device *dev)\n{\n\tint error = 0, txq = 0, rxq = 0, real_rx = 0, real_tx = 0;\n\n#ifdef CONFIG_SYSFS\n\tdev->queues_kset = kset_create_and_add(\"queues\",\n\t\t\t\t\t       NULL, &dev->dev.kobj);\n\tif (!dev->queues_kset)\n\t\treturn -ENOMEM;\n\treal_rx = dev->real_num_rx_queues;\n#endif\n\treal_tx = dev->real_num_tx_queues;\n\n\terror = net_rx_queue_update_kobjects(dev, 0, real_rx);\n\tif (error)\n\t\tgoto error;\n\trxq = real_rx;\n\n\terror = netdev_queue_update_kobjects(dev, 0, real_tx);\n\tif (error)\n\t\tgoto error;\n\ttxq = real_tx;\n\n\treturn 0;\n\nerror:\n\tnetdev_queue_update_kobjects(dev, txq, 0);\n\tnet_rx_queue_update_kobjects(dev, rxq, 0);\n\treturn error;",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "virtual ssize_t readAt(off64_t offset, void *buffer, size_t size) {\n Parcel data, reply;\n        data.writeInterfaceToken(\n IMediaHTTPConnection::getInterfaceDescriptor());\n\n        data.writeInt64(offset);\n        data.writeInt32(size);\n\n status_t err = remote()->transact(READ_AT, data, &reply);\n if (err != OK) {\n            ALOGE(\"remote readAt failed\");\n return UNKNOWN_ERROR;\n }\n\n int32_t exceptionCode = reply.readExceptionCode();\n\n if (exceptionCode) {\n\n             return UNKNOWN_ERROR;\n         }\n \n        int32_t len = reply.readInt32();\n \n        if (len > 0) {\n            memcpy(buffer, mMemory->pointer(), len);\n         }\n \n         return len;\n     }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void __init postgresql_init(void)\n{\n   dissect_add(\"postgresql\", APP_LAYER_TCP, 5432, dissector_postgresql);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "asn1_read_node_value (asn1_node node, asn1_data_node_st * data)\n{\n  data->name = node->name;\n  data->value = node->value;\n  data->value_len = node->value_len;\n  data->type = type_field (node->type);\n\n  return ASN1_SUCCESS;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "SPR_NewEntry(struct rx_call *call, char aname[], afs_int32 flag, afs_int32 oid,\n\t     afs_int32 *aid)\n{\n    afs_int32 code;\n    afs_int32 cid = ANONYMOUSID;\n\n    code = newEntry(call, aname, flag, oid, aid, &cid);\n    osi_auditU(call, PTS_NewEntEvent, code, AUD_ID, *aid, AUD_STR, aname,\n\t       AUD_ID, oid, AUD_END);\n    ViceLog(5, (\"PTS_NewEntry: code %d cid %d aid %d aname %s oid %d\\n\", code, cid, *aid, aname, oid));\n    return code;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "char_entity(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tsize_t end = 1;\n\tstruct buf work = { 0, 0, 0, 0 };\n\n\tif (end < size && data[end] == '#')\n\t\tend++;\n\n\twhile (end < size && _isalnum(data[end]))\n\t\tend++;\n\n\tif (end < size && data[end] == ';')\n\t\tend++; /* real entity */\n\telse\n\t\treturn 0; /* lone '&' */\n\n\tif (rndr->cb.entity) {\n\t\twork.data = data;\n\t\twork.size = end;\n\t\trndr->cb.entity(ob, &work, rndr->opaque);\n\t}\n\telse bufput(ob, data, end);\n\n\treturn end;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void jpeg2000_dec_cleanup(Jpeg2000DecoderContext *s)\n\n{\n\n    int tileno, compno;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++) {\n\n        if (s->tile[tileno].comp) {\n\n            for (compno = 0; compno < s->ncomponents; compno++) {\n\n                Jpeg2000Component *comp     = s->tile[tileno].comp   + compno;\n\n                Jpeg2000CodingStyle *codsty = s->tile[tileno].codsty + compno;\n\n\n\n                ff_jpeg2000_cleanup(comp, codsty);\n\n            }\n\n            av_freep(&s->tile[tileno].comp);\n\n        }\n\n    }\n\n    av_freep(&s->tile);\n\n\n\n    s->numXtiles = s->numYtiles = 0;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "GF_Err gf_mpegv12_get_config(u8 *rawdsi, u32 rawdsi_size, GF_M4VDecSpecInfo *dsi)\n{\n\tGF_Err e;\n\tGF_M4VParser *vparse;\n\tif (!rawdsi || !rawdsi_size) return GF_NON_COMPLIANT_BITSTREAM;\n\tvparse = gf_m4v_parser_new(rawdsi, rawdsi_size, GF_TRUE);\n\te = gf_m4v_parse_config(vparse, dsi);\n\tdsi->next_object_start = (u32)vparse->current_object_start;\n\tgf_m4v_parser_del(vparse);\n\treturn e;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void transit(h2_session *session, const char *action, h2_session_state nstate)\n{\n    if (session->state != nstate) {\n        int loglvl = APLOG_DEBUG;\n        if ((session->state == H2_SESSION_ST_BUSY && nstate == H2_SESSION_ST_WAIT)\n            || (session->state == H2_SESSION_ST_WAIT && nstate == H2_SESSION_ST_BUSY)){\n            loglvl = APLOG_TRACE1;\n        }\n        ap_log_cerror(APLOG_MARK, loglvl, 0, session->c, \n                      H2_SSSN_LOG(APLOGNO(03078), session, \n                      \"transit [%s] -- %s --> [%s]\"), \n                      h2_session_state_str(session->state), action, \n                      h2_session_state_str(nstate));\n        session->state = nstate;\n        switch (session->state) {\n            case H2_SESSION_ST_IDLE:\n                update_child_status(session, (session->open_streams == 0? \n                                              SERVER_BUSY_KEEPALIVE\n                                              : SERVER_BUSY_READ), \"idle\");\n                break;\n            case H2_SESSION_ST_DONE:\n                update_child_status(session, SERVER_CLOSING, \"done\");\n                break;\n            default:\n                /* nop */\n                break;\n        }\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static av_cold int vqa_decode_end(AVCodecContext *avctx)\n{\n    VqaContext *s = avctx->priv_data;\n\n    av_freep(&s->codebook);\n    av_freep(&s->next_codebook_buffer);\n    av_freep(&s->decode_buffer);\n\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "push_spaces(struct readbuffer *obuf, int pre_mode, int width)\n{\n    int i;\n\n    if (width <= 0)\n\treturn;\n    check_breakpoint(obuf, pre_mode, \" \");\n    for (i = 0; i < width; i++)\n\tStrcat_char(obuf->line, ' ');\n    obuf->pos += width;\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->flag |= RB_NFLUSHED;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int sas_discover_event(struct asd_sas_port *port, enum discover_event ev)\n{\n\tstruct sas_discovery *disc;\n\n\tif (!port)\n\t\treturn 0;\n\tdisc = &port->disc;\n\n\tBUG_ON(ev >= DISC_NUM_EVENTS);\n\n\tsas_chain_event(ev, &disc->pending, &disc->disc_work[ev].work, port->ha);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int pdf_is_pdf(FILE *fp)\n{\n    int   is_pdf;\n    char *header;\n\n    header = get_header(fp);\n\n    if (header && strstr(header, \"%PDF-\"))\n      is_pdf = 1;\n    else \n      is_pdf = 0;\n\n    free(header);\n    return is_pdf;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "krb5_ticket_get_server(krb5_context context,\n\t\t       const krb5_ticket *ticket,\n\t\t       krb5_principal *server)\n{\n    return krb5_copy_principal(context, ticket->server, server);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void palette8torgb24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n/*\n\n\twrites 1 byte o much and might cause alignment issues on some architectures?\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];\n\n*/\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t//FIXME slow?\n\n\t\tdst[0]= palette[ src[i]*4+2 ];\n\n\t\tdst[1]= palette[ src[i]*4+1 ];\n\n\t\tdst[2]= palette[ src[i]*4+0 ];\n\n\t\tdst+= 3;\n\n\t}\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "fbFetch_a8b8g8r8 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD32 *pixel = (CARD32 *)bits + x;\n    const CARD32 *end = pixel + width;\n    while (pixel < end) {\n        WRITE(buffer++, ((READ(pixel) & 0xff00ff00) |\n                         ((READ(pixel) >> 16) & 0xff) |\n                         ((READ(pixel) & 0xff) << 16)));\n        ++pixel;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "DECLAREContigPutFunc(put16bitbwtile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n\n    (void) y;\n    while (h-- > 0) {\n        uint16 *wp = (uint16 *) pp;\n\n\tfor (x = w; x-- > 0;)\n        {\n            /* use high order byte of 16bit value */\n\n\t    *cp++ = BWmap[*wp >> 8][0];\n            pp += 2 * samplesperpixel;\n            wp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "ft_font_face_free (FtFontFace *font_face)\n{\n\tif (!font_face)\n\t\treturn;\n\n\tg_slice_free (FtFontFace, font_face);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)\n{\n\treturn rxq->tail == rxq->head;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "htmlGetEndPriority (const xmlChar *name) {\n    int i = 0;\n\n    while ((htmlEndPriority[i].name != NULL) &&\n\t   (!xmlStrEqual((const xmlChar *)htmlEndPriority[i].name, name)))\n\ti++;\n\n    return(htmlEndPriority[i].priority);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ivshmem_client_parse_args(IvshmemClientArgs *args, int argc, char *argv[])\n\n{\n\n    int c;\n\n\n\n    while ((c = getopt(argc, argv,\n\n                       \"h\"  /* help */\n\n                       \"v\"  /* verbose */\n\n                       \"S:\" /* unix_sock_path */\n\n                      )) != -1) {\n\n\n\n        switch (c) {\n\n        case 'h': /* help */\n\n            ivshmem_client_usage(argv[0], 0);\n\n            break;\n\n\n\n        case 'v': /* verbose */\n\n            args->verbose = 1;\n\n            break;\n\n\n\n        case 'S': /* unix_sock_path */\n\n            args->unix_sock_path = strdup(optarg);\n\n            break;\n\n\n\n        default:\n\n            ivshmem_client_usage(argv[0], 1);\n\n            break;\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void pcie_cap_slot_hot_unplug_cb(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                 Error **errp)\n\n{\n\n    uint8_t *exp_cap;\n\n\n\n    pcie_cap_slot_hotplug_common(PCI_DEVICE(hotplug_dev), dev, &exp_cap, errp);\n\n\n\n    object_unparent(OBJECT(dev));\n\n    pci_word_test_and_clear_mask(exp_cap + PCI_EXP_SLTSTA,\n\n                                 PCI_EXP_SLTSTA_PDS);\n\n    pcie_cap_slot_event(PCI_DEVICE(hotplug_dev), PCI_EXP_HP_EV_PDC);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n size_t len = snprintf(buffer, SIZE, \"Client[%d] (%p) PID: %d\\n\",\n            mCameraId,\n            getRemoteCallback()->asBinder().get(),\n            mClientPid);\n    len = (len > SIZE - 1) ? SIZE - 1 : len;\n    write(fd, buffer, len);\n return mHardware->dump(fd, args);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static char *dex_class_super_name(RBinDexObj *bin, RBinDexClass *c) {\n\tint cid, tid;\n\tif (!bin || !c || !bin->types) {\n\t\treturn NULL;\n\t}\n\tcid = c->super_class;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->types[cid].descriptor_id;\n\treturn getstr (bin, tid);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void *spl_ptr_llist_shift(spl_ptr_llist *llist TSRMLS_DC) /* {{{ */\n{\n\tvoid                    *data;\n\tspl_ptr_llist_element   *head = llist->head;\n\n\tif (head == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (head->next) {\n\t\thead->next->prev = NULL;\n\t} else {\n\t\tllist->tail = NULL;\n\t}\n\n\tllist->head = head->next;\n\tllist->count--;\n\tdata = head->data;\n\n\tif (llist->dtor) {\n\t\tllist->dtor(head TSRMLS_CC);\n\t}\n\thead->data = NULL;\n\n\tSPL_LLIST_DELREF(head);\n\n\treturn data;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline int decode_attr_length(struct xdr_stream *xdr, uint32_t *attrlen, __be32 **savep)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\tREAD32(*attrlen);\n\t*savep = xdr->p;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "const base::Process& BrowserChildProcessHostImpl::GetProcess() const {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  DCHECK(child_process_.get())\n      << \"Requesting a child process handle before launching.\";\n  DCHECK(child_process_->GetProcess().IsValid())\n      << \"Requesting a child process handle before launch has completed OK.\";\n  return child_process_->GetProcess();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int __kprobes do_translation_fault(unsigned long addr,\n\t\t\t\t\t  unsigned int esr,\n\t\t\t\t\t  struct pt_regs *regs)\n{\n\tif (addr < TASK_SIZE)\n\t\treturn do_page_fault(addr, esr, regs);\n\n\tdo_bad_area(addr, esr, regs);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void rtw_indicate_wx_disassoc_event(struct adapter *padapter)\n{\n\tunion iwreq_data wrqu;\n\n\tmemset(&wrqu, 0, sizeof(union iwreq_data));\n\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\teth_zero_addr(wrqu.ap_addr.sa_data);\n\n\tDBG_88E_LEVEL(_drv_always_, \"indicate disassoc\\n\");\n\twireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "e_named_parameters_new_string (const gchar *str)\n{\n\tENamedParameters *parameters;\n\tgchar **split;\n\tgint ii;\n\n\tg_return_val_if_fail (str != NULL, NULL);\n\n\tsplit = g_strsplit (str, \"\\n\", -1);\n\n\tparameters = e_named_parameters_new ();\n\tfor (ii = 0; split && split[ii]; ii++) {\n\t\tg_ptr_array_add ((GPtrArray *) parameters, g_strcompress (split[ii]));\n\t}\n\n\tg_strfreev (split);\n\n\treturn parameters;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "Vector<RenderBlock::FloatWithRect>& floats() { return m_floats; }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int local_statfs(FsContext *s, V9fsPath *fs_path, struct statfs *stbuf)\n\n{\n\n    char *buffer;\n\n    int ret;\n\n    char *path = fs_path->data;\n\n\n\n    buffer = rpath(s, path);\n\n    ret = statfs(buffer, stbuf);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "png_get_uint_16)(png_const_bytep buf)\n{\n   /* ANSI-C requires an int value to accomodate at least 16 bits so this\n    * works and allows the compiler not to worry about possible narrowing\n    * on 32-bit systems.  (Pre-ANSI systems did not make integers smaller\n    * than 16 bits either.)\n    */\n   unsigned int val =\n       ((unsigned int)(*buf) << 8) +\n       ((unsigned int)(*(buf + 1)));\n\n   return (png_uint_16)val;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void construct_get_dest_keyring(struct key **_dest_keyring)\n {\n \tstruct request_key_auth *rka;\n \tconst struct cred *cred = current_cred();\n \tstruct key *dest_keyring = *_dest_keyring, *authkey;\n \n \tkenter(\"%p\", dest_keyring);\n \n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n \t\t/* the caller supplied one */\n \t\tkey_get(dest_keyring);\n \t} else {\n \t\t/* use a default keyring; falling through the cases until we\n \t\t * find one that we actually have */\n \t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n \t\t\t\t\tdest_keyring =\n \t\t\t\t\t\tkey_get(rka->dest_keyring);\n \t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n \t\t\t\t\tbreak;\n \t\t\t}\n \n \t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n \t\tdefault:\n \t\t\tBUG();\n \t\t}\n \t}\n \n \t*_dest_keyring = dest_keyring;\n \tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n }",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "struct proclistlist *pll_create(void){\n  struct proclistlist *pll=calloc(1,sizeof(struct proclistlist));\n  pll->proclist=get_proclist(&pll->length);\n  return pll;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "TPML_ALG_Unmarshal(TPML_ALG *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n    \n    UINT32 i;\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT32_Unmarshal(&target->count, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->count > MAX_ALG_LIST_SIZE) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {\n\trc = TPM_ALG_ID_Unmarshal(&target->algorithms[i], buffer, size);\n    }\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline int lock_hpte(void *hpte, target_ulong bits)\n\n{\n\n    uint64_t pteh;\n\n\n\n    pteh = ldq_p(hpte);\n\n\n\n    /* We're protected by qemu's global lock here */\n\n    if (pteh & bits) {\n\n        return 0;\n\n    }\n\n    stq_p(hpte, pteh | HPTE_V_HVLOCK);\n\n    return 1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "struct timespec timespec_add_safe(const struct timespec lhs,\n\t\t\t\t  const struct timespec rhs)\n{\n\tstruct timespec res;\n\n\tset_normalized_timespec(&res, lhs.tv_sec + rhs.tv_sec,\n\t\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)\n\t\tres.tv_sec = TIME_T_MAX;\n\n\treturn res;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int WordAwareIterator::length() const\n{\n    if (!m_buffer.isEmpty())\n        return m_buffer.size();\n    if (m_previousText)\n        return m_previousLength;\n    return m_textIterator.length();\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int XMLRPC_ServerRegisterMethod(XMLRPC_SERVER server, const char *name, XMLRPC_Callback cb) {\n   if(server && name && cb) {\n\n      server_method* sm = malloc(sizeof(server_method));\n      \n      if(sm) {\n         sm->name = strdup(name);\n         sm->method = cb;\n         sm->desc = NULL;\n\n         return Q_PushTail(&server->methodlist, sm);\n      }\n   }\n   return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline int usb_bt_fifo_dequeue(struct usb_hci_in_fifo_s *fifo,\n\n                USBPacket *p)\n\n{\n\n    int len;\n\n\n\n    if (likely(!fifo->len))\n\n        return USB_RET_STALL;\n\n\n\n    len = MIN(p->len, fifo->fifo[fifo->start].len);\n\n    memcpy(p->data, fifo->fifo[fifo->start].data, len);\n\n    if (len == p->len) {\n\n        fifo->fifo[fifo->start].len -= len;\n\n        fifo->fifo[fifo->start].data += len;\n\n    } else {\n\n        fifo->start ++;\n\n        fifo->start &= CFIFO_LEN_MASK;\n\n        fifo->len --;\n\n    }\n\n\n\n    fifo->dstart += len;\n\n    fifo->dlen -= len;\n\n    if (fifo->dstart >= fifo->dsize) {\n\n        fifo->dstart = 0;\n\n        fifo->dsize = DFIFO_LEN_MASK + 1;\n\n    }\n\n\n\n    return len;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "PrintRenderFrameHelper::PrintPreviewContext::prepared_node() const {\n  DCHECK(state_ != UNINITIALIZED);\n  return prep_frame_view_->node();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void openpic_load_IRQ_queue(QEMUFile* f, IRQ_queue_t *q)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)\n\n        qemu_get_be32s(f, &q->queue[i]);\n\n\n\n    qemu_get_sbe32s(f, &q->next);\n\n    qemu_get_sbe32s(f, &q->priority);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "nfs4_proc_lock(struct file *filp, int cmd, struct file_lock *request)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tunsigned long timeout = NFS4_LOCK_MINTIMEOUT;\n\tint status;\n\n\t/* verify open state */\n\tctx = nfs_file_open_context(filp);\n\tstate = ctx->state;\n\n\tif (request->fl_start < 0 || request->fl_end < 0)\n\t\treturn -EINVAL;\n\n\tif (IS_GETLK(cmd))\n\t\treturn nfs4_proc_getlk(state, F_GETLK, request);\n\n\tif (!(IS_SETLK(cmd) || IS_SETLKW(cmd)))\n\t\treturn -EINVAL;\n\n\tif (request->fl_type == F_UNLCK)\n\t\treturn nfs4_proc_unlck(state, cmd, request);\n\n\tdo {\n\t\tstatus = nfs4_proc_setlk(state, cmd, request);\n\t\tif ((status != -EAGAIN) || IS_SETLK(cmd))\n\t\t\tbreak;\n\t\ttimeout = nfs4_set_lock_task_retry(timeout);\n\t\tstatus = -ERESTARTSYS;\n\t\tif (signalled())\n\t\t\tbreak;\n\t} while(status < 0);\n\treturn status;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void SetImpl(Handle<JSObject> holder, uint32_t entry, Object* value) {\n uint32_t length = static_cast<uint32_t>(GetString(*holder)->length());\n if (entry < length) {\n return; // String contents are read-only.\n }\n BackingStoreAccessor::SetImpl(holder->elements(), entry - length, value);\n }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool operator!=(absl::string_view rhs) const { return getStringView() != rhs; }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "asn1_get_length(unsigned char **buffer,\t/* IO - Pointer in buffer */\n\t\tunsigned char *bufend)\t/* I  - End of buffer */\n{\n  unsigned\tlength;\t\t\t/* Length */\n\n\n  length = **buffer;\n  (*buffer) ++;\n\n  if (length & 128)\n  {\n    int\tcount;\t\t\t\t/* Number of bytes for length */\n\n\n    if ((count = length & 127) > sizeof(unsigned))\n    {\n      (*buffer) += count;\n      return (0);\n    }\n\n    for (length = 0;\n\t count > 0 && *buffer < bufend;\n\t count --, (*buffer) ++)\n      length = (length << 8) | **buffer;\n  }\n\n  return (length);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int wmi_add_cipher_key(struct wil6210_priv *wil, u8 key_index,\n\t\t       const void *mac_addr, int key_len, const void *key,\n\t\t       int key_usage)\n{\n\tstruct wmi_add_cipher_key_cmd cmd = {\n\t\t.key_index = key_index,\n\t\t.key_usage = key_usage,\n\t\t.key_len = key_len,\n\t};\n\n\tif (!key || (key_len > sizeof(cmd.key)))\n\t\treturn -EINVAL;\n\n\tmemcpy(cmd.key, key, key_len);\n\tif (mac_addr)\n\t\tmemcpy(cmd.mac, mac_addr, WMI_MAC_LEN);\n\n\treturn wmi_send(wil, WMI_ADD_CIPHER_KEY_CMDID, &cmd, sizeof(cmd));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\n\tmsg->msg_namelen = 0;\n\tif (u->addr) {\n\t\tmsg->msg_namelen = u->addr->len;\n\t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline uint16_t mipsdsp_lshift16(uint16_t a, uint8_t s,\n\n                                        CPUMIPSState *env)\n\n{\n\n    uint8_t  sign;\n\n    uint16_t discard;\n\n\n\n    if (s == 0) {\n\n        return a;\n\n    } else {\n\n        sign = (a >> 15) & 0x01;\n\n        if (sign != 0) {\n\n            discard = (((0x01 << (16 - s)) - 1) << s) |\n\n                      ((a >> (14 - (s - 1))) & ((0x01 << s) - 1));\n\n        } else {\n\n            discard = a >> (14 - (s - 1));\n\n        }\n\n\n\n        if ((discard != 0x0000) && (discard != 0xFFFF)) {\n\n            set_DSPControl_overflow_flag(1, 22, env);\n\n        }\n\n        return a << s;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "u8 gf_mp3_version(u32 hdr)\n{\n\treturn ((hdr >> 19) & 0x3);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "generate_hash_secret_salt(void)\n{\n  unsigned int seed = time(NULL) % UINT_MAX;\n  srand(seed);\n  return rand();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int ext4_valid_extent_idx(struct inode *inode,\n\t\t\t\tstruct ext4_extent_idx *ext_idx)\n{\n\text4_fsblk_t block = ext4_idx_pblock(ext_idx);\n\n\treturn ext4_data_block_valid(EXT4_SB(inode->i_sb), block, 1);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void CWebServer::RestoreDatabase(WebEmSession & session, const request& req, std::string & redirect_uri)\n\t\t{\n\t\t\tredirect_uri = \"/index.html\";\n\t\t\tif (session.rights != 2)\n\t\t\t{\n\t\t\t\tsession.reply_status = reply::forbidden;\n\t\t\t\treturn; //Only admin user allowed\n\t\t\t}\n\n\t\t\tstd::string dbasefile = request::findValue(&req, \"dbasefile\");\n\t\t\tif (dbasefile.empty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tm_mainworker.StopDomoticzHardware();\n\n\t\t\tm_sql.RestoreDatabase(dbasefile);\n\t\t\tm_mainworker.AddAllDomoticzHardware();\n\t\t}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int __io_async_wake(struct io_kiocb *req, struct io_poll_iocb *poll,\n\t\t\t   __poll_t mask, task_work_func_t func)\n{\n\tint ret;\n\n\t/* for instances that support it check for an event match first: */\n\tif (mask && !(mask & poll->events))\n\t\treturn 0;\n\n\ttrace_io_uring_task_add(req->ctx, req->opcode, req->user_data, mask);\n\n\tlist_del_init(&poll->wait.entry);\n\n\treq->result = mask;\n\tinit_task_work(&req->task_work, func);\n\t/*\n\t * If this fails, then the task is exiting. When a task exits, the\n\t * work gets canceled, so just cancel this request as well instead\n\t * of executing it. We can't safely execute it anyway, as we may not\n\t * have the needed state needed for it anyway.\n\t */\n\tret = io_req_task_work_add(req, &req->task_work);\n\tif (unlikely(ret)) {\n\t\tstruct task_struct *tsk;\n\n\t\tWRITE_ONCE(poll->canceled, true);\n\t\ttsk = io_wq_get_task(req->ctx->io_wq);\n\t\ttask_work_add(tsk, &req->task_work, 0);\n\t\twake_up_process(tsk);\n\t}\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void sub2video_copy_rect(uint8_t *dst, int dst_linesize, int w, int h,\n\n                                AVSubtitleRect *r)\n\n{\n\n    uint32_t *pal, *dst2;\n\n    uint8_t *src, *src2;\n\n    int x, y;\n\n\n\n    if (r->type != SUBTITLE_BITMAP) {\n\n        av_log(NULL, AV_LOG_WARNING, \"sub2video: non-bitmap subtitle\\n\");\n\n        return;\n\n    }\n\n    if (r->x < 0 || r->x + r->w > w || r->y < 0 || r->y + r->h > h) {\n\n        av_log(NULL, AV_LOG_WARNING, \"sub2video: rectangle overflowing\\n\");\n\n        return;\n\n    }\n\n\n\n    dst += r->y * dst_linesize + r->x * 4;\n\n    src = r->pict.data[0];\n\n    pal = (uint32_t *)r->pict.data[1];\n\n    for (y = 0; y < r->h; y++) {\n\n        dst2 = (uint32_t *)dst;\n\n        src2 = src;\n\n        for (x = 0; x < r->w; x++)\n\n            *(dst2++) = pal[*(src2++)];\n\n        dst += dst_linesize;\n\n        src += r->pict.linesize[0];\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void usbredirparser_destroy(struct usbredirparser *parser_pub)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    struct usbredirparser_buf *wbuf, *next_wbuf;\n\n    free(parser->data);\n    parser->data = NULL;\n\n    wbuf = parser->write_buf;\n    while (wbuf) {\n        next_wbuf = wbuf->next;\n        free(wbuf->buf);\n        free(wbuf);\n        wbuf = next_wbuf;\n    }\n\n    if (parser->lock)\n        parser->callb.free_lock_func(parser->lock);\n\n    free(parser);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\n\tkfree(name);\n\nerror:\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "bool migration_has_failed(MigrationState *s)\n\n{\n\n    return (s->state == MIG_STATE_CANCELLED ||\n\n            s->state == MIG_STATE_ERROR);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void ff_write_pass1_stats(MpegEncContext *s)\n\n{\n\n    snprintf(s->avctx->stats_out, 256,\n\n             \"in:%d out:%d type:%d q:%d itex:%d ptex:%d mv:%d misc:%d \"\n\n             \"fcode:%d bcode:%d mc-var:%d var:%d icount:%d skipcount:%d hbits:%d;\\n\",\n\n             s->current_picture_ptr->f.display_picture_number,\n\n             s->current_picture_ptr->f.coded_picture_number,\n\n             s->pict_type,\n\n             s->current_picture.f.quality,\n\n             s->i_tex_bits,\n\n             s->p_tex_bits,\n\n             s->mv_bits,\n\n             s->misc_bits,\n\n             s->f_code,\n\n             s->b_code,\n\n             s->current_picture.mc_mb_var_sum,\n\n             s->current_picture.mb_var_sum,\n\n             s->i_count, s->skip_count,\n\n             s->header_bits);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "SPL_METHOD(SplFileObject, getChildren)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\t/* return NULL */\n} /* }}} */",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ProcFreePixmap(ClientPtr client)\n{\n    PixmapPtr pMap;\n    int rc;\n\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n\n    rc = dixLookupResourceByType((void **) &pMap, stuff->id, RT_PIXMAP,\n                                 client, DixDestroyAccess);\n    if (rc == Success) {\n        FreeResource(stuff->id, RT_NONE);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->id;\n        return rc;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "const char* CMSEXPORT cmsIT8GetData(cmsHANDLE hIT8, const char* cPatch, const char* cSample)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    int iField, iSet;\n\n    _cmsAssert(hIT8 != NULL);\n\n    iField = LocateSample(it8, cSample);\n    if (iField < 0) {\n        return NULL;\n    }\n\n    iSet = LocatePatch(it8, cPatch);\n    if (iSet < 0) {\n            return NULL;\n    }\n\n    return GetData(it8, iSet, iField);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "base::string16 AuthenticatorClientPinTapAgainSheetModel::GetStepTitle() const {\n  return l10n_util::GetStringFUTF16(IDS_WEBAUTHN_GENERIC_TITLE,\n                                    GetRelyingPartyIdString(dialog_model()));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void rds_tcp_tune(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\n\trds_tcp_nonagle(sock);\n\tlock_sock(sk);\n\tif (rtn->sndbuf_size > 0) {\n\t\tsk->sk_sndbuf = rtn->sndbuf_size;\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t}\n\tif (rtn->rcvbuf_size > 0) {\n\t\tsk->sk_sndbuf = rtn->rcvbuf_size;\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t}\n\trelease_sock(sk);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void MP4_FreeBox_stdp( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stdp->i_priority );\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "ZEND_API int zend_ts_hash_index_find(TsHashTable *ht, ulong h, void **pData)\n{\n\tint retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_index_find(TS_HASH(ht), h, pData);\n\tend_read(ht);\n\n\treturn retval;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static half nan() { const half val_nan = (half)-std::sqrt(-1.0); return val_nan; }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int ocfs2_write_remove_suid(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = ocfs2_read_inode_block(inode, &bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret =  __ocfs2_write_remove_suid(inode, bh);\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, kiocb->ki_nbytes)))\n\t\treturn -EFAULT;\n\n\tiovec->iov_base = buf;\n\tiovec->iov_len = kiocb->ki_nbytes;\n\t*nr_segs = 1;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void bnx2x_reg_wr_ind(struct bnx2x *bp, u32 addr, u32 val)\n{\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS, addr);\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_DATA, val);\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,\n\t\t\t       PCICFG_VENDOR_ID_OFFSET);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, scopeCount); /* ScopeCount (4 bytes) */\n\n\tscopeList->count = scopeCount;\n\tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);\n\n\t/* ScopeArray */\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int mlx5_ib_dealloc_xrcd(struct ib_xrcd *xrcd)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(xrcd->device);\n\tu32 xrcdn = to_mxrcd(xrcd)->xrcdn;\n\tint err;\n\n\terr = mlx5_core_xrcd_dealloc(dev->mdev, xrcdn);\n\tif (err)\n\t\tmlx5_ib_warn(dev, \"failed to dealloc xrcdn 0x%x\\n\", xrcdn);\n\n\tkfree(xrcd);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                    UINT32* pDstSize, UINT32 flags)\n {\n \tint status = -1;\n \tBYTE descriptor;\n \twStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);\n \tif (!stream)\n \t\treturn -1;\n \n\tif (Stream_GetRemainingLength(stream) < 1)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(stream, descriptor); /* descriptor (1 byte) */\n\n\tif (descriptor == ZGFX_SEGMENTED_SINGLE)\n\t{\n\t\tif (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))\n \t\t\tgoto fail;\n \n \t\t*ppDstData = NULL;\n \t\tif (zgfx->OutputCount > 0)\n \t\t\t*ppDstData = (BYTE*) malloc(zgfx->OutputCount);\n \n\t\tif (!*ppDstData)\n\t\t\tgoto fail;\n\n\t\t*pDstSize = zgfx->OutputCount;\n\t\tCopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);\n\t}\n\telse if (descriptor == ZGFX_SEGMENTED_MULTIPART)\n\t{\n\t\tUINT32 segmentSize;\n\t\tUINT16 segmentNumber;\n \t\tUINT16 segmentCount;\n \t\tUINT32 uncompressedSize;\n \t\tBYTE* pConcatenated;\n \n \t\tif (Stream_GetRemainingLength(stream) < 6)\n \t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(stream, segmentCount); /* segmentCount (2 bytes) */\n\t\tStream_Read_UINT32(stream, uncompressedSize); /* uncompressedSize (4 bytes) */\n\n\t\tif (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))\n\t\t\tgoto fail;\n\n\t\tpConcatenated = (BYTE*) malloc(uncompressedSize);\n\n\t\tif (!pConcatenated)\n\t\t\tgoto fail;\n\n\t\t*ppDstData = pConcatenated;\n\t\t*pDstSize = uncompressedSize;\n\n\t\tfor (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(stream) < sizeof(UINT32))\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT32(stream, segmentSize); /* segmentSize (4 bytes) */\n\n \t\t\tif (!zgfx_decompress_segment(zgfx, stream, segmentSize))\n \t\t\t\tgoto fail;\n \n \t\t\tCopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);\n \t\t\tpConcatenated += zgfx->OutputCount;\n \t\t}\n \t}\n \telse\n\t{\n\t\tgoto fail;\n\t}\n\n\tstatus = 1;\nfail:\n\tStream_Free(stream, FALSE);\n\treturn status;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int lxc_safe_long(const char *numstr, long int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno == ERANGE && (sli == LONG_MAX || sli == LONG_MIN))\n\t\treturn -ERANGE;\n\n\tif (errno != 0 && sli == 0)\n\t\treturn -EINVAL;\n\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\t*converted = sli;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void b43_security_init(struct b43_wldev *dev)\n{\n\tdev->ktp = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_KTP);\n\t/* KTP is a word address, but we address SHM bytewise.\n\t * So multiply by two.\n\t */\n\tdev->ktp *= 2;\n\t/* Number of RCMTA address slots */\n\tb43_write16(dev, B43_MMIO_RCMTA_COUNT, B43_NR_PAIRWISE_KEYS);\n\t/* Clear the key memory. */\n\tb43_clear_keys(dev);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "sph_enc16le(void *dst, unsigned val)\n{\n\t((unsigned char *)dst)[0] = val;\n\t((unsigned char *)dst)[1] = val >> 8;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void MenuGtk::UpdateMenu() {\n  gtk_container_foreach(GTK_CONTAINER(menu_.get()), SetMenuItemInfo, this);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static __inline__ void scm_destroy_cred(struct scm_cookie *scm)\n{\n\tput_pid(scm->pid);\n\tscm->pid  = NULL;\n\n\tif (scm->cred)\n\t\tput_cred(scm->cred);\n\tscm->cred = NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void limits_nesting(void)\n\n{\n\n    enum { max_nesting = 1024 }; /* see qobject/json-streamer.c */\n\n    char buf[2 * (max_nesting + 1) + 1];\n\n    QObject *obj;\n\n\n\n    obj = qobject_from_json(make_nest(buf, max_nesting), NULL);\n\n    g_assert(obj != NULL);\n\n    qobject_decref(obj);\n\n\n\n    obj = qobject_from_json(make_nest(buf, max_nesting + 1), NULL);\n\n    g_assert(obj == NULL);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct vm_area_struct *vmm;\n\n\tif (flags & MAP_FIXED) {\n\t\t/* We do not accept a shared mapping if it would violate\n\t\t * cache aliasing constraints.\n\t\t */\n\t\tif ((flags & MAP_SHARED) &&\n\t\t\t\t((addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)))\n\t\t\treturn -EINVAL;\n\t\treturn addr;\n\t}\n\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\tif (!addr)\n\t\taddr = TASK_UNMAPPED_BASE;\n\n\tif (flags & MAP_SHARED)\n\t\taddr = COLOUR_ALIGN(addr, pgoff);\n\telse\n\t\taddr = PAGE_ALIGN(addr);\n\n\tfor (vmm = find_vma(current->mm, addr); ; vmm = vmm->vm_next) {\n\t\t/* At this point:  (!vmm || addr < vmm->vm_end). */\n\t\tif (TASK_SIZE - len < addr)\n\t\t\treturn -ENOMEM;\n\t\tif (!vmm || addr + len <= vmm->vm_start)\n\t\t\treturn addr;\n\t\taddr = vmm->vm_end;\n\t\tif (flags & MAP_SHARED)\n\t\t\taddr = COLOUR_ALIGN(addr, pgoff);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int rds_conn_init(void)\n{\n\trds_conn_slab = kmem_cache_create(\"rds_connection\",\n\t\t\t\t\t  sizeof(struct rds_connection),\n\t\t\t\t\t  0, 0, NULL);\n\tif (!rds_conn_slab)\n\t\treturn -ENOMEM;\n\n\trds_info_register_func(RDS_INFO_CONNECTIONS, rds_conn_info);\n\trds_info_register_func(RDS_INFO_SEND_MESSAGES,\n\t\t\t       rds_conn_message_info_send);\n\trds_info_register_func(RDS_INFO_RETRANS_MESSAGES,\n\t\t\t       rds_conn_message_info_retrans);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\n\t/*\n\t * Make sure the root blkg exists and count the existing blkgs.  As\n\t * @q is bypassing at this point, blkg_lookup_create() can't be\n\t * used.  Open code insertion.\n\t */\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\n \tif (preloaded)\n \t\tradix_tree_preload_end();\n \n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n \t\treturn PTR_ERR(blkg);\n\t}\n \n \tq->root_blkg = blkg;\n \tq->root_rl.blkg = blkg;\n\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void palette8torgb24(const uint8_t *src, uint8_t *dst, unsigned num_pixels, const uint8_t *palette)\n\n{\n\n\tunsigned i;\n\n/*\n\n\twrites 1 byte o much and might cause alignment issues on some architectures?\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];\n\n*/\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t//FIXME slow?\n\n\t\tdst[0]= palette[ src[i]*4+2 ];\n\n\t\tdst[1]= palette[ src[i]*4+1 ];\n\n\t\tdst[2]= palette[ src[i]*4+0 ];\n\n\t\tdst+= 3;\n\n\t}\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void do_json_page_labels(QPDF& pdf, Options& o, JSON& j)\n{\n    JSON j_labels = j.addDictionaryMember(\"pagelabels\", JSON::makeArray());\n    QPDFPageLabelDocumentHelper pldh(pdf);\n    QPDFPageDocumentHelper pdh(pdf);\n    std::vector<QPDFPageObjectHelper> pages = pdh.getAllPages();\n    if (pldh.hasPageLabels())\n    {\n        std::vector<QPDFObjectHandle> labels;\n        pldh.getLabelsForPageRange(0, pages.size() - 1, 0, labels);\n        for (std::vector<QPDFObjectHandle>::iterator iter = labels.begin();\n             iter != labels.end(); ++iter)\n        {\n            std::vector<QPDFObjectHandle>::iterator next = iter;\n            ++next;\n            if (next == labels.end())\n            {\n                // This can't happen, so ignore it. This could only\n                // happen if getLabelsForPageRange somehow returned an\n                // odd number of items.\n                break;\n            }\n            JSON j_label = j_labels.addArrayElement(JSON::makeDictionary());\n            j_label.addDictionaryMember(\"index\", (*iter).getJSON());\n            ++iter;\n            j_label.addDictionaryMember(\"label\", (*iter).getJSON());\n        }\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void Document::didSplitTextNode(Text& oldNode)\n{\n    for (Range* range : m_ranges)\n        range->didSplitTextNode(oldNode);\n\n    if (m_frame)\n        m_frame->selection().didSplitTextNode(oldNode);\n\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)\n{\n\treturn (!lapic_in_kernel(vcpu) ||\n\t\tkvm_apic_accept_pic_intr(vcpu));\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "bson_iter_overwrite_bool (bson_iter_t *iter, /* IN */\n                          bool value)        /* IN */\n{\n   BSON_ASSERT (iter);\n   value = !!value;\n\n   if (ITER_TYPE (iter) == BSON_TYPE_BOOL) {\n      memcpy ((void *) (iter->raw + iter->d1), &value, 1);\n   }\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "init_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n\n  if (u2fh_sendrecv\n       (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n        &resplen) == U2FH_OK)\n     {\n      U2FHID_INIT_RESP initresp;\n      if (resplen > sizeof (initresp))\n \t{\n\t  return U2FH_MEMORY_ERROR;\n \t}\n      memcpy (&initresp, resp, resplen);\n      dev->cid = initresp.cid;\n      dev->versionInterface = initresp.versionInterface;\n      dev->versionMajor = initresp.versionMajor;\n      dev->versionMinor = initresp.versionMinor;\n      dev->capFlags = initresp.capFlags;\n     }\n   else\n     {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,\n\n                BlockBackend *blk, qemu_irq irq, qemu_irq dma[],\n\n                omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = fclk;\n\n    s->lines = 4;\n\n    s->rev = 2;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    /* Instantiate the storage */\n\n    s->card = sd_init(blk, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    s->cdet = qemu_allocate_irq(omap_mmc_cover_cb, s, 0);\n\n    sd_set_cb(s->card, NULL, s->cdet);\n\n\n\n    return s;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void Document::SendDidEditFieldInInsecureContext() {\n  if (!GetFrame())\n    return;\n\n  mojom::blink::InsecureInputServicePtr insecure_input_service_ptr;\n  GetFrame()->GetInterfaceProvider().GetInterface(\n      mojo::MakeRequest(&insecure_input_service_ptr));\n\n  insecure_input_service_ptr->DidEditFieldInInsecureContext();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tint err = key->type_data.x[0];\n\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key)) {\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void UpdateKeyboardDevices(std::vector<ui::KeyboardDevice> keyboard_devices) {\n    ui::DeviceHotplugEventObserver* manager =\n        ui::DeviceDataManager::GetInstance();\n    manager->OnKeyboardDevicesUpdated(keyboard_devices);\n  }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void MojoAudioInputStream::OnError() {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  DCHECK(deleter_callback_);\n  std::move(deleter_callback_).Run();  // Deletes |this|.\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "_TIFFSwab64BitData(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n    (void) tif;\n    assert((cc & 7) == 0);\n    TIFFSwabArrayOfDouble((double*) buf, cc/8);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void sock_rmem_free(struct sk_buff *skb)\n{\n\tstruct sock *sk = skb->sk;\n\n\tatomic_sub(skb->truesize, &sk->sk_rmem_alloc);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void qpci_iounmap(QPCIDevice *dev, void *data)\n\n{\n\n    /* FIXME */\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "AudioFramesPerBuffer AsAudioFramesPerBuffer(int frames_per_buffer) {\n  switch (frames_per_buffer) {\n    case 160: return k160;\n    case 320: return k320;\n    case 440: return k440;\n    case 480: return k480;\n    case 640: return k640;\n    case 880: return k880;\n    case 960: return k960;\n    case 1440: return k1440;\n    case 1920: return k1920;\n  }\n  return kUnexpectedAudioBufferSize;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void WebContents::MessageHost(const std::string& channel,\n                              blink::CloneableMessage arguments,\n                              content::RenderFrameHost* render_frame_host) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageHost\", \"channel\", channel);\n  // webContents.emit('ipc-message-host', new Event(), channel, args);\n  EmitWithSender(\"ipc-message-host\", render_frame_host,\n                 electron::mojom::ElectronBrowser::InvokeCallback(), channel,\n                 std::move(arguments));\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "didset_options2(void)\n{\n    /* Initialize the highlight_attr[] table. */\n    (void)highlight_changed();\n\n    /* Parse default for 'wildmode'  */\n    check_opt_wim();\n\n    (void)set_chars_option(&p_lcs);\n#if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)\n    /* Parse default for 'fillchars'. */\n    (void)set_chars_option(&p_fcs);\n#endif\n\n#ifdef FEAT_CLIPBOARD\n    /* Parse default for 'clipboard' */\n    (void)check_clipboard_option();\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "PackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void shifter_out_im(TCGv var, int shift)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    if (shift == 0) {\n\n        tcg_gen_andi_i32(tmp, var, 1);\n\n    } else {\n\n        tcg_gen_shri_i32(tmp, var, shift);\n\n        if (shift != 31)\n\n            tcg_gen_andi_i32(tmp, tmp, 1);\n\n    }\n\n    gen_set_CF(tmp);\n\n    dead_tmp(tmp);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n \n \t/* We can reliably get at most 31 bits since ISO/IEC 9899 only\n \t  guarantees that a long can represent values up to 2^31-1. */\n\tassert(n >= 0 && n < 32);\n \n \t/* Get the number of bits requested from the specified bit stream. */\n \tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int dn_fib_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct dn_fib_table *tb;\n\tstruct rtmsg *r = nlmsg_data(nlh);\n\tstruct nlattr *attrs[RTA_MAX+1];\n\tint err;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EINVAL;\n\n\terr = nlmsg_parse(nlh, sizeof(*r), attrs, RTA_MAX, rtm_dn_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\ttb = dn_fib_get_table(rtm_get_table(attrs, r->rtm_table), 1);\n\tif (!tb)\n\t\treturn -ENOBUFS;\n\n\treturn tb->insert(tb, r, attrs, nlh, &NETLINK_CB(skb));\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "map_engine_get_talk_button(void)\n{\n\treturn s_talk_button;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int fsmRmdir(int dirfd, const char *path)\n{\n    int rc = unlinkat(dirfd, path, AT_REMOVEDIR);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s) %s\\n\", __func__,\n\t       dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\tswitch (errno) {\n\tcase ENOENT:        rc = RPMERR_ENOENT;    break;\n\tcase ENOTEMPTY:     rc = RPMERR_ENOTEMPTY; break;\n\tdefault:            rc = RPMERR_RMDIR_FAILED; break;\n\t}\n    return rc;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "PHP_FUNCTION(locale_accept_from_http)\n{\n\tUEnumeration *available;\n\tchar *http_accept = NULL;\n\tint http_accept_len;\n\tUErrorCode status = 0;\n\tint len;\n\tchar resultLocale[INTL_MAX_LOCALE_LEN+1];\n\tUAcceptResult outResult;\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &http_accept, &http_accept_len) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n \t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n \tavailable = ures_openAvailableLocales(NULL, &status);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN, \n \t\t\t\t\t\t&outResult, http_accept, available, &status);\n \tuenum_close(available);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");\n\tif (len < 0 || outResult == ULOC_ACCEPT_FAILED) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(resultLocale, len, 1);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "std::unique_ptr<service_manager::Service> StartDownloadManager() {\n  return DownloadManagerService::GetInstance()\n      ->CreateServiceManagerServiceInstance();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"%p\\n\", sock);\n\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &llcp_rawsock_ops;\n\telse\n\t\tsock->ops = &llcp_sock_ops;\n\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "mprintf_event(\n\tint\t\tevcode,\t\t/* event code */\n\tstruct peer *\tp,\t\t/* may be NULL */\n\tconst char *\tfmt,\t\t/* msnprintf format */\n\t...\n\t)\n{\n\tva_list\tap;\n\tint\trc;\n\tchar\tmsg[512];\n\n\tva_start(ap, fmt);\n\trc = mvsnprintf(msg, sizeof(msg), fmt, ap);\n\tva_end(ap);\n\treport_event(evcode, p, msg);\n\n\treturn rc;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "bool L2NormalizeReduceAxis(Value sq_op, DenseElementsAttr axis) {\n  if (sq_op.getType().cast<ShapedType>().getRank() - 1 ==\n          *axis.getValues<int>().begin() ||\n      *axis.getValues<int>().begin() == -1) {\n    return true;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() != axis.getNumElements()) {\n    return false;\n  }\n  auto shape = sq_op.getType().cast<ShapedType>();\n  SmallVector<int, 4> elems{axis.getValues<int>().begin(),\n                            axis.getValues<int>().end()};\n  for (int i = 0; i < shape.getRank(); ++i) {\n    if (i != elems[i]) return false;\n  }\n  return true;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "GF_Err trgr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, trgr_AddBox, s->type);",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int find_and_check_chardev(CharDriverState **chr,\n\n                                  char *chr_name,\n\n                                  Error **errp)\n\n{\n\n    CompareChardevProps props;\n\n\n\n    *chr = qemu_chr_find(chr_name);\n\n    if (*chr == NULL) {\n\n        error_setg(errp, \"Device '%s' not found\",\n\n                   chr_name);\n\n        return 1;\n\n    }\n\n\n\n    memset(&props, 0, sizeof(props));\n\n    if (qemu_opt_foreach((*chr)->opts, compare_chardev_opts, &props, errp)) {\n\n        return 1;\n\n    }\n\n\n\n    if (!props.is_socket) {\n\n        error_setg(errp, \"chardev \\\"%s\\\" is not a tcp socket\",\n\n                   chr_name);\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static size_t curl_size_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n\n{\n\n    CURLState *s = ((CURLState*)opaque);\n\n    size_t realsize = size * nmemb;\n\n    size_t fsize;\n\n\n\n    if(sscanf(ptr, \"Content-Length: %zd\", &fsize) == 1) {\n\n        s->s->len = fsize;\n\n    }\n\n\n\n    return realsize;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static ssize_t ctor_show(struct kmem_cache *s, char *buf)\n{\n\tif (s->ctor) {\n\t\tint n = sprint_symbol(buf, (unsigned long)s->ctor);\n\n\t\treturn n + sprintf(buf + n, \"\\n\");\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void sqlite3ExprCodeCopy(Parse *pParse, Expr *pExpr, int target){\n  sqlite3 *db = pParse->db;\n  pExpr = sqlite3ExprDup(db, pExpr, 0);\n  if( !db->mallocFailed ) sqlite3ExprCode(pParse, pExpr, target);\n  sqlite3ExprDelete(db, pExpr);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void ext4_xattr_inode_set_hash(struct inode *ea_inode, u32 hash)\n{\n\tea_inode->i_atime.tv_sec = hash;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n \tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n \treturn 0;\n \n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void put_uint32(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint32_t *v = pv;\n\n    qemu_put_be32s(f, v);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "  void RemoveZeroAdd(HAdd** add, HConstant** constant) {\n    if (*add != NULL && (*constant)->Integer32Value() == 0) {\n      (*add)->DeleteAndReplaceWith((*add)->left());\n      (*constant)->DeleteAndReplaceWith(NULL);\n    }\n  }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "chunk_new_with_alloc_size(size_t alloc)\n{\n  chunk_t *ch;\n  ch = tor_malloc(alloc);\n  ch->next = NULL;\n  ch->datalen = 0;\n#ifdef DEBUG_CHUNK_ALLOC\n  ch->DBG_alloc = alloc;\n#endif\n  ch->memlen = CHUNK_SIZE_WITH_ALLOC(alloc);\n  total_bytes_allocated_in_chunks += alloc;\n  ch->data = &ch->mem[0];\n  return ch;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "//! Load image from a DLM file \\overloading.\n    CImg<T>& load_dlm(std::FILE *const file) {\n      return _load_dlm(file,0);",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "dvi_document_file_exporter_end (EvFileExporter *exporter)\n{\n\tgchar *command_line;\n\tgint exit_stat;\n\tGError *err = NULL;\n\tgboolean success;\n\t\n\tDviDocument *dvi_document = DVI_DOCUMENT(exporter);\n\t\n\tcommand_line = g_strdup_printf (\"dvipdfm %s -o %s \\\"%s\\\"\", /* dvipdfm -s 1,2,.., -o exporter_filename dvi_filename */\n\t\t\t\t\tdvi_document->exporter_opts->str,\n\t\t\t\t\tdvi_document->exporter_filename,\n\t\t\t\t\tdvi_document->context->filename);\n\t\n\tsuccess = g_spawn_command_line_sync (command_line,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     &exit_stat,\n\t\t\t\t\t     &err);\n\n\tg_free (command_line);\n\n\tif (success == FALSE) {\n\t\tg_warning (\"Error: %s\", err->message);\n\t} else if (!WIFEXITED(exit_stat) || WEXITSTATUS(exit_stat) != EXIT_SUCCESS){\n\t\tg_warning (\"Error: dvipdfm does not end normally or exit with a failure status.\");\n\t}\n\n\tif (err)\n\t\tg_error_free (err);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "fill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void analyzeAggregatesInSelectEnd(Walker *pWalker, Select *pSelect){\n  UNUSED_PARAMETER(pSelect);\n  pWalker->walkerDepth--;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "GF_Err piff_tenc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PIFFTrackEncryptionBox *ptr = (GF_PIFFTrackEncryptionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\n\tgf_bs_write_int(bs, ptr->AlgorithmID, 24);\n\tgf_bs_write_u8(bs, ptr->key_info[3]);\n\tgf_bs_write_data(bs, ptr->key_info+4, 16);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "av_cold void ff_psy_preprocess_end(struct FFPsyPreprocessContext *ctx)\n\n{\n\n    int i;\n\n    ff_iir_filter_free_coeffs(ctx->fcoeffs);\n\n    if (ctx->fstate)\n\n        for (i = 0; i < ctx->avctx->channels; i++)\n\n            ff_iir_filter_free_state(ctx->fstate[i]);\n\n    av_freep(&ctx->fstate);\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "XdmcpDecrementKey (XdmAuthKeyPtr key)\n{\n    int\ti;\n\n    i = 7;\n    while (key->data[i]-- == 0)\n\tif (--i < 0)\n\t    break;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void vhost_init_is_le(struct vhost_virtqueue *vq)\n{\n\tif (vhost_has_feature(vq, VIRTIO_F_VERSION_1))\n\t\tvq->is_le = true;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void cg3_initfn(Object *obj)\n\n{\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n\n    CG3State *s = CG3(obj);\n\n\n\n    memory_region_init_ram(&s->rom, NULL, \"cg3.prom\", FCODE_MAX_ROM_SIZE,\n\n                           &error_abort);\n\n    memory_region_set_readonly(&s->rom, true);\n\n    sysbus_init_mmio(sbd, &s->rom);\n\n\n\n    memory_region_init_io(&s->reg, NULL, &cg3_reg_ops, s, \"cg3.reg\",\n\n                          CG3_REG_SIZE);\n\n    sysbus_init_mmio(sbd, &s->reg);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\t/* depend on compiler for an atomic pmd read */\n\tpmd_t pmdval = *pmd;\n\t/*\n\t * The barrier will stabilize the pmdval in a register or on\n\t * the stack so that it will stop changing under the code.\n\t */\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "e_mail_parser_init (EMailParser *parser)\n{\n\tparser->priv = E_MAIL_PARSER_GET_PRIVATE (parser);\n\tparser->priv->ongoing_part_lists = g_hash_table_new (g_direct_hash, g_direct_equal);\n\n\tg_mutex_init (&parser->priv->mutex);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void hidpp_touchpad_touch_event(u8 *data,\n\tstruct hidpp_touchpad_raw_xy_finger *finger)\n{\n\tu8 x_m = data[0] << 2;\n\tu8 y_m = data[2] << 2;\n\n\tfinger->x = x_m << 6 | data[1];\n\tfinger->y = y_m << 6 | data[3];\n\n\tfinger->contact_type = data[0] >> 6;\n\tfinger->contact_status = data[2] >> 6;\n\n\tfinger->z = data[4];\n\tfinger->area = data[5];\n\tfinger->finger_id = data[6] >> 4;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "Jsi_HashEntry* Jsi_HashSet(Jsi_Hash *tbl, const void *key, void *value) {\n    Jsi_HashEntry *hPtr;\n    bool isNew;\n    hPtr = Jsi_HashEntryNew(tbl, key, &isNew);\n    if (!hPtr) return hPtr;\n    Jsi_HashValueSet(hPtr, value);\n    return hPtr;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static const unsigned char *seq_decode_op2(SeqVideoContext *seq, const unsigned char *src, unsigned char *dst)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        memcpy(dst, src, 8);\n\n        src += 8;\n\n        dst += seq->frame.linesize[0];\n\n    }\n\n\n\n    return src;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "flatpak_run_apply_env_vars (FlatpakBwrap *bwrap, FlatpakContext *context)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n\n  g_hash_table_iter_init (&iter, context->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *var = key;\n      const char *val = value;\n\n      if (val && val[0] != 0)\n        flatpak_bwrap_set_env (bwrap, var, val, TRUE);\n      else\n        flatpak_bwrap_unset_env (bwrap, var);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static bool qcow_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\treturn false;\n\t}\n\tpath += 1; /* get past '/' */\n\n\tif (access(path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"File not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\treturn false;\n\t}\n\n\treturn true; /* File exists and is writable */\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ushort * CLASS make_decoder_ref (const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max=16; max && !count[max]; max--);\n  huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);\n  merror (huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h=len=1; len <= max; len++)\n    for (i=0; i < count[len]; i++, ++*source)\n      for (j=0; j < 1 << (max-len); j++)\n\tif (h <= 1 << max)\n\t  huff[h++] = len << 8 | **source;\n  return huff;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "dummy_handler(SIGNAL_ARGS)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void draw_slice(AVFilterLink *inlink, int y, int h, int slice_dir)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef *outpicref = outlink->out_buf;\n\n    OverlayContext *over = ctx->priv;\n\n\n\n    if (over->overpicref &&\n\n        !(over->x >= outpicref->video->w || over->y >= outpicref->video->h ||\n\n          y+h < over->y || y >= over->y + over->overpicref->video->h)) {\n\n        blend_slice(ctx, outpicref, over->overpicref, over->x, over->y,\n\n                    over->overpicref->video->w, over->overpicref->video->h,\n\n                    y, outpicref->video->w, h);\n\n    }\n\n    avfilter_draw_slice(outlink, y, h, slice_dir);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void temac_dma_out32_be(struct temac_local *lp, int reg, u32 value)\n{\n\tiowrite32be(value, lp->sdma_regs + (reg << 2));\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int f2fs_write_node_page(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\treturn __write_node_page(page, false, NULL, wbc);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static ssize_t write_policy_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\n\tunsigned int ci_attr = this_leaf->attributes;\n\tint n = 0;\n\n\tif (ci_attr & CACHE_WRITE_THROUGH)\n\t\tn = sprintf(buf, \"WriteThrough\\n\");\n\telse if (ci_attr & CACHE_WRITE_BACK)\n\t\tn = sprintf(buf, \"WriteBack\\n\");\n\treturn n;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void vfio_put_group(VFIOGroup *group)\n\n{\n\n    if (!QLIST_EMPTY(&group->device_list)) {\n\n        return;\n\n    }\n\n\n\n    vfio_kvm_device_del_group(group);\n\n    vfio_disconnect_container(group);\n\n    QLIST_REMOVE(group, next);\n\n    trace_vfio_put_group(group->fd);\n\n    close(group->fd);\n\n    g_free(group);\n\n\n\n    if (QLIST_EMPTY(&vfio_group_list)) {\n\n        qemu_unregister_reset(vfio_reset_handler, NULL);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static s32 wl_init_priv(struct brcmf_cfg80211_info *cfg)\n{\n\ts32 err = 0;\n\n\tcfg->scan_request = NULL;\n\tcfg->pwr_save = true;\n\tcfg->dongle_up = false;\t\t/* dongle is not up yet */\n\terr = brcmf_init_priv_mem(cfg);\n\tif (err)\n\t\treturn err;\n\tbrcmf_register_event_handlers(cfg);\n\tmutex_init(&cfg->usr_sync);\n\tbrcmf_init_escan(cfg);\n\tbrcmf_init_conf(cfg->conf);\n\tinit_completion(&cfg->vif_disabled);\n\treturn err;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int handle_io(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint size, in, string;\n\tunsigned port;\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\tstring = (exit_qualification & 16) != 0;\n\n\t++vcpu->stat.io_exits;\n\n\tif (string)\n\t\treturn kvm_emulate_instruction(vcpu, 0);\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\tin = (exit_qualification & 8) != 0;\n\n\treturn kvm_fast_pio(vcpu, size, port, in);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void HandleCrash(int signo, siginfo_t* siginfo, void* context) {\n    SandboxedHandler* state = Get();\n    state->HandleCrashNonFatal(signo, siginfo, context);\n    Signals::RestoreHandlerAndReraiseSignalOnReturn(\n        siginfo, state->old_actions_.ActionForSignal(signo));\n  }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static unsigned int unix_skb_len(const struct sk_buff *skb)\n{\n\treturn skb->len - UNIXCB(skb).consumed;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "yang_free_container(struct ly_ctx *ctx, struct lys_node_container * cont)\n{\n    uint8_t i;\n\n    yang_tpdf_free(ctx, cont->tpdf, 0, cont->tpdf_size);\n    free(cont->tpdf);\n    lydict_remove(ctx, cont->presence);\n\n    for (i = 0; i < cont->must_size; ++i) {\n        lys_restr_free(ctx, &cont->must[i], NULL);\n    }\n    free(cont->must);\n\n    lys_when_free(ctx, cont->when, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "vhost_net_ubuf_alloc(struct vhost_virtqueue *vq, bool zcopy)\n{\n\tstruct vhost_net_ubuf_ref *ubufs;\n\t/* No zero copy backend? Nothing to count. */\n\tif (!zcopy)\n\t\treturn NULL;\n\tubufs = kmalloc(sizeof(*ubufs), GFP_KERNEL);\n\tif (!ubufs)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&ubufs->refcount, 1);\n\tinit_waitqueue_head(&ubufs->wait);\n\tubufs->vq = vq;\n\treturn ubufs;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static CPUArchState *find_cpu(uint32_t thread_id)\n\n{\n\n    CPUState *cpu;\n\n\n\n    cpu = qemu_get_cpu(thread_id);\n\n    if (cpu == NULL) {\n\n        return NULL;\n\n    }\n\n    return cpu->env_ptr;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void vmx_write_guest_kernel_gs_base(struct vcpu_vmx *vmx, u64 data)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, data);\n\tpreempt_enable();\n\tvmx->msr_guest_kernel_gs_base = data;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int register_pernet_subsys(struct pernet_operations *ops)\n{\n\tint error;\n\tdown_write(&pernet_ops_rwsem);\n\terror =  register_pernet_operations(first_device, ops);\n\tup_write(&pernet_ops_rwsem);\n\treturn error;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,\n\t\t     struct sk_buff *skb)\n{\n\tBR_INPUT_SKB_CB(skb)->igmp = 0;\n\tBR_INPUT_SKB_CB(skb)->mrouters_only = 0;\n\n\tif (br->multicast_disabled)\n\t\treturn 0;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\treturn br_multicast_ipv4_rcv(br, port, skb);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\treturn br_multicast_ipv6_rcv(br, port, skb);\n#endif\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static ssize_t sbi_ui_store(struct ext4_attr *a,\n\t\t\t    struct ext4_sb_info *sbi,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned int *ui = (unsigned int *) (((char *) sbi) + a->offset);\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 0xffffffff, &t))\n\t\treturn -EINVAL;\n\t*ui = t;\n\treturn count;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "SPL_METHOD(MultipleIterator, rewind)\n{\n\tspl_SplObjectStorage        *intern;\n\tspl_SplObjectStorageElement *element;\n\tzval                        *it;\n\n\tintern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\twhile (zend_hash_get_current_data_ex(&intern->storage, (void**)&element, &intern->pos) == SUCCESS && !EG(exception)) {\n\t\tit = element->obj;\n\t\tzend_call_method_with_0_params(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_rewind, \"rewind\", NULL);\n\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "inline void SearchBuffer::append(UChar c, bool isStart)\n{\n    m_buffer[m_cursor] = c == noBreakSpace ? ' ' : foldQuoteMarkOrSoftHyphen(c);\n    m_isCharacterStartBuffer[m_cursor] = isStart;\n    if (++m_cursor == m_target.length()) {\n        m_cursor = 0;\n        m_isBufferFull = true;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tmemset(vcpu->arch.eoi_exit_bitmap, 0, 256 / 8);\n\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.eoi_exit_bitmap);\n\telse {\n\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.eoi_exit_bitmap);\n\t}\n\tkvm_x86_ops->load_eoi_exitmap(vcpu);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void SRP_user_pwd_free(SRP_user_pwd *user_pwd)\n{\n    if (user_pwd == NULL)\n        return;\n    BN_free(user_pwd->s);\n    BN_clear_free(user_pwd->v);\n    OPENSSL_free(user_pwd->id);\n    OPENSSL_free(user_pwd->info);\n    OPENSSL_free(user_pwd);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "ZEND_API void zend_ts_hash_graceful_destroy(TsHashTable *ht)\n{\n\tbegin_write(ht);\n\tzend_hash_graceful_destroy(TS_HASH(ht));\n\tend_write(ht);\n\n#ifdef ZTS\n\ttsrm_mutex_free(ht->mx_reader);\n\ttsrm_mutex_free(ht->mx_reader);\n#endif\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "SRC_DumpSources(void)\n{\n  FILE *out;\n  int i;\n\n  for (i = 0; i < n_sources; i++) {\n    out = open_dumpfile(sources[i], \"w\");\n    if (!out)\n      continue;\n    SST_SaveToFile(sources[i]->stats, out);\n    fclose(out);\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int ehci_init_transfer(EHCIPacket *p)\n{\n    uint32_t cpage, offset, bytes, plen;\n    dma_addr_t page;\n\n    cpage  = get_field(p->qtd.token, QTD_TOKEN_CPAGE);\n    bytes  = get_field(p->qtd.token, QTD_TOKEN_TBYTES);\n    offset = p->qtd.bufptr[0] & ~QTD_BUFPTR_MASK;\n    qemu_sglist_init(&p->sgl, p->queue->ehci->device, 5, p->queue->ehci->as);\n\n    while (bytes > 0) {\n        if (cpage > 4) {\n            fprintf(stderr, \"cpage out of range (%d)\\n\", cpage);\n            return -1;\n        }\n\n        page  = p->qtd.bufptr[cpage] & QTD_BUFPTR_MASK;\n        page += offset;\n        plen  = bytes;\n        if (plen > 4096 - offset) {\n            plen = 4096 - offset;\n            offset = 0;\n            cpage++;\n        }\n\n        qemu_sglist_add(&p->sgl, page, plen);\n        bytes -= plen;\n    }\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "HTMLImportsController::HTMLImportsController(Document& master)\n     : root_(HTMLImportTreeRoot::Create(&master)) {}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int fibw_count(void) {\n\tint rv = 0;\n\tIFBW *ptr = ifbw;\n\n\twhile (ptr) {\n\t\trv++;\n\t\tptr = ptr->next;\n\t}\n\t\n\treturn rv;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int ogg_restore(AVFormatContext *s, int discard)\n\n{\n\n    struct ogg *ogg = s->priv_data;\n\n    AVIOContext *bc = s->pb;\n\n    struct ogg_state *ost = ogg->state;\n\n    int i;\n\n\n\n    if (!ost)\n\n        return 0;\n\n\n\n    ogg->state = ost->next;\n\n\n\n    if (!discard){\n\n        for (i = 0; i < ogg->nstreams; i++)\n\n            av_free (ogg->streams[i].buf);\n\n\n\n        avio_seek (bc, ost->pos, SEEK_SET);\n\n        ogg->curidx = ost->curidx;\n\n        ogg->nstreams = ost->nstreams;\n\n        memcpy(ogg->streams, ost->streams,\n\n               ost->nstreams * sizeof(*ogg->streams));\n\n    }\n\n\n\n    av_free (ost);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "hb_set_symmetric_difference (hb_set_t       *set,\n\t\t\t     const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->symmetric_difference (*other);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void jpc_seg_destroy(jpc_dec_seg_t *seg)\n{\n\tif (seg->stream) {\n\t\tjas_stream_close(seg->stream);\n\t}\n\tjas_free(seg);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void BookmarkManagerView::ExecuteCommand(int id) {\n  switch (id) {\n    case IDS_BOOKMARK_MANAGER_IMPORT_MENU:\n      UserMetrics::RecordAction(L\"BookmarkManager_Import\", profile_);\n      ShowImportBookmarksFileChooser();\n      break;\n\n    case IDS_BOOKMARK_MANAGER_EXPORT_MENU:\n      UserMetrics::RecordAction(L\"BookmarkManager_Export\", profile_);\n      ShowExportBookmarksFileChooser();\n      break;\n\n    default:\n      NOTREACHED();\n      break;\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void tcg_handle_interrupt(CPUArchState *env, int mask)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    int old_mask;\n\n\n\n    old_mask = env->interrupt_request;\n\n    env->interrupt_request |= mask;\n\n\n\n    /*\n\n     * If called from iothread context, wake the target cpu in\n\n     * case its halted.\n\n     */\n\n    if (!qemu_cpu_is_self(cpu)) {\n\n        qemu_cpu_kick(cpu);\n\n        return;\n\n    }\n\n\n\n    if (use_icount) {\n\n        env->icount_decr.u16.high = 0xffff;\n\n        if (!can_do_io(env)\n\n            && (mask & ~old_mask) != 0) {\n\n            cpu_abort(env, \"Raised interrupt while not in I/O function\");\n\n        }\n\n    } else {\n\n        cpu_unlink_tb(cpu);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "**/\n    CImg<T>& pow(const char *const expression) {\n      return pow((+*this)._fill(expression,true,true,0,0,\"pow\",this));",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n    int n;\n    uint8_t *p;\n    uint32_t crc;\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return -1;\n    if (s->np >= 31) {\n        return 0;\n    }\n\n    DPRINTF(\"Received packet len=%zu\\n\", size);\n    n = s->next_packet + s->np;\n    if (n >= 31)\n        n -= 31;\n    s->np++;\n\n    s->rx[n].len = size + 6;\n    p = s->rx[n].data;\n    *(p++) = (size + 6);\n    *(p++) = (size + 6) >> 8;\n    memcpy (p, buf, size);\n    p += size;\n    crc = crc32(~0, buf, size);\n    *(p++) = crc;\n    *(p++) = crc >> 8;\n    *(p++) = crc >> 16;\n    *(p++) = crc >> 24;\n    /* Clear the remaining bytes in the last word.  */\n    if ((size & 3) != 2) {\n        memset(p, 0, (6 - size) & 3);\n    }\n\n    s->ris |= SE_INT_RX;\n    stellaris_enet_update(s);\n\n    return size;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int do_vfs_lock(struct file *file, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "gs_window_set_lock_enabled (GSWindow *window,\n                            gboolean  lock_enabled)\n{\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        if (window->priv->lock_enabled == lock_enabled) {\n                return;\n        }\n\n        window->priv->lock_enabled = lock_enabled;\n        g_object_notify (G_OBJECT (window), \"lock-enabled\");\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "RenderMenuList::~RenderMenuList()\n{\n    if (m_popup)\n        m_popup->disconnectClient();\n    m_popup = 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "proto_tree_add_boolean_format_value(proto_tree *tree, int hfindex,\n\t\t\t\t    tvbuff_t *tvb, gint start, gint length,\n\t\t\t\t    guint32 value, const char *format, ...)\n{\n\tproto_item\t  *pi;\n\tva_list\t\t   ap;\n\n\tpi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);\n\tif (pi != tree) {\n\t\tva_start(ap, format);\n\t\tproto_tree_set_representation_value(pi, format, ap);\n\t\tva_end(ap);\n\t}\n\n\treturn pi;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n\n    njs_set_array(&value, array);\n    array->object.fast_array = 0;\n\n    length = array->length;\n\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n\n            prop->value = array->start[i];\n        }\n    }\n\n    /* GC: release value. */\n\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n\n    return NJS_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static irqreturn_t ll_temac_tx_irq(int irq, void *_ndev)\n{\n\tstruct net_device *ndev = _ndev;\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tunsigned int status;\n\n\tstatus = lp->dma_in(lp, TX_IRQ_REG);\n\tlp->dma_out(lp, TX_IRQ_REG, status);\n\n\tif (status & (IRQ_COAL | IRQ_DLY))\n\t\ttemac_start_xmit_done(lp->ndev);\n\tif (status & (IRQ_ERR | IRQ_DMAERR))\n\t\tdev_err_ratelimited(&ndev->dev,\n\t\t\t\t    \"TX error 0x%x TX_CHNL_STS=0x%08x\\n\",\n\t\t\t\t    status, lp->dma_in(lp, TX_CHNL_STS));\n\n\treturn IRQ_HANDLED;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void OPPROTO op_check_addo_64 (void)\n\n{\n\n    if (likely(!(((uint64_t)T2 ^ (uint64_t)T1 ^ UINT64_MAX) &\n\n                 ((uint64_t)T2 ^ (uint64_t)T0) & (1ULL << 63)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n    RETURN();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "clean_cell_pool(void)\n{\n  tor_assert(cell_pool);\n  mp_pool_clean(cell_pool, 0, 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int pagemap_release(struct inode *inode, struct file *file)\n{\n\tstruct mm_struct *mm = file->private_data;\n\n\tif (mm)\n\t\tmmdrop(mm);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void reds_client_monitors_config_cleanup(void)\n{\n    RedsClientMonitorsConfig *cmc = &reds->client_monitors_config;\n\n    cmc->buffer_size = cmc->buffer_pos = 0;\n    free(cmc->buffer);\n    cmc->buffer = NULL;\n    cmc->mcc = NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline void gen_lookup_tb(DisasContext *s)\n\n{\n\n    tcg_gen_movi_i32(cpu_R[15], s->pc & ~1);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static struct omap_mpuio_s *omap_mpuio_init(MemoryRegion *memory,\n\n                hwaddr base,\n\n                qemu_irq kbd_int, qemu_irq gpio_int, qemu_irq wakeup,\n\n                omap_clk clk)\n\n{\n\n    struct omap_mpuio_s *s = (struct omap_mpuio_s *)\n\n            g_malloc0(sizeof(struct omap_mpuio_s));\n\n\n\n    s->irq = gpio_int;\n\n    s->kbd_irq = kbd_int;\n\n    s->wakeup = wakeup;\n\n    s->in = qemu_allocate_irqs(omap_mpuio_set, s, 16);\n\n    omap_mpuio_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mpuio_ops, s,\n\n                          \"omap-mpuio\", 0x800);\n\n    memory_region_add_subregion(memory, base, &s->iomem);\n\n\n\n    omap_clk_adduser(clk, qemu_allocate_irq(omap_mpuio_onoff, s, 0));\n\n\n\n    return s;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int set_next_request(void)\n{\n\tcurrent_req = list_first_entry_or_null(&floppy_reqs, struct request,\n\t\t\t\t\t       queuelist);\n\tif (current_req) {\n\t\tcurrent_req->error_count = 0;\n\t\tlist_del_init(&current_req->queuelist);\n\t}\n\treturn current_req != NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static handle_t *new_handle(int nblocks)\n{\n\thandle_t *handle = jbd2_alloc_handle(GFP_NOFS);\n\tif (!handle)\n\t\treturn NULL;\n\thandle->h_buffer_credits = nblocks;\n\thandle->h_ref = 1;\n\n\treturn handle;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "unlock_encryption_data_new (DBusGMethodInvocation *context,\n                            Device *device,\n                            UnlockEncryptionHookFunc hook_func,\n                            gpointer hook_user_data)\n{\n  UnlockEncryptionData *data;\n\n  data = g_new0 (UnlockEncryptionData, 1);\n  data->refcount = 1;\n\n  data->context = context;\n  data->device = g_object_ref (device);\n  data->hook_func = hook_func;\n  data->hook_user_data = hook_user_data;\n  return data;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "format_timestamp(uint32_t timestamp)\n{\n\tstatic char buffer[32];\n\n\tif ((timestamp & 0xff000000) == 0xff000000)\n\t\tsnprintf(buffer, sizeof(buffer), \"boot + %us\", timestamp &\n\t\t0x00ffffff);\n\telse\n\t\tsnprintf(buffer, sizeof(buffer), \"%us\", timestamp);\n\treturn buffer;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "uint16_t Iptcdatum::tag() const\n    {\n        return key_.get() == 0 ? 0 : key_->tag();\n    }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void set_peername(int net, CLIENT *client) {\n\tstruct sockaddr_in addrin;\n\tint addrinlen = sizeof( addrin );\n\tchar *peername ;\n\n\tif (getpeername(net, (struct sockaddr *) &addrin, (socklen_t *)&addrinlen) < 0)\n\t\terr(\"getsockname failed: %m\");\n\tpeername = inet_ntoa(addrin.sin_addr);\n\tclient->exportname=g_strdup_printf(client->server->exportname, peername);\n\n\tmsg4(LOG_INFO, \"connect from %s, assigned file is %s\", \n\t     peername, client->exportname);\n\tclient->clientname=g_strdup(peername);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void __ldsem_wake_writer(struct ld_semaphore *sem)\n{\n\tstruct ldsem_waiter *waiter;\n\n\twaiter = list_entry(sem->write_wait.next, struct ldsem_waiter, list);\n\twake_up_process(waiter->task);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void do_notify_work(struct work_struct *work)\n{\n\tstruct capictr_event *event =\n\t\tcontainer_of(work, struct capictr_event, work);\n\n\tswitch (event->type) {\n\tcase CAPICTR_UP:\n\t\tnotify_up(event->controller);\n\t\tbreak;\n\tcase CAPICTR_DOWN:\n\t\tnotify_down(event->controller);\n\t\tbreak;\n\t}\n\n\tkfree(event);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void ring_buffer_put(struct ring_buffer *rb)\n{\n\tstruct perf_event *event, *n;\n\tunsigned long flags;\n\n\tif (!atomic_dec_and_test(&rb->refcount))\n\t\treturn;\n\n\tspin_lock_irqsave(&rb->event_lock, flags);\n\tlist_for_each_entry_safe(event, n, &rb->event_list, rb_entry) {\n\t\tlist_del_init(&event->rb_entry);\n\t\twake_up_all(&event->waitq);\n\t}\n\tspin_unlock_irqrestore(&rb->event_lock, flags);\n\n\tcall_rcu(&rb->rcu_head, rb_free_rcu);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int unlock_futex_pi(u32 __user *uaddr, u32 uval)\n{\n\tu32 oldval;\n\n\t/*\n\t * There is no waiter, so we unlock the futex. The owner died\n\t * bit has not to be preserved here. We are the owner:\n\t */\n\toldval = cmpxchg_futex_value_locked(uaddr, uval, 0);\n\n\tif (oldval == -EFAULT)\n\t\treturn oldval;\n\tif (oldval != uval)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "proto_item_get_parent(const proto_item *ti) {\n\tif (!ti)\n\t\treturn NULL;\n\treturn ti->parent;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void Compute(OpKernelContext* ctx) override {\n    // This call processes inputs 1 and 2 to write output 0.\n    ReshapeOp::Compute(ctx);\n\n    const float input_min_float = ctx->input(2).flat<float>()(0);\n    const float input_max_float = ctx->input(3).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    output_min->flat<float>()(0) = input_min_float;\n\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));\n    output_max->flat<float>()(0) = input_max_float;\n  }",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool previousLineBrokeCleanly() const { return m_previousLineBrokeCleanly; }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int open_flags_to_access_mode(int open_flags) {\n if ((open_flags & O_ACCMODE) == O_RDONLY) {\n return R_OK;\n } else if ((open_flags & O_ACCMODE) == O_WRONLY) {\n return W_OK;\n } else {\n /* Probably O_RDRW, but treat as default to be safe */\n return R_OK | W_OK;\n }\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int __feat_register_sp(struct list_head *fn, u8 feat, u8 is_local,\n\t\t\t      u8 mandatory, u8 const *sp_val, u8 sp_len)\n{\n\tdccp_feat_val fval;\n\n\tif (dccp_feat_type(feat) != FEAT_SP ||\n\t    !dccp_feat_sp_list_ok(feat, sp_val, sp_len))\n\t\treturn -EINVAL;\n\n\t/* Avoid negotiating alien CCIDs by only advertising supported ones */\n\tif (feat == DCCPF_CCID && !ccid_support_check(sp_val, sp_len))\n\t\treturn -EOPNOTSUPP;\n\n\tif (dccp_feat_clone_sp_val(&fval, sp_val, sp_len))\n\t\treturn -ENOMEM;\n\n\treturn dccp_feat_push_change(fn, feat, is_local, mandatory, &fval);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\n\t/* If SMI is not intercepted, ignore guest SMI intercept as well  */\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void aead_geniv_exit(struct crypto_tfm *tfm)\n{\n\tcrypto_free_aead(tfm->crt_aead.base);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "rsvg_new_filter (void)\n{\n    RsvgFilter *filter;\n\n    filter = g_new (RsvgFilter, 1);\n    _rsvg_node_init (&filter->super);\n    filter->filterunits = objectBoundingBox;\n    filter->primitiveunits = userSpaceOnUse;\n    filter->x = _rsvg_css_parse_length (\"-10%\");\n    filter->y = _rsvg_css_parse_length (\"-10%\");\n    filter->width = _rsvg_css_parse_length (\"120%\");\n    filter->height = _rsvg_css_parse_length (\"120%\");\n    filter->super.set_atts = rsvg_filter_set_args;\n    return (RsvgNode *) filter;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "IntSize RenderLayerScrollableArea::clampScrollOffset(const IntSize& scrollOffset) const\n{\n    int maxX = scrollWidth() - box().pixelSnappedClientWidth();\n    int maxY = scrollHeight() - box().pixelSnappedClientHeight();\n\n    int x = std::max(std::min(scrollOffset.width(), maxX), 0);\n    int y = std::max(std::min(scrollOffset.height(), maxY), 0);\n    return IntSize(x, y);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\n\t/* If we're in rcuwalk, drop out of it to handle last component */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\t/*\n\t\t * No cached dentry. Mounted dentries are pinned in the cache,\n\t\t * so that means that this dentry is probably a symlink or the\n\t\t * path doesn't actually point to a mounted dentry.\n\t\t */\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n \t\tgoto out;\n \t}\n \tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n \tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n \t\treturn 1;\n \tfollow_mount(path);\n \terror = 0;\n out:\n\tterminate_walk(nd);\n\treturn error;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void boot_sector_test(void)\n\n{\n\n    uint8_t signature_low;\n\n    uint8_t signature_high;\n\n    uint16_t signature;\n\n    int i;\n\n\n\n    /* Wait at most 90 seconds */\n\n#define TEST_DELAY (1 * G_USEC_PER_SEC / 10)\n\n#define TEST_CYCLES MAX((90 * G_USEC_PER_SEC / TEST_DELAY), 1)\n\n\n\n    /* Poll until code has run and modified memory.  Once it has we know BIOS\n\n     * initialization is done.  TODO: check that IP reached the halt\n\n     * instruction.\n\n     */\n\n    for (i = 0; i < TEST_CYCLES; ++i) {\n\n        signature_low = readb(BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET);\n\n        signature_high = readb(BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET + 1);\n\n        signature = (signature_high << 8) | signature_low;\n\n        if (signature == SIGNATURE) {\n\n            break;\n\n        }\n\n        g_usleep(TEST_DELAY);\n\n    }\n\n\n\n    g_assert_cmphex(signature, ==, SIGNATURE);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void DeepScanLineInputFile::multiPartInitialize(InputPartData* part)\n{\n    \n    _data->_streamData = part->mutex;\n    _data->memoryMapped = _data->_streamData->is->isMemoryMapped();\n    _data->version = part->version;\n    \n    initialize(part->header);\n    \n    _data->lineOffsets = part->chunkOffsets;\n    \n    _data->partNumber = part->partNumber;\n    \n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "detached_get_signatures(ns_detached_signatures_t *sigs,\n                        const char *flavor_name)\n{\n  smartlist_t *sl = strmap_get(sigs->signatures, flavor_name);\n  if (!sl) {\n    sl = smartlist_new();\n    strmap_set(sigs->signatures, flavor_name, sl);\n  }\n  return sl;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void bnx2x__link_reset(struct bnx2x *bp)\n{\n\tif (!BP_NOMCP(bp)) {\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\tbnx2x_lfa_reset(&bp->link_params, &bp->link_vars);\n\t\tbnx2x_release_phy_lock(bp);\n\t} else\n\t\tBNX2X_ERR(\"Bootcode is missing - can not reset link\\n\");\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "vte_sequence_handler_nd (VteTerminal *terminal, GValueArray *params)\n{\n\tVteScreen *screen;\n\tscreen = terminal->pvt->screen;\n\tif ((screen->cursor_current.col + 1) < terminal->column_count) {\n\t\t/* There's room to move right. */\n\t\tscreen->cursor_current.col++;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void HTMLTextAreaElement::setValue(const String& value)\n{\n    setValueCommon(value);\n    m_isDirty = true;\n    setNeedsValidityCheck();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "_wrap_umac128_set_key(void *ctx, size_t len, const uint8_t * key)\n{\n\tif (unlikely(len != 16))\n\t\tabort();\n\tumac128_set_key(ctx, key);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "u_int16_t ndpi_get_proto_by_name(struct ndpi_detection_module_struct *ndpi_str, const char *name) {\n  u_int16_t i, num = ndpi_get_num_supported_protocols(ndpi_str);\n\n  for (i = 0; i < num; i++)\n    if(strcasecmp(ndpi_get_proto_by_id(ndpi_str, i), name) == 0)\n      return(i);\n\n  return(NDPI_PROTOCOL_UNKNOWN);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int dirac_probe(AVProbeData *p)\n\n{\n\n    if (AV_RL32(p->buf) == MKTAG('B', 'B', 'C', 'D'))\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static struct omap_32khz_timer_s *omap_os_timer_init(MemoryRegion *memory,\n\n                hwaddr base,\n\n                qemu_irq irq, omap_clk clk)\n\n{\n\n    struct omap_32khz_timer_s *s = (struct omap_32khz_timer_s *)\n\n            g_malloc0(sizeof(struct omap_32khz_timer_s));\n\n\n\n    s->timer.irq = irq;\n\n    s->timer.clk = clk;\n\n    s->timer.timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, omap_timer_tick, &s->timer);\n\n    omap_os_timer_reset(s);\n\n    omap_timer_clk_setup(&s->timer);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_os_timer_ops, s,\n\n                          \"omap-os-timer\", 0x800);\n\n    memory_region_add_subregion(memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "  bool has_memory_limit() const TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    return memory_limit_ > 0;\n  }",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events)\n\t\tkvm_x86_ops->check_nested_events(vcpu, false);\n\n\treturn kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)\n{\n   unsigned int k;\n   int sgn;\n   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\n\n   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)\n   k = stbi_lrot(j->code_buffer, n);\n   j->code_buffer = k & ~stbi__bmask[n];\n   k &= stbi__bmask[n];\n   j->code_bits -= n;\n   return k + (stbi__jbias[n] & (sgn - 1));\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static PHP_INI_MH(OnUpdateInternalEncoding)\n{\n\tif (ZSTR_LEN(new_value) >= ICONV_CSNMAXLEN) {\n\t\treturn FAILURE;\n\t}\n\tif (stage & (PHP_INI_STAGE_ACTIVATE | PHP_INI_STAGE_RUNTIME)) {\n\t\tphp_error_docref(\"ref.iconv\", E_DEPRECATED, \"Use of iconv.internal_encoding is deprecated\");\n\t}\n\tOnUpdateString(entry, new_value, mh_arg1, mh_arg2, mh_arg3, stage);\n\treturn SUCCESS;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bool Performance::PassesTimingAllowCheck(\n    const ResourceResponse& response,\n     const SecurityOrigin& initiator_security_origin,\n     const AtomicString& original_timing_allow_origin,\n     ExecutionContext* context) {\n   scoped_refptr<const SecurityOrigin> resource_origin =\n      SecurityOrigin::Create(response.Url());\n   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))\n     return true;\n \n  const AtomicString& timing_allow_origin_string =\n      original_timing_allow_origin.IsEmpty()\n          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)\n          : original_timing_allow_origin;\n  if (timing_allow_origin_string.IsEmpty() ||\n      EqualIgnoringASCIICase(timing_allow_origin_string, \"null\"))\n    return false;\n\n  if (timing_allow_origin_string == \"*\") {\n    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);\n    return true;\n  }\n\n  const String& security_origin = initiator_security_origin.ToString();\n  Vector<String> timing_allow_origins;\n  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);\n  if (timing_allow_origins.size() > 1) {\n    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);\n  } else if (timing_allow_origins.size() == 1 &&\n             timing_allow_origin_string != \"*\") {\n    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);\n  }\n  for (const String& allow_origin : timing_allow_origins) {\n    const String allow_origin_stripped = allow_origin.StripWhiteSpace();\n    if (allow_origin_stripped == security_origin ||\n        allow_origin_stripped == \"*\") {\n      return true;\n    }\n  }\n\n  return false;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\tinit_rwsem(&ei->xattr_sem);\n\tinit_rwsem(&ei->i_data_sem);\n\tinode_init_once(&ei->vfs_inode);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "struct crypto_alg *crypto_mod_get(struct crypto_alg *alg)\n{\n\treturn try_module_get(alg->cra_module) ? crypto_alg_get(alg) : NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void free_unref_page(struct page *page)\n{\n\tunsigned long flags;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_unref_page_prepare(page, pfn))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tfree_unref_page_commit(page, pfn);\n\tlocal_irq_restore(flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bool kvm_arch_has_vcpu_debugfs(void)\n{\n\treturn false;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\n\t\t/* Initialize the control mutex and condition var */\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Initialize and data mutex and condition var */\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t/* Wait for the threads to start */\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\n\treturn threads;\n\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline struct sk_buff *skb_peek(const struct sk_buff_head *list_)\n{\n\tstruct sk_buff *skb = list_->next;\n\n\tif (skb == (struct sk_buff *)list_)\n\t\tskb = NULL;\n\treturn skb;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "decode_OFPAT_RAW10_SET_VLAN_VID(uint16_t vid,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    return decode_set_vlan_vid(vid, true, out);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n \tstruct xt_table_info *info = NULL;\n \tsize_t sz = sizeof(*info) + size;\n \n \t/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */\n \tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n \t\treturn NULL;\n\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void nvdimm_dsm_set_label_data(NVDIMMDevice *nvdimm, NvdimmDsmIn *in,\n\n                                      hwaddr dsm_mem_addr)\n\n{\n\n    NVDIMMClass *nvc = NVDIMM_GET_CLASS(nvdimm);\n\n    NvdimmFuncSetLabelDataIn *set_label_data;\n\n    uint32_t status;\n\n\n\n    set_label_data = (NvdimmFuncSetLabelDataIn *)in->arg3;\n\n\n\n    le32_to_cpus(&set_label_data->offset);\n\n    le32_to_cpus(&set_label_data->length);\n\n\n\n    nvdimm_debug(\"Write Label Data: offset %#x length %#x.\\n\",\n\n                 set_label_data->offset, set_label_data->length);\n\n\n\n    status = nvdimm_rw_label_data_check(nvdimm, set_label_data->offset,\n\n                                        set_label_data->length);\n\n    if (status != 0 /* Success */) {\n\n        nvdimm_dsm_no_payload(status, dsm_mem_addr);\n\n        return;\n\n    }\n\n\n\n    assert(sizeof(*in) + sizeof(*set_label_data) + set_label_data->length <=\n\n           4096);\n\n\n\n    nvc->write_label_data(nvdimm, set_label_data->in_buf,\n\n                          set_label_data->length, set_label_data->offset);\n\n    nvdimm_dsm_no_payload(0 /* Success */, dsm_mem_addr);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "uipbuf_search_header(uint8_t *buffer, uint16_t size, uint8_t protocol)\n{\n  uint8_t *nbuf;\n  uint8_t next_proto;\n\n  nbuf = uipbuf_get_next_header(buffer, size, &next_proto, true);\n  while(nbuf != NULL && next_proto != protocol && uip_is_proto_ext_hdr(next_proto)) {\n    /* move to the ext hdr */\n    nbuf = uipbuf_get_next_header(nbuf, size - (nbuf - buffer), &next_proto, false);\n  }\n\n  if(next_proto == protocol) {\n    return nbuf;\n  } else {\n    return NULL;\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n\n    k->get_config(vdev, vdev->config);\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n\n    val = ldl_p(vdev->config + addr);\n    return val;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void restore_sigs(sigset_t *oldset)\n{\n\tsigprocmask(SIG_SETMASK, oldset, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static struct sock *__raw_v4_lookup(struct net *net, struct sock *sk,\n\t\tunsigned short num, __be32 raddr, __be32 laddr, int dif)\n{\n\tsk_for_each_from(sk) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\tif (net_eq(sock_net(sk), net) && inet->inet_num == num\t&&\n\t\t    !(inet->inet_daddr && inet->inet_daddr != raddr) \t&&\n\t\t    !(inet->inet_rcv_saddr && inet->inet_rcv_saddr != laddr) &&\n\t\t    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))\n\t\t\tgoto found; /* gotcha */\n\t}\n\tsk = NULL;\nfound:\n\treturn sk;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void prb_run_all_ft_ops(struct tpacket_kbdq_core *pkc,\n\t\t\tstruct tpacket3_hdr *ppd)\n{\n\tppd->hv1.tp_padding = 0;\n\tprb_fill_vlan_info(pkc, ppd);\n\n\tif (pkc->feature_req_word & TP_FT_REQ_FILL_RXHASH)\n\t\tprb_fill_rxhash(pkc, ppd);\n\telse\n\t\tprb_clear_rxhash(pkc, ppd);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static struct net_device *inet6_fib_lookup_dev(struct net *net,\n\t\t\t\t\t       const void *addr)\n{\n\tstruct net_device *dev;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6;\n\tint err;\n\n\tif (!ipv6_stub)\n\t\treturn ERR_PTR(-EAFNOSUPPORT);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tmemcpy(&fl6.daddr, addr, sizeof(struct in6_addr));\n\terr = ipv6_stub->ipv6_dst_lookup(net, NULL, &dst, &fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tdev = dst->dev;\n\tdev_hold(dev);\n\tdst_release(dst);\n\n\treturn dev;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int tg3_get_default_macaddr_sparc(struct tg3 *tp)\n{\n\tstruct net_device *dev = tp->dev;\n\n\tmemcpy(dev->dev_addr, idprom->id_ethaddr, 6);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\n\t//ok, not self contained, let's go for it...\n\t//we don't know what's a URN yet\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tlong width, long height,\n\n\tlong lumStride, long chromStride, long dstStride)\n\n{\n\n\t//FIXME interpolate chroma\n\n\tRENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void HTMLFormControlElement::didMoveToNewDocument(Document& oldDocument)\n{\n    FormAssociatedElement::didMoveToNewDocument(oldDocument);\n    HTMLElement::didMoveToNewDocument(oldDocument);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void quirk_iommu_rwbf(struct pci_dev *dev)\n{\n\t/*\n\t * Mobile 4 Series Chipset neglects to set RWBF capability,\n\t * but needs it. Same seems to hold for the desktop versions.\n\t */\n\tpci_info(dev, \"Forcing write-buffer flush capability\\n\");\n\trwbf_quirk = 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "onig_init(void)\n{\n  if (onig_inited != 0)\n    return 0;\n\n  onig_inited = 1;\n\n#if defined(ONIG_DEBUG_MEMLEAK) && defined(_MSC_VER)\n  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\n#endif\n\n  onigenc_init();\n  /* onigenc_set_default_caseconv_table((UChar* )0); */\n\n#ifdef ONIG_DEBUG_STATISTICS\n  onig_statistics_init();\n#endif\n\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "inline double rand(const double val_min, const double val_max) {\n      cimg::mutex(4);\n      const double res = cimg::rand(val_min,val_max,&cimg::rng());\n      cimg::mutex(4,0);\n      return res;",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "**/\n    CImg<T>& operator--() {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=524288))\n      cimg_rof(*this,ptrd,T) *ptrd = *ptrd - (T)1;\n      return *this;",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd3_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n \tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n \nout_drop_write:\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);\nout:\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfs3svc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\tRETURN_STATUS(nfserr);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "struct rds_connection *rds_conn_create(struct net *net,\n\t\t\t\t       const struct in6_addr *laddr,\n\t\t\t\t       const struct in6_addr *faddr,\n\t\t\t\t       struct rds_transport *trans, u8 tos,\n\t\t\t\t       gfp_t gfp, int dev_if)\n{\n\treturn __rds_conn_create(net, laddr, faddr, trans, gfp, tos, 0, dev_if);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "purged_acs(TERMTYPE2 *tterm)\n{\n    bool result = FALSE;\n\n    if (VALID_STRING(acs_chars)) {\n\tif (!one_one_mapping(acs_chars)) {\n\t    enter_alt_charset_mode = ABSENT_STRING;\n\t    exit_alt_charset_mode = ABSENT_STRING;\n\t    SHOW_WHY(\"# (rmacs/smacs removed for consistency)\\n\");\n\t}\n\tresult = TRUE;\n    }\n    return result;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "_g_file_remove_directory (GFile         *directory,\n\t\t\t  GCancellable  *cancellable,\n\t\t\t  GError       **error)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *info;\n\tgboolean         error_occurred = FALSE;\n\n\tif (directory == NULL)\n\t\treturn TRUE;\n\n\tenumerator = g_file_enumerate_children (directory,\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_TYPE,\n\t\t\t\t\t        0,\n\t\t\t\t\t        cancellable,\n\t\t\t\t\t        error);\n\n\twhile (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {\n\t\tGFile *child;\n\n\t\tchild = g_file_get_child (directory, g_file_info_get_name (info));\n\t\tswitch (g_file_info_get_file_type (info)) {\n\t\tcase G_FILE_TYPE_DIRECTORY:\n\t\t\tif (! _g_file_remove_directory (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (! g_file_delete (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tg_object_unref (child);\n\t\tg_object_unref (info);\n\t}\n\n\tif (! error_occurred && ! g_file_delete (directory, cancellable, error))\n \t\terror_occurred = TRUE;\n\n\tg_object_unref (enumerator);\n\n\treturn ! error_occurred;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "person_on_event(person_t* person, int type, script_t* script)\n{\n\tscript_unref(person->scripts[type]);\n\tperson->scripts[type] = script;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "MagickExport void MagickFatalError(const ExceptionType error,const char *reason,\n  const char *description)\n{\n  if (fatal_error_handler != (ErrorHandler) NULL)\n    (*fatal_error_handler)(error,reason,description);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n  *session_data_size = psession.size;\n\n  if (psession.size > *session_data_size)\n    {\n      ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n      goto error;\n    }\n\n  if (session_data != NULL)\n    memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline unsigned long get_mm_rss(struct mm_struct *mm)\n{\n\treturn get_mm_counter(mm, MM_FILEPAGES) +\n\t\tget_mm_counter(mm, MM_ANONPAGES) +\n\t\tget_mm_counter(mm, MM_SHMEMPAGES);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "sshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void Document::scheduleUseShadowTreeUpdate(SVGUseElement& element)\n{\n    m_useElementsNeedingUpdate.add(&element);\n    scheduleLayoutTreeUpdateIfNeeded();\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "save_text(const char *fmt, const char *s, int len)\n{\n    size_t s_len = strlen(s);\n    if (len > (int) s_len)\n\ts_len = (size_t) len;\n\n    get_space(s_len + 1);\n\n    _nc_SPRINTF(TPS(out_buff) + TPS(out_used),\n\t\t_nc_SLIMIT(TPS(out_size) - TPS(out_used))\n\t\tfmt, s);\n    TPS(out_used) += strlen(TPS(out_buff) + TPS(out_used));\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "uint64_t crypt_jobj_get_uint64(json_object *jobj)\n{\n\tuint64_t r;\n\tjson_str_to_uint64(jobj, &r);\n\treturn r;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ArrayExtension() : Extension(\"array\") {}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "cr_input_set_cur_index (CRInput * a_this, glong a_index)\n{\n        g_return_val_if_fail (a_this && PRIVATE (a_this), CR_BAD_PARAM_ERROR);\n\n        PRIVATE (a_this)->next_byte_index = a_index;\n\n        return CR_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "  void Compute(OpKernelContext* context) override {\n    // Only create one, if one does not exist already. Report status for all\n    // other exceptions. If one already exists, it unrefs the new one.\n    // An epsilon value of zero could cause performance issues and is therefore,\n    // disallowed.\n    const Tensor* epsilon_t;\n    OP_REQUIRES_OK(context, context->input(kEpsilonName, &epsilon_t));\n    float epsilon = epsilon_t->scalar<float>()();\n    OP_REQUIRES(\n        context, epsilon > 0,\n        errors::InvalidArgument(\"An epsilon value of zero is not allowed.\"));\n\n    const Tensor* num_streams_t;\n    OP_REQUIRES_OK(context, context->input(kNumStreamsName, &num_streams_t));\n    int64_t num_streams = num_streams_t->scalar<int64>()();\n\n    auto result =\n        new QuantileStreamResource(epsilon, max_elements_, num_streams);\n    auto status = CreateResource(context, HandleFromInput(context, 0), result);\n    if (!status.ok() && status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES(context, false, status);\n    }\n  }",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void xhci_calc_intr_kick(XHCIState *xhci, XHCITransfer *xfer,\n                                XHCIEPContext *epctx, uint64_t mfindex)\n{\n    uint64_t asap = ((mfindex + epctx->interval - 1) &\n                     ~(epctx->interval-1));\n    uint64_t kick = epctx->mfindex_last + epctx->interval;\n\n    assert(epctx->interval != 0);\n    xfer->mfindex_kick = MAX(asap, kick);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int encode_fsinfo(struct xdr_stream *xdr, const u32* bitmask)\n{\n\treturn encode_getattr_two(xdr, bitmask[0] & nfs4_fsinfo_bitmap[0],\n\t\t\tbitmask[1] & nfs4_fsinfo_bitmap[1]);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "bool Item_float::eq(const Item *arg, bool binary_cmp) const\n{\n  if (arg->basic_const_item() && arg->type() == type())\n  {\n    /*\n      We need to cast off const to call val_int(). This should be OK for\n      a basic constant.\n    */\n    Item *item= (Item*) arg;\n    return item->val_real() == value;\n  }\n  return FALSE;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "iperf_get_verbose(struct iperf_test *ipt)\n{\n    return ipt->verbose;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "lha_read_file_header_1(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tsize_t extdsize;\n\tint i, err, err2;\n\tint namelen, padding;\n\tunsigned char headersum, sum_calculated;\n\n\terr = ARCHIVE_OK;\n\n\tif ((p = __archive_read_ahead(a, H1_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\n\tlha->header_size = p[H1_HEADER_SIZE_OFFSET] + 2;\n\theadersum = p[H1_HEADER_SUM_OFFSET];\n\t/* Note: An extended header size is included in a compsize. */\n\tlha->compsize = archive_le32dec(p + H1_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H1_ORIG_SIZE_OFFSET);\n\tlha->mtime = lha_dos_time(p + H1_DOS_TIME_OFFSET);\n\tnamelen = p[H1_NAME_LEN_OFFSET];\n\t/* Calculate a padding size. The result will be normally 0 only(?) */\n\tpadding = ((int)lha->header_size) - H1_FIXED_SIZE - namelen;\n\n\tif (namelen > 230 || padding < 0)\n\t\tgoto invalid;\n\n\tif ((p = __archive_read_ahead(a, lha->header_size, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\n\tfor (i = 0; i < namelen; i++) {\n\t\tif (p[i + H1_FILE_NAME_OFFSET] == 0xff)\n\t\t\tgoto invalid;/* Invalid filename. */\n\t}\n\tarchive_strncpy(&lha->filename, p + H1_FILE_NAME_OFFSET, namelen);\n\tlha->crc = archive_le16dec(p + H1_FILE_NAME_OFFSET + namelen);\n\tlha->setflag |= CRC_IS_SET;\n\n\tsum_calculated = lha_calcsum(0, p, 2, lha->header_size - 2);\n\t/* Consume used bytes but not include `next header size' data\n\t * since it will be consumed in lha_read_file_extended_header(). */\n\t__archive_read_consume(a, lha->header_size - 2);\n\n\t/* Read extended headers */\n\terr2 = lha_read_file_extended_header(a, lha, NULL, 2,\n\t    (size_t)(lha->compsize + 2), &extdsize);\n\tif (err2 < ARCHIVE_WARN)\n\t\treturn (err2);\n\tif (err2 < err)\n\t\terr = err2;\n \t/* Get a real compressed file size. */\n \tlha->compsize -= extdsize - 2;\n \n \tif (sum_calculated != headersum) {\n \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n \t\t    \"LHa header sum error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\treturn (err);\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid LHa header\");\n\treturn (ARCHIVE_FATAL);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "fetch_from_buf_socks_client(buf_t *buf, int state, char **reason)\n{\n  ssize_t drain = 0;\n  int r;\n  if (buf->datalen < 2)\n    return 0;\n\n  buf_pullup(buf, MAX_SOCKS_MESSAGE_LEN, 0);\n  tor_assert(buf->head && buf->head->datalen >= 2);\n\n  r = parse_socks_client((uint8_t*)buf->head->data, buf->head->datalen,\n                         state, reason, &drain);\n  if (drain > 0)\n    buf_remove_from_front(buf, drain);\n  else if (drain < 0)\n    buf_clear(buf);\n\n  return r;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "const char *btrfs_super_csum_driver(u16 csum_type)\n{\n\t/* csum type is validated at mount time */\n\treturn btrfs_csums[csum_type].driver[0] ?\n\t\tbtrfs_csums[csum_type].driver :\n\t\tbtrfs_csums[csum_type].name;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static dma_addr_t intel_map_page(struct device *dev, struct page *page,\n\t\t\t\t unsigned long offset, size_t size,\n\t\t\t\t enum dma_data_direction dir,\n\t\t\t\t unsigned long attrs)\n{\n\treturn __intel_map_single(dev, page_to_phys(page) + offset, size,\n\t\t\t\t  dir, *dev->dma_mask);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int tm_atnode(\n\n  tm_task_id  tid,  /* in  */\n  tm_node_id *node)  /* out */\n\n  {\n  task_info *tp;\n\n  if (!init_done)\n    return TM_BADINIT;\n\n  if ((tp = find_task(tid)) == NULL)\n    return TM_ENOTFOUND;\n\n  *node = tp->t_node;\n\n  return TM_SUCCESS;\n  }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\n\t/* mm's last user has gone, and its about to be pulled down */\n\tmmu_notifier_release(mm);\n\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\n\tarch_exit_mmap(mm);\n\n\tvma = mm->mmap;\n\tif (!vma)\t/* Can happen if dup_mmap() received an OOM */\n\t\treturn;\n\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\t/* update_hiwater_rss(mm) here? but nobody should be looking */\n\t/* Use -1 here to ensure all VMAs in the mm are unmapped */\n\tunmap_vmas(&tlb, vma, 0, -1);\n\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\t/*\n\t\t * Wait for oom_reap_task() to stop working on this\n\t\t * mm. Because MMF_OOM_SKIP is already set before\n\t\t * calling down_read(), oom_reap_task() will not run\n\t\t * on this \"mm\" post up_write().\n\t\t *\n\t\t * mm_is_oom_victim() cannot be set from under us\n\t\t * either because victim->mm is already set to NULL\n\t\t * under task_lock before calling mmput and oom_mm is\n\t\t * set not NULL by the OOM killer only if victim->mm\n\t\t * is found not NULL while holding the task_lock.\n\t\t */\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\n\t/*\n\t * Walk the list again, actually closing and freeing it,\n\t * with preemption enabled, without holding any MM locks.\n\t */\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "DataBuf LoaderXmpJpeg::getData() const\n    {\n        if (!valid()) return DataBuf();\n        return DataBuf(preview_.pData_, preview_.size_);\n    }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int nfs4_proc_renew(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, 0);\n\tif (status < 0)\n\t\treturn status;\n\tdo_renew_lease(clp, now);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void LibRaw::kodak_thumb_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void monitor_init(CharDriverState *hd, int show_banner)\n{\n    int i;\n    if (is_first_init) {\n        for (i = 0; i < MAX_MON; i++) {\n            monitor_hd[i] = NULL;\n        }\n        is_first_init = 0;\n    }\n    for (i = 0; i < MAX_MON; i++) {\n        if (monitor_hd[i] == NULL) {\n            monitor_hd[i] = hd;\n            break;\n        }\n    }\n    hide_banner = !show_banner;\n    qemu_chr_add_handlers(hd, term_can_read, term_read, term_event, NULL);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool ShouldTrackProcessForSite(BrowserContext* browser_context,\n                               RenderProcessHost* render_process_host,\n                               const GURL& site_url) {\n  if (site_url.is_empty())\n    return false;\n\n  return ShouldUseSiteProcessTracking(\n      browser_context, render_process_host->GetStoragePartition(), site_url);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Document::setDesignMode(const String& value)\n{\n    bool newValue = m_designMode;\n    if (equalIgnoringCase(value, \"on\"))\n        newValue = true;\n    else if (equalIgnoringCase(value, \"off\"))\n        newValue = false;\n    if (newValue == m_designMode)\n        return;\n    m_designMode = newValue;\n    setNeedsStyleRecalc(SubtreeStyleChange, StyleChangeReasonForTracing::create(StyleChangeReason::DesignMode));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void nfs_umountall_req(void)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\n\tif ((nfs_server_mount_port == -1) || (!fs_mounted))\n\t\t/* Nothing mounted, nothing to umount */\n\t\treturn;\n\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\trpc_req(PROG_MOUNT, MOUNT_UMOUNTALL, data, len);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "xps_select_font_encoding(xps_font_t *font, int idx)\n {\n     byte *cmapdata, *entry;\n     int pid, eid;\n     if (idx < 0 || idx >= font->cmapsubcount)\n        return;\n     cmapdata = font->data + font->cmaptable;\n     entry = cmapdata + 4 + idx * 8;\n     pid = u16(entry + 0);\n     eid = u16(entry + 2);\n     font->cmapsubtable = font->cmaptable + u32(entry + 4);\n     font->usepua = (pid == 3 && eid == 0);\n }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int __init evm_display_config(void)\n{\n\tchar **xattrname;\n\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++)\n\t\tpr_info(\"%s\\n\", *xattrname);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void usb_wakeup(USBEndpoint *ep, unsigned int stream)\n\n{\n\n    USBDevice *dev = ep->dev;\n\n    USBBus *bus = usb_bus_from_device(dev);\n\n\n\n\n\n\n\n\n\n\n\n    if (dev->remote_wakeup && dev->port && dev->port->ops->wakeup) {\n\n        dev->port->ops->wakeup(dev->port);\n\n\n    if (bus->ops->wakeup_endpoint) {\n\n        bus->ops->wakeup_endpoint(bus, ep, stream);\n\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void __exit twofish_mod_fini(void)\n{\n\tcrypto_unregister_alg(&alg);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static String FullyDecodeString(const String& string,\n                                const WTF::TextEncoding& encoding) {\n  size_t old_working_string_length;\n  String working_string = string;\n  do {\n    old_working_string_length = working_string.length();\n    working_string = Decode16BitUnicodeEscapeSequences(\n        DecodeStandardURLEscapeSequences(working_string, encoding));\n  } while (working_string.length() < old_working_string_length);\n  working_string.Replace('+', ' ');\n  return working_string;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static uint8_t esp_pdma_read(ESPState *s)\n{\n    uint8_t val;\n\n    if (s->do_cmd) {\n        val = esp_cmdfifo_pop(s);\n    } else {\n        val = esp_fifo_pop(s);\n    }\n\n    return val;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "memxor_different_alignment (word_t *dst, const char *src, size_t n)\n{\n  int shl, shr;\n  const word_t *src_word;\n  unsigned offset = ALIGN_OFFSET (src);\n  word_t s0, s1;\n\n  shl = CHAR_BIT * offset;\n  shr = CHAR_BIT * (sizeof(word_t) - offset);\n\n  src_word = (const word_t *) ((uintptr_t) src & -sizeof(word_t));\n\n  if (n & 1)\n    {\n      n--;\n      s1 = src_word[n];\n      s0 = src_word[n+1]; /* FIXME: Overread */\n      dst[n] ^= MERGE (s1, shl, s0, shr);\n    }\n  else\n    s1 = src_word[n]; /* FIXME: Overread */\n\n  while (n > 0)\n    {\n      n -= 2;\n      s0 = src_word[n+1];\n      dst[n+1] ^= MERGE(s0, shl, s1, shr);\n      s1 = src_word[n]; /* FIXME: Overread on last iteration */\n      dst[n] ^= MERGE(s1, shl, s0, shr);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "wc_ucs_toupper(wc_uint32 ucs)\n{\n    wc_map *conv = NULL;\n    if (ucs <= WC_C_UCS2_END)\n\tconv = wc_map_search((wc_uint16)ucs,\n\t\t\t     ucs_toupper_map, N_ucs_toupper_map);\n    return conv ? (wc_uint32)(conv->code2) : ucs;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "libxlDomainDeathThread(void *opaque)\n{\n    struct libxlEventHandlerThreadInfo *death_info = opaque;\n    virDomainObj *vm = death_info->vm;\n    libxl_event *ev = death_info->event;\n    libxlDriverPrivate *driver = death_info->driver;\n    virObjectEvent *dom_event = NULL;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto cleanup;\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTOFF_DESTROYED);\n    dom_event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_STOPPED,\n                                                  VIR_DOMAIN_EVENT_STOPPED_DESTROYED);\n    libxlDomainCleanup(driver, vm);\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n    libxlDomainObjEndJob(driver, vm);\n    virObjectEventStateQueue(driver->domainEventState, dom_event);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    libxl_event_free(cfg->ctx, ev);\n    VIR_FREE(death_info);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "struct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void pc_init_pci_1_3(QEMUMachineInitArgs *args)\n\n{\n\n    enable_compat_apic_id_mode();\n\n    pc_sysfw_flash_vs_rom_bug_compatible = true;\n\n    has_pvpanic = false;\n\n    pc_init_pci(args);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline void idct4col_add(uint8_t *dest, int line_size, const DCTELEM *col)\n\n{\n\n    int c0, c1, c2, c3, a0, a1, a2, a3;\n\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n\n\n    a0 = col[8*0];\n\n    a1 = col[8*1];\n\n    a2 = col[8*2];\n\n    a3 = col[8*3];\n\n    c0 = (a0 + a2)*C3 + (1 << (C_SHIFT - 1));\n\n    c2 = (a0 - a2)*C3 + (1 << (C_SHIFT - 1));\n\n    c1 = a1 * C1 + a3 * C2;\n\n    c3 = a1 * C2 - a3 * C1;\n\n    dest[0] = cm[dest[0] + ((c0 + c1) >> C_SHIFT)];\n\n    dest += line_size;\n\n    dest[0] = cm[dest[0] + ((c2 + c3) >> C_SHIFT)];\n\n    dest += line_size;\n\n    dest[0] = cm[dest[0] + ((c2 - c3) >> C_SHIFT)];\n\n    dest += line_size;\n\n    dest[0] = cm[dest[0] + ((c0 - c1) >> C_SHIFT)];\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static __le32 ext4_xattr_hash_entry(char *name, size_t name_len, __le32 *value,\n\t\t\t\t    size_t value_count)\n{\n\t__u32 hash = 0;\n\n\twhile (name_len--) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\twhile (value_count--) {\n\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(*value++);\n\t}\n\treturn cpu_to_le32(hash);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline bool cpu_has_vmx_tsc_scaling(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_TSC_SCALING;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "const GURL& TopSitesCache::GetURLFromIterator(\n    CanonicalURLs::const_iterator it) const {\n  DCHECK(it != canonical_urls_.end());\n  return it->first.first->redirects[it->first.second];\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int scsi_write_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->iov.iov_len / 512;\n\n    if (n) {\n\n        qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n        r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n\n                                   scsi_write_complete, r);\n\n        if (r->req.aiocb == NULL) {\n\n            scsi_write_complete(r, -EIO);\n\n        }\n\n    } else {\n\n        /* Invoke completion routine to fetch data from host.  */\n\n        scsi_write_complete(r, 0);\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "PHPAPI void php_url_free(php_url *theurl)\n{\n\tif (theurl->scheme)\n\t\tzend_string_release_ex(theurl->scheme, 0);\n\tif (theurl->user)\n\t\tzend_string_release_ex(theurl->user, 0);\n\tif (theurl->pass)\n\t\tzend_string_release_ex(theurl->pass, 0);\n\tif (theurl->host)\n\t\tzend_string_release_ex(theurl->host, 0);\n\tif (theurl->path)\n\t\tzend_string_release_ex(theurl->path, 0);\n\tif (theurl->query)\n\t\tzend_string_release_ex(theurl->query, 0);\n\tif (theurl->fragment)\n\t\tzend_string_release_ex(theurl->fragment, 0);\n\tefree(theurl);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "AuthenticatorNoAvailableTransportsErrorModel::GetStepIllustration(\n    ImageColorScheme color_scheme) const {\n  return color_scheme == ImageColorScheme::kDark ? kWebauthnErrorDarkIcon\n                                                 : kWebauthnErrorIcon;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void __exit exit_f2fs_fs(void)\n{\n\tremove_proc_entry(\"fs/f2fs\", NULL);\n\tf2fs_destroy_root_stats();\n\tunregister_shrinker(&f2fs_shrinker_info);\n\tunregister_filesystem(&f2fs_fs_type);\n\tf2fs_exit_crypto();\n\tdestroy_extent_cache();\n\tdestroy_checkpoint_caches();\n\tdestroy_segment_manager_caches();\n\tdestroy_node_manager_caches();\n\tdestroy_inodecache();\n\tkset_unregister(f2fs_kset);\n\tf2fs_destroy_trace_ios();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int ZEXPORT inflateSyncPoint(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    return state->mode == STORED && state->bits == 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "compileError(FileInfo *nested, char *format, ...) {\n#ifndef __SYMBIAN32__\n\tchar buffer[MAXSTRING];\n\tva_list arguments;\n\tva_start(arguments, format);\n\tvsnprintf(buffer, sizeof(buffer), format, arguments);\n\tva_end(arguments);\n\tif (nested)\n\t\t_lou_logMessage(LOG_ERROR, \"%s:%d: error: %s\", nested->fileName,\n\t\t\t\tnested->lineNumber, buffer);\n\telse\n\t\t_lou_logMessage(LOG_ERROR, \"error: %s\", buffer);\n\terrorCount++;\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\n\t*len = sizeof(*addr);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Statement_Ptr Expand::operator()(Declaration_Ptr d)\n  {\n    Block_Obj ab = d->block();\n    String_Obj old_p = d->property();\n    Expression_Obj prop = old_p->perform(&eval);\n    String_Obj new_p = Cast<String>(prop);\n    // we might get a color back\n    if (!new_p) {\n      std::string str(prop->to_string(ctx.c_options));\n      new_p = SASS_MEMORY_NEW(String_Constant, old_p->pstate(), str);\n    }\n    Expression_Obj value = d->value()->perform(&eval);\n    Block_Obj bb = ab ? operator()(ab) : NULL;\n    if (!bb) {\n      if (!value || (value->is_invisible() && !d->is_important())) return 0;\n    }\n    Declaration_Ptr decl = SASS_MEMORY_NEW(Declaration,\n                                        d->pstate(),\n                                        new_p,\n                                        value,\n                                        d->is_important(),\n                                        d->is_custom_property(),\n                                        bb);\n    decl->tabs(d->tabs());\n    return decl;\n  }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int main(int argc, char **argv, char **envp)\n{\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"b:h:k:p:q:w:z:xv\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'b':\n\t\t\ttmate_settings->bind_addr = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\ttmate_settings->tmate_host = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\ttmate_settings->keys_dir = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttmate_settings->ssh_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\ttmate_settings->ssh_port_advertized = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttmate_settings->websocket_hostname = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\ttmate_settings->websocket_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\ttmate_settings->use_proxy_protocol = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\ttmate_settings->log_level++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tinit_logging(tmate_settings->log_level);\n\n\tsetup_locale();\n\n\tif (!tmate_settings->tmate_host)\n\t\ttmate_settings->tmate_host = get_full_hostname();\n\n\tcmdline = *argv;\n\tcmdline_end = *envp;\n\n\ttmate_preload_trace_lib();\n\ttmate_catch_sigsegv();\n\ttmate_init_rand();\n\n\tif ((mkdir(TMATE_WORKDIR, 0701)             < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0703) < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/jail\", 0700)     < 0 && errno != EEXIST))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\t/* The websocket server needs to access the /session dir to rename sockets */\n\tif ((chmod(TMATE_WORKDIR, 0701)             < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/sessions\", 0703) < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/jail\", 0700)     < 0))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\ttmate_ssh_server_main(tmate_session,\n\t\t\t      tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "size_t ADDCALL sass_compiler_get_import_stack_size(struct Sass_Compiler* compiler) { return compiler->cpp_ctx->import_stack.size(); }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "iperf_get_test_unit_format(struct iperf_test *ipt)\n{\n    return ipt->settings->unit_format;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void KaxSimpleBlock::SetParent(KaxCluster & aParentCluster) {\n  KaxInternalBlock::SetParent( aParentCluster );\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int check_write_unsafe(BlockDriverState *bs, int64_t sector_num,\n\n                              const uint8_t *buf, int nb_sectors)\n\n{\n\n    /* assume that if the user specifies the format explicitly, then assume\n\n       that they will continue to do so and provide no safety net */\n\n    if (!bs->probed) {\n\n        return 0;\n\n    }\n\n\n\n    if (sector_num == 0 && nb_sectors > 0) {\n\n        return check_for_block_signature(bs, buf);\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void update_context(struct ImapData *idata, int oldmsgcount)\n{\n  struct Header *h = NULL;\n\n  struct Context *ctx = idata->ctx;\n  if (!idata->uid_hash)\n    idata->uid_hash = mutt_hash_int_create(MAX(6 * ctx->msgcount / 5, 30), 0);\n\n  for (int msgno = oldmsgcount; msgno < ctx->msgcount; msgno++)\n  {\n    h = ctx->hdrs[msgno];\n    mutt_hash_int_insert(idata->uid_hash, HEADER_DATA(h)->uid, h);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "delegpt_add_rrset(struct delegpt* dp, struct regional* region,\n        struct ub_packed_rrset_key* rrset, uint8_t lame)\n{\n\tif(!rrset)\n\t\treturn 1;\n\tif(ntohs(rrset->rk.type) == LDNS_RR_TYPE_NS)\n\t\treturn delegpt_rrset_add_ns(dp, region, rrset, lame);\n\telse if(ntohs(rrset->rk.type) == LDNS_RR_TYPE_A)\n\t\treturn delegpt_add_rrset_A(dp, region, rrset, lame);\n\telse if(ntohs(rrset->rk.type) == LDNS_RR_TYPE_AAAA)\n\t\treturn delegpt_add_rrset_AAAA(dp, region, rrset, lame);\n\tlog_warn(\"Unknown rrset type added to delegpt\");\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void *oss_audio_init (void)\n\n{\n\n    OSSConf *conf = g_malloc(sizeof(OSSConf));\n\n    *conf = glob_conf;\n\n\n\n    if (access(conf->devpath_in, R_OK | W_OK) < 0 ||\n\n        access(conf->devpath_out, R_OK | W_OK) < 0) {\n\n\n        return NULL;\n\n    }\n\n    return conf;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\n\t}\n\tput_io_context(ioc);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void setFileState(rpmfs fs, int i)\n{\n    switch (rpmfsGetAction(fs, i)) {\n    case FA_SKIPNSTATE:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NOTINSTALLED);\n\tbreak;\n    case FA_SKIPNETSHARED:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NETSHARED);\n\tbreak;\n    case FA_SKIPCOLOR:\n\trpmfsSetState(fs, i, RPMFILE_STATE_WRONGCOLOR);\n\tbreak;\n    case FA_TOUCH:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NORMAL);\n\tbreak;\n    default:\n\tbreak;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "uipbuf_get_len_field(struct uip_ip_hdr *hdr)\n{\n  return ((uint16_t)(hdr->len[0]) << 8) + hdr->len[1];\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int add_mount(const char *source, const char *mnt, const char *type,\n\t\t     const char *opts)\n{\n\t(void) source;\n\t(void) mnt;\n\t(void) type;\n\t(void) opts;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int aiff_read_packet(AVFormatContext *s,\n\n                            AVPacket *pkt)\n\n{\n\n    AVStream *st = s->streams[0];\n\n    AIFFInputContext *aiff = s->priv_data;\n\n    int64_t max_size;\n\n    int res, size;\n\n\n\n    /* calculate size of remaining data */\n\n    max_size = aiff->data_end - avio_tell(s->pb);\n\n    if (max_size <= 0)\n\n        return AVERROR_EOF;\n\n\n\n    /* Now for that packet */\n\n    if (st->codec->block_align >= 33) // GSM, QCLP, IMA4\n\n        size = st->codec->block_align;\n\n    else\n\n        size = (MAX_SIZE / st->codec->block_align) * st->codec->block_align;\n\n    size = FFMIN(max_size, size);\n\n    res = av_get_packet(s->pb, pkt, size);\n\n    if (res < 0)\n\n        return res;\n\n\n\n\n\n    /* Only one stream in an AIFF file */\n\n    pkt->stream_index = 0;\n\n    pkt->duration     = (res / st->codec->block_align) * aiff->block_duration;\n\n    return 0;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline pmd_t pmd_mknonnuma(pmd_t pmd)\n{\n\treturn pmd;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void do_POWER_divso (void)\n\n{\n\n    if (((int32_t)T0 == INT32_MIN && (int32_t)T1 == -1) || (int32_t)T1 == 0) {\n\n        T0 = (long)((-1) * (T0 >> 31));\n\n        env->spr[SPR_MQ] = 0;\n\n        xer_ov = 1;\n\n        xer_so = 1;\n\n    } else {\n\n        T0 = (int32_t)T0 / (int32_t)T1;\n\n        env->spr[SPR_MQ] = (int32_t)T0 % (int32_t)T1;\n\n        xer_ov = 0;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "explicit FakeDownloadItem()\n      : state_(IN_PROGRESS) {\n  }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void wav_capture_destroy (void *opaque)\n\n{\n\n    WAVState *wav = opaque;\n\n\n\n    AUD_del_capture (wav->cap, wav);\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void stellaris_gamepad_init(int n, qemu_irq *irq, const int *keycode)\n\n{\n\n    gamepad_state *s;\n\n    int i;\n\n\n\n    s = (gamepad_state *)g_malloc0(sizeof (gamepad_state));\n\n    s->buttons = (gamepad_button *)g_malloc0(n * sizeof (gamepad_button));\n\n    for (i = 0; i < n; i++) {\n\n        s->buttons[i].irq = irq[i];\n\n        s->buttons[i].keycode = keycode[i];\n\n    }\n\n    s->num_buttons = n;\n\n    qemu_add_kbd_event_handler(stellaris_gamepad_put_key, s);\n\n    vmstate_register(NULL, -1, &vmstate_stellaris_gamepad, s);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int count() const { return m_count; }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static CURLcode read_data(struct connectdata *conn,\n                          curl_socket_t fd,\n                          struct krb5buffer *buf)\n{\n  int len;\n  void *tmp = NULL;\n  CURLcode result;\n\n  result = socket_read(fd, &len, sizeof(len));\n  if(result)\n    return result;\n\n  if(len) {\n    /* only realloc if there was a length */\n    len = ntohl(len);\n    tmp = Curl_saferealloc(buf->data, len);\n  }\n  if(tmp == NULL)\n    return CURLE_OUT_OF_MEMORY;\n\n  buf->data = tmp;\n  result = socket_read(fd, buf->data, len);\n  if(result)\n    return result;\n  buf->size = conn->mech->decode(conn->app_data, buf->data, len,\n                                 conn->data_prot, conn);\n  buf->index = 0;\n  return CURLE_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int snd_usb_cm106_write_int_reg(struct usb_device *dev, int reg, u16 value)\n{\n\tu8 buf[4];\n\tbuf[0] = 0x20;\n\tbuf[1] = value & 0xff;\n\tbuf[2] = (value >> 8) & 0xff;\n\tbuf[3] = reg;\n\treturn snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), USB_REQ_SET_CONFIGURATION,\n\t\t\t       USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\n\t\t\t       0, 0, &buf, 4);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "CImgDisplay& close() {\n      if (is_empty() || _is_closed) return *this;\n      Display *const dpy = cimg::X11_attr().display;\n      cimg_lock_display();\n      if (_is_fullscreen) _desinit_fullscreen();\n      XUnmapWindow(dpy,_window);\n      _window_x = _window_y = -1;\n      _is_closed = true;\n      cimg_unlock_display();\n      return *this;",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "uint32_t TiffIfdMakernote::doWriteData(IoWrapper&/*ioWrapper*/,\n                                           ByteOrder /*byteOrder*/,\n                                           int32_t   /*offset*/,\n                                           uint32_t  /*dataIdx*/,\n                                           uint32_t& /*imageIdx*/) const\n    {\n        assert(false);\n        return 0;\n    } // TiffIfdMakernote::doWriteData",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool Image::good() const\n    {\n        if (io_->open() != 0) return false;\n        IoCloser closer(*io_);\n        return ImageFactory::checkType(imageType_, *io_, false);\n    }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_glock *gl;\n\n\twhile ((n = rb_first(&sdp->sd_rindex_tree))) {\n\t\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tgl = rgd->rd_gl;\n\n\t\trb_erase(n, &sdp->sd_rindex_tree);\n\n\t\tif (gl) {\n\t\t\tspin_lock(&gl->gl_lockref.lock);\n\t\t\tgl->gl_object = NULL;\n\t\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\t\tgfs2_glock_add_to_lru(gl);\n\t\t\tgfs2_glock_put(gl);\n\t\t}\n\n\t\tgfs2_free_clones(rgd);\n\t\tkfree(rgd->rd_bits);\n\t\treturn_all_reservations(rgd);\n\t\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int OTHERNAME_cmp(OTHERNAME *a, OTHERNAME *b)\n{\n    int result = -1;\n\n    if (!a || !b)\n        return -1;\n    /* Check their type first. */\n    if ((result = OBJ_cmp(a->type_id, b->type_id)) != 0)\n        return result;\n    /* Check the value. */\n    result = ASN1_TYPE_cmp(a->value, b->value);\n    return result;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void CommandBufferProxyImpl::SetUpdateVSyncParametersCallback(\n    const UpdateVSyncParametersCallback& callback) {\n  CheckLock();\n  update_vsync_parameters_completion_callback_ = callback;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void test_none(void)\n\n{\n\n    struct qdist dist;\n\n    char *pr;\n\n\n\n    qdist_init(&dist);\n\n\n\n    g_assert(isnan(qdist_avg(&dist)));\n\n    g_assert(isnan(qdist_xmin(&dist)));\n\n    g_assert(isnan(qdist_xmax(&dist)));\n\n\n\n    pr = qdist_pr_plain(&dist, 0);\n\n    g_assert(pr == NULL);\n\n\n\n    pr = qdist_pr_plain(&dist, 2);\n\n    g_assert(pr == NULL);\n\n\n\n    qdist_destroy(&dist);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void cache_fini(PageCache *cache)\n\n{\n\n    int64_t i;\n\n\n\n    g_assert(cache);\n\n    g_assert(cache->page_cache);\n\n\n\n    for (i = 0; i < cache->max_num_items; i++) {\n\n        g_free(cache->page_cache[i].it_data);\n\n    }\n\n\n\n    g_free(cache->page_cache);\n\n    cache->page_cache = NULL;\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline unsigned long vm_end_gap(struct vm_area_struct *vma)\n{\n\tunsigned long vm_end = vma->vm_end;\n\n\tif (vma->vm_flags & VM_GROWSUP) {\n\t\tvm_end += stack_guard_gap;\n\t\tif (vm_end < vma->vm_end)\n\t\t\tvm_end = -PAGE_SIZE;\n\t}\n\treturn vm_end;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void ipmr_destroy_unres(struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\n\tatomic_dec(&cache_resolve_queue_len);\n\n\twhile((skb=skb_dequeue(&c->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -ETIMEDOUT;\n\t\t\tnetlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n\n\tkmem_cache_free(mrt_cachep, c);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void RenderProcessHostImpl::BindRouteProvider(\n    mojom::RouteProviderAssociatedRequest request) {\n  if (route_provider_binding_.is_bound())\n    return;\n  route_provider_binding_.Bind(std::move(request));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void __netdev_watchdog_up(struct net_device *dev)\n{\n\tif (dev->tx_timeout) {\n\t\tif (dev->watchdog_timeo <= 0)\n\t\t\tdev->watchdog_timeo = 5*HZ;\n\t\tif (!mod_timer(&dev->watchdog_timer,\n\t\t\t       round_jiffies(jiffies + dev->watchdog_timeo)))\n\t\t\tdev_hold(dev);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static BOOL rdg_skip_seed_payload(rdpTls* tls, SSIZE_T lastResponseLength)\n{\n\tBYTE seed_payload[10];\n\tconst size_t size = sizeof(seed_payload);\n\n\tassert(size < SSIZE_MAX);\n\n\t/* Per [MS-TSGU] 3.3.5.1 step 4, after final OK response RDG server sends\n\t * random \"seed\" payload of limited size. In practice it's 10 bytes.\n\t */\n\tif (lastResponseLength < (SSIZE_T)size)\n\t{\n\t\tif (!rdg_read_all(tls, seed_payload, size - lastResponseLength))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline void shmem_show_mpol(struct seq_file *seq, struct mempolicy *mpol)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "__ext4_xattr_check_block(struct inode *inode, struct buffer_head *bh,\n\t\t\t const char *function, unsigned int line)\n{\n\tint error = -EFSCORRUPTED;\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\tgoto errout;\n\terror = -EFSBADCRC;\n\tif (!ext4_xattr_block_csum_verify(inode, bh))\n\t\tgoto errout;\n\terror = ext4_xattr_check_entries(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t\t bh->b_data);\nerrout:\n\tif (error)\n\t\t__ext4_error_inode(inode, function, line, 0,\n\t\t\t\t   \"corrupted xattr block %llu\",\n\t\t\t\t   (unsigned long long) bh->b_blocknr);\n\telse\n\t\tset_buffer_verified(bh);\n\treturn error;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\n\tif (line == NULL)\n\t\treturn (0);\n\n\tif (*line != '<')\n\t\treturn (0);\n\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\t/* accept empty return-path in MAIL FROM, required for bounces */\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\n\t\t/* no user-part, reject */\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\n\t\t/* no domain, local user */\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "TDuplexProtocolFactory() {}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static bool glfs_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tglfs_t *fs = NULL;\n\tglfs_fd_t *gfd = NULL;\n\tgluster_server *hosts = NULL; /* gluster server defination */\n\tbool result = true;\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto done;\n\t}\n\tpath += 1; /* get past '/' */\n\tfs = tcmu_create_glfs_object(path, &hosts);\n\tif (!fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto done;\n\t}\n\tgfd = glfs_open(fs, hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfd) {\n\t\tif (asprintf(reason, \"glfs_open failed: %m\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tif (glfs_access(fs, hosts->path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"glfs_access file not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tgoto done;\nunref:\n\tgluster_cache_refresh(fs, path);\ndone:\n\tif (gfd)\n\t\tglfs_close(gfd);\n\tgluster_free_server(&hosts);\n\treturn result;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int ha_end()\n{\n  int error= 0;\n  DBUG_ENTER(\"ha_end\");\n\n  /* \n    This should be eventually based on the graceful shutdown flag.\n    So if flag is equal to HA_PANIC_CLOSE, the deallocate\n    the errors.\n  */\n  if (unlikely(ha_finish_errors()))\n    error= 1;\n\n  DBUG_RETURN(error);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "KillRing() : size(0), index(0), lastAction(actionOther) {\n        theRing.reserve(capacity);\n    }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int Instance::GetScaled(int x) const {\n  return static_cast<int>(x * device_scale_);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void scsi_bus_legacy_handle_cmdline(SCSIBus *bus)\n\n{\n\n    DriveInfo *dinfo;\n\n    int unit;\n\n\n\n    for (unit = 0; unit < MAX_SCSI_DEVS; unit++) {\n\n        dinfo = drive_get(IF_SCSI, bus->busnr, unit);\n\n        if (dinfo == NULL) {\n\n            continue;\n\n        }\n\n        scsi_bus_legacy_add_drive(bus, dinfo, unit);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "SpiceMarshaller *red_channel_client_get_marshaller(RedChannelClient *rcc)\n{\n    return rcc->send_data.marshaller;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static ExitStatus trans_fop_wew_0e(DisasContext *ctx, uint32_t insn,\n\n                                   const DisasInsn *di)\n\n{\n\n    unsigned rt = assemble_rt64(insn);\n\n    unsigned ra = assemble_ra64(insn);\n\n    return do_fop_wew(ctx, rt, ra, di->f_wew);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "const char *SoundTouch::getVersionString()\r\n{\r\n    static const char *_version = SOUNDTOUCH_VERSION;\r\n\r\n    return _version;\r\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void RenderThreadImpl::RemoveEmbeddedWorkerRoute(int32 routing_id) {\n  RemoveRoute(routing_id);\n  if (devtools_agent_message_filter_.get()) {\n    devtools_agent_message_filter_->RemoveEmbeddedWorkerRouteOnMainThread(\n        routing_id);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "memxor3_different_alignment_b (word_t *dst,\n\t\t\t       const word_t *a, const char *b, unsigned offset, size_t n)\n{\n  int shl, shr;\n  const word_t *b_word;\n\n  word_t s0, s1;\n\n  shl = CHAR_BIT * offset;\n  shr = CHAR_BIT * (sizeof(word_t) - offset);\n\n  b_word = (const word_t *) ((uintptr_t) b & -sizeof(word_t));\n\n  if (n & 1)\n    {\n      n--;\n      s1 = b_word[n];\n      s0 = b_word[n+1];\n      dst[n] = a[n] ^ MERGE (s1, shl, s0, shr);\n    }\n  else\n    s1 = b_word[n];\n\n  while (n > 0)\n    {\n      n -= 2;\n      s0 = b_word[n+1];\n      dst[n+1] = a[n+1] ^ MERGE(s0, shl, s1, shr);\n      s1 = b_word[n];\n      dst[n] = a[n] ^ MERGE(s1, shl, s0, shr);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "base::string16 AuthenticatorPaaskSheetModel::GetStepDescription() const {\n  return l10n_util::GetStringUTF16(IDS_WEBAUTHN_CABLE_ACTIVATE_DESCRIPTION);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int rxrpc_krb5_decode_ticket(u8 **_ticket, u16 *_tktlen,\n\t\t\t\t    const __be32 **_xdr, unsigned int *_toklen)\n{\n\tconst __be32 *xdr = *_xdr;\n\tunsigned int toklen = *_toklen, len;\n\n\t/* there must be at least one length word */\n\tif (toklen <= 4)\n\t\treturn -EINVAL;\n\n\t_enter(\",{%x},%u\", ntohl(xdr[0]), toklen);\n\n\tlen = ntohl(*xdr++);\n\ttoklen -= 4;\n\tif (len > AFSTOKEN_K5_TIX_MAX)\n\t\treturn -EINVAL;\n\t*_tktlen = len;\n\n\t_debug(\"ticket len %u\", len);\n\n\tif (len > 0) {\n\t\t*_ticket = kmemdup(xdr, len, GFP_KERNEL);\n\t\tif (!*_ticket)\n\t\t\treturn -ENOMEM;\n\t\tlen = (len + 3) & ~3;\n\t\ttoklen -= len;\n\t\txdr += len >> 2;\n\t}\n\n\t*_xdr = xdr;\n\t*_toklen = toklen;\n\t_leave(\" = 0 [toklen=%u]\", toklen);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "compare_field_marshal (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_FIELD_MARSHAL_PARENT] - b_values [MONO_FIELD_MARSHAL_PARENT];\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "GF_Err mfhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->sequence_number);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "ext4_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext4_xattr_handler_map))\n\t\thandler = ext4_xattr_handler_map[name_index];\n\treturn handler;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval *key, *data, **old_data;\n\n\t\tALLOC_INIT_ZVAL(key);\n\n\t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\n\t\tALLOC_INIT_ZVAL(data);\n\n\t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\tzval_dtor(data);\n\t\t\tFREE_ZVAL(data);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!objprops) {\n\t\t\tswitch (Z_TYPE_P(key)) {\n\t\t\tcase IS_LONG:\n\t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\tcase IS_STRING:\n\t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\t}\n \t\t} else {\n \t\t\t/* object properties should include no integers */\n \t\t\tconvert_to_string(key);\n\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n \t\t\t\tvar_push_dtor(var_hash, old_data);\n \t\t\t}\n \t\t\tzend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,\n\t\t\t\t\tsizeof data, NULL);\n\t\t}\n\t\t\n\t\tzval_dtor(key);\n\t\tFREE_ZVAL(key);\n\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void RenderFrameHostImpl::NavigateToURL(const GURL& url) {\n  FrameMsg_Navigate_Params params;\n  params.page_id = -1;\n  params.pending_history_list_offset = -1;\n  params.current_history_list_offset = -1;\n  params.current_history_list_length = 0;\n  params.url = url;\n  params.transition = PAGE_TRANSITION_LINK;\n  params.navigation_type = FrameMsg_Navigate_Type::NORMAL;\n  Navigate(params);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "check_rpcsec_auth(struct svc_req *rqstp)\n{\n     gss_ctx_id_t ctx;\n     krb5_context kctx;\n     OM_uint32 maj_stat, min_stat;\n     gss_name_t name;\n     krb5_principal princ;\n     int ret, success;\n     krb5_data *c1, *c2, *realm;\n     gss_buffer_desc gss_str;\n     kadm5_server_handle_t handle;\n     size_t slen;\n     char *sdots;\n\n     success = 0;\n     handle = (kadm5_server_handle_t)global_server_handle;\n\n     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)\n\t  return 0;\n\n     ctx = rqstp->rq_svccred;\n\n     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,\n\t\t\t\t    NULL, NULL, NULL, NULL, NULL);\n     if (maj_stat != GSS_S_COMPLETE) {\n\t  krb5_klog_syslog(LOG_ERR, _(\"check_rpcsec_auth: failed \"\n\t\t\t\t      \"inquire_context, stat=%u\"), maj_stat);\n\t  log_badauth(maj_stat, min_stat, rqstp->rq_xprt, NULL);\n\t  goto fail_name;\n     }\n\n     kctx = handle->context;\n     ret = gss_to_krb5_name_1(rqstp, kctx, name, &princ, &gss_str);\n     if (ret == 0)\n\t  goto fail_name;\n\n     slen = gss_str.length;\n     trunc_name(&slen, &sdots);\n     /*\n      * Since we accept with GSS_C_NO_NAME, the client can authenticate\n      * against the entire kdb.  Therefore, ensure that the service\n      * name is something reasonable.\n      */\n     if (krb5_princ_size(kctx, princ) != 2)\n\t  goto fail_princ;\n\n      c1 = krb5_princ_component(kctx, princ, 0);\n      c2 = krb5_princ_component(kctx, princ, 1);\n      realm = krb5_princ_realm(kctx, princ);\n     if (strncmp(handle->params.realm, realm->data, realm->length) == 0\n\t && strncmp(\"kadmin\", c1->data, c1->length) == 0) {\n\t  if (strncmp(\"history\", c2->data, c2->length) == 0)\n\t       goto fail_princ;\n\t  else\n\t       success = 1;\n     }\n \n fail_princ:\n      if (!success) {\n\t krb5_klog_syslog(LOG_ERR, _(\"bad service principal %.*s%s\"),\n\t\t\t  (int) slen, (char *) gss_str.value, sdots);\n     }\n     gss_release_buffer(&min_stat, &gss_str);\n     krb5_free_principal(kctx, princ);\nfail_name:\n     gss_release_name(&min_stat, &name);\n     return success;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline void padlock_reset_key(struct cword *cword)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tif (cword != per_cpu(paes_last_cword, cpu))\n#ifndef CONFIG_X86_64\n\t\tasm volatile (\"pushfl; popfl\");\n#else\n\t\tasm volatile (\"pushfq; popfq\");\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "GF_Err schm_box_size(GF_Box *s)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += 8;\n\tif (ptr->flags & 0x000001) ptr->size += 1 + (ptr->URI ? strlen(ptr->URI) : 0);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n\n    /* +1 is needed for https://github.com/uclouvain/openjpeg/issues/835 */\n    /* and actually +2 required for https://github.com/uclouvain/openjpeg/issues/982 */\n    /* and +7 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 3) */\n    /* and +26 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 7) */\n    /* TODO: is there a theoretical upper-bound for the compressed code */\n    /* block size ? */\n    l_data_size = 26 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            /* We refer to data - 1 since below we incremented it */\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n\n        /* We reserve the initial byte as a fake byte to a non-FF value */\n        /* and increment the data pointer, so that opj_mqc_init_enc() */\n        /* can do bp = data - 1, and opj_mqc_byteout() can safely dereference */\n        /* it. */\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; /*why +1 ?*/\n    }\n    return OPJ_TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "PHP_FUNCTION(bcsub)\n{\n\tchar *left, *right;\n\tint left_len, right_len;\n\tlong scale_param = 0;\n\tbc_num first, second, result;\n\tint scale = BCG(bc_precision), argc = ZEND_NUM_ARGS();\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tif (argc == 3) {\n\t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n\t}\n\n\tbc_init_num(&first TSRMLS_CC);\n\tbc_init_num(&second TSRMLS_CC);\n\tbc_init_num(&result TSRMLS_CC);\n\tphp_str2num(&first, left TSRMLS_CC);\n\tphp_str2num(&second, right TSRMLS_CC);\n\tbc_sub (first, second, &result, scale);\n\n\tif (result->n_scale > scale) {\n\t\tresult->n_scale = scale;\n\t}\n\n\tZ_STRVAL_P(return_value) = bc_num2str(result);\n\tZ_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));\n\tZ_TYPE_P(return_value) = IS_STRING;\n\tbc_free_num(&first);\n\tbc_free_num(&second);\n\tbc_free_num(&result);\n\treturn;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline abi_long do_msgrcv(int msqid, abi_long msgp,\n\n                                 unsigned int msgsz, abi_long msgtyp,\n\n                                 int msgflg)\n\n{\n\n    struct target_msgbuf *target_mb;\n\n    char *target_mtext;\n\n    struct msgbuf *host_mb;\n\n    abi_long ret = 0;\n\n\n\n    if (!lock_user_struct(VERIFY_WRITE, target_mb, msgp, 0))\n\n        return -TARGET_EFAULT;\n\n\n\n    host_mb = malloc(msgsz+sizeof(long));\n\n    ret = get_errno(msgrcv(msqid, host_mb, msgsz, tswapal(msgtyp), msgflg));\n\n\n\n    if (ret > 0) {\n\n        abi_ulong target_mtext_addr = msgp + sizeof(abi_ulong);\n\n        target_mtext = lock_user(VERIFY_WRITE, target_mtext_addr, ret, 0);\n\n        if (!target_mtext) {\n\n            ret = -TARGET_EFAULT;\n\n            goto end;\n\n        }\n\n        memcpy(target_mb->mtext, host_mb->mtext, ret);\n\n        unlock_user(target_mtext, target_mtext_addr, ret);\n\n    }\n\n\n\n    target_mb->mtype = tswapal(host_mb->mtype);\n\n    free(host_mb);\n\n\n\nend:\n\n    if (target_mb)\n\n        unlock_user_struct(target_mb, msgp, 1);\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int sisusb_write_pci_config(struct sisusb_usb_data *sisusb,\n\t\tint regnum, u32 data)\n{\n\tstruct sisusb_packet packet;\n\n\tpacket.header = 0x008f;\n\tpacket.address = regnum | 0x10000;\n\tpacket.data = data;\n\treturn sisusb_send_packet(sisusb, 10, &packet);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat x,\n                  typename TTypes<T>::ConstFlat y, T tolerance,\n                  typename TTypes<bool>::Flat z) {\n    auto diff = x - y;\n    z.device(d) = diff.abs() <= tolerance;\n  }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void nfs_destroy_inode(struct inode *inode)\n{\n\tkmem_cache_free(nfs_inode_cachep, NFS_I(inode));\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void tricore_cpu_class_init(ObjectClass *c, void *data)\n\n{\n\n    TriCoreCPUClass *mcc = TRICORE_CPU_CLASS(c);\n\n    CPUClass *cc = CPU_CLASS(c);\n\n    DeviceClass *dc = DEVICE_CLASS(c);\n\n\n\n    mcc->parent_realize = dc->realize;\n\n    dc->realize = tricore_cpu_realizefn;\n\n\n\n    mcc->parent_reset = cc->reset;\n\n    cc->reset = tricore_cpu_reset;\n\n    cc->class_by_name = tricore_cpu_class_by_name;\n\n    cc->has_work = tricore_cpu_has_work;\n\n\n\n    cc->dump_state = tricore_cpu_dump_state;\n\n    cc->set_pc = tricore_cpu_set_pc;\n\n    cc->synchronize_from_tb = tricore_cpu_synchronize_from_tb;\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "uint32_t next() {\n if (!mCount)\n return 0;\n        mCount--;\n return (mNext++ % mSize) + mMin;\n }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int tda9855_treble(int val) { return (val/0x1c71+0x3)<<1; }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void LibRaw::hat_transform(float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i = 0; i < sc; i++)\n    temp[i] = 2 * base[st * i] + base[st * (sc - i)] + base[st * (i + sc)];\n  for (; i + sc < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (i + sc)];\n  for (; i < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] +\n              base[st * (2 * size - 2 - (i + sc))];\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void scsi_disk_emulate_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    int buflen = r->iov.iov_len;\n\n    if (buflen) {\n        trace_scsi_disk_emulate_read_data(buflen);\n        r->iov.iov_len = 0;\n        r->started = true;\n        scsi_req_data(&r->req, buflen);\n        return;\n    }\n\n    /* This also clears the sense buffer for REQUEST SENSE.  */\n    scsi_req_complete(&r->req, GOOD);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\n\tbuf->tr = tr;\n\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Allocate the first page for all buffers */\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "Casio2MnHeader::~Casio2MnHeader()\n    {\n    }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool Decoder::canSplitFunctionOn(\n\t\tutils::Address addr,\n\t\tllvm::BasicBlock* splitBb,\n\t\tstd::set<llvm::BasicBlock*>& newFncStarts)\n{\n\tnewFncStarts.insert(splitBb);\n\n\tauto* f = splitBb->getParent();\n\tauto fAddr = getFunctionAddress(f);\n\n\tauto fSzIt = _fnc2sz.find(f);\n\tif (fSzIt != _fnc2sz.end())\n\t{\n\t\tif (fAddr <= addr && addr < (fAddr+fSzIt->second))\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\\t\" << \"!CAN S: addr cond @ \" << addr << std::endl;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstd::set<Address> fncStarts;\n\tfncStarts.insert(fAddr);\n\tfncStarts.insert(addr);\n\n\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << fAddr << std::endl;\n\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << addr << std::endl;\n\n\tbool changed = true;\n\twhile (changed)\n\t{\n\t\tchanged = false;\n\t\tfor (BasicBlock& b : *f)\n\t\t{\n//\t\t\tAddress bAddr = getBasicBlockAddress(&b);\n\t\t\tAddress bAddr;\n\t\t\t// TODO: shitty\n\t\t\tBasicBlock* bPrev = &b;\n\t\t\twhile (bAddr.isUndefined() && bPrev)\n\t\t\t{\n\t\t\t\tbAddr = getBasicBlockAddress(bPrev);\n\t\t\t\tbPrev = bPrev->getPrevNode();\n\t\t\t}\n\t\t\tif (bAddr.isUndefined())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tauto up = fncStarts.upper_bound(bAddr);\n\t\t\t--up;\n\t\t\tAddress bFnc = *up;\n\n\t\t\tfor (auto* p : predecessors(&b))\n\t\t\t{\n//\t\t\t\tAddress pAddr = getBasicBlockAddress(p);\n\t\t\t\tAddress pAddr;\n\t\t\t\t// TODO: shitty\n\t\t\t\tBasicBlock* pPrev = p;\n\t\t\t\twhile (pAddr.isUndefined() && pPrev)\n\t\t\t\t{\n\t\t\t\t\tpAddr = getBasicBlockAddress(pPrev);\n\t\t\t\t\tpPrev = pPrev->getPrevNode();\n\t\t\t\t}\n\t\t\t\tif (pAddr.isUndefined())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tauto up = fncStarts.upper_bound(pAddr);\n\t\t\t\t--up;\n\t\t\t\tAddress pFnc = *up;\n\n\t\t\t\tif (bFnc != pFnc)\n\t\t\t\t{\n\t\t\t\t\tif (!canSplitFunctionOn(&b))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tchanged |= newFncStarts.insert(&b).second;\n\t\t\t\t\tchanged |= fncStarts.insert(bAddr).second;\n\n\t\t\t\t\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << bAddr << std::endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int rtnl_net_dumpid_one(int id, void *peer, void *data)\n{\n\tstruct rtnl_net_dump_cb *net_cb = (struct rtnl_net_dump_cb *)data;\n\tint ret;\n\n\tif (net_cb->idx < net_cb->s_idx)\n\t\tgoto cont;\n\n\tnet_cb->fillargs.nsid = id;\n\tif (net_cb->fillargs.add_ref)\n\t\tnet_cb->fillargs.ref_nsid = __peernet2id(net_cb->ref_net, peer);\n\tret = rtnl_net_fill(net_cb->skb, &net_cb->fillargs);\n\tif (ret < 0)\n\t\treturn ret;\n\ncont:\n\tnet_cb->idx++;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\ts_cmd->command += ec->cmd_offset;\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n\t/* Only copy data to userland if data was received. */\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n\t\tret = -EFAULT;\nexit:\n\tkfree(s_cmd);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void uhci_async_cancel_device(UHCIState *s, USBDevice *dev)\n\n{\n\n    UHCIAsync *curr, *n;\n\n\n\n    QTAILQ_FOREACH_SAFE(curr, &s->async_pending, next, n) {\n\n        if (curr->packet.owner == NULL ||\n\n            curr->packet.owner->dev != dev) {\n\n            continue;\n\n        }\n\n        uhci_async_unlink(s, curr);\n\n        uhci_async_cancel(s, curr);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "parse_SET_MPLS_TC(char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_mpls_tc *mpls_tc = ofpact_put_SET_MPLS_TC(ofpacts);\n\n    if (*arg == '\\0') {\n        return xstrdup(\"set_mpls_tc: expected tc.\");\n    }\n\n    mpls_tc->tc = atoi(arg);\n    return NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void tiff_unmapproc(thandle_t h, tdata_t d, toff_t o)\n{\n\t(void)h;\n\t(void)d;\n\t(void)o;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int pollfds_fill(GArray *pollfds, fd_set *rfds, fd_set *wfds,\n\n                        fd_set *xfds)\n\n{\n\n    int nfds = -1;\n\n    int i;\n\n\n\n    for (i = 0; i < pollfds->len; i++) {\n\n        GPollFD *pfd = &g_array_index(pollfds, GPollFD, i);\n\n        int fd = pfd->fd;\n\n        int events = pfd->events;\n\n        if (events & (G_IO_IN | G_IO_HUP | G_IO_ERR)) {\n\n            FD_SET(fd, rfds);\n\n            nfds = MAX(nfds, fd);\n\n        }\n\n        if (events & (G_IO_OUT | G_IO_ERR)) {\n\n            FD_SET(fd, wfds);\n\n            nfds = MAX(nfds, fd);\n\n        }\n\n        if (events & G_IO_PRI) {\n\n            FD_SET(fd, xfds);\n\n            nfds = MAX(nfds, fd);\n\n        }\n\n    }\n\n    return nfds;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "rdpsnddbg_process(STREAM s)\n{\n\tunsigned int pkglen;\n \tstatic char *rest = NULL;\n \tchar *buf;\n \n \tpkglen = s->end - s->p;\n \t/* str_handle_lines requires null terminated strings */\n \tbuf = (char *) xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\n\tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);\n\n\txfree(buf);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "Check if the IMAP stream is still active */\nPHP_FUNCTION(imap_ping)\n{\n\tzval *streamind;\n\tpils *imap_le_struct;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &streamind) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(mail_ping(imap_le_struct->imap_stream));",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int snd_msndmidi_input_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_msndmidi *mpu;\n\n\tmpu = substream->rmidi->private_data;\n\tsnd_msnd_send_dsp_cmd(mpu->dev, HDEX_MIDI_IN_STOP);\n\tclear_bit(MSNDMIDI_MODE_BIT_INPUT, &mpu->mode);\n\tmpu->substream_input = NULL;\n\tsnd_msnd_disable_irq(mpu->dev);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "cluster_finish (void)\n{\n  hash_free (cluster_hash);\n  cluster_hash = NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void gen_check_cpenable(DisasContext *dc, unsigned cp)\n\n{\n\n    if (option_enabled(dc, XTENSA_OPTION_COPROCESSOR) &&\n\n            !(dc->cpenable & (1 << cp))) {\n\n        gen_exception_cause(dc, COPROCESSOR0_DISABLED + cp);\n\n        dc->is_jmp = DISAS_UPDATE;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "IW_IMPL(int) iw_get_input_density(struct iw_context *ctx,\n   double *px, double *py, int *pcode)\n {\n \t*px = 1.0;\n \t*py = 1.0;\n\t*pcode = ctx->img1.density_code;\n\tif(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) {\n\t\t*px = ctx->img1.density_x;\n\t\t*py = ctx->img1.density_y;\n\t\treturn 1;\n \t}\n\treturn 0;\n }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tint error = 0;\n\n\tlock_sock(sk);\n\n\topt->src_addr = sp->sa_addr.pptp;\n\tif (add_chan(po))\n\t\terror = -EBUSY;\n\n\trelease_sock(sk);\n\treturn error;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void MonClient::_start_hunting()\n{\n  ceph_assert(!_hunting());\n  // adjust timeouts if necessary\n  if (!had_a_connection)\n    return;\n  reopen_interval_multiplier *= cct->_conf->mon_client_hunt_interval_backoff;\n  if (reopen_interval_multiplier >\n      cct->_conf->mon_client_hunt_interval_max_multiple) {\n    reopen_interval_multiplier =\n      cct->_conf->mon_client_hunt_interval_max_multiple;\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int send_dhcpv6_confirm(GDHCPClient *dhcp_client)\n{\n\treturn send_dhcpv6_msg(dhcp_client, DHCPV6_CONFIRM, \"confirm\");\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void ahci_uninit(AHCIState *s)\n\n{\n\n    int i, j;\n\n\n\n    for (i = 0; i < s->ports; i++) {\n\n        AHCIDevice *ad = &s->dev[i];\n\n\n\n        for (j = 0; j < 2; j++) {\n\n            IDEState *s = &ad->port.ifs[j];\n\n\n\n            ide_exit(s);\n\n        }\n\n\n    }\n\n\n\n    g_free(s->dev);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "StringValueBase::~StringValueBase()\n    {\n    }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "TIFFjpeg_finish_decompress(JPEGState* sp)\n{\n\treturn CALLJPEG(sp, -1, (int) jpeg_finish_decompress(&sp->cinfo.d));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void rtas_write_pci_config(sPAPREnvironment *spapr,\n\n                                  uint32_t token, uint32_t nargs,\n\n                                  target_ulong args,\n\n                                  uint32_t nret, target_ulong rets)\n\n{\n\n    uint32_t val, size, addr;\n\n    PCIDevice *dev = find_dev(spapr, 0, rtas_ld(args, 0));\n\n\n\n    if (!dev) {\n\n        rtas_st(rets, 0, -1);\n\n        return;\n\n    }\n\n    val = rtas_ld(args, 2);\n\n    size = rtas_ld(args, 1);\n\n    addr = rtas_pci_cfgaddr(rtas_ld(args, 0));\n\n    pci_default_write_config(dev, addr, val, size);\n\n    rtas_st(rets, 0, 0);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void nic_reset(void *opaque)\n\n{\n\n    EEPRO100State *s = opaque;\n\n    TRACE(OTHER, logout(\"%p\\n\", s));\n\n    /* TODO: Clearing of multicast table for selective reset, too? */\n\n    memset(&s->mult[0], 0, sizeof(s->mult));\n\n    nic_selective_reset(s);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "xmlRegNewRange(xmlRegParserCtxtPtr ctxt,\n\t       int neg, xmlRegAtomType type, int start, int end) {\n    xmlRegRangePtr ret;\n\n    ret = (xmlRegRangePtr) xmlMalloc(sizeof(xmlRegRange));\n    if (ret == NULL) {\n\txmlRegexpErrMemory(ctxt, \"allocating range\");\n\treturn(NULL);\n    }\n    ret->neg = neg;\n    ret->type = type;\n    ret->start = start;\n    ret->end = end;\n    return(ret);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "std::string GetRegistryControlledDomain(const GURL& signon_realm) {\n  return net::registry_controlled_domains::GetDomainAndRegistry(\n      signon_realm,\n      net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "//! Construct list as a copy of an existing list and force shared state of elements \\inplace \\specialization.\n    CImgList<T>& assign(const CImgList<T>& list, const bool is_shared=false) {\n      if (this==&list) return *this;\n      CImgList<T> res(list._width);\n      cimglist_for(res,l) res[l].assign(list[l],is_shared);\n      return res.move_to(*this);",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "_bluetooth_client_set_discoverable (BluetoothClient *client,\n\t\t\t\t    gboolean discoverable,\n\t\t\t\t    guint timeout)\n{\n\tBluetoothClientPrivate *priv = BLUETOOTH_CLIENT_GET_PRIVATE (client);\n\tGtkTreePath *path;\n\tGObject *adapter;\n\tGtkTreeIter iter;\n\n\tg_return_val_if_fail (BLUETOOTH_IS_CLIENT (client), FALSE);\n\n\tif (priv->default_adapter == NULL)\n\t\treturn FALSE;\n\n\tpath = gtk_tree_row_reference_get_path (priv->default_adapter);\n\tgtk_tree_model_get_iter (GTK_TREE_MODEL (priv->store), &iter, path);\n\tgtk_tree_model_get (GTK_TREE_MODEL (priv->store), &iter,\n                            BLUETOOTH_COLUMN_PROXY, &adapter, -1);\n        gtk_tree_path_free (path);\n\n\tif (adapter == NULL)\n\t\treturn FALSE;\n\n\tg_object_set (adapter,\n\t\t      \"discoverable\", discoverable,\n\t\t      \"discoverable-timeout\", timeout,\n\t\t      NULL);\n\tg_object_unref (adapter);\n\n\treturn TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void* IOBuf::operator new(size_t size) {\n  size_t fullSize = offsetof(HeapStorage, buf) + size;\n  auto storage = static_cast<HeapStorage*>(checkedMalloc(fullSize));\n\n  new (&storage->prefix) HeapPrefix(kIOBufInUse, fullSize);\n\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, fullSize);\n  }\n\n  return &(storage->buf);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "Ins_MIN( FT_Long*  args )\n  {\n    if ( args[1] < args[0] )\n      args[0] = args[1];\n  }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                errors::InvalidArgument(\"key must not be empty\"));\n\n    // Create copy for insertion into Staging Area\n    Tensor key(*key_tensor);\n\n    // Create the tuple to store\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n\n    // Store the tuple in the map\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int init_sig_algs(SSL *s, unsigned int context)\n{\n    /* Clear any signature algorithms extension received */\n    OPENSSL_free(s->s3->tmp.peer_sigalgs);\n    s->s3->tmp.peer_sigalgs = NULL;\n\n    return 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "xsltFreeCompMatchList(xsltCompMatchPtr comp) {\n    xsltCompMatchPtr cur;\n\n    while (comp != NULL) {\n\tcur = comp;\n\tcomp = comp->next;\n\txsltFreeCompMatch(cur);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline void put_free_pages(struct xen_blkif_ring *ring, struct page **page,\n                                  int num)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&ring->free_pages_lock, flags);\n\tfor (i = 0; i < num; i++)\n\t\tlist_add(&page[i]->lru, &ring->free_pages);\n\tring->free_pages_num += num;\n\tspin_unlock_irqrestore(&ring->free_pages_lock, flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "bool migrate_rdma_pin_all(void)\n\n{\n\n    MigrationState *s;\n\n\n\n    s = migrate_get_current();\n\n\n\n    return s->enabled_capabilities[MIGRATION_CAPABILITY_RDMA_PIN_ALL];\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\treturn do_inotify_init(flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void pop_string(stroke_msg_t *msg, char **string)\n{\n\tif (*string == NULL)\n\t{\n\t\treturn;\n\t}\n\n\t/* check for sanity of string pointer and string */\n\tif (string < (char**)msg ||\n\t\tstring > (char**)((char*)msg + sizeof(stroke_msg_t)) ||\n\t\t(unsigned long)*string < (unsigned long)((char*)msg->buffer - (char*)msg) ||\n\t\t(unsigned long)*string > msg->length)\n\t{\n\t\t*string = \"(invalid pointer in stroke msg)\";\n\t}\n\telse\n\t{\n\t\t*string = (char*)msg + (unsigned long)*string;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int jpc_firstone(int x)\n{\n\tint n;\n\n\t/* The argument must be nonnegative. */\n\tassert(x >= 0);\n\n\tn = -1;\n\twhile (x > 0) {\n\t\tx >>= 1;\n\t\t++n;\n\t}\n\treturn n;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int css_do_rsch(SubchDev *sch)\n\n{\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    int ret;\n\n\n\n    if (~(p->flags) & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA)) {\n\n        ret = -ENODEV;\n\n        goto out;\n\n    }\n\n\n\n    if (s->ctrl & SCSW_STCTL_STATUS_PEND) {\n\n        ret = -EINPROGRESS;\n\n        goto out;\n\n    }\n\n\n\n    if (((s->ctrl & SCSW_CTRL_MASK_FCTL) != SCSW_FCTL_START_FUNC) ||\n\n        (s->ctrl & SCSW_ACTL_RESUME_PEND) ||\n\n        (!(s->ctrl & SCSW_ACTL_SUSP))) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    /* If monitoring is active, update counter. */\n\n    if (channel_subsys.chnmon_active) {\n\n        css_update_chnmon(sch);\n\n    }\n\n\n\n    s->ctrl |= SCSW_ACTL_RESUME_PEND;\n\n    do_subchannel_work(sch);\n\n    ret = 0;\n\n\n\nout:\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "size_t LibRaw::strnlen(const char *s, size_t n)\n{\n#if !defined(__FreeBSD__) && !defined(__OpenBSD__)\n  const char *p = (const char *)memchr(s, 0, n);\n  return (p ? p - s : n);\n#else\n  return ::strnlen(s, n);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline void rtmsg_iwinfo(struct net_device *\tdev,\n\t\t\t\tchar *\t\t\tevent,\n\t\t\t\tint\t\t\tevent_len)\n{\n\tstruct sk_buff *skb;\n\tint size = NLMSG_GOODSIZE;\n\n\tskb = alloc_skb(size, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tif (rtnetlink_fill_iwinfo(skb, dev, RTM_NEWLINK,\n\t\t\t\t  event, event_len) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tNETLINK_CB(skb).dst_groups = RTMGRP_LINK;\n\tnetlink_broadcast(rtnl, skb, 0, RTMGRP_LINK, GFP_ATOMIC);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static bool startsMultiLineCommentAt(const String& string, size_t start)\n{\n    return (start + 1 < string.length() && string[start] == '/' && string[start+1] == '*');\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static long snd_disconnect_ioctl(struct file *file,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\treturn -ENODEV;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void sony_remove_dev_list(struct sony_sc *sc)\n{\n\tunsigned long flags;\n\n\tif (sc->list_node.next) {\n\t\tspin_lock_irqsave(&sony_dev_list_lock, flags);\n\t\tlist_del(&(sc->list_node));\n\t\tspin_unlock_irqrestore(&sony_dev_list_lock, flags);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "spa_base64_to_bits (char *out, int outlength, const char *in)\n/* base 64 to raw bytes in quasi-big-endian order, returning count of bytes */\n{\n  int len = 0;\n  register uschar digit1, digit2, digit3, digit4;\n\n  if (in[0] == '+' && in[1] == ' ')\n    in += 2;\n  if (*in == '\\r')\n    return (0);\n\n  do\n    {\n      if (len >= outlength)                   /* Added by PH */\n        return (-1);                          /* Added by PH */\n      digit1 = in[0];\n      if (DECODE64 (digit1) == BAD)\n       return (-1);\n      digit2 = in[1];\n      if (DECODE64 (digit2) == BAD)\n       return (-1);\n      digit3 = in[2];\n      if (digit3 != '=' && DECODE64 (digit3) == BAD)\n       return (-1);\n      digit4 = in[3];\n      if (digit4 != '=' && DECODE64 (digit4) == BAD)\n       return (-1);\n      in += 4;\n      *out++ = (DECODE64 (digit1) << 2) | (DECODE64 (digit2) >> 4);\n      ++len;\n      if (digit3 != '=')\n       {\n         if (len >= outlength)                   /* Added by PH */\n           return (-1);                          /* Added by PH */\n         *out++ =\n           ((DECODE64 (digit2) << 4) & 0xf0) | (DECODE64 (digit3) >> 2);\n         ++len;\n         if (digit4 != '=')\n           {\n             if (len >= outlength)                   /* Added by PH */\n               return (-1);                          /* Added by PH */\n             *out++ = ((DECODE64 (digit3) << 6) & 0xc0) | DECODE64 (digit4);\n             ++len;\n           }\n       }\n    }\n  while (*in && *in != '\\r' && digit4 != '=');\n\n  return (len);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int qemu_reset_requested_get(void)\n\n{\n\n    return reset_requested;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "i915_gem_userptr_dmabuf_export(struct drm_i915_gem_object *obj)\n{\n\tif (obj->userptr.mmu_object)\n\t\treturn 0;\n\n\treturn i915_gem_userptr_init__mmu_notifier(obj, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "gss_unwrap_aead (minor_status,\n                 context_handle,\n\t\t input_message_buffer,\n\t\t input_assoc_buffer,\n\t\t output_payload_buffer,\n                 conf_state,\n                 qop_state)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\toutput_payload_buffer;\nint \t\t\t*conf_state;\ngss_qop_t\t\t*qop_state;\n{\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_unwrap_aead_args(minor_status, context_handle,\n\t\t\t\t  input_message_buffer, input_assoc_buffer,\n\t\t\t\t  output_payload_buffer,\n\t\t\t\t  conf_state, qop_state);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n\n    return gssint_unwrap_aead(mech, minor_status, ctx,\n\t\t\t      input_message_buffer, input_assoc_buffer,\n\t\t\t      output_payload_buffer, conf_state, qop_state);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "cstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    // tolower() and toupper() can be slow, comparing twice should be a lot\n    // faster (esp. when using MS Visual C++!).\n    // For UTF-8 need to use folded case.\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tif (utf_fold(utf_ptr2char(p)) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\t// Faster version for when there are no multi-byte characters.\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "T& _atNXYZ(const int pos, const int x, const int y, const int z, const int c=0) {\n      return _data[cimg::cut(pos,0,width() - 1)].atXYZ(x,y,z,c);",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void qeth_clear_thread_running_bit(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tcard->thread_running_mask &= ~thread;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\twake_up(&card->wait_q);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int chip_write(struct CHIPSTATE *chip, int subaddr, int val)\n{\n\tunsigned char buffer[2];\n\n\tif (-1 == subaddr) {\n\t\tv4l_dbg(1, debug, chip->c, \"%s: chip_write: 0x%x\\n\",\n\t\t\tchip->c->name, val);\n\t\tchip->shadow.bytes[1] = val;\n\t\tbuffer[0] = val;\n\t\tif (1 != i2c_master_send(chip->c,buffer,1)) {\n\t\t\tv4l_warn(chip->c, \"%s: I/O error (write 0x%x)\\n\",\n\t\t\t\tchip->c->name, val);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tv4l_dbg(1, debug, chip->c, \"%s: chip_write: reg%d=0x%x\\n\",\n\t\t\tchip->c->name, subaddr, val);\n\t\tchip->shadow.bytes[subaddr+1] = val;\n\t\tbuffer[0] = subaddr;\n\t\tbuffer[1] = val;\n\t\tif (2 != i2c_master_send(chip->c,buffer,2)) {\n\t\t\tv4l_warn(chip->c, \"%s: I/O error (write reg%d=0x%x)\\n\",\n\t\t\tchip->c->name, subaddr, val);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "calc_duration(long long int start, long long int now,\n              uint32_t *sec, uint32_t *nsec)\n{\n    long long int msecs = now - start;\n    *sec = msecs / 1000;\n    *nsec = (msecs % 1000) * (1000 * 1000);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline int may_ptrace_stop(void)\n{\n\tif (!likely(current->ptrace))\n\t\treturn 0;\n\t/*\n\t * Are we in the middle of do_coredump?\n\t * If so and our tracer is also part of the coredump stopping\n\t * is a deadlock situation, and pointless because our tracer\n\t * is dead so don't allow us to stop.\n\t * If SIGKILL was already sent before the caller unlocked\n\t * ->siglock we must see ->core_state != NULL. Otherwise it\n\t * is safe to enter schedule().\n\t */\n\tif (unlikely(current->mm->core_state) &&\n\t    unlikely(current->mm == current->parent->mm))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void intel_iommu_domain_free(struct iommu_domain *domain)\n{\n\tdomain_exit(to_dmar_domain(domain));\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void BrowserCommandController::UpdateCommandsForMediaRouter() {\n  if (is_locked_fullscreen_)\n    return;\n\n  command_updater_.UpdateCommandEnabled(IDC_ROUTE_MEDIA,\n                                        CanRouteMedia(browser_));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int megasas_ctrl_shutdown(MegasasState *s, MegasasCmd *cmd)\n{\n    s->fw_state = MFI_FWSTATE_READY;\n    return MFI_STAT_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void XMLTokenizer::cdataBlock(const xmlChar* s, int len)\n{\n    if (m_parserStopped)\n        return;\n\n    if (m_parserPaused) {\n        m_pendingCallbacks->appendCDATABlockCallback(s, len);\n        return;\n    }\n    \n    exitText();\n\n    RefPtr<Node> newNode = new CDATASection(m_doc, toString(s, len));\n    if (!m_currentNode->addChild(newNode.get()))\n        return;\n    if (m_view && !newNode->attached())\n        newNode->attach();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int exprProbability(Expr *p){\n  double r = -1.0;\n  if( p->op!=TK_FLOAT ) return -1;\n  sqlite3AtoF(p->u.zToken, &r, sqlite3Strlen30(p->u.zToken), SQLITE_UTF8);\n  assert( r>=0.0 );\n  if( r>1.0 ) return -1;\n  return (int)(r*134217728.0);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void nl80211_finish_netdev_dump(struct cfg80211_registered_device *rdev)\n{\n\tcfg80211_unlock_rdev(rdev);\n\trtnl_unlock();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void Clipboard::ReadData(const std::string& format, std::string* result) {\n  GtkSelectionData* data =\n      gtk_clipboard_wait_for_contents(clipboard_, StringToGdkAtom(format));\n  if (!data)\n    return;\n  result->assign(reinterpret_cast<char*>(data->data), data->length);\n  gtk_selection_data_free(data);\n }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "struct resource_pool *dce100_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void ring_buffer_reset_online_cpus(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\tfor_each_online_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\n\t\tatomic_inc(&cpu_buffer->resize_disabled);\n\t\tatomic_inc(&cpu_buffer->record_disabled);\n\t}\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tfor_each_online_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\n\t\treset_disabled_cpu_buffer(cpu_buffer);\n\n\t\tatomic_dec(&cpu_buffer->record_disabled);\n\t\tatomic_dec(&cpu_buffer->resize_disabled);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "RE_NODE* yr_re_node_create(\n    int type,\n    RE_NODE* left,\n    RE_NODE* right)\n{\n  RE_NODE* result = (RE_NODE*) yr_malloc(sizeof(RE_NODE));\n\n  if (result != NULL)\n  {\n    result->type = type;\n    result->left = left;\n    result->right = right;\n    result->greedy = TRUE;\n    result->forward_code = NULL;\n    result->backward_code = NULL;\n  }\n\n  return result;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "warning(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool Instance::IsOverlayScrollbar() {\n  return GetScrollbarReservedThickness() == 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "nfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    struct nfs_getaclres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(xdr, rqstp, &res->acl_len);\n\nout:\n\treturn status;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void kthread_flush_work_fn(struct kthread_work *work)\n{\n\tstruct kthread_flush_work *fwork =\n\t\tcontainer_of(work, struct kthread_flush_work, work);\n\tcomplete(&fwork->done);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int preg_get_backref(char **str, int *backref)\n{\n\tregister char in_brace = 0;\n\tregister char *walk = *str;\n\n\tif (walk[1] == 0)\n\t\treturn 0;\n\n\tif (*walk == '$' && walk[1] == '{') {\n\t\tin_brace = 1;\n\t\twalk++;\n\t}\n\twalk++;\n\n\tif (*walk >= '0' && *walk <= '9') {\n\t\t*backref = *walk - '0';\n\t\twalk++;\n\t} else\n\t\treturn 0;\n\t\n\tif (*walk && *walk >= '0' && *walk <= '9') {\n\t\t*backref = *backref * 10 + *walk - '0';\n\t\twalk++;\n\t}\n\n\tif (in_brace) {\n\t\tif (*walk == 0 || *walk != '}')\n\t\t\treturn 0;\n\t\telse\n\t\t\twalk++;\n\t}\n\t\n\t*str = walk;\n\treturn 1;\t\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline int kvm_lapic_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int cmpname (const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\treturn (int)strcmp (a->name, b->name);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline uint8_t mirror8bit(uint8_t byte)\n{\n    return (byte * 0x0202020202ULL & 0x010884422010ULL) % 1023;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n    switch (ri->accessfn(env, ri)) {\n\n    case CP_ACCESS_OK:\n\n        return;\n\n    case CP_ACCESS_TRAP:\n\n    case CP_ACCESS_TRAP_UNCATEGORIZED:\n\n        /* These cases will eventually need to generate different\n\n         * syndrome information.\n\n         */\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n    raise_exception(env, EXCP_UDEF);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline unsigned long __bitmap_size(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\n\t/* return NAT or SIT bitmap */\n\tif (flag == NAT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);\n\telse if (flag == SIT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "INST_HANDLER (eijmp) {\t// EIJMP\n\tut64 z, eind;\n\tr_anal_esil_reg_read (anal->esil, \"z\",    &z,    NULL);\n\tr_anal_esil_reg_read (anal->esil, \"eind\", &eind, NULL);\n\top->jump = ((eind << 16) + z) << 1;\n\tESIL_A (\"1,z,16,eind,<<,+,<<,pc,=,\");\n\top->cycles = 2;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void mark_screen_rdonly(struct mm_struct *mm)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tint i;\n\n\tpgd = pgd_offset(mm, 0xA0000);\n\tif (pgd_none_or_clear_bad(pgd))\n\t\tgoto out;\n\tpud = pud_offset(pgd, 0xA0000);\n\tif (pud_none_or_clear_bad(pud))\n\t\tgoto out;\n\tpmd = pmd_offset(pud, 0xA0000);\n\tsplit_huge_page_pmd(mm, pmd);\n\tif (pmd_none_or_clear_bad(pmd))\n\t\tgoto out;\n\tpte = pte_offset_map_lock(mm, pmd, 0xA0000, &ptl);\n\tfor (i = 0; i < 32; i++) {\n\t\tif (pte_present(*pte))\n\t\t\tset_pte(pte, pte_wrprotect(*pte));\n\t\tpte++;\n\t}\n\tpte_unmap_unlock(pte, ptl);\nout:\n\tflush_tlb();\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "long do_arch_prctl_common(struct task_struct *task, int option,\n\t\t\t  unsigned long cpuid_enabled)\n{\n\tswitch (option) {\n\tcase ARCH_GET_CPUID:\n\t\treturn get_cpuid_mode();\n\tcase ARCH_SET_CPUID:\n\t\treturn set_cpuid_mode(task, cpuid_enabled);\n\t}\n\n\treturn -EINVAL;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "png_set_read_user_chunk_fn(png_structp png_ptr, png_voidp user_chunk_ptr,\n   png_user_chunk_ptr read_user_chunk_fn)\n{\n   png_debug(1, \"in png_set_read_user_chunk_fn\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->read_user_chunk_fn = read_user_chunk_fn;\n   png_ptr->user_chunk_ptr = user_chunk_ptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "R_API char *r_bin_java_resolve_cp_idx_type(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaCPTypeObj *item = NULL;\n\tchar *str = NULL;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\t// r_bin_java_new_bin(BIN_OBJ);\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\tstr = strdup (((RBinJavaCPTypeMetas *) item->metas->type_info)->name);\n\t} else {\n\t\tstr = strdup (\"INVALID\");\n\t}\n\treturn str;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "uint64_t FrameIndexForView(RenderWidgetHostViewAura* view) {\n  return ImageTransportFactory::GetInstance()\n      ->GetContextFactoryPrivate()\n      ->GetFrameSinkManager()\n      ->surface_manager()\n      ->GetSurfaceForId(view->GetCurrentSurfaceId())\n      ->GetActiveFrameIndex();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void calc_sums(int pmin, int pmax, uint32_t *data, int n, int pred_order,\n\n                      uint32_t sums[][MAX_PARTITIONS])\n\n{\n\n    int i, j;\n\n    int parts;\n\n    uint32_t *res, *res_end;\n\n\n\n    /* sums for highest level */\n\n    parts   = (1 << pmax);\n\n    res     = &data[pred_order];\n\n    res_end = &data[n >> pmax];\n\n    for (i = 0; i < parts; i++) {\n\n        uint32_t sum = 0;\n\n        while (res < res_end)\n\n            sum += *(res++);\n\n        sums[pmax][i] = sum;\n\n        res_end += n >> pmax;\n\n    }\n\n    /* sums for lower levels */\n\n    for (i = pmax - 1; i >= pmin; i--) {\n\n        parts = (1 << i);\n\n        for (j = 0; j < parts; j++)\n\n            sums[i][j] = sums[i+1][2*j] + sums[i+1][2*j+1];\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "GF_Err rely_dump(GF_Box *a, FILE * trace)\n{\n\tGF_RelyHintBox *p;\n\tp = (GF_RelyHintBox *)a;\n\tgf_isom_box_dump_start(a, \"RelyTransmissionBox\", trace);\n\tfprintf(trace, \"Prefered=\\\"%d\\\" required=\\\"%d\\\">\\n\", p->prefered, p->required);\n\tgf_isom_box_dump_done(\"RelyTransmissionBox\", a, trace);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "MagickExport MagickBooleanType PasskeyDecipherImage(Image *image,\n  const StringInfo *passkey,ExceptionInfo *exception)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  (void) passkey;\n  ThrowBinaryException(ImageError,\"CipherSupportNotEnabled\",image->filename);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n \t\treturn;\n \n \ttimer = &pit->pit_state.timer;\n \tif (hrtimer_cancel(timer))\n \t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n }",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\t    struct msghdr *msg, size_t len, int noblock,\n\t\t\t    int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n \t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n \t\tlsa->l2tp_flowinfo = 0;\n \t\tlsa->l2tp_scope_id = 0;\n \t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n \t\t\tlsa->l2tp_scope_id = IP6CB(skb)->iif;\n \t}\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void bdrv_set_dirty_tracking(BlockDriverState *bs, int enable)\n\n{\n\n    int64_t bitmap_size;\n\n\n\n    if (enable) {\n\n        if (bs->dirty_tracking == 0) {\n\n            int64_t i;\n\n            uint8_t test;\n\n\n\n            bitmap_size = (bdrv_getlength(bs) >> BDRV_SECTOR_BITS);\n\n            bitmap_size /= BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n            bitmap_size++;\n\n\n\n            bs->dirty_bitmap = qemu_mallocz(bitmap_size);\n\n\n\n            bs->dirty_tracking = enable;\n\n            for(i = 0; i < bitmap_size; i++) test = bs->dirty_bitmap[i]; \n\n        }\n\n    } else {\n\n        if (bs->dirty_tracking != 0) {\n\n            qemu_free(bs->dirty_bitmap);\n\n            bs->dirty_tracking = enable;\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "PHP_METHOD(snmp, setSecurity)\n{\n\tphp_snmp_object *snmp_object;\n\tzval *object = getThis();\n\tchar *a1 = \"\", *a2 = \"\", *a3 = \"\", *a4 = \"\", *a5 = \"\", *a6 = \"\", *a7 = \"\";\n\tint a1_len = 0, a2_len = 0, a3_len = 0, a4_len = 0, a5_len = 0, a6_len = 0, a7_len = 0;\n\tint argc = ZEND_NUM_ARGS();\n\n\tsnmp_object = (php_snmp_object *)zend_object_store_get_object(object TSRMLS_CC);\n\t\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"s|ssssss\", &a1, &a1_len, &a2, &a2_len, &a3, &a3_len,\n\t\t&a4, &a4_len, &a5, &a5_len, &a6, &a6_len, &a7, &a7_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (netsnmp_session_set_security(snmp_object->session, a1, a2, a3, a4, a5, a6, a7 TSRMLS_CC)) {\n\t\t/* Warning message sent already, just bail out */\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void usbredir_log_data(USBRedirDevice *dev, const char *desc,\n\n    const uint8_t *data, int len)\n\n{\n\n    int i, j, n;\n\n\n\n    if (dev->debug < usbredirparser_debug_data) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < len; i += j) {\n\n        char buf[128];\n\n\n\n        n = sprintf(buf, \"%s\", desc);\n\n        for (j = 0; j < 8 && i + j < len; j++) {\n\n            n += sprintf(buf + n, \" %02X\", data[i + j]);\n\n        }\n\n        error_report(\"%s\", buf);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void Document::AdjustFloatQuadsForScrollAndAbsoluteZoom(\n    Vector<FloatQuad>& quads,\n    const LayoutObject& layout_object) const {\n  if (!View())\n    return;\n\n  LayoutRect visible_content_rect(View()->VisibleContentRect());\n  for (size_t i = 0; i < quads.size(); ++i) {\n    quads[i].Move(-FloatSize(visible_content_rect.X().ToFloat(),\n                             visible_content_rect.Y().ToFloat()));\n    AdjustFloatQuadForAbsoluteZoom(quads[i], layout_object);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "ref_stack_release(ref_stack_t *pstack)\n{\n    gs_ref_memory_t *mem = pstack->memory;\n\n    ref_stack_clear(pstack);\n    /* Free the parameter structure. */\n    gs_free_object((gs_memory_t *)mem, pstack->params,\n                   \"ref_stack_release(stack.params)\");\n    /* Free the original (bottom) block. */\n    gs_free_ref_array(mem, &pstack->current, \"ref_stack_release\");\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "const std::string& BluetoothSocketListenUsingL2capFunction::uuid() const {\n  return params_->uuid;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "pam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\n\n/* It seems that PAM frees reply[] */\n\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\n\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = CS string_copy_malloc(arg); /* PAM frees resp */\n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n\n    case PAM_TEXT_INFO:    /* Just acknowledge messages */\n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n\n    default:  /* Must be an error of some sort... */\n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n\n*resp = reply;\nreturn PAM_SUCCESS;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "inline double rand(const double val_min, const double val_max) {\n      const double val = cimg::_rand()/16777215.;\n      return val_min + (val_max - val_min)*val;",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void FrameLoader::didAccessInitialDocument()\n{\n    if (isLoadingMainFrame() && !m_didAccessInitialDocument) {\n        m_didAccessInitialDocument = true;\n        m_didAccessInitialDocumentTimer.startOneShot(0);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int Photoshop::locateIptcIrb(const byte*     pPsData,\n                                 size_t sizePsData,\n                                 const byte**    record,\n                                 uint32_t *const sizeHdr,\n                                 uint32_t *const sizeData)\n    {\n        return locateIrb(pPsData, sizePsData, iptc_, record, sizeHdr, sizeData);\n    }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int ip_rt_bug(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tpr_debug(\"%s: %pI4 -> %pI4, %s\\n\",\n\t\t __func__, &ip_hdr(skb)->saddr, &ip_hdr(skb)->daddr,\n\t\t skb->dev ? skb->dev->name : \"?\");\n\tkfree_skb(skb);\n\tWARN_ON(1);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "pci_lintr_release(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint pin;\n\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\n\tsi = &bi->slotinfo[dev->slot];\n\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tsi->si_intpins[pin].ii_count = 0;\n\t\tsi->si_intpins[pin].ii_pirq_pin = 0;\n\t\tsi->si_intpins[pin].ii_ioapic_irq = 0;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n{\n  register Image\n    *curr,\n    *next;\n\n  RectangleInfo\n    bounds;\n\n  assert((*images) != (const Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n  {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n      continue;\n    bounds=CompareImageBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      /*\n        the two images are the same, merge time delays and delete one.\n      */\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n  }\n  *images = GetFirstImageInList(*images);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void _imap_quote_string (char *dest, size_t dlen, const char *src,\n                                const char *to_quote)\n{\n  char *pt;\n  const char *s;\n\n  pt = dest;\n  s  = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr (to_quote, *s))\n    {\n      dlen -= 2;\n      if (!dlen)\n\tbreak;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "Strtruncate(Str s, int pos)\n{\n    STR_LENGTH_CHECK(s);\n    s->ptr[pos] = '\\0';\n    s->length = pos;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "GF_Err pmax_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tptr->maxSize = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int ttusb_dec_stop_ts_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct ttusb_dec *dec = dvbdmxfeed->demux->priv;\n\tu8 b0[] = { 0x00 };\n\n\tttusb_dec_send_command(dec, 0x81, sizeof(b0), b0, NULL, NULL);\n\n\tdec->pva_stream_count--;\n\n\tttusb_dec_stop_iso_xfer(dec);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tASSERT(is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "e_timeout_add_seconds_with_name (gint priority,\n                                 guint interval,\n                                 const gchar *name,\n                                 GSourceFunc function,\n                                 gpointer data,\n                                 GDestroyNotify notify)\n{\n\tguint tag;\n\n\tg_return_val_if_fail (function != NULL, 0);\n\n\ttag = g_timeout_add_seconds_full (\n\t\tpriority, interval, function, data, notify);\n\tg_source_set_name_by_id (tag, name);\n\n\treturn tag;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,\n\t\t\t       dma_addr_t dma)\n{\n\tint pg;\n\n\tif (ptr == NULL)\n\t\treturn;\n\tpg = get_order(size);\n\tdec_snd_pages(pg);\n\tdma_free_coherent(dev, PAGE_SIZE << pg, ptr, dma);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "ebt_cleanup_watcher(struct ebt_entry_watcher *w, struct net *net, unsigned int *i)\n{\n\tstruct xt_tgdtor_param par;\n\n\tif (i && (*i)-- == 0)\n\t\treturn 1;\n\n\tpar.net      = net;\n\tpar.target   = w->u.watcher;\n\tpar.targinfo = w->data;\n\tpar.family   = NFPROTO_BRIDGE;\n\tif (par.target->destroy != NULL)\n\t\tpar.target->destroy(&par);\n\tmodule_put(par.target->me);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int flac_probe(AVProbeData *p)\n\n{\n\n    uint8_t *bufptr = p->buf;\n\n    uint8_t *end    = p->buf + p->buf_size;\n\n\n\n    if(bufptr > end-4 || memcmp(bufptr, \"fLaC\", 4)) return 0;\n\n    else                                            return AVPROBE_SCORE_MAX/2;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "unsigned Utf8Decoder<kBufferSize>::WriteUtf16(uint16_t* data,\n                                              unsigned length) const {\n  DCHECK(length > 0);\n  if (length > utf16_length_) length = utf16_length_;\n  // memcpy everything in buffer.\n  unsigned buffer_length =\n      last_byte_of_buffer_unused_ ? kBufferSize - 1 : kBufferSize;\n  unsigned memcpy_length = length <= buffer_length ? length : buffer_length;\n  v8::internal::MemCopy(data, buffer_, memcpy_length * sizeof(uint16_t));\n  if (length <= buffer_length) return length;\n  DCHECK(unbuffered_start_ != NULL);\n  // Copy the rest the slow way.\n  WriteUtf16Slow(unbuffered_start_,\n                 data + buffer_length,\n                 length - buffer_length);\n  return length;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void rcu_free_pwq(struct rcu_head *rcu)\n{\n\tkmem_cache_free(pwq_cache,\n\t\t\tcontainer_of(rcu, struct pool_workqueue, rcu));\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void php_filter_url(PHP_INPUT_FILTER_PARAM_DECL)\n{\n\t/* Strip all chars not part of section 5 of\n\t * http://www.faqs.org/rfcs/rfc1738.html */\n\tconst unsigned char allowed_list[] = LOWALPHA HIALPHA DIGIT SAFE EXTRA NATIONAL PUNCTUATION RESERVED;\n\tfilter_map     map;\n\n\tfilter_map_init(&map);\n\tfilter_map_update(&map, 1, allowed_list);\n\tfilter_map_apply(value, &map);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void CE_WideToChar(unsigned short *w_str, char *str)\n{\n\tWideCharToMultiByte(CP_ACP, 0, w_str, -1, str, GF_MAX_PATH, NULL, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "PassRefPtr<HTMLFormElement> HTMLFormElement::create(const QualifiedName& tagName, Document& document)\n{\n    UseCounter::count(&document, UseCounter::FormElement);\n    return adoptRef(new HTMLFormElement(tagName, document));\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void doDie(int sig)\n{\n#\tdefine MSG1 \"DoDie called.\\n\"\n#\tdefine MSG2 \"DoDie called 5 times - unconditional exit\\n\"\n\tstatic int iRetries = 0; /* debug aid */\n\tif(Debug)\n\t\twrite(1, MSG1, sizeof(MSG1) - 1);\n\tif(iRetries++ == 4) {\n\t\tif(Debug)\n\t\t\twrite(1, MSG2, sizeof(MSG2) - 1);\n\t\tabort();\n\t}\n\tbFinished = sig;\n#\tundef MSG1\n#\tundef MSG2\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline int nla_nest_end(struct sk_buff *skb, struct nlattr *start)\n{\n\tstart->nla_len = skb_tail_pointer(skb) - (unsigned char *)start;\n\treturn skb->len;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void HTTPSession::onCertificateRequest(uint16_t requestId,\n                                       std::unique_ptr<IOBuf> authRequest) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE_REQUEST on\" << *this << \", requestId=\" << requestId;\n\n  std::pair<uint16_t, std::unique_ptr<folly::IOBuf>> authenticator;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      authenticator =\n          secondAuthManager_->getAuthenticator(*fizzBase,\n                                               TransportDirection::UPSTREAM,\n                                               requestId,\n                                               std::move(authRequest));\n    } else {\n      authenticator =\n          secondAuthManager_->getAuthenticator(*fizzBase,\n                                               TransportDirection::DOWNSTREAM,\n                                               requestId,\n                                               std::move(authRequest));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (codec_->generateCertificate(writeBuf_,\n                                  authenticator.first,\n                                  std::move(authenticator.second)) > 0) {\n    scheduleWrite();\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static const char *wsgi_set_group_authoritative(cmd_parms *cmd, void *mconfig,\n                                                const char *f)\n{\n    WSGIDirectoryConfig *dconfig = NULL;\n    dconfig = (WSGIDirectoryConfig *)mconfig;\n\n    if (strcasecmp(f, \"Off\") == 0)\n        dconfig->group_authoritative = 0;\n    else if (strcasecmp(f, \"On\") == 0)\n        dconfig->group_authoritative = 1;\n    else\n        return \"WSGIGroupAuthoritative must be one of: Off | On\";\n\n    return NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void lsi_request_cancelled(SCSIRequest *req)\n{\n    LSIState *s = LSI53C895A(req->bus->qbus.parent);\n    lsi_request *p = req->hba_private;\n\n    req->hba_private = NULL;\n    lsi_request_free(s, p);\n    scsi_req_unref(req);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "snd_seq_oss_synth_load_patch(struct seq_oss_devinfo *dp, int dev, int fmt,\n\t\t\t    const char __user *buf, int p, int c)\n{\n\tstruct seq_oss_synth *rec;\n\tint rc;\n\n\tif (dev < 0 || dev >= dp->max_synthdev)\n\t\treturn -ENXIO;\n\n\tif (is_midi_dev(dp, dev))\n\t\treturn 0;\n\tif ((rec = get_synthdev(dp, dev)) == NULL)\n\t\treturn -ENXIO;\n\n\tif (rec->oper.load_patch == NULL)\n\t\trc = -ENXIO;\n\telse\n\t\trc = rec->oper.load_patch(&dp->synths[dev].arg, fmt, buf, p, c);\n\tsnd_use_lock_free(&rec->use_lock);\n\treturn rc;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline void ept_sync_individual_addr(u64 eptp, gpa_t gpa)\n{\n\tif (vm_need_ept()) {\n\t\tif (cpu_has_vmx_invept_individual_addr())\n\t\t\t__invept(VMX_EPT_EXTENT_INDIVIDUAL_ADDR,\n\t\t\t\t\teptp, gpa);\n\t\telse\n\t\t\tept_sync_context(eptp);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void test_date_date()\n{\n  int        rc;\n\n  myheader(\"test_date_date\");\n\n  rc= mysql_query(mysql, \"DROP TABLE IF EXISTS test_date\");\n  myquery(rc);\n\n  rc= mysql_query(mysql, \"CREATE TABLE test_date(c1 DATE, \\\n                                                 c2 DATE, \\\n                                                 c3 DATE, \\\n                                                 c4 DATE)\");\n\n  myquery(rc);\n\n  test_bind_date_conv(3);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n\n{\n\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n\n    uint32_t val;\n\n\n\n    k->get_config(vdev, vdev->config);\n\n\n\n    if (addr > (vdev->config_len - sizeof(val)))\n\n        return (uint32_t)-1;\n\n\n\n    val = ldl_p(vdev->config + addr);\n\n    return val;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void InterstitialPage::InterstitialPageRVHViewDelegate::GotFocus() {\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void gf_isom_sample_entry_init(GF_SampleEntryBox *ent)\n{\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool AsyncReadPixelsCompletedQuery::Process() {\n  return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "MagickExport MagickBooleanType IsHistogramImage(const Image *image,\n  ExceptionInfo *exception)\n{\n#define MaximumUniqueColors  1024\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(CheckImageColors(image,exception,MaximumUniqueColors));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void RootWindowHostLinux::SetFocusWhenShown(bool focus_when_shown) {\n  static const char* k_NET_WM_USER_TIME = \"_NET_WM_USER_TIME\";\n  focus_when_shown_ = focus_when_shown;\n  if (IsWindowManagerPresent() && !focus_when_shown_) {\n    ui::SetIntProperty(xwindow_,\n                       k_NET_WM_USER_TIME,\n                       k_NET_WM_USER_TIME,\n                       0);\n   }\n }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      // Legacy behavior in V1.\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void decode_pitch_lag_low(int *lag_int, int *lag_frac, int pitch_index,\n\n                                 uint8_t *base_lag_int, int subframe, enum Mode mode)\n\n{\n\n    if (subframe == 0 || (subframe == 2 && mode != MODE_6k60)) {\n\n        if (pitch_index < 116) {\n\n            *lag_int  = (pitch_index + 69) >> 1;\n\n            *lag_frac = (pitch_index - (*lag_int << 1) + 68) << 1;\n\n        } else {\n\n            *lag_int  = pitch_index - 24;\n\n            *lag_frac = 0;\n\n        }\n\n        // XXX: same problem as before\n\n        *base_lag_int = av_clip(*lag_int - 8 - (*lag_frac < 0),\n\n                                AMRWB_P_DELAY_MIN, AMRWB_P_DELAY_MAX - 15);\n\n    } else {\n\n        *lag_int  = (pitch_index + 1) >> 1;\n\n        *lag_frac = (pitch_index - (*lag_int << 1)) << 1;\n\n        *lag_int += *base_lag_int;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "setnonblocking(int fd)\n{\n    int flags;\n    if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {\n        flags = 0;\n    }\n    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "  void allocHeaders() override {\n    ASSERT(nullptr == absl::get<RequestHeaderMapPtr>(headers_or_trailers_));\n    headers_or_trailers_.emplace<RequestHeaderMapPtr>(RequestHeaderMapImpl::create());\n  }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int send_signal(int sig, struct siginfo *info, struct task_struct *t,\n\t\t\tint group)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, group, from_ancestor_ns);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "SkBitmap BrowserNonClientFrameViewAura::GetFaviconForTabIconView() {\n  views::WidgetDelegate* delegate = frame()->widget_delegate();\n  if (!delegate)\n    return SkBitmap();\n  return delegate->GetWindowIcon();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "OperationID FileSystemOperationRunner::BeginOperation(\n     std::unique_ptr<FileSystemOperation> operation) {\n   OperationID id = next_operation_id_++;\n \n  operations_.emplace(id, std::move(operation));\n   return id;\n }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool ParamTraits<IPC::ChannelHandle>::Read(const Message* m,\n                                           PickleIterator* iter,\n                                           param_type* r) {\n  return ReadParam(m, iter, &r->name)\n#if defined(OS_POSIX)\n      && ReadParam(m, iter, &r->socket)\n#endif\n      ;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline signed int ReadPropertySignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) ((buffer[3] << 24) | (buffer[2] << 16) |\n        (buffer[1] << 8 ) | (buffer[0]));\n      quantum.unsigned_value=(value & 0xffffffff);\n      return(quantum.signed_value);\n    }\n  value=(unsigned int) ((buffer[0] << 24) | (buffer[1] << 16) |\n    (buffer[2] << 8) | buffer[3]);\n  quantum.unsigned_value=(value & 0xffffffff);\n  return(quantum.signed_value);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *tctx,\n                                     Flow *f,\n                                     uint8_t *buf, uint32_t buflen,\n                                     uint8_t ipproto, uint8_t direction)\n{\n    SCEnter();\n    SCLogDebug(\"buflen %u for %s direction\", buflen,\n             (direction & STREAM_TOSERVER) ? \"toserver\" : \"toclient\");\n \n     AppProto alproto = ALPROTO_UNKNOWN;\n \n     if (!FLOW_IS_PM_DONE(f, direction)) {\n         AppProto pm_results[ALPROTO_MAX];\n        uint16_t pm_matches = AppLayerProtoDetectPMGetProto(tctx, f,\n                                                   buf, buflen,\n                                                   direction,\n                                                   ipproto,\n                                                    pm_results);\n         if (pm_matches > 0) {\n             alproto = pm_results[0];\n            goto end;\n         }\n     }\n \n    if (!FLOW_IS_PP_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPPGetProto(f, buf, buflen,\n                                                ipproto, direction);\n        if (alproto != ALPROTO_UNKNOWN)\n            goto end;\n    }\n\n    /* Look if flow can be found in expectation list */\n    if (!FLOW_IS_PE_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPEGetProto(f, ipproto, direction);\n     }\n \n  end:\n     SCReturnUInt(alproto);\n }",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "dns_zone_getmctx(dns_zone_t *zone) {\n\tREQUIRE(DNS_ZONE_VALID(zone));\n\n\treturn (zone->mctx);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "  CdsIntegrationTest()\n      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),\n                            ConfigHelper::discoveredClustersBootstrap(\n                                sotwOrDelta() == Grpc::SotwOrDelta::Sotw ||\n                                        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n                                    ? \"GRPC\"\n                                    : \"DELTA_GRPC\")) {\n    if (sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw ||\n        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedDelta) {\n      config_helper_.addRuntimeOverride(\"envoy.reloadable_features.unified_mux\", \"true\");\n    }\n    use_lds_ = false;\n    sotw_or_delta_ = sotwOrDelta();\n  }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int vhdx_create_new_headers(BlockDriverState *bs, uint64_t image_size,\n\n                                   uint32_t log_size)\n\n{\n\n    int ret = 0;\n\n    VHDXHeader *hdr = NULL;\n\n\n\n    hdr = g_malloc0(sizeof(VHDXHeader));\n\n\n\n    hdr->signature       = VHDX_HEADER_SIGNATURE;\n\n    hdr->sequence_number = g_random_int();\n\n    hdr->log_version     = 0;\n\n    hdr->version         = 1;\n\n    hdr->log_length      = log_size;\n\n    hdr->log_offset      = VHDX_HEADER_SECTION_END;\n\n    vhdx_guid_generate(&hdr->file_write_guid);\n\n    vhdx_guid_generate(&hdr->data_write_guid);\n\n\n\n    ret = vhdx_write_header(bs, hdr, VHDX_HEADER1_OFFSET, false);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n    hdr->sequence_number++;\n\n    ret = vhdx_write_header(bs, hdr, VHDX_HEADER2_OFFSET, false);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\nexit:\n\n    g_free(hdr);\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void Magick::Image::strokePattern(const Image &strokePattern_)\n{\n  modifyImage();\n  if(strokePattern_.isValid())\n    options()->strokePattern(strokePattern_.constImage());\n  else\n    options()->strokePattern(static_cast<MagickCore::Image*>(NULL));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "pci_emul_add_msicap(struct pci_vdev *dev, int msgnum)\n{\n\tstruct msicap msicap;\n\n\tpci_populate_msicap(&msicap, msgnum, 0);\n\n\treturn pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "Jsi_Value* Jsi_ValueNew(Jsi_Interp *interp) {\n    return ValueNew(interp);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "    char* skipSpaces( char* ptr, int min_indent, int max_comment_indent )\n    {\n        for(;;)\n        {\n            while( *ptr == ' ' )\n                ptr++;\n            if( *ptr == '#' )\n            {\n                if( ptr - fs->bufferStart() > max_comment_indent )\n                    return ptr;\n                *ptr = '\\0';\n            }\n            else if( cv_isprint(*ptr) )\n            {\n                if( ptr - fs->bufferStart() < min_indent )\n                    CV_PARSE_ERROR_CPP( \"Incorrect indentation\" );\n                break;\n            }\n            else if( *ptr == '\\0' || *ptr == '\\n' || *ptr == '\\r' )\n            {\n                ptr = fs->gets();\n                if( !ptr )\n                {\n                    // emulate end of stream\n                    ptr = fs->bufferStart();\n                    ptr[0] = ptr[1] = ptr[2] = '.';\n                    ptr[3] = '\\0';\n                    fs->setEof();\n                    break;\n                }\n                else\n                {\n                    int l = (int)strlen(ptr);\n                    if( ptr[l-1] != '\\n' && ptr[l-1] != '\\r' && !fs->eof() )\n                        CV_PARSE_ERROR_CPP( \"Too long string or a last string w/o newline\" );\n                }\n            }\n            else\n                CV_PARSE_ERROR_CPP( *ptr == '\\t' ? \"Tabs are prohibited in YAML!\" : \"Invalid character\" );\n        }\n\n        return ptr;\n    }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void _xml_add_to_info(xml_parser *parser,char *name)\n{\n\tzval **element, *values;\n\n\tif (! parser->info) {\n\t\treturn;\n\t}\n\n\tif (zend_hash_find(Z_ARRVAL_P(parser->info),name,strlen(name) + 1,(void **) &element) == FAILURE) {\n\t\tMAKE_STD_ZVAL(values);\n\t\t\n\t\tarray_init(values);\n\t\t\n\t\tzend_hash_update(Z_ARRVAL_P(parser->info), name, strlen(name)+1, (void *) &values, sizeof(zval*), (void **) &element);\n\t} \n\t\t\t\n\tadd_next_index_long(*element,parser->curtag);\n\t\n\tparser->curtag++;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "exif_data_option_get_description (ExifDataOption o)\n{\n\tunsigned int i;\n\n\tfor (i = 0; exif_data_option[i].description; i++)\n\t\tif (exif_data_option[i].option == o) \n\t\t\tbreak;\n\treturn _(exif_data_option[i].description);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "TPMT_TK_VERIFIED_Unmarshal(TPMT_TK_VERIFIED *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n    \n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_ST_Unmarshal(&target->tag, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->tag != TPM_ST_VERIFIED) {\n\t    rc = TPM_RC_TAG;\n\t}\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPMI_RH_HIERARCHY_Unmarshal(&target->hierarchy, buffer, size, YES);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM2B_DIGEST_Unmarshal(&target->digest, buffer, size);\n    }\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void mp_update_termios(struct sb_uart_state *state)\n{\n\tstruct tty_struct *tty = state->info->tty;\n\tstruct sb_uart_port *port = state->port;\n\n\tif (!(tty->flags & (1 << TTY_IO_ERROR))) {\n\t\tmp_change_speed(state, NULL);\n\n\t\tif (tty->termios.c_cflag & CBAUD)\n\t\t\tuart_set_mctrl(port, TIOCM_DTR | TIOCM_RTS);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ext4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\terr = ext4_wait_block_bitmap(sb, block_group, bh);\n\tif (err) {\n\t\tput_bh(bh);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void FrameView::recalculateScrollbarOverlayStyle()\n{\n    ScrollbarOverlayStyle oldOverlayStyle = scrollbarOverlayStyle();\n    ScrollbarOverlayStyle overlayStyle = ScrollbarOverlayStyleDefault;\n\n    Color backgroundColor = documentBackgroundColor();\n    double hue, saturation, lightness;\n    backgroundColor.getHSL(hue, saturation, lightness);\n    if (lightness <= .5)\n        overlayStyle = ScrollbarOverlayStyleLight;\n\n    if (oldOverlayStyle != overlayStyle)\n        setScrollbarOverlayStyle(overlayStyle);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline void setup_usemap(struct pglist_data *pgdat, struct zone *zone,\n\t\t\t\tunsigned long zone_start_pfn, unsigned long zonesize) {}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void set_company_id(uint8_t cid[3], uint32_t cid_in)\n{\n\tcid[0] = (cid_in & 0xff0000) >> 16;\n\tcid[1] = (cid_in & 0x00ff00) >> 8;\n\tcid[2] = (cid_in & 0x0000ff);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "ACodec::ExecutingState::ExecutingState(ACodec *codec)\n : BaseState(codec),\n      mActive(false) {\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void SetOpAttrScalarDefault(\n    TFE_Context* ctx, TFE_Op* op, const tensorflow::AttrValue& default_value,\n    const char* attr_name,\n    tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,\n    TF_Status* status) {\n  SetOpAttrValueScalar(ctx, op, default_value, attr_name, status);\n  if (default_value.value_case() == tensorflow::AttrValue::kI) {\n    (*attr_list_sizes)[attr_name] = default_value.i();\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Number;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tuint_fast8_t tmp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &siz->caps) ||\n\t  jpc_getuint32(in, &siz->width) ||\n\t  jpc_getuint32(in, &siz->height) ||\n\t  jpc_getuint32(in, &siz->xoff) ||\n\t  jpc_getuint32(in, &siz->yoff) ||\n\t  jpc_getuint32(in, &siz->tilewidth) ||\n\t  jpc_getuint32(in, &siz->tileheight) ||\n\t  jpc_getuint32(in, &siz->tilexoff) ||\n\t  jpc_getuint32(in, &siz->tileyoff) ||\n\t  jpc_getuint16(in, &siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tif (!siz->width || !siz->height || !siz->tilewidth ||\n\t  !siz->tileheight || !siz->numcomps) {\n\t\treturn -1;\n\t}\n\tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_getuint8(in, &tmp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {\n \t\t\tjas_free(siz->comps);\n \t\t\treturn -1;\n \t\t}\n \t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;\n \t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;\n \t}\n\tif (jas_stream_eof(in)) {\n\t\tjas_free(siz->comps);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int mwifiex_pcie_probe_of(struct device *dev)\n{\n\tif (!of_match_node(mwifiex_pcie_of_match_table, dev->of_node)) {\n\t\tdev_err(dev, \"required compatible string missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_int n;\n  mrb_value val;\n\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  };\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int drm_mode_attachmode(struct drm_device *dev,\n\t\t\t       struct drm_connector *connector,\n\t\t\t       struct drm_display_mode *mode)\n{\n\tint ret = 0;\n\n\tlist_add_tail(&mode->head, &connector->user_modes);\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "ArgParser::argOiMinArea(char* parameter)\n{\n    o.oi_min_area = QUtil::string_to_int(parameter);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "CommentValue::CharsetId CommentValue::CharsetInfo::charsetIdByCode(\n        const std::string& code)\n    {\n        int i = 0;\n        for (;    charsetTable_[i].charsetId_ != lastCharsetId\n               && std::string(charsetTable_[i].code_, 8) != code; ++i) {}\n        return charsetTable_[i].charsetId_ == lastCharsetId ?\n               invalidCharsetId : charsetTable_[i].charsetId_;\n    }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "INTERNAL void vterm_screen_free(VTermScreen *screen)\n{\n  vterm_allocator_free(screen->vt, screen->buffers[0]);\n  if(screen->buffers[1])\n    vterm_allocator_free(screen->vt, screen->buffers[1]);\n\n  vterm_allocator_free(screen->vt, screen->sb_buffer);\n\n  vterm_allocator_free(screen->vt, screen);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void add_pixels_clamped4_c(const DCTELEM *block, uint8_t *restrict pixels,\n\n                          int line_size)\n\n{\n\n    int i;\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n\n\n    /* read the pixels */\n\n    for(i=0;i<4;i++) {\n\n        pixels[0] = cm[pixels[0] + block[0]];\n\n        pixels[1] = cm[pixels[1] + block[1]];\n\n        pixels[2] = cm[pixels[2] + block[2]];\n\n        pixels[3] = cm[pixels[3] + block[3]];\n\n        pixels += line_size;\n\n        block += 8;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bool HTMLLinkElement::LoadLink(const LinkLoadParameters& params) {\n  return link_loader_->LoadLink(params, GetDocument(),\n                                NetworkHintsInterfaceImpl());\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void php_image_filter_edgedetect(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageEdgeDetectQuick(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "check_mountpoint(const char *progname, char *mountpoint)\n{\n\tint err;\n\tstruct stat statbuf;\n\n\t/* does mountpoint exist and is it a directory? */\n\terr = stat(mountpoint, &statbuf);\n\tif (err) {\n\t\tfprintf(stderr, \"%s: failed to stat %s: %s\\n\", progname,\n\t\t\t\tmountpoint, strerror(errno));\n\t\treturn EX_USAGE;\n\t}\n\n\tif (!S_ISDIR(statbuf.st_mode)) {\n\t\tfprintf(stderr, \"%s: %s is not a directory!\", progname,\n\t\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n\n#if CIFS_LEGACY_SETUID_CHECK\n\t/* do extra checks on mountpoint for legacy setuid behavior */\n\tif (!getuid() || geteuid())\n\t\treturn 0;\n\n\tif (statbuf.st_uid != getuid()) {\n\t\tfprintf(stderr, \"%s: %s is not owned by user\\n\", progname,\n\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n\n\tif ((statbuf.st_mode & S_IRWXU) != S_IRWXU) {\n\t\tfprintf(stderr, \"%s: invalid permissions on %s\\n\", progname,\n\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n#endif /* CIFS_LEGACY_SETUID_CHECK */\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "inet_sockaddrip6(struct sockaddr_storage *addr, struct in6_addr *ip6)\n{\n\tif (addr->ss_family != AF_INET6)\n\t\treturn -1;\n\n\t*ip6 = ((struct sockaddr_in6 *) addr)->sin6_addr;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "ieee802_11_radio_if_print(netdissect_options *ndo,\n                          const struct pcap_pkthdr *h, const u_char *p)\n{\n\treturn ieee802_11_radio_print(ndo, p, h->len, h->caplen);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "parse_tag_11_packet(unsigned char *data, unsigned char *contents,\n\t\t    size_t max_contents_bytes, size_t *tag_11_contents_size,\n\t\t    size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*tag_11_contents_size) = 0;\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 11\n\t *\n\t * Tag 11 identifier (1 byte)\n\t * Max Tag 11 packet size (max 3 bytes)\n\t * Binary format specifier (1 byte)\n\t * Filename length (1 byte)\n\t * Filename (\"_CONSOLE\") (8 bytes)\n\t * Modification date (4 bytes)\n\t * Literal data (arbitrary)\n\t *\n\t * We need at least 16 bytes of data for the packet to even be\n\t * valid.\n\t */\n\tif (max_packet_size < 16) {\n\t\tprintk(KERN_ERR \"Maximum packet size too small\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_11_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\tgoto out;\n\t}\n\tif (body_size < 14) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += length_size;\n\t(*tag_11_contents_size) = (body_size - 14);\n\tif (unlikely((*packet_size) + body_size + 1 > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x62) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x08) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += 12; /* Ignore filename and modification date */\n\tmemcpy(contents, &data[(*packet_size)], (*tag_11_contents_size));\n\t(*packet_size) += (*tag_11_contents_size);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*tag_11_contents_size) = 0;\n\t}\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void validateCapacity(uint64_t new_capacity) {\n  // If the resizing will cause buffer overflow due to hitting uint32_t::max, an OOM is likely\n  // imminent. Fast-fail rather than allow a buffer overflow attack (issue #1421)\n  RELEASE_ASSERT(new_capacity <= std::numeric_limits<uint32_t>::max(),\n                 \"Trying to allocate overly large headers.\");\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void Http2Session::Origin(nghttp2_origin_entry* ov, size_t count) {\n  Http2Scope h2scope(this);\n  CHECK_EQ(nghttp2_submit_origin(session_, NGHTTP2_FLAG_NONE, ov, count), 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tunsigned long iovlen;\n\tstruct iovec *iov;\n\tint err = -EAGAIN;\n\tint used;\n \tlong copied = 0;\n \n \tlock_sock(sk);\n \tfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\n \t     iovlen--, iov++) {\n \t\tunsigned long seglen = iov->iov_len;\n\t\tchar __user *from = iov->iov_base;\n\n\t\twhile (seglen) {\n\t\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t\t       struct skcipher_sg_list, list);\n\t\t\tsg = sgl->sg;\n\n\t\t\twhile (!sg->length)\n\t\t\t\tsg++;\n\n\t\t\tused = ctx->used;\n\t\t\tif (!used) {\n\t\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tused = min_t(unsigned long, used, seglen);\n\n\t\t\tused = af_alg_make_sg(&ctx->rsgl, from, used, 1);\n\t\t\terr = used;\n\t\t\tif (err < 0)\n\t\t\t\tgoto unlock;\n\n\t\t\tif (ctx->more || used < ctx->used)\n\t\t\t\tused -= used % bs;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (!used)\n\t\t\t\tgoto free;\n\n\t\t\tablkcipher_request_set_crypt(&ctx->req, sg,\n\t\t\t\t\t\t     ctx->rsgl.sg, used,\n\t\t\t\t\t\t     ctx->iv);\n\n\t\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_ablkcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_ablkcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\n\nfree:\n\t\t\taf_alg_free_sg(&ctx->rsgl);\n\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\n\t\t\tcopied += used;\n\t\t\tfrom += used;\n\t\t\tseglen -= used;\n\t\t\tskcipher_pull_sgl(sk, used);\n\t\t}\n\t}\n\n\terr = 0;\n\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct ring_buffer *rb)\n{\n\tunsigned long flags;\n\n\tif (!list_empty(&event->rb_entry))\n\t\treturn;\n\n\tspin_lock_irqsave(&rb->event_lock, flags);\n\tif (!list_empty(&event->rb_entry))\n\t\tgoto unlock;\n\n\tlist_add(&event->rb_entry, &rb->event_list);\nunlock:\n\tspin_unlock_irqrestore(&rb->event_lock, flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void rbd_finish_aiocb(rbd_completion_t c, RADOSCB *rcb)\n\n{\n\n    int ret;\n\n    rcb->ret = rbd_aio_get_return_value(c);\n\n    rbd_aio_release(c);\n\n    ret = qemu_rbd_send_pipe(rcb->s, rcb);\n\n    if (ret < 0) {\n\n        error_report(\"failed writing to acb->s->fds\");\n\n        g_free(rcb);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int renameColumnSelectCb(Walker *pWalker, Select *p){\n  renameWalkWith(pWalker, p);\n  return WRC_Continue;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n \t\t    return FALSE;\n \t       }\n \t  }\n\t  return (xdr_opaque(xdrs, *objp, size));\n \n      case XDR_ENCODE:\n \t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n\n     return FALSE;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "query_rename(struct cpio_file_stat* file_hdr, FILE *tty_in, FILE *tty_out,\n\t     FILE *rename_in)\n{\n  char *str_res;\t\t/* Result for string function.  */\n  static dynamic_string new_name;\t/* New file name for rename option.  */\n  static int initialized_new_name = false;\n  if (!initialized_new_name)\n  {\n    ds_init (&new_name, 128);\n    initialized_new_name = true;\n  }\n\n  if (rename_flag)\n    {\n      fprintf (tty_out, _(\"rename %s -> \"), file_hdr->c_name);\n      fflush (tty_out);\n      str_res = ds_fgets (tty_in, &new_name);\n    }\n  else\n    {\n      str_res = ds_fgetstr (rename_in, &new_name, '\\n');\n    }\n  if (str_res == NULL || str_res[0] == 0)\n    {\n      return -1;\n    }\n  else\n    cpio_set_c_name (file_hdr, new_name.ds_string);\n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void Compute(OpKernelContext* context) override {\n    INDEX_TYPE first_dimension;\n    OP_REQUIRES_OK(context, GetFirstDimensionSize(context, &first_dimension));\n    vector<INDEX_TYPE> output_size;\n    OP_REQUIRES_OK(context,\n                   CalculateOutputSize(first_dimension, context, &output_size));\n    vector<INDEX_TYPE> multiplier;\n    multiplier.resize(ragged_rank_ + 1);\n\n    multiplier[multiplier.size() - 1] = 1;\n    for (int i = multiplier.size() - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * output_size[i + 1];\n    }\n    // Full size of the tensor.\n    TensorShape output_shape;\n    OP_REQUIRES_OK(context,\n                   TensorShapeUtils::MakeShape(output_size, &output_shape));\n    Tensor* output_tensor = nullptr;\n\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, output_shape, &output_tensor));\n    const INDEX_TYPE full_size = multiplier[0] * output_size[0];\n    if (full_size > 0) {\n      vector<INDEX_TYPE> output_index, new_output_index;\n      int nvals = context->input(kValueInputIndex).shape().dim_size(0);\n      output_index.reserve(nvals);\n      new_output_index.reserve(nvals);\n\n      CalculateFirstParentOutputIndex(first_dimension, multiplier[0],\n                                      output_size[0], &output_index);\n      for (int i = 1; i <= ragged_rank_; ++i) {\n        OP_REQUIRES_OK(context, CalculateOutputIndex(\n                                    context, i - 1, output_index, multiplier[i],\n                                    output_size[i], &new_output_index));\n        output_index.swap(new_output_index);\n        new_output_index.clear();\n      }\n\n      SetOutput(context, ragged_rank_, output_index, output_tensor);\n    }\n  }",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n\n\tif (more)\n\t\treturn;\n\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n{\n    // Socket disconnection will now be handled by LanDeviceLink\n    disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n\n    LanDeviceLink* deviceLink;\n    //Do we have a link for this device already?\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n    if (linkIterator != m_links.end()) {\n        //qCDebug(KDECONNECT_CORE) << \"Reusing link to\" << deviceId;\n        deviceLink = linkIterator.value();\n        deviceLink->reset(socket, connectionOrigin);\n    } else {\n        deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n        connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n        m_links[deviceId] = deviceLink;\n        if (m_pairingHandlers.contains(deviceId)) {\n            //We shouldn't have a pairinghandler if we didn't have a link.\n            //Crash if debug, recover if release (by setting the new devicelink to the old pairinghandler)\n            Q_ASSERT(m_pairingHandlers.contains(deviceId));\n            m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n        }\n    }\n    Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline unsigned int userpolicy_type_attrsize(void)\n{\n#ifdef CONFIG_XFRM_SUB_POLICY\n\treturn nla_total_size(sizeof(struct xfrm_userpolicy_type));\n#else\n\treturn 0;\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)\n{\n    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "GfxState::ReusablePathIterator::ReusablePathIterator(GfxPath *pathA) : path(pathA), subPathOff(0), coordOff(0), numCoords(0), curSubPath(nullptr)\n{\n    if (path->getNumSubpaths()) {\n        curSubPath = path->getSubpath(subPathOff);\n        numCoords = curSubPath->getNumPoints();\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static gint conv_noconv(gchar *outbuf, gint outlen, const gchar *inbuf)\n{\n\tstrncpy2(outbuf, inbuf, outlen);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n\n    jsonp_free(hashtable->buckets);\n\n    hashtable->num_buckets++;\n    new_size = num_buckets(hashtable);\n\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "**/\n    CImg<T>& operator|=(const char *const expression) {\n      return *this|=(+*this)._fill(expression,true,1,0,0,\"operator|=\",this);",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "JSStream::JSStream(Environment* env, Local<Object> obj)\n    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_JSSTREAM),\n      StreamBase(env) {\n  MakeWeak();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void CarbonProtocolReader::skip(const FieldType ft) {\n  switch (ft) {\n    case FieldType::True:\n    case FieldType::False: {\n      break;\n    }\n    case FieldType::Int8: {\n      readRaw<int8_t>();\n      break;\n    }\n    case FieldType::Int16: {\n      readRaw<int16_t>();\n      break;\n    }\n    case FieldType::Int32: {\n      readRaw<int32_t>();\n      break;\n    }\n    case FieldType::Int64: {\n      readRaw<int64_t>();\n      break;\n    }\n    case FieldType::Double: {\n      readRaw<double>();\n      break;\n    }\n    case FieldType::Float: {\n      readRaw<float>();\n      break;\n    }\n    case FieldType::Binary: {\n      readRaw<std::string>();\n      break;\n    }\n    case FieldType::List: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Struct: {\n      readStructBegin();\n      while (true) {\n        const auto fieldType = readFieldHeader().first;\n        if (fieldType == FieldType::Stop) {\n          break;\n        }\n        skip(fieldType);\n      }\n      readStructEnd();\n      break;\n    }\n    case FieldType::Set: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Map: {\n      skipKVContainer();\n      break;\n    }\n    default: { break; }\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); /* timeDelta (4 bytes) */\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); /* byteCount (4 bytes) */\n\n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "bool CephxAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t      bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                                              EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,  uint64_t *auid)\n{\n  bufferlist::iterator iter = authorizer_data.begin();\n\n  if (!authorizer_data.length()) {\n    ldout(cct, 1) << \"verify authorizer, authorizer_data.length()=0\" << dendl;\n    return false;\n  }\n\n  CephXServiceTicketInfo auth_ticket_info;\n\n  bool isvalid = cephx_verify_authorizer(cct, keys, iter, auth_ticket_info, authorizer_reply);\n\n  if (isvalid) {\n    caps_info = auth_ticket_info.ticket.caps;\n    entity_name = auth_ticket_info.ticket.name;\n    global_id = auth_ticket_info.ticket.global_id;\n    session_key = auth_ticket_info.session_key;\n    if (auid) *auid = auth_ticket_info.ticket.auid;\n  }\n\n  return isvalid;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static double mp_argmax(_cimg_math_parser& mp) {\n        const unsigned int i_end = (unsigned int)mp.opcode[2];\n        double val = _mp_arg(3);\n        unsigned int argval = 0;\n        for (unsigned int i = 4; i<i_end; ++i) {\n          const double _val = _mp_arg(i);\n          if (_val>val) { val = _val; argval = i - 3; }\n        }\n        return (double)argval;",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "**/\n    inline int fdate(const char *const path, unsigned int attr) {\n      int out = (int)attr;\n      return fdate(path,&out,1);",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)\n{\n\tuint64 end1 = start1 + length1 - 1;\n\tuint64 intersectEnd = (end1 <= end2) ? end1 : end2;\n\n\t*intersectStart = (start1 >= start2) ? start1 : start2;\n\t*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);\n\n\tif (*intersectLength == 0)\n\t\t*intersectStart = start1;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "tparm_proto(const char *string,\n\t    TPARM_ARG a1,\n\t    TPARM_ARG a2,\n\t    TPARM_ARG a3,\n\t    TPARM_ARG a4,\n\t    TPARM_ARG a5,\n\t    TPARM_ARG a6,\n\t    TPARM_ARG a7,\n\t    TPARM_ARG a8,\n\t    TPARM_ARG a9)\n{\n    return tparm_varargs(string, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "TestSubstituteDataWebFrameClient()\n        : m_commitCalled(false)\n    {\n    }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void palette8tobgr24(const uint8_t *src, uint8_t *dst, unsigned num_pixels, const uint8_t *palette)\n\n{\n\n\tunsigned i;\n\n/*\n\n\twrites 1 byte o much and might cause alignment issues on some architectures?\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];\n\n*/\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t//FIXME slow?\n\n\t\tdst[0]= palette[ src[i]*4+0 ];\n\n\t\tdst[1]= palette[ src[i]*4+1 ];\n\n\t\tdst[2]= palette[ src[i]*4+2 ];\n\n\t\tdst+= 3;\n\n\t}\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "COMPAT_SYSCALL_DEFINE1(time, compat_time_t __user *, tloc)\n{\n\tcompat_time_t i;\n\tstruct timeval tv;\n\n\tdo_gettimeofday(&tv);\n\ti = tv.tv_sec;\n\n\tif (tloc) {\n\t\tif (put_user(i,tloc))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn i;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "struct block_device *f2fs_target_device(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t blk_addr, struct bio *bio)\n{\n\tstruct block_device *bdev = sbi->sb->s_bdev;\n\tint i;\n\n\tif (f2fs_is_multi_device(sbi)) {\n\t\tfor (i = 0; i < sbi->s_ndevs; i++) {\n\t\t\tif (FDEV(i).start_blk <= blk_addr &&\n\t\t\t    FDEV(i).end_blk >= blk_addr) {\n\t\t\t\tblk_addr -= FDEV(i).start_blk;\n\t\t\t\tbdev = FDEV(i).bdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (bio) {\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blk_addr);\n\t}\n\treturn bdev;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return false;\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return false;\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return false;\n  }\n  CHECK_EQ(1, outputs.size());\n\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return false;\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return false;\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return false;\n  }\n\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n\n  return shape.IsCompatibleWith(new_dims);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void phar_spl_foreign_dtor(spl_filesystem_object *object) /* {{{ */\n{\n\tphar_archive_data *phar = (phar_archive_data *) object->oth;\n\n\tif (!phar->is_persistent) {\n\t\tphar_archive_delref(phar);\n\t}\n\n\tobject->oth = NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline void gen_neon_widen(TCGv_i64 dest, TCGv src, int size, int u)\n\n{\n\n    if (u) {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_u8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_u16(dest, src); break;\n\n        case 2: tcg_gen_extu_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    } else {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_s8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_s16(dest, src); break;\n\n        case 2: tcg_gen_ext_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    }\n\n    dead_tmp(src);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline int perf_intr_is_nmi(struct pt_regs *regs)\n{\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n \tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n \tint ret;\n \n\tif (args->buffer_count < 1) {\n \t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n \t\treturn -EINVAL;\n \t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void GLES2DecoderImpl::DoTexParameterfv(\n    GLenum target, GLenum pname, const GLfloat* params) {\n  TextureManager::TextureInfo* info = GetTextureInfoForTarget(target);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glTexParameterfv: unknown texture\");\n  } else {\n    texture_manager()->SetParameter(\n        info, pname, *reinterpret_cast<const GLint*>(params));\n    glTexParameterfv(target, pname, params);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool WriteEbmlElement(IMkvWriter* writer, uint64 type, const uint8* value,\n                      uint64 size) {\n  if (!writer || !value || size < 1)\n    return false;\n\n  if (WriteID(writer, type))\n    return false;\n\n  if (WriteUInt(writer, size))\n    return false;\n\n  if (writer->Write(value, static_cast<uint32>(size)))\n    return false;\n\n  return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "c_start (struct seq_file *m, loff_t *pos)\n{\n#ifdef CONFIG_SMP\n\twhile (*pos < NR_CPUS && !cpu_isset(*pos, cpu_online_map))\n\t\t++*pos;\n#endif\n\treturn *pos < NR_CPUS ? cpu_data(*pos) : NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ext4_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\n\t/* If the file has inline data, no need to do readpages. */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn ext4_mpage_readpages(mapping, pages, NULL, nr_pages, true);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "CertDecoder::CertDecoder(Source& s, bool decode, SignerList* signers,\n                         bool noVerify, CertType ct)\n    : BER_Decoder(s), certBegin_(0), sigIndex_(0), sigLength_(0),\n      signature_(0), verify_(!noVerify)\n{\n    issuer_[0] = 0;\n    subject_[0] = 0;\n\n    if (decode)\n        Decode(signers, ct);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool mod_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t struct delayed_work *dwork, unsigned long delay)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(&dwork->work, true, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (likely(ret >= 0)) {\n\t\t__queue_delayed_work(cpu, wq, dwork, delay);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\t/* -ENOENT from try_to_grab_pending() becomes %true */\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bool HeifContext::is_image(heif_item_id ID) const\n{\n  for (const auto& img : m_all_images) {\n    if (img.first == ID)\n      return true;\n  }\n\n  return false;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void oledate_to_iso8601(char *buf, int buf_size, int64_t value)\n\n{\n\n    time_t t = 631112400LL + 86400*av_int2dbl(value);\n\n    strftime(buf, buf_size, \"%Y-%m-%d %H:%M:%S\", gmtime(&t));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "media_status_t AMediaCodec_releaseOutputBufferAtTime(\n AMediaCodec *mData, size_t idx, int64_t timestampNs) {\n    ALOGV(\"render @ %\" PRId64, timestampNs);\n return translate_error(mData->mCodec->renderOutputBufferAndRelease(idx, timestampNs));\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "mono_set_pending_exception (MonoException *exc)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\t/* The thread may already be stopping */\n\tif (thread == NULL)\n\t\treturn;\n\n\tif (mono_thread_notify_pending_exc_fn) {\n\t\tMONO_OBJECT_SETREF (thread, pending_exception, exc);\n\n\t\tmono_thread_notify_pending_exc_fn ();\n\t} else {\n\t\t/* No way to notify the JIT about the exception, have to throw it now */\n\t\tmono_raise_exception (exc);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int player_set_setting(struct avrcp_player *player, uint8_t id,\n\t\t\t\t\t\t\t\tuint8_t val)\n{\n\tconst char *key, *value;\n\n\tkey = attr_to_str(id);\n\tif (key == NULL)\n\t\treturn -EINVAL;\n\n\tvalue = attrval_to_str(id, val);\n\tif (value == NULL)\n\t\treturn -EINVAL;\n\n\tif (player == NULL)\n\t\treturn -ENOENT;\n\n\treturn player->cb->set_setting(key, value, player->user_data);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we're handed a smaller struct than we know of,\n\t * ensure all the unknown bits are 0 - i.e. old\n\t * user-space does not get uncomplete information.\n\t */\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\n \t\tattr->size = usize;\n \t}\n \n\tret = copy_to_user(uattr, attr, usize);\n \tif (ret)\n \t\treturn -EFAULT;\n \nout:\n\treturn ret;\n\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool IsValidatedSCT(\n    const net::SignedCertificateTimestampAndStatus& sct_status) {\n  return sct_status.status == net::ct::SCT_STATUS_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "nfs_init_locked(struct inode *inode, void *opaque)\n{\n\tstruct nfs_find_desc\t*desc = (struct nfs_find_desc *)opaque;\n\tstruct nfs_fattr\t*fattr = desc->fattr;\n\n\tset_nfs_fileid(inode, fattr->fileid);\n\tnfs_copy_fh(NFS_FH(inode), desc->fh);\n\treturn 0;\n}",
    "output": "0"
  }
]