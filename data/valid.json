[
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void RenderView::setMouseOverURL(const WebURL& url) {\n  mouse_over_url_ = GURL(url);\n  UpdateTargetURL(mouse_over_url_, focus_url_);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "ciMethod* ciEnv::get_method_by_index(const constantPoolHandle& cpool,\n                                     int index, Bytecodes::Code bc,\n                                     ciInstanceKlass* accessor) {\n  GUARDED_VM_ENTRY(return get_method_by_index_impl(cpool, index, bc, accessor);)\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "//! Load image from a JPEG file \\newinstance.\n    static CImg<T> get_load_jpeg(const char *const filename) {\n      return CImg<T>().load_jpeg(filename);",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool Smb4KGlobal::updateMountedShare(Smb4KShare* share)\n{\n  Q_ASSERT(share);\n  \n  bool updated = false;\n  \n  if (share)\n  {\n    Smb4KShare *mountedShare = findShareByPath(share->path());\n    \n    if (mountedShare)\n    {\n      mountedShare->setMountData(share);\n      updated = true;\n    }\n    else\n    {\n    }\n  }\n  else\n  {\n  }\n  \n  return updated;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")\n{\n    parser parser(R\"(\n        ~ROOT <- _\n        _ <- ' '\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == false);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "DISOpticalFlowImpl::Densification_ParBody::Densification_ParBody(DISOpticalFlowImpl &_dis, int _nstripes, int _h,\n                                                                 Mat &dst_Ux, Mat &dst_Uy, Mat &src_Sx, Mat &src_Sy,\n                                                                 Mat &_I0, Mat &_I1)\n    : dis(&_dis), nstripes(_nstripes), h(_h), Ux(&dst_Ux), Uy(&dst_Uy), Sx(&src_Sx), Sy(&src_Sy), I0(&_I0), I1(&_I1)\n{\n    stripe_sz = (int)ceil(h / (double)nstripes);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bit_send(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as varbit_send, so share code */\n\treturn varbit_send(fcinfo);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "explicit CopyOpBase(OpKernelConstruction* ctx) : OpKernel(ctx) {}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void imcb_file_finished(struct im_connection *ic, file_transfer_t *file)\n{\n\tbee_t *bee = ic->bee;\n\n\tif (bee->ui->ft_finished) {\n\t\tbee->ui->ft_finished(ic, file);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "\tvoid verifyDirectoryPermissions(const string &path) {\n\t\tTRACE_POINT();\n\t\tstruct stat buf;\n\n\t\tif (stat(path.c_str(), &buf) == -1) {\n\t\t\tint e = errno;\n\t\t\tthrow FileSystemException(\"Cannot stat() \" + path, e, path);\n\t\t} else if (buf.st_mode != (S_IFDIR | parseModeString(\"u=rwx,g=rx,o=rx\"))) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong permissions\");\n\t\t} else if (buf.st_uid != geteuid() || buf.st_gid != getegid()) {\n\t\t\t/* The server instance directory is always created by the Watchdog. Its UID/GID never\n\t\t\t * changes because:\n\t\t\t * 1. Disabling user switching only lowers the privilege of the HelperAgent.\n\t\t\t * 2. For the UID/GID to change, the web server must be completely restarted\n\t\t\t *    (not just graceful reload) so that the control process can change its UID/GID.\n\t\t\t *    This causes the PID to change, so that an entirely new server instance\n\t\t\t *    directory is created.\n\t\t\t */\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong owner and group\");\n\t\t}\n\t}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void dvb_frontend_wakeup(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tfepriv->wakeup = 1;\n\twake_up_interruptible(&fepriv->wait_queue);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void imap_free_idata (IMAP_DATA** idata)\n{\n  if (!idata)\n    return;\n\n  FREE (&(*idata)->capstr);\n  mutt_free_list (&(*idata)->flags);\n  imap_mboxcache_free (*idata);\n  mutt_buffer_free(&(*idata)->cmdbuf);\n  FREE (&(*idata)->buf);\n  mutt_bcache_close (&(*idata)->bcache);\n  FREE (&(*idata)->cmds);\n  FREE (idata);\t\t/* __FREE_CHECKED__ */\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "av_cold int ff_lpc_init(LPCContext *s, int blocksize, int max_order,\n\n                        enum FFLPCType lpc_type)\n\n{\n\n    s->blocksize = blocksize;\n\n    s->max_order = max_order;\n\n    s->lpc_type  = lpc_type;\n\n\n\n    if (lpc_type == FF_LPC_TYPE_LEVINSON) {\n\n        s->windowed_samples = av_mallocz((blocksize + max_order + 2) *\n\n                                         sizeof(*s->windowed_samples));\n\n        if (!s->windowed_samples)\n\n            return AVERROR(ENOMEM);\n\n    } else {\n\n        s->windowed_samples = NULL;\n\n    }\n\n\n\n    s->lpc_apply_welch_window = lpc_apply_welch_window_c;\n\n    s->lpc_compute_autocorr   = lpc_compute_autocorr_c;\n\n\n\n    if (HAVE_MMX)\n\n        ff_lpc_init_x86(s);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void setup_format_params(int track)\n{\n\tint n;\n\tint il;\n\tint count;\n\tint head_shift;\n\tint track_shift;\n\tstruct fparm {\n\t\tunsigned char track, head, sect, size;\n\t} *here = (struct fparm *)floppy_track_buffer;\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->track = track;\n\n\traw_cmd->flags = (FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN |\n\t\t\t  FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\traw_cmd->cmd_count = NR_F;\n\tCOMMAND = FM_MODE(_floppy, FD_FORMAT);\n\tDR_SELECT = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);\n\tF_SIZECODE = FD_SIZECODE(_floppy);\n\tF_SECT_PER_TRACK = _floppy->sect << 2 >> F_SIZECODE;\n\tF_GAP = _floppy->fmt_gap;\n\tF_FILL = FD_FILL_BYTE;\n\n \traw_cmd->kernel_data = floppy_track_buffer;\n \traw_cmd->length = 4 * F_SECT_PER_TRACK;\n \n \t/* allow for about 30ms for data transport per track */\n \thead_shift = (F_SECT_PER_TRACK + 5) / 6;\n \n\t/* a ``cylinder'' is two tracks plus a little stepping time */\n\ttrack_shift = 2 * head_shift + 3;\n\n\t/* position of logical sector 1 on this track */\n\tn = (track_shift * format_req.track + head_shift * format_req.head)\n\t    % F_SECT_PER_TRACK;\n\n\t/* determine interleave */\n\til = 1;\n\tif (_floppy->fmt_gap < 0x22)\n\t\til++;\n\n\t/* initialize field */\n\tfor (count = 0; count < F_SECT_PER_TRACK; ++count) {\n\t\there[count].track = format_req.track;\n\t\there[count].head = format_req.head;\n\t\there[count].sect = 0;\n\t\there[count].size = F_SIZECODE;\n\t}\n\t/* place logical sectors */\n\tfor (count = 1; count <= F_SECT_PER_TRACK; ++count) {\n\t\there[n].sect = count;\n\t\tn = (n + il) % F_SECT_PER_TRACK;\n\t\tif (here[n].sect) {\t/* sector busy, find next free sector */\n\t\t\t++n;\n\t\t\tif (n >= F_SECT_PER_TRACK) {\n\t\t\t\tn -= F_SECT_PER_TRACK;\n\t\t\t\twhile (here[n].sect)\n\t\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t}\n\tif (_floppy->stretch & FD_SECTBASEMASK) {\n\t\tfor (count = 0; count < F_SECT_PER_TRACK; count++)\n\t\t\there[count].sect += FD_SECTBASE(_floppy) - 1;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "fz_device_rgb(fz_context *ctx)\n{\n\treturn ctx->colorspace->rgb;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static MemTxResult memory_region_write_with_attrs_accessor(MemoryRegion *mr,\n\n                                                           hwaddr addr,\n\n                                                           uint64_t *value,\n\n                                                           unsigned size,\n\n                                                           unsigned shift,\n\n                                                           uint64_t mask,\n\n                                                           MemTxAttrs attrs)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = (*value >> shift) & mask;\n\n    if (mr->subpage) {\n\n        trace_memory_region_subpage_write(get_cpu_index(), mr, addr, tmp, size);\n\n\n\n\n\n\n    } else if (TRACE_MEMORY_REGION_OPS_WRITE_ENABLED) {\n\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n\n        trace_memory_region_ops_write(get_cpu_index(), mr, abs_addr, tmp, size);\n\n    }\n\n    return mr->ops->write_with_attrs(mr->opaque, addr, tmp, size, attrs);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static CharDriverState *qemu_chr_open_stdio(ChardevStdio *opts)\n\n{\n\n    CharDriverState *chr;\n\n\n\n    if (is_daemonized()) {\n\n        error_report(\"cannot use stdio with -daemonize\");\n\n        return NULL;\n\n    }\n\n    old_fd0_flags = fcntl(0, F_GETFL);\n\n    tcgetattr (0, &oldtty);\n\n    qemu_set_nonblock(0);\n\n    atexit(term_exit);\n\n\n\n    chr = qemu_chr_open_fd(0, 1);\n\n    chr->chr_close = qemu_chr_close_stdio;\n\n    chr->chr_set_echo = qemu_chr_set_echo_stdio;\n\n    if (opts->has_signal) {\n\n        stdio_allow_signal = opts->signal;\n\n    }\n\n    qemu_chr_fe_set_echo(chr, false);\n\n\n\n    return chr;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "StreamListener::~StreamListener() {\n  if (stream_ != nullptr)\n    stream_->RemoveStreamListener(this);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void test_submit_aio(void)\n\n{\n\n    WorkerTestData data = { .n = 0, .ret = -EINPROGRESS };\n\n    data.aiocb = thread_pool_submit_aio(pool, worker_cb, &data,\n\n                                        done_cb, &data);\n\n\n\n    /* The callbacks are not called until after the first wait.  */\n\n    active = 1;\n\n    g_assert_cmpint(data.ret, ==, -EINPROGRESS);\n\n    qemu_aio_wait_all();\n\n    g_assert_cmpint(active, ==, 0);\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.ret, ==, 0);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void OutOfProcessInstance::Alert(const std::string& message) {\n  ModalDialog(this, \"alert\", message, std::string());\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "image_strdup (MonoImage *image, const char *s)\n{\n\tif (image)\n\t\treturn mono_image_strdup (image, s);\n\telse\n\t\treturn g_strdup (s);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "cgi_compare_variables(\n    const _cgi_var_t *v1,\t\t/* I - First variable */\n    const _cgi_var_t *v2)\t\t/* I - Second variable */\n{\n  return (_cups_strcasecmp(v1->name, v2->name));\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int tree_entry_gently(struct tree_desc *desc, struct name_entry *entry)\n{\n\tif (!desc->size)\n\t\treturn 0;\n\n\t*entry = desc->entry;\n\tif (update_tree_entry_gently(desc))\n\t\treturn 0;\n\treturn 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "write_to_temp(struct archive_write *a, const void *buff, size_t s)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tssize_t written;\n\tconst unsigned char *b;\n\n\tb = (const unsigned char *)buff;\n\twhile (s) {\n\t\twritten = write(iso9660->temp_fd, b, s);\n\t\tif (written < 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Can't write to temporary file\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\ts -= written;\n\t\tb += written;\n\t}\n\treturn (ARCHIVE_OK);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void AppCacheGroup::StartUpdateWithNewMasterEntry(\n    AppCacheHost* host, const GURL& new_master_resource) {\n  DCHECK(!is_obsolete() && !is_being_deleted());\n  if (is_in_dtor_)\n    return;\n\n  if (!update_job_)\n    update_job_ = new AppCacheUpdateJob(storage_->service(), this);\n\n  update_job_->StartUpdate(host, new_master_resource);\n\n  if (!restart_update_task_.IsCancelled()) {\n    restart_update_task_.Cancel();\n    RunQueuedUpdates();\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline void skb_reserve(struct sk_buff *skb, int len)\n{\n\tskb->data += len;\n\tskb->tail += len;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "tor_tls_context_init_one(tor_tls_context_t **ppcontext,\n                         crypto_pk_env_t *identity,\n                         unsigned int key_lifetime)\n{\n  tor_tls_context_t *new_ctx = tor_tls_context_new(identity,\n                                                   key_lifetime);\n  tor_tls_context_t *old_ctx = *ppcontext;\n\n  if (new_ctx != NULL) {\n    *ppcontext = new_ctx;\n\n    /* Free the old context if one existed. */\n    if (old_ctx != NULL) {\n      /* This is safe even if there are open connections: we reference-\n       * count tor_tls_context_t objects. */\n      tor_tls_context_decref(old_ctx);\n    }\n  }\n\n  return ((new_ctx != NULL) ? 0 : -1);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "hb_buffer_reference (hb_buffer_t *buffer)\n{\n  HB_OBJECT_DO_REFERENCE (buffer);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int PrintWebViewHelper::PrintPreviewContext::total_page_count() const {\n  DCHECK(IsRendering());\n  return total_page_count_;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void qemu_fdt_dumpdtb(void *fdt, int size)\n{\n    const char *dumpdtb = qemu_opt_get(qemu_get_machine_opts(), \"dumpdtb\");\n\n    if (dumpdtb) {\n        /* Dump the dtb to a file and quit */\n        exit(g_file_set_contents(dumpdtb, fdt, size, NULL) ? 0 : 1);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "zbuildfont3(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    int code;\n    build_proc_refs build;\n    gs_font_base *pfont;\n\n    check_type(*op, t_dictionary);\n    code = build_gs_font_procs(op, &build);\n    if (code < 0)\n        return code;\n    code = build_gs_simple_font(i_ctx_p, op, &pfont, ft_user_defined,\n                                &st_gs_font_base, &build, bf_options_none);\n    if (code < 0)\n        return code;\n    return define_gs_font(i_ctx_p, (gs_font *) pfont);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void pci_data_write(PCIBus *s, uint32_t addr, uint32_t val, int len)\n\n{\n\n    PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);\n\n    uint32_t config_addr = addr & (PCI_CONFIG_SPACE_SIZE - 1);\n\n\n\n    if (!pci_dev)\n\n        return;\n\n\n\n    PCI_DPRINTF(\"%s: %s: addr=%02\" PRIx32 \" val=%08\" PRIx32 \" len=%d\\n\",\n\n                __func__, pci_dev->name, config_addr, val, len);\n\n    pci_dev->config_write(pci_dev, config_addr, val, len);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int update_event_timestamp(RADIUS_PACKET *packet, time_t when)\n{\n\tVALUE_PAIR *vp;\n\n\tvp = pairfind(packet->vps, PW_EVENT_TIMESTAMP);\n\tif (!vp) return 0;\n\n\tvp->vp_date = when;\n\n\tif (packet->data) {\n\t\tfree(packet->data);\n\t\tpacket->data = NULL;\n\t\tpacket->data_len = 0;\n\t}\n\n\treturn 1;\t\t/* time stamp updated */\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int __init migration_init(void)\n{\n\tvoid *cpu = (void *)(long)smp_processor_id();\n\tint err;\n\n\t/* Initialize migration for the boot CPU */\n\terr = migration_call(&migration_notifier, CPU_UP_PREPARE, cpu);\n\tBUG_ON(err == NOTIFY_BAD);\n\tmigration_call(&migration_notifier, CPU_ONLINE, cpu);\n\tregister_cpu_notifier(&migration_notifier);\n\n\t/* Register cpu active notifiers */\n\tcpu_notifier(sched_cpu_active, CPU_PRI_SCHED_ACTIVE);\n\tcpu_notifier(sched_cpu_inactive, CPU_PRI_SCHED_INACTIVE);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int close_user_core(int user_core_fd, off_t core_size)\n{\n    if (user_core_fd >= 0 && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0))\n    {\n        perror_msg(\"Error writing '%s' at '%s'\", core_basename, user_pwd);\n        return -1;\n    }\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "LightProcess::LightProcess()\n: m_shadowProcess(0), m_fin(nullptr), m_fout(nullptr), m_afdt_fd(-1),\n  m_afdt_lfd(-1) { }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)\n{\n    cJSON *bool_item = cJSON_CreateBool(boolean);\n    if (add_item_to_object(object, name, bool_item, &global_hooks, false))\n    {\n        return bool_item;\n    }\n\n    cJSON_Delete(bool_item);\n    return NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "TfLiteStatus ReverseSequenceHelper(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* seq_lengths_tensor =\n      GetInput(context, node, kSeqLengthsTensor);\n  switch (seq_lengths_tensor->type) {\n    case kTfLiteInt32: {\n      return ReverseSequenceImpl<T, int32_t>(context, node);\n    }\n    case kTfLiteInt64: {\n      return ReverseSequenceImpl<T, int64_t>(context, node);\n    }\n    default: {\n      context->ReportError(\n          context,\n          \"Seq_lengths type '%s' is not supported by reverse_sequence.\",\n          TfLiteTypeGetName(seq_lengths_tensor->type));\n      return kTfLiteError;\n    }\n  }\n  return kTfLiteOk;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "__be16 skb_network_protocol(struct sk_buff *skb, int *depth)\n{\n\t__be16 type = skb->protocol;\n\n\t/* Tunnel gso handlers can set protocol to ethernet. */\n\tif (type == htons(ETH_P_TEB)) {\n\t\tstruct ethhdr *eth;\n\n\t\tif (unlikely(!pskb_may_pull(skb, sizeof(struct ethhdr))))\n\t\t\treturn 0;\n\n\t\teth = (struct ethhdr *)skb->data;\n\t\ttype = eth->h_proto;\n\t}\n\n\treturn __vlan_get_protocol(skb, type, depth);",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void qpci_pc_config_writel(QPCIBus *bus, int devfn, uint8_t offset, uint32_t value)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    outl(0xcfc, value);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "CPUState *cpu_create(const char *typename)\n\n{\n\n    Error *err = NULL;\n\n    CPUState *cpu = CPU(object_new(typename));\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_report_err(err);\n\n        object_unref(OBJECT(cpu));\n\n        return NULL;\n\n    }\n\n    return cpu;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void ManifestCallbackAndRun(const base::Closure& continuation,\n                                     const GURL&,\n                                     const content::Manifest&) {\n    continuation.Run();\n  }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "bool qemu_input_is_absolute(void)\n{\n    QemuInputHandlerState *s;\n\n    s = qemu_input_find_handler(INPUT_EVENT_MASK_REL | INPUT_EVENT_MASK_ABS,\n                                NULL);\n    return (s != NULL) && (s->handler->mask & INPUT_EVENT_MASK_ABS);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void vp8_deblock(VP8_COMMON *cm, YV12_BUFFER_CONFIG *source,\n                 YV12_BUFFER_CONFIG *post, int q, int low_var_thresh,\n                 int flag) {\n  double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065;\n  int ppl = (int)(level + .5);\n\n  const MODE_INFO *mode_info_context = cm->show_frame_mi;\n  int mbr, mbc;\n\n  /* The pixel thresholds are adjusted according to if or not the macroblock\n   * is a skipped block.  */\n  unsigned char *ylimits = cm->pp_limits_buffer;\n  unsigned char *uvlimits = cm->pp_limits_buffer + 16 * cm->mb_cols;\n  (void)low_var_thresh;\n  (void)flag;\n\n  if (ppl > 0) {\n    for (mbr = 0; mbr < cm->mb_rows; ++mbr) {\n      unsigned char *ylptr = ylimits;\n      unsigned char *uvlptr = uvlimits;\n      for (mbc = 0; mbc < cm->mb_cols; ++mbc) {\n        unsigned char mb_ppl;\n\n        if (mode_info_context->mbmi.mb_skip_coeff) {\n          mb_ppl = (unsigned char)ppl >> 1;\n        } else {\n          mb_ppl = (unsigned char)ppl;\n        }\n\n        memset(ylptr, mb_ppl, 16);\n        memset(uvlptr, mb_ppl, 8);\n\n        ylptr += 16;\n        uvlptr += 8;\n        mode_info_context++;\n      }\n      mode_info_context++;\n\n      vpx_post_proc_down_and_across_mb_row(\n          source->y_buffer + 16 * mbr * source->y_stride,\n          post->y_buffer + 16 * mbr * post->y_stride, source->y_stride,\n          post->y_stride, source->y_width, ylimits, 16);\n\n      vpx_post_proc_down_and_across_mb_row(\n          source->u_buffer + 8 * mbr * source->uv_stride,\n          post->u_buffer + 8 * mbr * post->uv_stride, source->uv_stride,\n          post->uv_stride, source->uv_width, uvlimits, 8);\n      vpx_post_proc_down_and_across_mb_row(\n          source->v_buffer + 8 * mbr * source->uv_stride,\n          post->v_buffer + 8 * mbr * post->uv_stride, source->uv_stride,\n          post->uv_stride, source->uv_width, uvlimits, 8);\n    }\n  } else {\n    vp8_yv12_copy_frame(source, post);\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "handle_offline(CMD_Request *rx_message, CMD_Reply *tx_message)\n{\n  int status;\n  IPAddr address, mask;\n  UTI_IPNetworkToHost(&rx_message->data.offline.mask, &mask);\n  UTI_IPNetworkToHost(&rx_message->data.offline.address, &address);\n  status = NSR_TakeSourcesOffline(&mask, &address);\n  if (status) {\n    tx_message->status = htons(STT_SUCCESS);\n  } else {\n    tx_message->status = htons(STT_NOSUCHSOURCE);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "ssize_t qemu_sendv_packet_async(NetClientState *sender,\n                                const struct iovec *iov, int iovcnt,\n                                NetPacketSent *sent_cb)\n{\n    NetQueue *queue;\n    int ret;\n\n    if (sender->link_down || !sender->peer) {\n        return iov_size(iov, iovcnt);\n    }\n\n    /* Let filters handle the packet first */\n    ret = filter_receive_iov(sender, NET_FILTER_DIRECTION_TX, sender,\n                             QEMU_NET_PACKET_FLAG_NONE, iov, iovcnt, sent_cb);\n    if (ret) {\n        return ret;\n    }\n\n    ret = filter_receive_iov(sender->peer, NET_FILTER_DIRECTION_RX, sender,\n                             QEMU_NET_PACKET_FLAG_NONE, iov, iovcnt, sent_cb);\n    if (ret) {\n        return ret;\n    }\n\n    queue = sender->peer->incoming_queue;\n\n    return qemu_net_queue_send_iov(queue, sender,\n                                   QEMU_NET_PACKET_FLAG_NONE,\n                                   iov, iovcnt, sent_cb);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int compare_window_spec_joined_lists(Window_spec *win_spec1,\n                                     Window_spec *win_spec2)\n{\n  win_spec1->join_partition_and_order_lists();\n  win_spec2->join_partition_and_order_lists();\n  int cmp= compare_order_lists(win_spec1->partition_list, \n                               win_spec2->partition_list);\n  win_spec1->disjoin_partition_and_order_lists();\n  win_spec2->disjoin_partition_and_order_lists();\n  return cmp;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int inotify_update_existing_watch(struct fsnotify_group *group,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t u32 arg)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\t__u32 old_mask, new_mask;\n\t__u32 mask;\n\tint add = (arg & IN_MASK_ADD);\n\tint create = (arg & IN_MASK_CREATE);\n\tint ret;\n\n\tmask = inotify_arg_to_mask(arg);\n\n\tfsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tif (!fsn_mark)\n\t\treturn -ENOENT;\n\telse if (create)\n\t\treturn -EEXIST;\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tspin_lock(&fsn_mark->lock);\n\told_mask = fsn_mark->mask;\n\tif (add)\n\t\tfsn_mark->mask |= mask;\n\telse\n\t\tfsn_mark->mask = mask;\n\tnew_mask = fsn_mark->mask;\n\tspin_unlock(&fsn_mark->lock);\n\n\tif (old_mask != new_mask) {\n\t\t/* more bits in old than in new? */\n\t\tint dropped = (old_mask & ~new_mask);\n\t\t/* more bits in this fsn_mark than the inode's mask? */\n\t\tint do_inode = (new_mask & ~inode->i_fsnotify_mask);\n\n\t\t/* update the inode with this new fsn_mark */\n\t\tif (dropped || do_inode)\n\t\t\tfsnotify_recalc_mask(inode->i_fsnotify_marks);\n\n\t}\n\n\t/* return the wd */\n\tret = i_mark->wd;\n\n\t/* match the get from fsnotify_find_mark() */\n\tfsnotify_put_mark(fsn_mark);\n\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \"Found constant of type %s where boolean was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \"true\") ||\n                istreq(ident, \"yes\") ||\n                istreq(ident, \"on\")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \"false\") ||\n                     istreq(ident, \"no\") ||\n                     istreq(ident, \"off\")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \"Identifier \\\"%s\\\" of type boolean is unknown\\n\", ident);\n        return false;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type boolean is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n \n     case EXPR_INVERT:\n     case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr, set_rtrn);\n         if (ok)\n             *set_rtrn = !*set_rtrn;\n         return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of boolean values not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveBoolean\\n\",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "    void serialize(DataRangeCursor* cursor) {\n        cursor->writeAndAdvance<LittleEndian<int32_t>>(originalOpCode);\n        cursor->writeAndAdvance<LittleEndian<int32_t>>(uncompressedSize);\n        cursor->writeAndAdvance<LittleEndian<uint8_t>>(compressorId);\n    }",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "explicit RestoreV2(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"dtypes\", &dtypes_));\n  }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void PNGType(png_bytep p,const png_byte *type)\n{\n  (void) memcpy(p,type,4*sizeof(png_byte));\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int destroy_pd(PVRDMADev *dev, union pvrdma_cmd_req *req,\n                      union pvrdma_cmd_resp *rsp)\n{\n    struct pvrdma_cmd_destroy_pd *cmd = &req->destroy_pd;\n\n    rdma_rm_dealloc_pd(&dev->rdma_dev_res, cmd->pd_handle);\n\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void set_acpi_power_state(IPMIBmcSim *ibs,\n\n                          uint8_t *cmd, unsigned int cmd_len,\n\n                          uint8_t *rsp, unsigned int *rsp_len,\n\n                          unsigned int max_rsp_len)\n\n{\n\n    IPMI_CHECK_CMD_LEN(4);\n\n    ibs->acpi_power_state[0] = cmd[2];\n\n    ibs->acpi_power_state[1] = cmd[3];\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "_hb_buffer_add_output_glyph( HB_Buffer buffer,\n\t\t\t     HB_UInt   glyph_index,\n\t\t\t     HB_UShort component,\n\t\t\t     HB_UShort ligID )\n{\n  HB_UShort glyph_data =  glyph_index;\n\n  return _hb_buffer_add_output_glyphs ( buffer, 1, 1,\n\t\t\t\t\t&glyph_data, component, ligID );\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void smp_process_pairing_commitment(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t* p = p_data->p_data;\n\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n\n if (smp_command_has_invalid_parameters(p_cb)) {\n    tSMP_INT_DATA smp_int_data;\n    smp_int_data.status = SMP_INVALID_PARAMETERS;\n    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n return;\n }\n\n  p_cb->flags |= SMP_PAIR_FLAG_HAVE_PEER_COMM;\n\n if (p != NULL) {\n    STREAM_TO_ARRAY(p_cb->remote_commitment, p, BT_OCTET16_LEN);\n }\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void megasas_command_complete(SCSIRequest *req, uint32_t status,\n\n                                     size_t resid)\n\n{\n\n    MegasasCmd *cmd = req->hba_private;\n\n    uint8_t cmd_status = MFI_STAT_OK;\n\n\n\n    trace_megasas_command_complete(cmd->index, status, resid);\n\n\n\n    if (req->io_canceled) {\n\n        return;\n\n    }\n\n\n\n    if (cmd->req == NULL) {\n\n        /*\n\n         * Internal command complete\n\n         */\n\n        cmd_status = megasas_finish_internal_dcmd(cmd, req, resid);\n\n        if (cmd_status == MFI_STAT_INVALID_STATUS) {\n\n            return;\n\n        }\n\n    } else {\n\n        req->status = status;\n\n        trace_megasas_scsi_complete(cmd->index, req->status,\n\n                                    cmd->iov_size, req->cmd.xfer);\n\n        if (req->status != GOOD) {\n\n            cmd_status = MFI_STAT_SCSI_DONE_WITH_ERROR;\n\n        }\n\n        if (req->status == CHECK_CONDITION) {\n\n            megasas_copy_sense(cmd);\n\n        }\n\n\n\n        cmd->frame->header.scsi_status = req->status;\n\n    }\n\n    cmd->frame->header.cmd_status = cmd_status;\n\n    megasas_complete_command(cmd);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void wm8750_audio_out_cb(void *opaque, int free_b)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n    wm8750_out_flush(s);\n\n\n\n    s->req_out = free_b;\n\n    s->data_req(s->opaque, free_b >> 2, s->req_in >> 2);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void scrub_parity_bio_endio(struct bio *bio)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct btrfs_fs_info *fs_info = sparity->sctx->fs_info;\n\n\tif (bio->bi_status)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tbio_put(bio);\n\n\tbtrfs_init_work(&sparity->work, btrfs_scrubparity_helper,\n\t\t\tscrub_parity_bio_endio_worker, NULL, NULL);\n\tbtrfs_queue_work(fs_info->scrub_parity_workers, &sparity->work);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int dvb_usbv2_exit(struct dvb_usb_device *d)\n{\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tdvb_usbv2_remote_exit(d);\n\tdvb_usbv2_adapter_exit(d);\n\tdvb_usbv2_i2c_exit(d);\n\tkfree(d->priv);\n\tkfree(d);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "__u32 secure_ipv6_id(const __be32 daddr[4])\n{\n\tconst struct keydata *keyptr;\n\t__u32 hash[4];\n\n\tkeyptr = get_keyptr();\n\n\thash[0] = (__force __u32)daddr[0];\n\thash[1] = (__force __u32)daddr[1];\n\thash[2] = (__force __u32)daddr[2];\n\thash[3] = (__force __u32)daddr[3];\n\n\treturn half_md4_transform(hash, keyptr->secret);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "mac_low16_read(E1000State *s, int index)\n{\n    return s->mac_reg[index] & 0xffff;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int cxusb_bluebird_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tu8 b = 0;\n\tif (onoff)\n\t\treturn cxusb_ctrl_msg(d, CMD_POWER_ON, &b, 1, NULL, 0);\n\telse\n\t\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int32_t cli_bcapi_pdf_getobjid(struct cli_bc_ctx *ctx , int32_t objidx)\n{\n    if (!ctx->pdf_phase ||\n\tobjidx >= ctx->pdf_nobjs)\n\treturn -1;\n    return ctx->pdf_objs[objidx].id;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "proto_tree_add_uint_format_value(proto_tree *tree, int hfindex, tvbuff_t *tvb,\n\t\t\t\t gint start, gint length, guint32 value,\n\t\t\t\t const char *format, ...)\n{\n\tproto_item\t  *pi;\n\tva_list\t\t   ap;\n\n\tpi = proto_tree_add_uint(tree, hfindex, tvb, start, length, value);\n\tif (pi != tree) {\n\t\tva_start(ap, format);\n\t\tproto_tree_set_representation_value(pi, format, ap);\n\t\tva_end(ap);\n\t}\n\n\treturn pi;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void event_format_fallback(ASS_Track *track)\n{\n    track->parser_priv->state = PST_EVENTS;\n    if (track->track_type == TRACK_TYPE_SSA)\n        track->event_format = strdup(ssa_event_format);\n    else\n        track->event_format = strdup(ass_event_format);\n    ass_msg(track->library, MSGL_V,\n            \"No event format found, using fallback\");\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "QVariant OpenConnectionTask::taskData(const int role) const\n{\n    return role == RoleTaskCompactName ? QVariant(tr(\"Connecting to mail server\")) : QVariant();\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static size_t\nphp_mysqlnd_change_auth_response_write(MYSQLND_CONN_DATA * conn, void * _packet)\n{\n\tMYSQLND_PACKET_CHANGE_AUTH_RESPONSE *packet= (MYSQLND_PACKET_CHANGE_AUTH_RESPONSE *) _packet;\n\tMYSQLND_ERROR_INFO * error_info = conn->error_info;\n\tMYSQLND_PFC * pfc = conn->protocol_frame_codec;\n\tMYSQLND_VIO * vio = conn->vio;\n\tMYSQLND_STATS * stats = conn->stats;\n\tMYSQLND_CONNECTION_STATE * connection_state = &conn->state;\n\tzend_uchar * const buffer = pfc->cmd_buffer.length >= packet->auth_data_len? pfc->cmd_buffer.buffer : mnd_emalloc(packet->auth_data_len);\n\tzend_uchar * p = buffer + MYSQLND_HEADER_SIZE; /* start after the header */\n\n\tDBG_ENTER(\"php_mysqlnd_change_auth_response_write\");\n\n\tif (packet->auth_data_len) {\n\t\tmemcpy(p, packet->auth_data, packet->auth_data_len);\n\t\tp+= packet->auth_data_len;\n\t}\n\n\t{\n\t\t/*\n\t\t  The auth handshake packet has no command in it. Thus we can't go over conn->command directly.\n\t\t  Well, we can have a command->no_command(conn, payload)\n\t\t*/\n\t\tconst size_t sent = pfc->data->m.send(pfc, vio, buffer, p - buffer - MYSQLND_HEADER_SIZE, stats, error_info);\n\t\tif (buffer != pfc->cmd_buffer.buffer) {\n\t\t\tmnd_efree(buffer);\n\t\t}\n\t\tif (!sent) {\n\t\t\tSET_CONNECTION_STATE(connection_state, CONN_QUIT_SENT);\n\t\t}\n\t\tDBG_RETURN(sent);\n\t}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "hash2field(gpointer key, gpointer value, gpointer user_data)\n{\n    const char *name = key;\n    const char *s_value = value;\n\n    xmlNode *xml_node = user_data;\n\n    if (crm_element_value(xml_node, name) == NULL) {\n        crm_xml_add(xml_node, name, s_value);\n\n    } else {\n        crm_trace(\"duplicate: %s=%s\", name, s_value);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n\t}\n\n\thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n\n\thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n\tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tPK11_FreeSlot(hash_slot);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void ewk_view_add_console_message(Evas_Object* ewkView, const char* message, unsigned int lineNumber, const char* sourceID)\n{\n    DBG(\"ewkView=%p message=%s lineNumber=%u sourceID=%s\", ewkView, message, lineNumber, sourceID);\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api->add_console_message);\n    smartData->api->add_console_message(smartData, message, lineNumber, sourceID);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void createPidFile(void) {\n    /* If pidfile requested, but no pidfile defined, use\n     * default pidfile path */\n    if (!server.pidfile) server.pidfile = zstrdup(CONFIG_DEFAULT_PID_FILE);\n\n    /* Try to write the pid file in a best-effort way. */\n    FILE *fp = fopen(server.pidfile,\"w\");\n    if (fp) {\n        fprintf(fp,\"%d\\n\",(int)getpid());\n        fclose(fp);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void fw_cfg_data_mem_write(void *opaque, hwaddr addr,\n\n                                  uint64_t value, unsigned size)\n\n{\n\n    FWCfgState *s = opaque;\n\n    uint8_t buf[8];\n\n    unsigned i;\n\n\n\n    switch (size) {\n\n    case 1:\n\n        buf[0] = value;\n\n        break;\n\n    case 2:\n\n        stw_he_p(buf, value);\n\n        break;\n\n    case 4:\n\n        stl_he_p(buf, value);\n\n        break;\n\n    case 8:\n\n        stq_he_p(buf, value);\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    for (i = 0; i < size; ++i) {\n\n        fw_cfg_write(s, buf[i]);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "PassRefPtr<AccessibilityTextMarker> AccessibilityUIElement::textMarkerForIndex(int textIndex)\n{\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int ms_init_ff(struct hid_device *hdev)\n{\n\tstruct hid_input *hidinput = list_entry(hdev->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *input_dev = hidinput->input;\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\n\tif (!(ms->quirks & MS_QUIRK_FF))\n\t\treturn 0;\n\n\tms->hdev = hdev;\n\tINIT_WORK(&ms->ff_worker, ms_ff_worker);\n\n\tms->output_report_dmabuf = devm_kzalloc(&hdev->dev,\n\t\t\t\t\t\tsizeof(struct xb1s_ff_report),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (ms->output_report_dmabuf == NULL)\n\t\treturn -ENOMEM;\n\n\tinput_set_capability(input_dev, EV_FF, FF_RUMBLE);\n\treturn input_ff_create_memless(input_dev, NULL, ms_play_effect);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "TEST(BasicFlatBufferModel, TestHandleMalformedModel) {\n  const auto model_paths = {\n      // These models use the same tensor as both input and ouput of a node\n      \"tensorflow/lite/testdata/add_shared_tensors.bin\",\n  };\n\n  for (const auto& model_path : model_paths) {\n    std::unique_ptr<tflite::FlatBufferModel> model =\n        FlatBufferModel::BuildFromFile(model_path);\n    ASSERT_NE(model, nullptr);\n\n    tflite::ops::builtin::BuiltinOpResolver resolver;\n    InterpreterBuilder builder(*model, resolver);\n    std::unique_ptr<Interpreter> interpreter;\n    ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n    ASSERT_NE(interpreter, nullptr);\n    ASSERT_NE(interpreter->AllocateTensors(), kTfLiteOk);\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ves_icall_MonoMethod_get_name (MonoReflectionMethod *m)\n{\n\tMonoMethod *method = m->method;\n\n\tMONO_OBJECT_SETREF (m, name, mono_string_new (mono_object_domain (m), method->name));\n\treturn m->name;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int snd_seq_set_queue_tempo(int client, struct snd_seq_queue_tempo *tempo)\n{\n\tif (!snd_seq_queue_check_access(tempo->queue, client))\n\t\treturn -EPERM;\n\treturn snd_seq_queue_timer_set_tempo(tempo->queue, client, tempo);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "__update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,\n\t      unsigned long delta_exec)\n{\n\tunsigned long delta_exec_weighted;\n\n\tschedstat_set(curr->exec_max, max((u64)delta_exec, curr->exec_max));\n\n\tcurr->sum_exec_runtime += delta_exec;\n\tschedstat_add(cfs_rq, exec_clock, delta_exec);\n\tdelta_exec_weighted = delta_exec;\n\tif (unlikely(curr->load.weight != NICE_0_LOAD)) {\n\t\tdelta_exec_weighted = calc_delta_fair(delta_exec_weighted,\n\t\t\t\t\t\t\t&curr->load);\n\t}\n\tcurr->vruntime += delta_exec_weighted;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "format_cb_session_group_list(struct format_tree *ft, struct format_entry *fe)\n{\n\tstruct session\t\t*s = ft->s;\n\tstruct session_group\t*sg;\n\tstruct session\t\t*loop;\n\tstruct evbuffer\t\t*buffer;\n\tint\t\t\t size;\n\n\tif (s == NULL)\n\t\treturn;\n\tsg = session_group_contains(s);\n\tif (sg == NULL)\n\t\treturn;\n\n\tbuffer = evbuffer_new();\n\tTAILQ_FOREACH(loop, &sg->sessions, gentry) {\n\t\tif (EVBUFFER_LENGTH(buffer) > 0)\n\t\t\tevbuffer_add(buffer, \",\", 1);\n\t\tevbuffer_add_printf(buffer, \"%s\", loop->name);\n\t}\n\tif ((size = EVBUFFER_LENGTH(buffer)) != 0)\n\t\txasprintf(&fe->value, \"%.*s\", size, EVBUFFER_DATA(buffer));\n\tevbuffer_free(buffer);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void RenderWidgetHostImpl::SetIsLoading(bool is_loading) {\n  if (owner_delegate_)\n    owner_delegate_->RenderWidgetWillSetIsLoading(is_loading);\n\n  is_loading_ = is_loading;\n  if (view_)\n    view_->SetIsLoading(is_loading);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "display_dollar(colnr_T col)\n{\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\t// If on the last byte of a multi-byte move to the first byte.\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    // recompute w_wrow and w_wcol\n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "av_cold int ff_dcaadpcm_init(DCAADPCMEncContext *s)\n{\n    if (!s)\n        return -1;\n    s->private_data = av_malloc(sizeof(premultiplied_coeffs) * DCA_ADPCM_VQCODEBOOK_SZ);\n    precalc(s->private_data);\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "TimeValue::TimeValue()\n        : Value(time)\n    {\n    }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "PHP_METHOD(Phar, loadPhar)\n{\n\tchar *fname, *alias = NULL, *error;\n\tsize_t fname_len, alias_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|s!\", &fname, &fname_len, &alias, &alias_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphar_request_initialize();\n\n\tRETVAL_BOOL(phar_open_from_filename(fname, fname_len, alias, alias_len, REPORT_ERRORS, NULL, &error) == SUCCESS);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"%s\", error);\n\t\tefree(error);\n\t}\n} /* }}} */",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "assegment_dup_all (struct assegment *seg)\n{\n  struct assegment *new = NULL;\n  struct assegment *head = NULL;\n  \n  while (seg)\n    {\n      if (head)\n        {\n          new->next = assegment_dup (seg);\n          new = new->next;\n        }\n      else\n        head = new = assegment_dup (seg);\n      \n      seg = seg->next;\n    }\n  return head;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static bool vers_create_sys_field(THD *thd, const char *field_name,\n                                  Alter_info *alter_info, int flags)\n{\n  Create_field *f= vers_init_sys_field(thd, field_name, flags, false);\n  if (!f)\n    return true;\n\n  alter_info->flags|= ALTER_PARSER_ADD_COLUMN;\n  alter_info->create_list.push_back(f);\n\n  return false;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int l_userauth_list (lua_State *L) {\n     return userauth_list(L, 0, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int page_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tDEFINE_DELAYED_CALL(done);\n\tint res = readlink_copy(buffer, buflen,\n\t\t\t\tpage_get_link(dentry, d_inode(dentry),\n\t\t\t\t\t      &done));\n\tdo_delayed_call(&done);\n\treturn res;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "MYSQLND_METHOD(mysqlnd_conn_data, error)(const MYSQLND_CONN_DATA * const conn TSRMLS_DC)\n{\n\treturn conn->error_info->error;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)\n{\n\tstruct blkcipher_alg *cipher = &tfm->__crt_alg->cra_blkcipher;\n\tunsigned long alignmask = crypto_tfm_alg_alignmask(tfm);\n\n\tif (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {\n\t\ttfm->crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\n\t\treturn -EINVAL;\n\t}\n\n\tif ((unsigned long)key & alignmask)\n\t\treturn setkey_unaligned(tfm, key, keylen);\n\n\treturn cipher->setkey(tfm, key, keylen);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void PasswordAutofillAgent::DidCommitProvisionalLoad(\n    bool is_same_document_navigation,\n    ui::PageTransition transition) {\n  if (!is_same_document_navigation) {\n    checked_safe_browsing_reputation_ = false;\n    recorded_first_filling_result_ = false;\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "std::string get_dir(const std::string& dir_path)\n{\n\tDIR* dir = opendir(dir_path.c_str());\n\tif(dir == NULL) {\n\t\tconst int res = mkdir(dir_path.c_str(),AccessMode);\n\t\tif(res == 0) {\n\t\t\tdir = opendir(dir_path.c_str());\n\t\t} else {\n\t\t\tERR_FS << \"could not open or create directory: \" << dir_path << '\\n';\n\t\t}\n\t}\n\n\tif(dir == NULL)\n\t\treturn \"\";\n\n\tclosedir(dir);\n\n\treturn dir_path;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int32_t cli_bcapi_map_addkey(struct cli_bc_ctx *ctx , const uint8_t* key, int32_t keysize, int32_t id)\n{\n    struct cli_map *s = get_hashtab(ctx, id);\n    if (!s)\n\treturn -1;\n    return cli_map_addkey(s, key, keysize);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "GfxColorSpace::GfxColorSpace() {\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int blkid_partition_set_type_string(blkid_partition par,\n\t\tconst unsigned char *type, size_t len)\n{\n\tset_string((unsigned char *) par->typestr,\n\t\t\tsizeof(par->typestr), type, len);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "AP_DECLARE(int) ap_calc_scoreboard_size(void)\n{\n    ap_mpm_query(AP_MPMQ_HARD_LIMIT_THREADS, &thread_limit);\n    ap_mpm_query(AP_MPMQ_HARD_LIMIT_DAEMONS, &server_limit);\n\n    scoreboard_size  = SIZE_OF_global_score;\n    scoreboard_size += SIZE_OF_process_score * server_limit;\n    scoreboard_size += SIZE_OF_worker_score * server_limit * thread_limit;\n\n    return scoreboard_size;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool MatchPattern(const std::wstring& source, const std::wstring& pattern) {\n  assert(pattern.find(L\"**\") == std::wstring::npos);\n  return MatchPatternImpl(source, pattern, 0, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void nvme_inc_cq_tail(NvmeCQueue *cq)\n{\n    cq->tail++;\n    if (cq->tail >= cq->size) {\n        cq->tail = 0;\n        cq->phase = !cq->phase;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "formatStrlen(char *target, char *source, int freeit)\n{\n    if (source != 0) {\n\tsprintf(target, \"%u\", (unsigned) strlen(source));\n\tif (freeit) {\n\t    free(source);\n\t}\n    } else {\n\tstrcpy(target, \"0\");\n    }\n    return target;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\n\t\tfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n\t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n\n\t\tcredssp_free(transport->credssp);\n\t\treturn FALSE;\n\t}\n\n\tcredssp_free(transport->credssp);\n\n\treturn TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int ff_http_do_new_request(URLContext *h, const char *uri)\n{\n    HTTPContext *s = h->priv_data;\n    AVDictionary *options = NULL;\n    int ret;\n    ret = http_shutdown(h, h->flags);\n    if (ret < 0)\n        return ret;\n    s->end_chunked_post = 0;\n    s->chunkend      = 0;\n    s->off           = 0;\n    s->icy_data_read = 0;\n    av_free(s->location);\n    s->location = av_strdup(uri);\n    if (!s->location)\n        return AVERROR(ENOMEM);\n    ret = http_open_cnx(h, &options);\n    av_dict_free(&options);\n    return ret;",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "genop_W(codegen_scope *s, mrb_code i, uint32_t a)\n{\n  uint8_t a1 = (a>>16) & 0xff;\n  uint8_t a2 = (a>>8) & 0xff;\n  uint8_t a3 = a & 0xff;\n\n  s->lastpc = s->pc;\n  gen_B(s, i);\n  gen_B(s, a1);\n  gen_B(s, a2);\n  gen_B(s, a3);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline TCGMemOp mo_64_32(TCGMemOp ot)\n{\n#ifdef TARGET_X86_64\n    return ot == MO_64 ? MO_64 : MO_32;\n#else\n    return MO_32;\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "zzip_disk_entry_fopen(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)\n{\n    /* keep this in sync with zzip_mem_entry_fopen */\n    struct zzip_file_header *header =\n        zzip_disk_entry_to_file_header(disk, entry);\n    if (! header)\n        return 0; /* EBADMSG */\n    ___ ZZIP_DISK_FILE *file = malloc(sizeof(ZZIP_DISK_FILE));\n    if (! file)\n        return 0; /* ENOMEM */\n    file->buffer = disk->buffer;\n    file->endbuf = disk->endbuf;\n    file->avail = zzip_file_header_usize(header);\n\n    if (! file->avail || zzip_file_header_data_stored(header))\n        { file->stored = zzip_file_header_to_data (header); return file; }\n\n    file->stored = 0;\n    file->zlib.opaque = 0;\n    file->zlib.zalloc = Z_NULL;\n    file->zlib.zfree = Z_NULL;\n    file->zlib.avail_in = zzip_file_header_csize(header);\n    file->zlib.next_in = zzip_file_header_to_data(header);\n\n    if (! zzip_file_header_data_deflated(header) ||\n        inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)\n    {\n        free (file);\n        errno = EBADMSG;\n        return 0; \n    }\n\n    return file;\n    ____;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "PHP_FUNCTION(pg_fetch_all)\n{\n\tzval *result;\n\tPGresult *pgsql_result;\n\tpgsql_result_handle *pg_result;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &result) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, \"PostgreSQL result\", le_result);\n\n\tpgsql_result = pg_result->result;\n\tarray_init(return_value);\n\tif (php_pgsql_result2array(pgsql_result, return_value TSRMLS_CC) == FAILURE) {\n\t\tzval_dtor(return_value);\n\t\tRETURN_FALSE;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void thr_info_cancel(struct thr_info *thr)\n{\n\tif (!thr)\n\t\treturn;\n\n\tif (PTH(thr) != 0L) {\n\t\tpthread_cancel(thr->pth);\n\t\tPTH(thr) = 0L;\n\t}\n\tcgsem_destroy(&thr->sem);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "tok_new(void)\n{\n    struct tok_state *tok = (struct tok_state *)PyMem_MALLOC(\n                                            sizeof(struct tok_state));\n    if (tok == NULL)\n        return NULL;\n    tok->buf = tok->cur = tok->end = tok->inp = tok->start = NULL;\n    tok->done = E_OK;\n    tok->fp = NULL;\n    tok->input = NULL;\n    tok->tabsize = TABSIZE;\n    tok->indent = 0;\n    tok->indstack[0] = 0;\n\n    tok->atbol = 1;\n    tok->pendin = 0;\n    tok->prompt = tok->nextprompt = NULL;\n    tok->lineno = 0;\n    tok->level = 0;\n    tok->altindstack[0] = 0;\n    tok->decoding_state = STATE_INIT;\n    tok->decoding_erred = 0;\n    tok->read_coding_spec = 0;\n    tok->enc = NULL;\n    tok->encoding = NULL;\n    tok->cont_line = 0;\n#ifndef PGEN\n    tok->filename = NULL;\n    tok->decoding_readline = NULL;\n    tok->decoding_buffer = NULL;\n#endif\n\n    return tok;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "virtual UnicodeString& format(int32_t ,UnicodeString& appendTo,FieldPosition& ) const {\n        return appendTo.append((UChar)0x0033);\n    }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "dirserv_free_all(void)\n{\n  dirserv_free_fingerprint_list();\n\n  strmap_free(cached_consensuses, free_cached_dir_);\n  cached_consensuses = NULL;\n\n  dirserv_clear_measured_bw_cache();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n \tut32 i = 0;\n \twhile (buf + i < max && buf[i] != eoc) {\n\t\ti += 1;\n \t}\n \tif (buf[i] != eoc) {\n \t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void vmx_switch_vmcs(struct kvm_vcpu *vcpu, struct loaded_vmcs *vmcs)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint cpu;\n\n\tif (vmx->loaded_vmcs == vmcs)\n\t\treturn;\n\n\tcpu = get_cpu();\n\tvmx->loaded_vmcs = vmcs;\n\tvmx_vcpu_put(vcpu);\n\tvmx_vcpu_load(vcpu, cpu);\n\tvcpu->cpu = cpu;\n\tput_cpu();\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "_dbus_marshal_header_test (void)\n{\n\n  return TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void virtio_blk_req_complete(VirtIOBlockReq *req, int status)\n{\n    VirtIOBlock *s = req->dev;\n\n    trace_virtio_blk_req_complete(req, status);\n\n    stb_p(&req->in->status, status);\n    virtqueue_push(s->vq, &req->elem, req->qiov.size + sizeof(*req->in));\n    virtio_notify(&s->vdev, s->vq);\n\n    qemu_free(req);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  // recvfrom() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), len);\n\n  // If |src_addr| is not NULL, and the underlying protocol provides the source\n  // address, this source address is filled in. When |src_addr| is NULL, nothing\n  // is filled in; in this case, |addrlen| is not used, and should also be NULL.\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n\n  return result;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "Goffset PDFDoc::getMainXRefEntriesOffset(bool tryingToReconstruct)\n{\n  unsigned int mainXRefEntriesOffset = 0;\n\n  if (isLinearized(tryingToReconstruct)) {\n    mainXRefEntriesOffset = getLinearization()->getMainXRefEntriesOffset();\n  }\n\n  return mainXRefEntriesOffset;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int aio_fsync(struct fsync_iocb *req, const struct iocb *iocb,\n\t\t     bool datasync)\n{\n\tif (unlikely(iocb->aio_buf || iocb->aio_offset || iocb->aio_nbytes ||\n\t\t\tiocb->aio_rw_flags))\n\t\treturn -EINVAL;\n\n\treq->file = fget(iocb->aio_fildes);\n\tif (unlikely(!req->file))\n\t\treturn -EBADF;\n\tif (unlikely(!req->file->f_op->fsync)) {\n\t\tfput(req->file);\n\t\treturn -EINVAL;\n\t}\n\n\treq->datasync = datasync;\n\tINIT_WORK(&req->work, aio_fsync_work);\n\tschedule_work(&req->work);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "acquire_caps (uid_t uid)\n{\n  struct __user_cap_header_struct hdr;\n  struct __user_cap_data_struct data;\n\n  /* Tell kernel not clear capabilities when dropping root */\n  if (prctl (PR_SET_KEEPCAPS, 1, 0, 0, 0) < 0)\n    g_error (\"prctl(PR_SET_KEEPCAPS) failed\");\n\n  /* Drop root uid, but retain the required permitted caps */\n  if (setuid (uid) < 0)\n    g_error (\"unable to drop privs\");\n\n  memset (&hdr, 0, sizeof(hdr));\n  hdr.version = _LINUX_CAPABILITY_VERSION;\n\n  /* Drop all non-require capabilities */\n  data.effective = REQUIRED_CAPS;\n  data.permitted = REQUIRED_CAPS;\n  data.inheritable = 0;\n  if (capset (&hdr, &data) < 0)\n    g_error (\"capset failed\");\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n \n \tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n \t\treturn false;\n\treturn true;\n }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void dname_print(FILE* out, struct sldns_buffer* pkt, uint8_t* dname)\n{\n\tuint8_t lablen;\n\tif(!out) out = stdout;\n\tif(!dname) return;\n\n\tlablen = *dname++;\n\tif(!lablen) \n\t\tfputc('.', out);\n\twhile(lablen) {\n\t\tif(LABEL_IS_PTR(lablen)) {\n\t\t\t/* follow pointer */\n\t\t\tif(!pkt) {\n\t\t\t\tfputs(\"??compressionptr??\", out);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));\n\t\t\tlablen = *dname++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(lablen > LDNS_MAX_LABELLEN) {\n\t\t\tfputs(\"??extendedlabel??\", out);\n\t\t\treturn;\n\t\t}\n\t\twhile(lablen--)\n\t\t\tfputc((int)*dname++, out);\n\t\tfputc('.', out);\n\t\tlablen = *dname++;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "TEST(Url, ParsingFails) {\n  Utility::Url url;\n  const bool is_connect = true;\n  EXPECT_FALSE(url.initialize(\"\", !is_connect));\n  EXPECT_FALSE(url.initialize(\"foo\", !is_connect));\n  EXPECT_FALSE(url.initialize(\"http://\", !is_connect));\n  EXPECT_FALSE(url.initialize(\"random_scheme://host.com/path\", !is_connect));\n  // Only port value in valid range (1-65535) is allowed.\n  EXPECT_FALSE(url.initialize(\"http://host.com:65536/path\", !is_connect));\n  EXPECT_FALSE(url.initialize(\"http://host.com:0/path\", !is_connect));\n  EXPECT_FALSE(url.initialize(\"http://host.com:-1/path\", !is_connect));\n  EXPECT_FALSE(url.initialize(\"http://host.com:port/path\", !is_connect));\n\n  // Test parsing fails for CONNECT request URLs.\n  EXPECT_FALSE(url.initialize(\"http://www.foo.com\", is_connect));\n  EXPECT_FALSE(url.initialize(\"foo.com\", is_connect));\n  // Only port value in valid range (1-65535) is allowed.\n  EXPECT_FALSE(url.initialize(\"foo.com:65536\", is_connect));\n  EXPECT_FALSE(url.initialize(\"foo.com:0\", is_connect));\n  EXPECT_FALSE(url.initialize(\"foo.com:-1\", is_connect));\n  EXPECT_FALSE(url.initialize(\"foo.com:port\", is_connect));\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "skip_space(char **cpp)\n{\n\tchar *cp;\n\n\tfor (cp = *cpp; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\t*cpp = cp;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void ElectronRenderFrameObserver::DraggableRegionsChanged() {\n  blink::WebVector<blink::WebDraggableRegion> webregions =\n      render_frame_->GetWebFrame()->GetDocument().DraggableRegions();\n  std::vector<mojom::DraggableRegionPtr> regions;\n  for (auto& webregion : webregions) {\n    auto region = mojom::DraggableRegion::New();\n    render_frame_->ConvertViewportToWindow(&webregion.bounds);\n    region->bounds = webregion.bounds;\n    region->draggable = webregion.draggable;\n    regions.push_back(std::move(region));\n  }\n\n  mojo::Remote<mojom::ElectronBrowser> browser_remote;\n  render_frame_->GetBrowserInterfaceBroker()->GetInterface(\n      browser_remote.BindNewPipeAndPassReceiver());\n  browser_remote->UpdateDraggableRegions(std::move(regions));\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid= fs->cache.array[x].objectId.id;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n\t\t\tcount+=2;\n \t\t}\n \t}\n \treturn count;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tconsole_verbose();\n\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\n\tset_pte(ptep, pte);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint err;\n\tstruct sock_diag_req *req = nlmsg_data(nlh);\n\tconst struct sock_diag_handler *hndl;\n\n\tif (nlmsg_len(nlh) < sizeof(*req))\n\t\treturn -EINVAL;\n\n\thndl = sock_diag_lock_handler(req->sdiag_family);\n\tif (hndl == NULL)\n\t\terr = -ENOENT;\n\telse\n\t\terr = hndl->dump(skb, nlh);\n\tsock_diag_unlock_handler(hndl);\n\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void imap_parser_enable_literal_minus(struct imap_parser *parser)\n{\n\tparser->literal_minus = TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int ad5755_update_dac_ctrl(struct iio_dev *indio_dev,\n\tunsigned int channel, unsigned int set, unsigned int clr)\n{\n\tstruct ad5755_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tst->ctrl[channel] |= set;\n\tst->ctrl[channel] &= ~clr;\n\n\tret = ad5755_write_ctrl_unlocked(indio_dev, channel,\n\t\tAD5755_CTRL_REG_DAC, st->ctrl[channel]);\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void OmniboxEditModel::OnUpOrDownKeyPressed(int count) {\n  if (popup_model() && popup_model()->IsOpen()) {\n    popup_model()->Move(count);\n    return;\n  }\n\n  if (!query_in_progress()) {\n    if (!user_input_in_progress_)\n      InternalSetUserText(permanent_text_);\n    view_->UpdatePopup();\n    return;\n  }\n\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tut8 *directory_base;\n\tstruct minidump_directory *entry;\n\n\tdirectory_base = obj->b->buf + obj->hdr->stream_directory_rva;\n\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\n\t/* Parse each entry in the directory */\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tentry = (struct minidump_directory *)(directory_base + (i * sizeof (struct minidump_directory)));\n\t\tr_bin_mdmp_init_directory_entry (obj, entry);\n\t}\n\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "R_API ut16 r_anal_bb_offset_inst(RAnalBlock *bb, int i) {\n\tif (i < 0 || i >= bb->ninstr) {\n\t\treturn UT16_MAX;\n\t}\n\treturn (i > 0 && (i - 1) < bb->op_pos_size) ? bb->op_pos[i - 1] : 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "rpmRC hdrblobInit(const void *uh, size_t uc,\n\t\trpmTagVal regionTag, int exact_size,\n\t\tstruct hdrblob_s *blob, char **emsg)\n{\n    rpmRC rc = RPMRC_FAIL;\n\n    memset(blob, 0, sizeof(*blob));\n    blob->ei = (int32_t *) uh; /* discards const */\n    blob->il = ntohl(blob->ei[0]);\n    blob->dl = ntohl(blob->ei[1]);\n    blob->pe = (entryInfo) &(blob->ei[2]);\n    blob->pvlen = sizeof(blob->il) + sizeof(blob->dl) +\n\t\t  (blob->il * sizeof(*blob->pe)) + blob->dl;\n    blob->dataStart = (uint8_t *) (blob->pe + blob->il);\n    blob->dataEnd = blob->dataStart + blob->dl;\n\n    /* Is the blob the right size? */\n    if (blob->pvlen >= headerMaxbytes || (uc && blob->pvlen != uc)) {\n\trasprintf(emsg, _(\"blob size(%d): BAD, 8 + 16 * il(%d) + dl(%d)\"),\n\t\t\tblob->pvlen, blob->il, blob->dl);\n\tgoto exit;\n    }\n\n    if (hdrblobVerifyRegion(regionTag, exact_size, blob, emsg) == RPMRC_FAIL)\n\tgoto exit;\n\n    /* Sanity check the rest of the header structure. */\n    if (hdrblobVerifyInfo(blob, emsg))\n\tgoto exit;\n\n    rc = RPMRC_OK;\n\nexit:\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "SYSCALL_DEFINE3(mknod, const char __user *, filename, int, mode, unsigned, dev)\n{\n\treturn sys_mknodat(AT_FDCWD, filename, mode, dev);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int wsrep_sst_donate(const std::string &msg, const wsrep::gtid &current_gtid,\n                     const bool bypass) {\n  /* This will be reset when sync callback is called.\n   * Should we set wsrep_ready to false here too? */\n  local_status.set(wsrep::server_state::s_donor);\n\n  const char *method = msg.data();\n  size_t method_len = strlen(method);\n  const char *data = method + method_len + 1;\n\n  wsp::env env(NULL);\n  if (env.error()) {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): env var ctor failed: %d\", -env.error());\n    return WSREP_CB_FAILURE;\n  }\n\n#if 0\n  /* Wait for wsrep-SE to initialize that also signals\n  completion of init_server_component which is important before we initiate\n  any meangiful action especially DONOR action from this node. */\n  while (!wsrep_is_SE_initialized()) {\n    sleep(1);\n    THD *applier_thd = static_cast<THD *>(recv_ctx);\n    if (applier_thd->killed == THD::KILL_CONNECTION) return WSREP_CB_FAILURE;\n  }\n#endif\n\n  int ret;\n  ret = sst_donate_other(method, data, current_gtid, bypass, env());\n\n  return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "get_uncompressed_data(struct archive_read *a, const void **buff, size_t size,\n    size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tssize_t bytes_avail;\n\n \tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n \t\t/* Copy mode. */\n \n\t\t/*\n\t\t * Note: '1' here is a performance optimization.\n\t\t * Recall that the decompression layer returns a count of\n\t\t * available bytes; asking for more than that forces the\n\t\t * decompressor to combine reads by copying data.\n\t\t */\n\t\t*buff = __archive_read_ahead(a, 1, &bytes_avail);\n \t\tif (bytes_avail <= 0) {\n \t\t\tarchive_set_error(&a->archive,\n \t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif ((size_t)bytes_avail >\n\t\t    zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\tif ((size_t)bytes_avail > size)\n\t\t\tbytes_avail = (ssize_t)size;\n\n\t\tzip->pack_stream_bytes_unconsumed = bytes_avail;\n\t} else if (zip->uncompressed_buffer_pointer == NULL) {\n\t\t/* Decompression has failed. */\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t} else {\n\t\t/* Packed mode. */\n\t\tif (minimum > zip->uncompressed_buffer_bytes_remaining) {\n\t\t\t/*\n\t\t\t * If remaining uncompressed data size is less than\n\t\t\t * the minimum size, fill the buffer up to the\n\t\t\t * minimum size.\n\t\t\t */\n\t\t\tif (extract_pack_stream(a, minimum) < 0)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (size > zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\telse\n\t\t\tbytes_avail = (ssize_t)size;\n\t\t*buff = zip->uncompressed_buffer_pointer;\n\t\tzip->uncompressed_buffer_pointer += bytes_avail;\n\t}\n\tzip->uncompressed_buffer_bytes_remaining -= bytes_avail;\n\treturn (bytes_avail);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int muscle_delete_file(sc_card_t *card, const sc_path_t *path_in)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmscfs_file_t *file_data = NULL;\n\tint r = 0;\n\n\tr = mscfs_loadFileInfo(fs, path_in->value, path_in->len, &file_data, NULL);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\tr = muscle_delete_mscfs_file(card, file_data);\n\tmscfs_clear_cache(fs);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int cmp(const void *key, const void *node)\n\n{\n\n    return (*(const int64_t *) key) - ((const CacheEntry *) node)->logical_pos;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void sd_response_r1_make(SDState *sd, uint8_t *response)\n\n{\n\n    uint32_t status = sd->card_status;\n\n    /* Clear the \"clear on read\" status bits (except APP_CMD) */\n\n    sd->card_status &= ~CARD_STATUS_C | APP_CMD;\n\n\n\n    response[0] = (status >> 24) & 0xff;\n\n    response[1] = (status >> 16) & 0xff;\n\n    response[2] = (status >> 8) & 0xff;\n\n    response[3] = (status >> 0) & 0xff;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void qdev_prop_allow_set_link_before_realize(Object *obj, const char *name,\n\n                                             Object *val, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n\n\n    if (dev->realized) {\n\n        error_setg(errp, \"Attempt to set link property '%s' on device '%s' \"\n\n                   \"(type '%s') after it was realized\",\n\n                   name, dev->id, object_get_typename(obj));\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "TiffDirectory* TiffDirectory::doClone() const\n    {\n        return new TiffDirectory(*this);\n    }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "gx_default_push_transparency_state(gx_device *dev, gs_gstate *pgs)\n{\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void populateOperands(intrusive_ptr<ExpressionNary>& expression) {\n        intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());\n        expression->addOperand(ExpressionConstant::create(expCtx, valueFromBson(operand())));\n    }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int wc_RsaSSL_VerifyInline(byte* in, word32 inLen, byte** out, RsaKey* key)\n{\n    WC_RNG* rng;\n#ifdef WC_RSA_BLINDING\n    rng = key->rng;\n#else\n    rng = NULL;\n#endif\n    return RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,\n        RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PKCSV15_PAD,\n        WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "bool DevToolsWindow::IsDocked() {\n  return dock_side_ != DEVTOOLS_DOCK_SIDE_UNDOCKED;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "   Returns TRUE if the algorithm is a block algorithm */\nPHP_FUNCTION(mcrypt_module_is_block_algorithm)\n{\n\tMCRYPT_GET_MODE_DIR_ARGS(algorithms_dir)\n\t\n\tif (mcrypt_module_is_block_algorithm(module, dir) == 1) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "PHPAPI zval* php_set_session_var(zend_string *name, zval *state_val, php_unserialize_data_t *var_hash) /* {{{ */\n{\n\tIF_SESSION_VARS() {\n\t\tzval *sess_var = Z_REFVAL(PS(http_session_vars));\n\t\tSEPARATE_ARRAY(sess_var);\n\t\treturn zend_hash_update(Z_ARRVAL_P(sess_var), name, state_val);\n\t}\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "libssh2_channel_eof(LIBSSH2_CHANNEL * channel)\n{\n    LIBSSH2_SESSION *session;\n    LIBSSH2_PACKET *packet;\n\n    if(!channel)\n        return LIBSSH2_ERROR_BAD_USE;\n\n    session = channel->session;\n    packet = _libssh2_list_first(&session->packets);\n\n    while(packet) {\n        if(((packet->data[0] == SSH_MSG_CHANNEL_DATA)\n             || (packet->data[0] == SSH_MSG_CHANNEL_EXTENDED_DATA))\n            && (channel->local.id == _libssh2_ntohu32(packet->data + 1))) {\n            /* There's data waiting to be read yet, mask the EOF status */\n            return 0;\n        }\n        packet = _libssh2_list_next(&packet->node);\n    }\n\n    return channel->remote.eof;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "gst_h264_create_sei_memory_avc (guint8 nal_length_size, GArray * messages)\n{\n  g_return_val_if_fail (nal_length_size > 0 && nal_length_size < 5, NULL);\n  g_return_val_if_fail (messages != NULL, NULL);\n  g_return_val_if_fail (messages->len > 0, NULL);\n\n  return gst_h264_create_sei_memory_internal (nal_length_size, TRUE, messages);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void xfrm_audit_state_delete(struct xfrm_state *x, int result, bool task_valid)\n{\n\tstruct audit_buffer *audit_buf;\n\n\taudit_buf = xfrm_audit_start(\"SAD-delete\");\n\tif (audit_buf == NULL)\n\t\treturn;\n\txfrm_audit_helper_usrinfo(task_valid, audit_buf);\n\txfrm_audit_helper_sainfo(x, audit_buf);\n\taudit_log_format(audit_buf, \" res=%u\", result);\n\taudit_log_end(audit_buf);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "struct smb_iconv_handle *get_iconv_handle(void)\n{\n\tif (global_iconv_handle == NULL)\n\t\tglobal_iconv_handle = smb_iconv_handle_reinit(talloc_autofree_context(),\n\t\t\t\t\t\t\t      \"ASCII\", \"UTF-8\", true, NULL);\n\treturn global_iconv_handle;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "uint64 ReadCodedSizeValue(const binary * InBuffer, uint32 & BufferSize, uint64 & SizeUnknown)\n{\n  binary SizeBitMask = 1 << 7;\n  uint64 Result = 0x7F;\n  unsigned int SizeIdx, PossibleSizeLength = 0;\n  binary PossibleSize[8];\n  memset(PossibleSize, 0, 8);\n\n  SizeUnknown = 0x7F; // the last bit is discarded when computing the size\n  for (SizeIdx = 0; SizeIdx < BufferSize && SizeIdx < 8; SizeIdx++) {\n    if (InBuffer[0] & (SizeBitMask >> SizeIdx)) {\n      // ID found\n      PossibleSizeLength = SizeIdx + 1;\n      SizeBitMask >>= SizeIdx;\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength; SizeIdx++) {\n        PossibleSize[SizeIdx] = InBuffer[SizeIdx];\n      }\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength - 1; SizeIdx++) {\n        Result <<= 7;\n        Result |= 0xFF;\n      }\n\n      Result = 0;\n      Result |= PossibleSize[0] & ~SizeBitMask;\n      for (unsigned int i = 1; i<PossibleSizeLength; i++) {\n        Result <<= 8;\n        Result |= PossibleSize[i];\n      }\n\n      BufferSize = PossibleSizeLength;\n\n      return Result;\n    }\n    SizeUnknown <<= 7;\n    SizeUnknown |= 0xFF;\n  }\n\n  BufferSize = 0;\n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "file_asynch_write (struct rw *rw,\n                   struct command *command,\n                   nbd_completion_callback cb)\n{\n  int dummy = 0;\n\n  file_synch_write (rw, slice_ptr (command->slice),\n                    command->slice.len, command->offset);\n  if (cb.callback (cb.user_data, &dummy) == -1) {\n    perror (rw->name);\n    exit (EXIT_FAILURE);\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void usb_deregister_dev(struct usb_interface *intf,\n\t\t\tstruct usb_class_driver *class_driver)\n{\n\tif (intf->minor == -1)\n\t\treturn;\n\n\tdev_dbg(&intf->dev, \"removing %d minor\\n\", intf->minor);\n\n\tdown_write(&minor_rwsem);\n\tusb_minors[intf->minor] = NULL;\n\tup_write(&minor_rwsem);\n\n\tdevice_destroy(usb_class->class, MKDEV(USB_MAJOR, intf->minor));\n\tintf->usb_dev = NULL;\n\tintf->minor = -1;\n\tdestroy_usb_class();\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static zend_bool php_auto_globals_create_post(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *vars;\n\n\tif (PG(variables_order) &&\n\t\t\t(strchr(PG(variables_order),'P') || strchr(PG(variables_order),'p')) &&\n\t\t!SG(headers_sent) &&\n\t\tSG(request_info).request_method &&\n\t\t!strcasecmp(SG(request_info).request_method, \"POST\")) {\n\t\tsapi_module.treat_data(PARSE_POST, NULL, NULL TSRMLS_CC);\n\t\tvars = PG(http_globals)[TRACK_VARS_POST];\n\t} else {\n\t\tALLOC_ZVAL(vars);\n\t\tarray_init(vars);\n\t\tINIT_PZVAL(vars);\n\t\tif (PG(http_globals)[TRACK_VARS_POST]) {\n\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_POST]);\n\t\t}\n\t\tPG(http_globals)[TRACK_VARS_POST] = vars;\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);\n\tZ_ADDREF_P(vars);\n\t\n\treturn 0; /* don't rearm */\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static long ioctl_file_clone(struct file *dst_file, unsigned long srcfd,\n\t\t\t     u64 off, u64 olen, u64 destoff)\n{\n\tstruct fd src_file = fdget(srcfd);\n\tint ret;\n\n\tif (!src_file.file)\n\t\treturn -EBADF;\n\tret = vfs_clone_file_range(src_file.file, off, dst_file, destoff, olen);\n\tfdput(src_file);\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int aa_probe(const AVProbeData *p)\n{\n    uint8_t *buf = p->buf;\n\n    if (AV_RB32(buf+4) != AA_MAGIC)\n        return 0;\n\n    return AVPROBE_SCORE_MAX / 2;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "SPL_METHOD(DirectoryIterator, valid)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(intern->u.dir.entry.d_name[0] != '\\0');\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void *clone_func(void *arg)\n\n{\n\n    new_thread_info *info = arg;\n\n    CPUArchState *env;\n\n    CPUState *cpu;\n\n    TaskState *ts;\n\n\n\n    rcu_register_thread();\n\n    env = info->env;\n\n    cpu = ENV_GET_CPU(env);\n\n    thread_cpu = cpu;\n\n    ts = (TaskState *)cpu->opaque;\n\n    info->tid = gettid();\n\n    cpu->host_tid = info->tid;\n\n    task_settid(ts);\n\n    if (info->child_tidptr)\n\n        put_user_u32(info->tid, info->child_tidptr);\n\n    if (info->parent_tidptr)\n\n        put_user_u32(info->tid, info->parent_tidptr);\n\n    /* Enable signals.  */\n\n    sigprocmask(SIG_SETMASK, &info->sigmask, NULL);\n\n    /* Signal to the parent that we're ready.  */\n\n    pthread_mutex_lock(&info->mutex);\n\n    pthread_cond_broadcast(&info->cond);\n\n    pthread_mutex_unlock(&info->mutex);\n\n    /* Wait until the parent has finshed initializing the tls state.  */\n\n    pthread_mutex_lock(&clone_lock);\n\n    pthread_mutex_unlock(&clone_lock);\n\n    cpu_loop(env);\n\n    /* never exits */\n\n    return NULL;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int write_all(int fd, const void *buf, int nr_bytes)\n{\n\tint block, offset = 0;\n\tchar *buffer = (char *) buf;\n\n\twhile (nr_bytes > 0) {\n\t\tblock = write(fd, &buffer[offset], nr_bytes);\n\n\t\tif (block < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn block;\n\t\t}\n\t\tif (block == 0)\n\t\t\treturn offset;\n\n\t\toffset += block;\n\t\tnr_bytes -= block;\n\t}\n\n\treturn offset;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "evdns_server_request_add_cname_reply(struct evdns_server_request *req, const char *name, const char *cname, int ttl)\n{\n\treturn evdns_server_request_add_reply(\n\t\t  req, EVDNS_ANSWER_SECTION, name, TYPE_CNAME, CLASS_INET,\n\t\t  ttl, -1, 1, cname);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "tile_make_weights (PixopsFilterDimension *dim,\n\t\t   double                 scale)\n{\n  int n = ceil (1 / scale + 1);\n  double *pixel_weights = g_new (double, SUBSAMPLE * n);\n  int offset;\n  int i;\n\n  dim->n = n;\n  dim->offset = 0;\n  dim->weights = pixel_weights;\n\n  for (offset = 0; offset < SUBSAMPLE; offset++)\n    {\n      double x = (double)offset / SUBSAMPLE;\n      double a = x + 1 / scale;\n\n      for (i = 0; i < n; i++)\n        {\n          if (i < x)\n            {\n              if (i + 1 > x)\n                *(pixel_weights++)  = (MIN (i + 1, a) - x) * scale;\n              else\n                *(pixel_weights++) = 0;\n            }\n          else\n            {\n              if (a > i)\n                *(pixel_weights++)  = (MIN (i + 1, a) - i) * scale;\n              else\n                *(pixel_weights++) = 0;\n            }\n       }\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int qcow2_check(BlockDriverState *bs, BdrvCheckResult *result,\n\n                       BdrvCheckMode fix)\n\n{\n\n    int ret = qcow2_check_refcounts(bs, result, fix);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (fix && result->check_errors == 0 && result->corruptions == 0) {\n\n        return qcow2_mark_clean(bs);\n\n    }\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline void FixupUsername(const std::string& text,\n                                 const url_parse::Component& part,\n                                 std::string* url) {\n  if (!part.is_valid())\n    return;\n\n  url->append(text, part.begin, part.len);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void virtio_blk_handle_read(VirtIOBlockReq *req)\n\n{\n\n    BlockDriverAIOCB *acb;\n\n    uint64_t sector;\n\n\n\n    sector = ldq_p(&req->out->sector);\n\n\n\n    if (sector & req->dev->sector_mask) {\n\n\n\n\n\n\n\n\n\n\n    acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov,\n\n                         req->qiov.size / BDRV_SECTOR_SIZE,\n\n                         virtio_blk_rw_complete, req);\n\n    if (!acb) {\n\n\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "pci_emul_dinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)\n{\n\tint error;\n\tstruct pci_emul_dummy *dummy;\n\n\tdummy = calloc(1, sizeof(struct pci_emul_dummy));\n\n\tdev->arg = dummy;\n\n\tpci_set_cfgdata16(dev, PCIR_DEVICE, 0x0001);\n\tpci_set_cfgdata16(dev, PCIR_VENDOR, 0x10DD);\n\tpci_set_cfgdata8(dev, PCIR_CLASS, 0x02);\n\n\terror = pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS);\n\tassert(error == 0);\n\n\terror = pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ);\n\tassert(error == 0);\n\n\terror = pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\n\terror = pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static unsigned int inf() { return max(); }\n      static unsigned int cut(const double val) {",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "bool wsrep_sst_receive_address_update(sys_var *, THD *, enum_var_type) {\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void* Type_Measurement_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n     return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsICCMeasurementConditions));\n\n     cmsUNUSED_PARAMETER(n);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int crc32_pclmul_cra_init(struct crypto_tfm *tfm)\n{\n\tu32 *key = crypto_tfm_ctx(tfm);\n\n\t*key = 0;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "usm_lookup_alg_type(const char *str, usm_alg_type_t *types)\n{\n    int i, l;\n    l = strlen(str);\n    for (i = 0; types[i].label; ++i) {\n        if (0 == strncasecmp(types[i].label, str, l))\n            return types[i].value;\n    }\n\n    return -1;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool ShouldUseMojoChannel() {\n  return CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableRendererMojoChannel);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "BitStream::reset()\n{\n    p = start;\n    bit_offset = 7;\n    if (static_cast<unsigned int>(nbytes) > static_cast<unsigned int>(-1) / 8)\n    {\n\tthrow std::runtime_error(\"array too large for bitstream\");\n    }\n    bits_available = 8 * nbytes;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "Ins_AND( INS_ARG )\n  {\n    DO_AND\n  }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "fmtfloat(double value, char type, int forcesign, int leftjust,\n\t\t int minlen, int zpad, int precision, int pointflag,\n\t\t PrintfTarget *target)\n{\n\tint\t\t\tsignvalue = 0;\n\tint\t\t\tvallen;\n\tchar\t\tfmt[32];\n\tchar\t\tconvert[512];\n\tint\t\t\tpadlen = 0;\t\t/* amount to pad */\n\n\t/* we rely on regular C library's sprintf to do the basic conversion */\n\tif (pointflag)\n\t\tsprintf(fmt, \"%%.%d%c\", precision, type);\n\telse\n\t\tsprintf(fmt, \"%%%c\", type);\n\n\tif (adjust_sign((value < 0), forcesign, &signvalue))\n\t\tvalue = -value;\n\n\tvallen = sprintf(convert, fmt, value);\n\n\tadjust_padlen(minlen, vallen, leftjust, &padlen);\n\n\tleading_pad(zpad, &signvalue, &padlen, target);\n\n\tdostr(convert, vallen, target);\n\n\ttrailing_pad(&padlen, target);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void multi_stop_rx(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\n\tmtpt->ier &= ~UART_IER_RLSI;\n\tmtpt->port.read_status_mask &= ~UART_LSR_DR;\n\tserial_out(mtpt, UART_IER, mtpt->ier);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void unit_unwatch_bus_name(Unit *u, const char *name) {\n        assert(u);\n        assert(name);\n\n        hashmap_remove_value(u->manager->watch_bus, name, u);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static gboolean fd_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    FDCharDriver *s = chr->opaque;\n\n    int len;\n\n    uint8_t buf[READ_BUF_LEN];\n\n    GIOStatus status;\n\n    gsize bytes_read;\n\n\n\n    len = sizeof(buf);\n\n    if (len > s->max_size) {\n\n        len = s->max_size;\n\n    }\n\n    if (len == 0) {\n\n        return TRUE;\n\n    }\n\n\n\n    status = g_io_channel_read_chars(chan, (gchar *)buf,\n\n                                     len, &bytes_read, NULL);\n\n    if (status == G_IO_STATUS_EOF) {\n\n        if (s->fd_in_tag) {\n\n            g_source_remove(s->fd_in_tag);\n\n            s->fd_in_tag = 0;\n\n        }\n\n        qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n        return FALSE;\n\n    }\n\n    if (status == G_IO_STATUS_NORMAL) {\n\n        qemu_chr_be_write(chr, buf, bytes_read);\n\n    }\n\n\n\n    return TRUE;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int match_entries(struct entry *entry1, struct entry *entry2)\n{\n\treturn entry1->timer       == entry2->timer\t  &&\n\t       entry1->start_func  == entry2->start_func  &&\n\t       entry1->expire_func == entry2->expire_func &&\n\t       entry1->pid\t   == entry2->pid;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int dccp_setsockopt_change(struct sock *sk, int type,\n\t\t\t\t  struct dccp_so_feat __user *optval)\n{\n\tstruct dccp_so_feat opt;\n\tu8 *val;\n\tint rc;\n\n\tif (copy_from_user(&opt, optval, sizeof(opt)))\n\t\treturn -EFAULT;\n\n\tval = kmalloc(opt.dccpsf_len, GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(val, opt.dccpsf_val, opt.dccpsf_len)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free_val;\n\t}\n\n\trc = dccp_feat_change(dccp_msk(sk), type, opt.dccpsf_feat,\n\t\t\t      val, opt.dccpsf_len, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out_free_val;\n\nout:\n\treturn rc;\n\nout_free_val:\n\tkfree(val);\n\tgoto out;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\n\tStream_Write_UINT16(s, fields->Len); /* Len (2 bytes) */\n\tStream_Write_UINT16(s, fields->MaxLen); /* MaxLen (2 bytes) */\n\tStream_Write_UINT32(s, fields->BufferOffset); /* BufferOffset (4 bytes) */\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int __netlink_deliver_tap_skb(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct sk_buff *nskb;\n\tstruct sock *sk = skb->sk;\n\tint ret = -ENOMEM;\n\n\tdev_hold(dev);\n\n\tif (is_vmalloc_addr(skb->head))\n\t\tnskb = netlink_to_full_skb(skb, GFP_ATOMIC);\n\telse\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (nskb) {\n\t\tnskb->dev = dev;\n\t\tnskb->protocol = htons((u16) sk->sk_protocol);\n\t\tnskb->pkt_type = netlink_is_kernel(sk) ?\n\t\t\t\t PACKET_KERNEL : PACKET_USER;\n\t\tskb_reset_network_header(nskb);\n\t\tret = dev_queue_xmit(nskb);\n\t\tif (unlikely(ret > 0))\n\t\t\tret = net_xmit_errno(ret);\n\t}\n\n\tdev_put(dev);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int mmu_topup_memory_cache(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t  struct kmem_cache *base_cache, int min)\n{\n\tvoid *obj;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tobj = kmem_cache_zalloc(base_cache, GFP_KERNEL);\n\t\tif (!obj)\n\t\t\treturn -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = obj;\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void rds_inc_init(struct rds_incoming *inc, struct rds_connection *conn,\n\t\t struct in6_addr *saddr)\n{\n\trefcount_set(&inc->i_refcount, 1);\n\tINIT_LIST_HEAD(&inc->i_item);\n\tinc->i_conn = conn;\n\tinc->i_saddr = *saddr;\n\tinc->i_rdma_cookie = 0;\n\tinc->i_rx_tstamp = ktime_set(0, 0);\n\n\tmemset(inc->i_rx_lat_trace, 0, sizeof(inc->i_rx_lat_trace));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "symbol_check_defined (symbol *sym)\n{\n  sym_content *s = sym->content;\n  if (s->class == unknown_sym || s->class == pct_type_sym)\n    {\n      complain_symbol_undeclared (sym);\n      s->class = nterm_sym;\n      s->number = nnterms++;\n    }\n\n  if (s->class == token_sym\n      && sym->tag[0] == '\"'\n      && !sym->is_alias)\n    complain (&sym->location, Wdangling_alias,\n              _(\"string literal %s not attached to a symbol\"),\n              sym->tag);\n\n  for (int i = 0; i < 2; ++i)\n    symbol_code_props_get (sym, i)->is_used = true;\n\n  /* Set the semantic type status associated to the current symbol to\n     'declared' so that we could check semantic types unnecessary uses. */\n  if (s->type_name)\n    {\n      semantic_type *sem_type = semantic_type_get (s->type_name, NULL);\n      if (sem_type)\n        sem_type->status = declared;\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void gen_cli(DisasContext *ctx)\n\n{\n\n    /* Cache line invalidate: privileged and treated as no-op */\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n#endif\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "std::string get_short_wml_path(const std::string &filename)\n{\n\tpath full_path(filename);\n\n\tpath partial = subtract_path(full_path, get_user_data_path() / \"data\");\n\tif (!partial.empty())\n\t\treturn \"~\" + partial.string();\n\n\tpartial = subtract_path(full_path, path(game_config::path) / \"data\");\n\tif (!partial.empty())\n\t\treturn partial.string();\n\n\treturn filename;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "get_raw_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format files with maxval = MAXJSAMPLE.\n * In this case we just read right into the JSAMPLE buffer!\n * Note that same code works for PPM and PGM files.\n */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int __mdiobus_register(struct mii_bus *bus, struct module *owner)\n{\n\tstruct mdio_device *mdiodev;\n\tint i, err;\n\tstruct gpio_desc *gpiod;\n\n\tif (NULL == bus || NULL == bus->name ||\n\t    NULL == bus->read || NULL == bus->write)\n\t\treturn -EINVAL;\n\n\tBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\n\t       bus->state != MDIOBUS_UNREGISTERED);\n\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\n \terr = device_register(&bus->dev);\n \tif (err) {\n \t\tpr_err(\"mii_bus %s failed to register\\n\", bus->id);\n\t\tput_device(&bus->dev);\n \t\treturn -EINVAL;\n \t}\n \n\tmutex_init(&bus->mdio_lock);\n\n\t/* de-assert bus level PHY GPIO reset */\n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\",\n\t\t\tbus->id);\n\t\tdevice_del(&bus->dev);\n\t\treturn PTR_ERR(gpiod);\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\n\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\tudelay(bus->reset_delay_us);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t}\n\n\tif (bus->reset)\n\t\tbus->reset(bus);\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & (1 << i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\n\t\t\tphydev = mdiobus_scan(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {\n\t\t\t\terr = PTR_ERR(phydev);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\n\n\tbus->state = MDIOBUS_REGISTERED;\n\tpr_info(\"%s: probed\\n\", bus->name);\n\treturn 0;\n\nerror:\n\twhile (--i >= 0) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t/* Put PHYs in RESET to save power */\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int __kvm_io_bus_write(struct kvm_io_bus *bus,\n\t\t\t      struct kvm_io_range *range, const void *val)\n{\n\tint idx;\n\n\tidx = kvm_io_bus_get_first_dev(bus, range->addr, range->len);\n\tif (idx < 0)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (idx < bus->dev_count &&\n\t\tkvm_io_bus_cmp(range, &bus->range[idx]) == 0) {\n\t\tif (!kvm_iodevice_write(bus->range[idx].dev, range->addr,\n\t\t\t\t\trange->len, val))\n\t\t\treturn idx;\n\t\tidx++;\n\t}\n\n\treturn -EOPNOTSUPP;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void tftp_input(struct sockaddr_storage *srcsas, struct mbuf *m)\n{\n    struct tftp_t *tp = mtod_check(m, offsetof(struct tftp_t, x.tp_buf));\n\n    if (tp == NULL) {\n        return;\n    }\n\n    switch (ntohs(tp->tp_op)) {\n    case TFTP_RRQ:\n        tftp_handle_rrq(m->slirp, srcsas, tp, m->m_len);\n        break;\n\n    case TFTP_ACK:\n        tftp_handle_ack(m->slirp, srcsas, tp, m->m_len);\n        break;\n\n    case TFTP_ERROR:\n        tftp_handle_error(m->slirp, srcsas, tp, m->m_len);\n        break;\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static QVirtioPCIDevice *virtio_blk_pci_init(QPCIBus *bus, int slot)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n\n\n    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_BLOCK);\n\n    g_assert(dev != NULL);\n\n    g_assert_cmphex(dev->vdev.device_type, ==, VIRTIO_ID_BLOCK);\n\n    g_assert_cmphex(dev->pdev->devfn, ==, ((slot << 3) | PCI_FN));\n\n\n\n    qvirtio_pci_device_enable(dev);\n\n    qvirtio_reset(&dev->vdev);\n\n    qvirtio_set_acknowledge(&dev->vdev);\n\n    qvirtio_set_driver(&dev->vdev);\n\n\n\n    return dev;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static X509_STORE *init_revocation_store(EAP_TLS_CONF *conf)\n{\n\tX509_STORE *store = NULL;\n\n\tstore = X509_STORE_new();\n\n\t/* Load the CAs we trust */\n        if (conf->ca_file || conf->ca_path)\n\t\tif(!X509_STORE_load_locations(store, conf->ca_file, conf->ca_path)) {\n\t\t\tradlog(L_ERR, \"rlm_eap: X509_STORE error %s\", ERR_error_string(ERR_get_error(), NULL));\n\t\t\tradlog(L_ERR, \"rlm_eap_tls: Error reading Trusted root CA list %s\",conf->ca_file );\n\t\t\treturn NULL;\n\t\t}\n\n#ifdef X509_V_FLAG_CRL_CHECK\n\tif (conf->check_crl)\n\t\tX509_STORE_set_flags(store, X509_V_FLAG_CRL_CHECK);\n#endif\n\treturn store;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "LEX_CSTRING *handler::engine_name()\n{\n  return hton_name(ht);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void HTMLInputElement::setHeight(unsigned height)\n{\n    setUnsignedIntegralAttribute(heightAttr, height);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "ErrorCode HTTP2Codec::parseCertificateRequest(Cursor& cursor) {\n  VLOG(4) << \"parsing CERTIFICATE_REQUEST frame length=\" << curHeader_.length;\n  uint16_t requestId = 0;\n  std::unique_ptr<IOBuf> authRequest;\n\n  auto err = http2::parseCertificateRequest(\n      cursor, curHeader_, requestId, authRequest);\n  RETURN_IF_ERROR(err);\n  if (callback_) {\n    callback_->onCertificateRequest(requestId, std::move(authRequest));\n  }\n  return ErrorCode::NO_ERROR;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = iocb->private;\n\tstruct workqueue_struct *wq;\n\n\t/* if not async direct IO or dio with 0 bytes write, just return */\n\tif (!io_end || !size)\n\t\treturn;\n\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p\"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %llu\\n\",\n \t\t  iocb->private, io_end->inode->i_ino, iocb, offset,\n\t\t  size);\n\n\t/* if not aio dio with unwritten extents, just free io and return */\n\tif (io_end->flag != EXT4_IO_UNWRITTEN){\n\t\text4_free_io_end(io_end);\n\t\tiocb->private = NULL;\n\t\treturn;\n\t}\n\n\tio_end->offset = offset;\n\tio_end->size = size;\n\twq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;\n\n\t/* queue the work to convert unwritten extents to written */\n\tqueue_work(wq, &io_end->work);\n\n\t/* Add the io_end to per-inode completed aio dio list*/\n\tlist_add_tail(&io_end->list,\n\t\t &EXT4_I(io_end->inode)->i_completed_io_list);\n\tiocb->private = NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void RenderWidgetHostImpl::ForwardTouchEventWithLatencyInfo(\n    const blink::WebTouchEvent& touch_event,\n    const ui::LatencyInfo& latency) {\n  TRACE_EVENT0(\"input\", \"RenderWidgetHostImpl::ForwardTouchEvent\");\n\n\n  TouchEventWithLatencyInfo touch_with_latency(touch_event, latency);\n  DispatchInputEventWithLatencyInfo(touch_event, &touch_with_latency.latency);\n  input_router_->SendTouchEvent(touch_with_latency);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int main(int argc, char *argv[])\n\n{\n\n    g_test_init(&argc, &argv, NULL);\n\n\n\n    qtest_add_func(\"qmp/protocol\", test_qmp_protocol);\n\n\n\n    return g_test_run();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "PermissionRequestGestureType PermissionUtil::GetGestureType(bool user_gesture) {\n  return user_gesture ? PermissionRequestGestureType::GESTURE\n                      : PermissionRequestGestureType::NO_GESTURE;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static unsigned get_num_discard_bios(struct dm_target *ti)\n{\n\treturn ti->num_discard_bios;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "rsvg_drawing_ctx_free (RsvgDrawingCtx * handle)\n{\n    rsvg_render_free (handle->render);\n\n    rsvg_state_free_all (handle->state);\n\n\t/* the drawsub stack's nodes are owned by the ->defs */\n\tg_slist_free (handle->drawsub_stack);\n\n    g_slist_free (handle->ptrs);\n\t\n    if (handle->base_uri)\n        g_free (handle->base_uri);\n\n    if (handle->pango_context != NULL)\n        g_object_unref (handle->pango_context);\n\n    g_free (handle);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "size_t choice() const { return choice_; }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int mg_base64_encode(const unsigned char *p, int n, char *to) {\n  int i, len = 0;\n  for (i = 0; i < n; i++) len = mg_base64_update(p[i], to, len);\n  len = mg_base64_final(to, len);\n  return len;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ext4_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "long tg_get_cfs_period(struct task_group *tg)\n{\n\tu64 cfs_period_us;\n\n\tcfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);\n\tdo_div(cfs_period_us, NSEC_PER_USEC);\n\n\treturn cfs_period_us;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void OPPROTO op_divw_AX_T0(void)\n\n{\n\n    unsigned int num, den, q, r;\n\n\n\n    num = (EAX & 0xffff) | ((EDX & 0xffff) << 16);\n\n    den = (T0 & 0xffff);\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n    q = (num / den) & 0xffff;\n\n    r = (num % den) & 0xffff;\n\n    EAX = (EAX & ~0xffff) | q;\n\n    EDX = (EDX & ~0xffff) | r;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void sasl_fail(IRC_SERVER_REC *server, const char *data, const char *from)\n{\n\tchar *params, *error;\n\n\t/* Stop any pending timeout, if any */\n\tif (server->sasl_timeout != 0) {\n\t\tg_source_remove(server->sasl_timeout);\n\t\tserver->sasl_timeout = 0;\n\t}\n\n\tparams = event_get_params(data, 2, NULL, &error);\n\n\tserver->sasl_success = FALSE;\n\n\tsignal_emit(\"server sasl failure\", 2, server, error);\n\n\t/* Terminate the negotiation */\n\tcap_finish_negotiation(server);\n\n\tg_free(params);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "init_nodelist(void)\n{\n  if (PREDICT_UNLIKELY(the_nodelist == NULL)) {\n    the_nodelist = tor_malloc_zero(sizeof(nodelist_t));\n    HT_INIT(nodelist_map, &the_nodelist->nodes_by_id);\n    the_nodelist->nodes = smartlist_new();\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "Ins_POP( void )\n  {\n    /* nothing to do */\n  }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int nfs3svc_decode_getaclargs(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_getaclargs *args)\n{\n\tp = nfs3svc_decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->mask = ntohl(*p); p++;\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void RenderWidgetHostImpl::SendScreenRects() {\n  if (!renderer_initialized_ || waiting_for_screen_rects_ack_)\n    return;\n\n  if (is_hidden_) {\n    return;\n  }\n\n  if (!view_)\n    return;\n\n  last_view_screen_rect_ = view_->GetViewBounds();\n  last_window_screen_rect_ = view_->GetBoundsInRootWindow();\n  view_->WillSendScreenRects();\n  Send(new ViewMsg_UpdateScreenRects(\n      GetRoutingID(), last_view_screen_rect_, last_window_screen_rect_));\n  waiting_for_screen_rects_ack_ = true;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void ChromotingInstance::PostChromotingMessage(\n    const std::string& method,\n    scoped_ptr<base::DictionaryValue> data) {\n  scoped_ptr<base::DictionaryValue> message(new base::DictionaryValue());\n  message->SetString(\"method\", method);\n  message->Set(\"data\", data.release());\n\n  std::string message_json;\n  base::JSONWriter::Write(message.get(), &message_json);\n  PostMessage(pp::Var(message_json));\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int get_float64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    float64 *v = pv;\n\n\n\n    *v = make_float64(qemu_get_be64(f));\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int read_len_table(uint8_t *dst, GetBitContext *gb){\n\n    int i, val, repeat;\n\n\n\n    for(i=0; i<256;){\n\n        repeat= get_bits(gb, 3);\n\n        val   = get_bits(gb, 5);\n\n        if(repeat==0)\n\n            repeat= get_bits(gb, 8);\n\n//printf(\"%d %d\\n\", val, repeat);\n\n        if(i+repeat > 256) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Error reading huffman table\\n\");\n\n            return -1;\n\n        }\n\n        while (repeat--)\n\n            dst[i++] = val;\n\n    }\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void __devinit init_hrtimers_cpu(int cpu)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tspin_lock_init(&cpu_base->lock);\n\tlockdep_set_class(&cpu_base->lock, &cpu_base->lock_key);\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++)\n\t\tcpu_base->clock_base[i].cpu_base = cpu_base;\n\n\thrtimer_init_hres(cpu_base);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void writeVector(Parcel &data, Vector<uint8_t> const &vector) const {\n        data.writeInt32(vector.size());\n        data.write(vector.array(), vector.size());\n }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\n\t\t\t  unsigned long cl,\n\t\t\t  u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = q->handle;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = 0;\n\tNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\n\tif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t qdisc_root_sleeping_lock(q), &d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "mrb_alias_method(mrb_state *mrb, struct RClass *c, mrb_sym a, mrb_sym b)\n{\n  mrb_method_t m = mrb_method_search(mrb, c, b);\n\n  mrb_define_method_raw(mrb, c, a, m);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int x_stat(const char *fname, STRUCT_STAT *fst, STRUCT_STAT *xst)\n{\n\tint ret = do_stat(fname, fst);\n\tif ((ret < 0 || get_stat_xattr(fname, -1, fst, xst) < 0) && xst)\n\t\txst->st_mode = 0;\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void *usb_alloc_coherent(struct usb_device *dev, size_t size, gfp_t mem_flags,\n\t\t\t dma_addr_t *dma)\n{\n\tif (!dev || !dev->bus)\n\t\treturn NULL;\n\treturn hcd_buffer_alloc(dev->bus, size, mem_flags, dma);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void gs_usb_xmit_callback(struct urb *urb)\n{\n\tstruct gs_tx_context *txc = urb->context;\n\tstruct gs_can *dev = txc->dev;\n\tstruct net_device *netdev = dev->netdev;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"usb xmit fail %d\\n\", txc->echo_id);\n\n\tusb_free_coherent(urb->dev,\n\t\t\t  urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer,\n\t\t\t  urb->transfer_dma);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static Jsi_OpCodes *code_delete(int n) { JSI_NEW_CODES(0,OP_DELETE, n); }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void bdev_set_nr_sectors(struct block_device *bdev, sector_t sectors)\n{\n\tspin_lock(&bdev->bd_size_lock);\n\ti_size_write(bdev->bd_inode, (loff_t)sectors << SECTOR_SHIFT);\n\tspin_unlock(&bdev->bd_size_lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ssize_t Http2Session::OnMaxFrameSizePadding(size_t frameLen,\n                                            size_t maxPayloadLen) {\n  Debug(this, \"using max frame size padding: %d\", maxPayloadLen);\n  return maxPayloadLen;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int sqlite3SelectWalkFail(Walker *pWalker, Select *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  pWalker->eCode = 0;\n  return WRC_Abort;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "RList *r_bin_wasm_get_datas (RBinWasmObj *bin) {\n\tRBinWasmSection *data = NULL;\n\tRList *datas = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_datas) {\n\t\treturn bin->g_datas;\n\t}\n\n\tif (!(datas = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_DATA))) {\n\t\treturn r_list_new();\n\t}\n\n\tif (!(data = (RBinWasmSection*) r_list_first (datas))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_datas = r_bin_wasm_get_data_entries (bin, data);\n\n\treturn bin->g_datas;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static BOOL update_read_multi_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                   MULTI_DRAW_NINE_GRID_ORDER* multi_draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, multi_draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, multi_draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, multi_draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, multi_draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, multi_draw_nine_grid->bitmapId);\n\tORDER_FIELD_BYTE(6, multi_draw_nine_grid->nDeltaEntries);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_draw_nine_grid->cbData);\n\t\treturn update_read_delta_rects(s, multi_draw_nine_grid->rectangles,\n\t\t                               multi_draw_nine_grid->nDeltaEntries);\n\t}\n\n\treturn TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void lsr_read_calc_mode(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 v;\n\t/*SMIL_CALCMODE_LINEAR is default and 0 in our code*/\n\tGF_LSR_READ_INT(lsr, v, 1, \"has_calcMode\");\n\tif (v) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_calcMode, GF_TRUE, GF_FALSE, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SMIL_CalcMode*)info.far_ptr, 2, \"calcMode\");\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "main (int argc, char **argv)\n{\tSTATE state ;\n\tSF_INFO sfinfo ;\n\tchar pathname [512], ext [32], *cptr ;\n\tint ch, double_split ;\n\n\tif (argc != 2)\n\t{\tif (argc != 1)\n\t\t\tputs (\"\\nError : need a single input file.\\n\") ;\n\t\tusage_exit () ;\n\t\t} ;\n\n\tmemset (&state, 0, sizeof (state)) ;\n\tmemset (&sfinfo, 0, sizeof (sfinfo)) ;\n\n\tif ((state.infile = sf_open (argv [1], SFM_READ, &sfinfo)) == NULL)\n\t{\tprintf (\"\\nError : Not able to open input file '%s'\\n%s\\n\", argv [1], sf_strerror (NULL)) ;\n\t\texit (1) ;\n\t\t} ;\n\n\tif (sfinfo.channels < 2)\n\t{\tprintf (\"\\nError : Input file '%s' only has one channel.\\n\", argv [1]) ;\n\t\texit (1) ;\n\t\t} ;\n\n\tstate.channels = sfinfo.channels ;\n\tsfinfo.channels = 1 ;\n\n\tif (snprintf (pathname, sizeof (pathname), \"%s\", argv [1]) > (int) sizeof (pathname))\n\t{\tprintf (\"\\nError : Length of provided filename '%s' exceeds MAX_PATH (%d).\\n\", argv [1], (int) sizeof (pathname)) ;\n\t\texit (1) ;\n\t\t} ;\n\n\tif ((cptr = strrchr (pathname, '.')) == NULL)\n\t\text [0] = 0 ;\n\telse\n\t{\tsnprintf (ext, sizeof (ext), \"%s\", cptr) ;\n\t\tcptr [0] = 0 ;\n\t\t} ;\n\n\tprintf (\"Input file : %s\\n\", pathname) ;\n\tputs (\"Output files :\") ;\n\n\tfor (ch = 0 ; ch < state.channels ; ch++)\n\t{\tchar filename [520] ;\n\n\t\tsnprintf (filename, sizeof (filename), \"%s_%02d%s\", pathname, ch, ext) ;\n\n\t\tif ((state.outfile [ch] = sf_open (filename, SFM_WRITE, &sfinfo)) == NULL)\n\t\t{\tprintf (\"Not able to open output file '%s'\\n%s\\n\", filename, sf_strerror (NULL)) ;\n\t\t\texit (1) ;\n\t\t\t} ;\n\n\t\tprintf (\"    %s\\n\", filename) ;\n\t\t} ;\n\n\tswitch (sfinfo.format & SF_FORMAT_SUBMASK)\n\t{\tcase SF_FORMAT_FLOAT :\n\t\tcase SF_FORMAT_DOUBLE :\n\t\tcase SF_FORMAT_VORBIS :\n\t\t\tdouble_split = 1 ;\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tdouble_split = 0 ;\n\t\t\tbreak ;\n\t\t} ;\n\n\tif (double_split)\n\t\tdeinterleave_double (&state) ;\n\telse\n\t\tdeinterleave_int (&state) ;\n\n\tsf_close (state.infile) ;\n\tfor (ch = 0 ; ch < MAX_CHANNELS ; ch++)\n\t\tif (state.outfile [ch] != NULL)\n\t\t\tsf_close (state.outfile [ch]) ;\n\n\treturn 0 ;\n} /* main */",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "TestTransactionConsumer::TestTransactionConsumer(\n    RequestPriority priority,\n    HttpTransactionFactory* factory)\n    : state_(IDLE), error_(OK) {\n  factory->CreateTransaction(priority, &trans_);\n  ++quit_counter_;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void string_output_append(StringOutputVisitor *sov, int64_t a)\n\n{\n\n    Range *r = g_malloc0(sizeof(*r));\n\n    r->begin = a;\n\n    r->end = a + 1;\n\n    sov->ranges = g_list_insert_sorted_merged(sov->ranges, r, range_compare);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "BGD_DECLARE(void *) gdImageGd2Ptr (gdImagePtr im, int cs, int fmt, int *size)\n{\n\t_noLibzError();\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "ip_printroute(netdissect_options *ndo,\n               register const u_char *cp, u_int length)\n {\n\tregister u_int ptr;\n\tregister u_int len;\n \n \tif (length < 3) {\n \t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\t\treturn;\n \t}\n \tif ((length + 1) & 3)\n \t\tND_PRINT((ndo, \" [bad length %u]\", length));\n \tptr = cp[2] - 1;\n \tif (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)\n \t\tND_PRINT((ndo, \" [bad ptr %u]\", cp[2]));\n \n \tfor (len = 3; len < length; len += 4) {\n \t\tND_PRINT((ndo, \" %s\", ipaddr_string(ndo, &cp[len])));\n \t\tif (ptr > len)\n \t\t\tND_PRINT((ndo, \",\"));\n \t}\n }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static gboolean\nis_sre_type_builder (MonoClass *class)\n{\n\treturn FALSE;",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static char *getpin(const char *prompt)\n{\n\tchar *buf, pass[20];\n\tint i;\n\n\tprintf(\"%s\", prompt);\n\tfflush(stdout);\n\tif (fgets(pass, 20, stdin) == NULL)\n\t\treturn NULL;\n\tfor (i = 0; i < 20; i++)\n\t\tif (pass[i] == '\\n')\n\t\t\tpass[i] = 0;\n\tif (strlen(pass) == 0)\n\t\treturn NULL;\n\tbuf = malloc(8);\n\tif (buf == NULL)\n\t\treturn NULL;\n\tif (strlen(pass) > 8) {\n\t\tfprintf(stderr, \"PIN code too long.\\n\");\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tmemset(buf, 0, 8);\n\tstrlcpy(buf, pass, 8);\n\treturn buf;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline cputime_t virt_ticks(struct task_struct *p)\n{\n\treturn p->utime;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "  QInt32() {}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline bool isOMXError(int32_t err) {\n return (ERROR_CODEC_MIN <= err && err <= ERROR_CODEC_MAX);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void vnc_tls_client_cleanup(VncState *vs)\n\n{\n\n    if (vs->tls.session) {\n\n        gnutls_deinit(vs->tls.session);\n\n        vs->tls.session = NULL;\n\n    }\n\n    g_free(vs->tls.dname);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "hb_set_union (hb_set_t       *set,\n\t      const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->union_ (*other);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "DLLEXPORT unsigned long DLLCALL tjPlaneSizeYUV(int componentID, int width,\n\tint stride, int height, int subsamp)\n{\n\tunsigned long retval=0;\n\tint pw, ph;\n\n\tif(width<1 || height<1 || subsamp<0 || subsamp>=NUMSUBOPT)\n\t\t_throwg(\"tjPlaneSizeYUV(): Invalid argument\");\n\n\tpw=tjPlaneWidth(componentID, width, subsamp);\n\tph=tjPlaneHeight(componentID, height, subsamp);\n\tif(pw<0 || ph<0) return -1;\n\n\tif(stride==0) stride=pw;\n\telse stride=abs(stride);\n\n\tretval=stride*(ph-1)+pw;\n\n\tbailout:\n\treturn retval;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tint start, end, count, soff;\n\n\tif (!lines) {\n\t\tvgacon_restore_screen(c);\n\t\treturn;\n\t}\n\n\tif (!vgacon_scrollback_cur->data)\n\t\treturn;\n\n\tif (!vgacon_scrollback_cur->save) {\n\t\tvgacon_cursor(c, CM_ERASE);\n\t\tvgacon_save_screen(c);\n\t\tc->vc_origin = (unsigned long)c->vc_screenbuf;\n\t\tvgacon_scrollback_cur->save = 1;\n\t}\n\n\tvgacon_scrollback_cur->restore = 0;\n\tstart = vgacon_scrollback_cur->cur + lines;\n\tend = start + abs(lines);\n\n\tif (start < 0)\n\t\tstart = 0;\n\n\tif (start > vgacon_scrollback_cur->cnt)\n\t\tstart = vgacon_scrollback_cur->cnt;\n\n\tif (end < 0)\n\t\tend = 0;\n\n\tif (end > vgacon_scrollback_cur->cnt)\n\t\tend = vgacon_scrollback_cur->cnt;\n\n\tvgacon_scrollback_cur->cur = start;\n\tcount = end - start;\n\tsoff = vgacon_scrollback_cur->tail -\n\t\t((vgacon_scrollback_cur->cnt - end) * c->vc_size_row);\n\tsoff -= count * c->vc_size_row;\n\n\tif (soff < 0)\n\t\tsoff += vgacon_scrollback_cur->size;\n\n\tcount = vgacon_scrollback_cur->cnt - start;\n\n\tif (count > c->vc_rows)\n\t\tcount = c->vc_rows;\n\n\tif (count) {\n\t\tint copysize;\n\n\t\tint diff = c->vc_rows - count;\n\t\tvoid *d = (void *) c->vc_visible_origin;\n\t\tvoid *s = (void *) c->vc_screenbuf;\n\n\t\tcount *= c->vc_size_row;\n\t\t/* how much memory to end of buffer left? */\n\t\tcopysize = min(count, vgacon_scrollback_cur->size - soff);\n\t\tscr_memcpyw(d, vgacon_scrollback_cur->data + soff, copysize);\n\t\td += copysize;\n\t\tcount -= copysize;\n\n\t\tif (count) {\n\t\t\tscr_memcpyw(d, vgacon_scrollback_cur->data, count);\n\t\t\td += count;\n\t\t}\n\n\t\tif (diff)\n\t\t\tscr_memcpyw(d, s, diff * c->vc_size_row);\n\t} else\n\t\tvgacon_cursor(c, CM_MOVE);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n\n    SafeStringValue(path);\n\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n\n    if (status < 0) {\n\tint e = errno;\n\tclose(fd);\n\trsock_syserr_fail_path(e, \"connect(2)\", path);\n    }\n\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    int e = errno;\n\t    close(fd);\n\t    rsock_syserr_fail_path(e, \"listen(2)\", path);\n\t}\n    }\n\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n\n    return sock;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int credssp_skip_ts_password_creds(rdpCredssp* credssp)\n{\n\tint length;\n\tint ts_password_creds_length = 0;\n\n\tlength = ber_skip_octet_string(credssp->identity.DomainLength * 2);\n\tlength += ber_skip_contextual_tag(length);\n\tts_password_creds_length += length;\n\n\tlength = ber_skip_octet_string(credssp->identity.UserLength * 2);\n\tlength += ber_skip_contextual_tag(length);\n\tts_password_creds_length += length;\n\n\tlength = ber_skip_octet_string(credssp->identity.PasswordLength * 2);\n\tlength += ber_skip_contextual_tag(length);\n\tts_password_creds_length += length;\n\n\tlength = ber_skip_sequence(ts_password_creds_length);\n\n\treturn length;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "mysql_fetch_field(MYSQL_RES *result)\n{\n  if (result->current_field >= result->field_count)\n    return(NULL);\n  return &result->fields[result->current_field++];\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int lua_ap_rflush (lua_State *L) {\n\n    int returnValue;\n    request_rec *r;\n    luaL_checktype(L, 1, LUA_TUSERDATA);\n    r = ap_lua_check_request_rec(L, 1);\n    returnValue = ap_rflush(r);\n    lua_pushboolean(L, (returnValue == 0));\n    return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int labvalidate(i_ctx_t *i_ctx_p, ref *space, float *values, int num_comps)\n{\n    os_ptr op = osp;\n    int i;\n\n    if (num_comps < 3)\n        return_error(gs_error_stackunderflow);\n    op -= 2;\n    for (i=0;i<3;i++) {\n        if (!r_has_type(op, t_integer) && !r_has_type(op, t_real))\n            return_error(gs_error_typecheck);\n        op++;\n    }\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void inet_csk_reqsk_queue_drop(struct sock *sk, struct request_sock *req)\n{\n\tif (reqsk_queue_unlink(&inet_csk(sk)->icsk_accept_queue, req)) {\n\t\treqsk_queue_removed(&inet_csk(sk)->icsk_accept_queue, req);\n\t\treqsk_put(req);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int64_t get_pts(const char *buf, int *duration)\n\n{\n\n    int i, hour, min, sec, hsec;\n\n    int he, me, se, mse;\n\n\n\n    for (i=0; i<2; i++) {\n\n        int64_t start, end;\n\n        if (sscanf(buf, \"%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d\",\n\n                   &hour, &min, &sec, &hsec, &he, &me, &se, &mse) == 8) {\n\n            min += 60*hour;\n\n            sec += 60*min;\n\n            start = sec*1000+hsec;\n\n            me += 60*he;\n\n            se += 60*me;\n\n            end = se*1000+mse;\n\n            *duration = end - start;\n\n            return start;\n\n        }\n\n        buf += strcspn(buf, \"\\n\") + 1;\n\n    }\n\n    return AV_NOPTS_VALUE;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void puts_queue(struct vc_data *vc, char *cp)\n{\n\twhile (*cp) {\n\t\ttty_insert_flip_char(&vc->port, *cp, 0);\n\t\tcp++;\n\t}\n\ttty_schedule_flip(&vc->port);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static struct async *alloc_async(unsigned int numisoframes)\n{\n\tstruct async *as;\n\n\tas = kzalloc(sizeof(struct async), GFP_KERNEL);\n\tif (!as)\n\t\treturn NULL;\n\tas->urb = usb_alloc_urb(numisoframes, GFP_KERNEL);\n\tif (!as->urb) {\n\t\tkfree(as);\n\t\treturn NULL;\n\t}\n\treturn as;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int adev_init_check(const struct audio_hw_device *dev)\n{\n (void)dev;\n\n return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "jpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_malloc(streamlist->maxstreams *\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void AveragePool(const uint8* input_data, const Dims<4>& input_dims, int stride,\n                 int pad_width, int pad_height, int filter_width,\n                 int filter_height, int32 output_activation_min,\n                 int32 output_activation_max, uint8* output_data,\n                 const Dims<4>& output_dims) {\n  AveragePool<Ac>(input_data, input_dims, stride, stride, pad_width, pad_height,\n                  filter_width, filter_height, output_activation_min,\n                  output_activation_max, output_data, output_dims);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "SCM_DEFINE (scm_mkdir, \"mkdir\", 1, 1, 0,\n            (SCM path, SCM mode),\n\t    \"Create a new directory named by @var{path}.  If @var{mode} is omitted\\n\"\n\t    \"then the permissions of the directory file are set using the current\\n\"\n\t    \"umask.  Otherwise they are set to the decimal value specified with\\n\"\n\t    \"@var{mode}.  The return value is unspecified.\")\n#define FUNC_NAME s_scm_mkdir\n{\n  int rv;\n  mode_t mask;\n\n  if (SCM_UNBNDP (mode))\n    {\n      mask = umask (0);\n      umask (mask);\n      STRING_SYSCALL (path, c_path, rv = mkdir (c_path, 0777 ^ mask));\n    }\n  else\n    {\n      STRING_SYSCALL (path, c_path, rv = mkdir (c_path, scm_to_uint (mode)));\n    }\n  if (rv != 0)\n    SCM_SYSERROR;\n  return SCM_UNSPECIFIED;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "mm_answer_authserv(int socket, Buffer *m)\n{\n\tmonitor_permit_authentications(1);\n\n\tauthctxt->service = buffer_get_string(m, NULL);\n\tauthctxt->style = buffer_get_string(m, NULL);\n\tdebug3(\"%s: service=%s, style=%s\",\n\t    __func__, authctxt->service, authctxt->style);\n\n\tif (strlen(authctxt->style) == 0) {\n\t\txfree(authctxt->style);\n\t\tauthctxt->style = NULL;\n\t}\n\n\treturn (0);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "size_t ring_buffer_page_len(void *page)\n{\n\treturn local_read(&((struct buffer_data_page *)page)->commit)\n\t\t+ BUF_PAGE_HDR_SIZE;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "TypeIgnore(int lineno, PyArena *arena)\n{\n    type_ignore_ty p;\n    p = (type_ignore_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = TypeIgnore_kind;\n    p->v.TypeIgnore.lineno = lineno;\n    return p;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static char *pool_strdup(const char *s)\n {\n\tsize_t len = strlen(s) + 1;\n\tchar *r = pool_alloc(len);\n\tmemcpy(r, s, len);\n \treturn r;\n }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static struct netlbl_lsm_secattr *selinux_netlbl_sock_genattr(struct sock *sk)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (sksec->nlbl_secattr != NULL)\n\t\treturn sksec->nlbl_secattr;\n\n\tsecattr = netlbl_secattr_alloc(GFP_ATOMIC);\n\tif (secattr == NULL)\n\t\treturn NULL;\n\trc = security_netlbl_sid_to_secattr(sksec->sid, secattr);\n\tif (rc != 0) {\n\t\tnetlbl_secattr_free(secattr);\n\t\treturn NULL;\n\t}\n\tsksec->nlbl_secattr = secattr;\n\n\treturn secattr;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "png_get_rgb_to_gray_status (png_structp png_ptr)\n{\n   return (png_byte)(png_ptr? png_ptr->rgb_to_gray_status : 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int dispatch_other_io(struct xen_blkif_ring *ring,\n\t\t\t     struct blkif_request *req,\n\t\t\t     struct pending_req *pending_req)\n{\n\tfree_req(ring, pending_req);\n\tmake_response(ring, req->u.other.id, req->operation,\n\t\t      BLKIF_RSP_EOPNOTSUPP);\n\treturn -EIO;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "FILE* CreateAndOpenTemporaryFileInDir(const FilePath& dir, FilePath* path) {\n  int fd = CreateAndOpenFdForTemporaryFile(dir, path);\n  if (fd < 0)\n    return NULL;\n\n  FILE* file = fdopen(fd, \"a+\");\n  if (!file)\n    ignore_result(HANDLE_EINTR(close(fd)));\n  return file;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int epo_create_compositor(gx_device *dev, gx_device **pcdev, const gs_composite_t *pcte,\n    gs_gstate *pgs, gs_memory_t *memory, gx_device *cdev)\n{\n    int code = epo_handle_erase_page(dev);\n\n    if (code != 0)\n        return code;\n    return dev_proc(dev, create_compositor)(dev, pcdev, pcte, pgs, memory, cdev);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "GF_Err sinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn  gf_isom_box_write_header(s, bs);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "grub_password_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  continue;\n\t}\n\n      if (!grub_isprint (key))\n\tcontinue;\n\n      if (cur_len + 2 < buf_size)\n\tbuf[cur_len++] = key;\n    }\n\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n\n  return (key != '\\e');\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void tcp_mtup_probe_failed(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ticsk->icsk_mtup.search_high = icsk->icsk_mtup.probe_size - 1;\n\ticsk->icsk_mtup.probe_size = 0;\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPMTUPFAIL);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "g_markup_parse_context_pop (GMarkupParseContext *context)\n{\n  gpointer user_data;\n\n  if (!context->awaiting_pop)\n    possibly_finish_subparser (context);\n\n  g_assert (context->awaiting_pop);\n\n  context->awaiting_pop = FALSE;\n\n  /* valgrind friendliness */\n  user_data = context->held_user_data;\n  context->held_user_data = NULL;\n\n  return user_data;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void gd_update(DisplayChangeListener *dcl,\n\n                      DisplayState *ds, int x, int y, int w, int h)\n\n{\n\n    GtkDisplayState *s = ds->opaque;\n\n    int x1, x2, y1, y2;\n\n    int mx, my;\n\n    int fbw, fbh;\n\n    int ww, wh;\n\n\n\n    DPRINTF(\"update(x=%d, y=%d, w=%d, h=%d)\\n\", x, y, w, h);\n\n\n\n    x1 = floor(x * s->scale_x);\n\n    y1 = floor(y * s->scale_y);\n\n\n\n    x2 = ceil(x * s->scale_x + w * s->scale_x);\n\n    y2 = ceil(y * s->scale_y + h * s->scale_y);\n\n\n\n    fbw = ds_get_width(s->ds) * s->scale_x;\n\n    fbh = ds_get_height(s->ds) * s->scale_y;\n\n\n\n    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);\n\n\n\n    mx = my = 0;\n\n    if (ww > fbw) {\n\n        mx = (ww - fbw) / 2;\n\n    }\n\n    if (wh > fbh) {\n\n        my = (wh - fbh) / 2;\n\n    }\n\n\n\n    gtk_widget_queue_draw_area(s->drawing_area, mx + x1, my + y1, (x2 - x1), (y2 - y1));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "tabstop_set(char_u *var, int **array)\n{\n    int valcount = 1;\n    int t;\n    char_u *cp;\n\n    if (var[0] == NUL || (var[0] == '0' && var[1] == NUL))\n    {\n\t*array = NULL;\n\treturn TRUE;\n    }\n\n    for (cp = var; *cp != NUL; ++cp)\n    {\n\tif (cp == var || cp[-1] == ',')\n\t{\n\t    char_u *end;\n\n\t    if (strtol((char *)cp, (char **)&end, 10) <= 0)\n\t    {\n\t\tif (cp != end)\n\t\t    emsg(_(e_positive));\n\t\telse\n\t\t    emsg(_(e_invarg));\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tif (VIM_ISDIGIT(*cp))\n\t    continue;\n\tif (cp[0] == ',' && cp > var && cp[-1] != ',' && cp[1] != NUL)\n\t{\n\t    ++valcount;\n\t    continue;\n\t}\n\temsg(_(e_invarg));\n\treturn FALSE;\n    }\n\n    *array = ALLOC_MULT(int, valcount + 1);\n    if (*array == NULL)\n\treturn FALSE;\n    (*array)[0] = valcount;\n\n    t = 1;\n    for (cp = var; *cp != NUL;)\n    {\n\t(*array)[t++] = atoi((char *)cp);\n\twhile (*cp  != NUL && *cp != ',')\n\t    ++cp;\n\tif (*cp != NUL)\n\t    ++cp;\n    }\n\n    return TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static bool red_stream_write_u32_le(RedStream *s, uint32_t n)\n{\n    n = GUINT32_TO_LE(n);\n    return red_stream_write_all(s, &n, sizeof(uint32_t));\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "gs_window_set_keyboard_enabled (GSWindow *window,\n                                gboolean  enabled)\n{\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        window->priv->keyboard_enabled = enabled;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void mac80211_hwsim_set_tsf(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_vif *vif, u64 tsf)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tu64 now = mac80211_hwsim_get_tsf(hw, vif);\n\tu32 bcn_int = data->beacon_int;\n\tu64 delta = abs(tsf - now);\n\n\t/* adjust after beaconing with new timestamp at old TBTT */\n\tif (tsf > now) {\n\t\tdata->tsf_offset += delta;\n\t\tdata->bcn_delta = do_div(delta, bcn_int);\n\t} else {\n\t\tdata->tsf_offset -= delta;\n\t\tdata->bcn_delta = -(s64)do_div(delta, bcn_int);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "//! Load image from an ascii file \\overloading.\n    CImg<T>& load_ascii(std::FILE *const file) {\n      return _load_ascii(file,0);",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  optimized_ops::Round(GetTensorShape(input), GetTensorData<float>(input),\n                       GetTensorShape(output), GetTensorData<float>(output));\n\n  return kTfLiteOk;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "GF_Err alis_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n//\tGF_DataEntryAliasBox *ptr = (GF_DataEntryAliasBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int convert_bytes_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tswitch (cval->val_type) {\n\tcase USB_MIXER_BOOLEAN:\n\t\treturn !!val;\n\tcase USB_MIXER_INV_BOOLEAN:\n\t\treturn !val;\n\tcase USB_MIXER_S8:\n\tcase USB_MIXER_U8:\n\t\treturn val & 0xff;\n\tcase USB_MIXER_S16:\n\tcase USB_MIXER_U16:\n\t\treturn val & 0xffff;\n\t}\n\treturn 0; /* not reached */\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void nf_tables_set_destroy(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tlist_del_rcu(&set->list);\n\tnf_tables_set_notify(ctx, set, NFT_MSG_DELSET, GFP_ATOMIC);\n\tnft_set_destroy(set);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "MagickExport int LocaleUppercase(const int c)\n{\n  if (c < 0)\n    return(c);\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  if (c_locale != (locale_t) NULL)\n    return(toupper_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(toupper((int) ((unsigned char) c)));\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void qemu_put_buffer_async(QEMUFile *f, const uint8_t *buf, int size)\n\n{\n\n    if (!f->ops->writev_buffer) {\n\n        qemu_put_buffer(f, buf, size);\n\n        return;\n\n    }\n\n\n\n    if (f->last_error) {\n\n        return;\n\n    }\n\n\n\n    f->bytes_xfer += size;\n\n    add_to_iovec(f, buf, size);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "//! Dilate image by a rectangular structuring element of specified size \\newinstance.\n    CImg<T> get_dilate(const unsigned int sx, const unsigned int sy, const unsigned int sz=1) const {\n      return (+*this).dilate(sx,sy,sz);",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void ipa_draw_arc(wmfAPI * API, wmfDrawArc_t * draw_arc)\n{\n  util_draw_arc(API, draw_arc, magick_arc_open);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "relay_header_unpack(relay_header_t *dest, const uint8_t *src)\n{\n  dest->command = get_uint8(src);\n  dest->recognized = ntohs(get_uint16(src+1));\n  dest->stream_id = ntohs(get_uint16(src+3));\n  memcpy(dest->integrity, src+5, 4);\n  dest->length = ntohs(get_uint16(src+9));\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "fbFetch_g1 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32  p = ((CARD32 *)bits)[(i+x) >> 5];\n        CARD32 a;\n#if BITMAP_BIT_ORDER == MSBFirst\n        a = p >> (0x1f - ((i+x) & 0x1f));\n#else\n        a = p >> ((i+x) & 0x1f);\n#endif\n        a = a & 1;\n        WRITE(buffer++, indexed->rgba[a]);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int cifs_close(struct inode *inode, struct file *file)\n{\n\tcifsFileInfo_put(file->private_data);\n\tfile->private_data = NULL;\n\n\t/* return code from the ->release op is always ignored */\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "TEST(CheckpointVersionTest, MinConsumer) {\n  VersionDef versions;\n  versions.set_producer(TF_CHECKPOINT_VERSION + 1);\n  versions.set_min_consumer(TF_CHECKPOINT_VERSION + 1);\n  VersionTest(\n      versions,\n      strings::StrCat(\"Checkpoint min consumer version \",\n                      TF_CHECKPOINT_VERSION + 1, \" above current version \",\n                      TF_CHECKPOINT_VERSION, \" for TensorFlow\"));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void AuthenticatorClientPinEntrySheetModel::SetDelegate(Delegate* delegate) {\n  DCHECK(!delegate_);\n  delegate_ = delegate;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int ip_output(struct sk_buff *skb)\n{\n\tIP_INC_STATS(IPSTATS_MIB_OUTREQUESTS);\n\n\tif (skb->len > dst_mtu(skb->dst) && !skb_shinfo(skb)->tso_size)\n\t\treturn ip_fragment(skb, ip_finish_output);\n\telse\n\t\treturn ip_finish_output(skb);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n \t\tstruct xfrm_user_tmpl *up = &vec[i];\n \t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n \n \t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n \t\tup->family = kp->encap_family;\n \t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "InlineFlowBox::~InlineFlowBox()\n{\n    if (!m_hasBadChildList)\n        for (InlineBox* child = firstChild(); child; child = child->nextOnLine())\n            child->setHasBadParent();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void UniqueElementData::removeAttribute(size_t index)\n{\n    ASSERT_WITH_SECURITY_IMPLICATION(index < length());\n    m_attributeVector.remove(index);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void __exit ipddp_cleanup_module(void)\n{\n        struct ipddp_route *p;\n\n\tunregister_netdev(dev_ipddp);\n        free_netdev(dev_ipddp);\n\n        while (ipddp_route_list) {\n                p = ipddp_route_list->next;\n                kfree(ipddp_route_list);\n                ipddp_route_list = p;\n        }\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int vfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)\n{\n\tint error = may_create(dir, dentry, NULL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op || !dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tDQUOT_INIT(dir);\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "GF_Box *tmax_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMAXBox, GF_ISOM_BOX_TYPE_TMAX);\n\treturn (GF_Box *)tmp;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "kg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n\n    return code;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void virtio_net_instance_init(Object *obj)\n{\n    VirtIONet *n = VIRTIO_NET(obj);\n\n    /*\n     * The default config_size is sizeof(struct virtio_net_config).\n     * Can be overriden with virtio_net_set_config_size.\n     */\n    n->config_size = sizeof(struct virtio_net_config);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "FastFetchFeedFetcher(JobScheduler* scheduler,\n                       DriveServiceInterface* drive_service,\n                       const std::string& directory_resource_id,\n                       const std::string& root_folder_id)\n      : scheduler_(scheduler),\n        drive_service_(drive_service),\n        directory_resource_id_(directory_resource_id),\n        root_folder_id_(root_folder_id),\n        weak_ptr_factory_(this) {\n  }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int main(int argc, char* argv[])\n{\n    whoami = QUtil::getWhoami(argv[0]);\n\n    // For libtool's sake....\n    if (strncmp(whoami, \"lt-\", 3) == 0)\n    {\n\twhoami += 3;\n    }\n\n    if (argc != 3)\n    {\n\tusage();\n    }\n    char const* filename = argv[1];\n    int pageno = atoi(argv[2]);\n\n    try\n    {\n\tQPDF pdf;\n\tpdf.processFile(filename);\n        std::vector<QPDFObjectHandle> pages = pdf.getAllPages();\n        if ((pageno < 1) || (static_cast<size_t>(pageno) > pages.size()))\n        {\n            usage();\n        }\n\n        QPDFObjectHandle page = pages.at(pageno-1);\n        QPDFObjectHandle contents = page.getKey(\"/Contents\");\n        ParserCallbacks cb;\n        QPDFObjectHandle::parseContentStream(contents, &cb);\n    }\n    catch (std::exception& e)\n    {\n\tstd::cerr << whoami << \": \" << e.what() << std::endl;\n\texit(2);\n    }\n\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "uint32_t pcnet_bcr_readw(PCNetState *s, uint32_t rap)\n{\n    uint32_t val;\n    rap &= 127;\n    switch (rap) {\n    case BCR_LNKST:\n    case BCR_LED1:\n    case BCR_LED2:\n    case BCR_LED3:\n        val = s->bcr[rap] & ~0x8000;\n        val |= (val & 0x017f & s->lnkst) ? 0x8000 : 0;\n        break;\n    default:\n        val = rap < 32 ? s->bcr[rap] : 0;\n        break;\n    }\n#ifdef PCNET_DEBUG_BCR\n    printf(\"pcnet_bcr_readw rap=%d val=0x%04x\\n\", rap, val);\n#endif\n    return val;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline bool __meminit early_page_uninitialised(unsigned long pfn)\n{\n\tint nid = early_pfn_to_nid(pfn);\n\n\tif (node_online(nid) && pfn >= NODE_DATA(nid)->first_deferred_pfn)\n\t\treturn true;\n\n\treturn false;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int originates_from_local_legacy_unicast_socket(AvahiServer *s, const AvahiAddress *address, uint16_t port) {\n    assert(s);\n    assert(address);\n    assert(port > 0);\n\n    if (!s->config.enable_reflector)\n        return 0;\n\n    if (!avahi_address_is_local(s->monitor, address))\n        return 0;\n\n    if (address->proto == AVAHI_PROTO_INET && s->fd_legacy_unicast_ipv4 >= 0) {\n        struct sockaddr_in lsa;\n        socklen_t l = sizeof(lsa);\n\n        if (getsockname(s->fd_legacy_unicast_ipv4, (struct sockaddr*) &lsa, &l) != 0)\n            avahi_log_warn(\"getsockname(): %s\", strerror(errno));\n        else\n            return lsa.sin_port == port;\n\n    }\n\n    if (address->proto == AVAHI_PROTO_INET6 && s->fd_legacy_unicast_ipv6 >= 0) {\n        struct sockaddr_in6 lsa;\n        socklen_t l = sizeof(lsa);\n\n        if (getsockname(s->fd_legacy_unicast_ipv6, (struct sockaddr*) &lsa, &l) != 0)\n            avahi_log_warn(\"getsockname(): %s\", strerror(errno));\n        else\n            return lsa.sin6_port == port;\n    }\n\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "struct net_device *dev_get_by_flags_rcu(struct net *net, unsigned short if_flags,\n\t\t\t\t    unsigned short mask)\n{\n\tstruct net_device *dev, *ret;\n\n\tret = NULL;\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (((dev->flags ^ if_flags) & mask) == 0) {\n\t\t\tret = dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,\n unsigned long arg)\n{\n unsigned long tmp;\n struct vm_area_struct * vma, *prev;\n int unmapped_error = 0;\n int error = -EINVAL;\n\n /*\n\t * If the interval [start,end) covers some unmapped address\n\t * ranges, just ignore them, but return -ENOMEM at the end.\n\t * - this matches the handling in madvise.\n\t */\n\tvma = find_vma_prev(current->mm, start, &prev);\n if (vma && start > vma->vm_start)\n\t\tprev = vma;\n\n for (;;) {\n /* Still start < end. */\n\t\terror = -ENOMEM;\n if (!vma)\n return error;\n\n /* Here start < (end|vma->vm_end). */\n if (start < vma->vm_start) {\n\t\t\tunmapped_error = -ENOMEM;\n\t\t\tstart = vma->vm_start;\n if (start >= end)\n return error;\n }\n\n /* Here vma->vm_start <= start < (end|vma->vm_end) */\n\t\ttmp = vma->vm_end;\n if (end < tmp)\n\n \t\t\ttmp = end;\n \n \t\t/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */\n\t\terror = prctl_update_vma_anon_name(vma, &prev, start, end,\n \t\t\t\t(const char __user *)arg);\n \t\tif (error)\n \t\t\treturn error;\n\t\tstart = tmp;\n if (prev && start < prev->vm_end)\n\t\t\tstart = prev->vm_end;\n\t\terror = unmapped_error;\n if (start >= end)\n return error;\n if (prev)\n\t\t\tvma = prev->vm_next;\n else /* madvise_remove dropped mmap_sem */\n\t\t\tvma = find_vma(current->mm, start);\n }\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "T _cubic_cut_atX(const float fx, const int y, const int z, const int c) const {\n      return cimg::type<T>::cut(_cubic_atX(fx,y,z,c));",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "DataValue* DataValue::clone_() const\n    {\n        return new DataValue(*this);\n    }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void gen_tlbwe_40x(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    switch (rB(ctx->opcode)) {\n\n    case 0:\n\n        gen_helper_4xx_tlbwe_hi(cpu_env, cpu_gpr[rA(ctx->opcode)],\n\n                                cpu_gpr[rS(ctx->opcode)]);\n\n        break;\n\n    case 1:\n\n        gen_helper_4xx_tlbwe_lo(cpu_env, cpu_gpr[rA(ctx->opcode)],\n\n                                cpu_gpr[rS(ctx->opcode)]);\n\n        break;\n\n    default:\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n        break;\n\n    }\n\n#endif\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static bool fix_all_session_vcol_exprs(THD *thd, TABLE_LIST *tables)\n{\n  Security_context *save_security_ctx= thd->security_ctx;\n  TABLE_LIST *first_not_own= thd->lex->first_not_own_table();\n  DBUG_ENTER(\"fix_session_vcol_expr\");\n\n  int error= 0;\n  for (TABLE_LIST *table= tables; table && table != first_not_own && !error;\n       table= table->next_global)\n  {\n    TABLE *t= table->table;\n    if (!table->placeholder() && t->s->vcols_need_refixing &&\n         table->lock_type >= TL_WRITE_ALLOW_WRITE)\n    {\n      Query_arena *stmt_backup= thd->stmt_arena;\n      if (thd->stmt_arena->is_conventional())\n        thd->stmt_arena= t->expr_arena;\n      if (table->security_ctx)\n        thd->security_ctx= table->security_ctx;\n\n      error= t->fix_vcol_exprs(thd);\n\n      thd->security_ctx= save_security_ctx;\n      thd->stmt_arena= stmt_backup;\n    }\n  }\n  DBUG_RETURN(error);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int AVI_get_audio_vbr(avi_t *AVI)\n{\n\treturn(AVI->track[AVI->aptr].a_vbr);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    /* should be the case, see cirrus_bitblt_start */\n    assert(s->cirrus_blt_width > 0);\n    assert(s->cirrus_blt_height > 0);\n\n    if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                              s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    if (blit_region_is_unsafe(s, s->cirrus_blt_srcpitch,\n                              s->cirrus_blt_srcaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n\n    return false;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void arm_sysctl_init(uint32_t base, uint32_t sys_id)\n\n{\n\n    arm_sysctl_state *s;\n\n    int iomemtype;\n\n\n\n    s = (arm_sysctl_state *)qemu_mallocz(sizeof(arm_sysctl_state));\n\n    if (!s)\n\n        return;\n\n    s->base = base;\n\n    s->sys_id = sys_id;\n\n    iomemtype = cpu_register_io_memory(0, arm_sysctl_readfn,\n\n                                       arm_sysctl_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    /* ??? Save/restore.  */\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void DelegatedFrameHost::WasHidden() {\n  frame_evictor_->SetVisible(false);\n  released_front_lock_ = NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static av_cold int vorbis_encode_init(AVCodecContext *avccontext)\n\n{\n\n    vorbis_enc_context *venc = avccontext->priv_data;\n\n\n\n    if (avccontext->channels != 2) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Current Libav Vorbis encoder only supports 2 channels.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    create_vorbis_context(venc, avccontext);\n\n\n\n    if (avccontext->flags & CODEC_FLAG_QSCALE)\n\n        venc->quality = avccontext->global_quality / (float)FF_QP2LAMBDA / 10.;\n\n    else\n\n        venc->quality = 0.03;\n\n    venc->quality *= venc->quality;\n\n\n\n    avccontext->extradata_size = put_main_header(venc, (uint8_t**)&avccontext->extradata);\n\n\n\n    avccontext->frame_size     = 1 << (venc->log2_blocksize[0] - 1);\n\n\n\n    avccontext->coded_frame            = avcodec_alloc_frame();\n\n    avccontext->coded_frame->key_frame = 1;\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "inline StreamWriteResult StreamBase::Write(\n    uv_buf_t* bufs,\n    size_t count,\n    uv_stream_t* send_handle,\n    v8::Local<v8::Object> req_wrap_obj) {\n  Environment* env = stream_env();\n  int err;\n\n  size_t total_bytes = 0;\n  for (size_t i = 0; i < count; ++i)\n    total_bytes += bufs[i].len;\n  bytes_written_ += total_bytes;\n\n  if (send_handle == nullptr) {\n    err = DoTryWrite(&bufs, &count);\n    if (err != 0 || count == 0) {\n      return StreamWriteResult { false, err, nullptr, total_bytes };\n    }\n  }\n\n  HandleScope handle_scope(env->isolate());\n\n  if (req_wrap_obj.IsEmpty()) {\n    req_wrap_obj =\n        env->write_wrap_template()\n            ->NewInstance(env->context()).ToLocalChecked();\n    StreamReq::ResetObject(req_wrap_obj);\n  }\n\n  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());\n  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\n\n  err = DoWrite(req_wrap, bufs, count, send_handle);\n  bool async = err == 0;\n\n  if (!async) {\n    req_wrap->Dispose();\n    req_wrap = nullptr;\n  }\n\n  const char* msg = Error();\n  if (msg != nullptr) {\n    req_wrap_obj->Set(env->error_string(), OneByteString(env->isolate(), msg));\n    ClearError();\n  }\n\n  return StreamWriteResult { async, err, req_wrap, total_bytes };\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "keyid_from_pk (PKT_public_key *pk, u32 *keyid)\n{\n  u32 lowbits;\n  u32 dummy_keyid[2];\n\n  if (!keyid)\n    keyid = dummy_keyid;\n\n  if( pk->keyid[0] || pk->keyid[1] )\n    {\n      keyid[0] = pk->keyid[0];\n      keyid[1] = pk->keyid[1];\n      lowbits = keyid[1];\n    }\n  else\n    {\n      const byte *dp;\n      gcry_md_hd_t md;\n\n      md = do_fingerprint_md(pk);\n      if(md)\n\t{\n\t  dp = gcry_md_read ( md, 0 );\n\t  keyid[0] = dp[12] << 24 | dp[13] << 16 | dp[14] << 8 | dp[15] ;\n\t  keyid[1] = dp[16] << 24 | dp[17] << 16 | dp[18] << 8 | dp[19] ;\n\t  lowbits = keyid[1];\n\t  gcry_md_close (md);\n\t  pk->keyid[0] = keyid[0];\n\t  pk->keyid[1] = keyid[1];\n\t}\n      else\n\tpk->keyid[0]=pk->keyid[1]=keyid[0]=keyid[1]=lowbits=0xFFFFFFFF;\n    }\n\n  return lowbits;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void  Ins_NOT( INS_ARG )\n  { (void)exc;\n    if ( args[0] != 0 )\n      args[0] = 0;\n    else\n      args[0] = 1;\n  }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n \tif (box->len == 1) {\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline void RENAME(nv21ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    int width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstV, dstU, src1, width);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "XML_SetStartDoctypeDeclHandler(XML_Parser parser,\n                               XML_StartDoctypeDeclHandler start) {\n  if (parser != NULL)\n    parser->m_startDoctypeDeclHandler = start;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void LayerWebKitThread::notifyAnimationsStarted(double time)\n{\n    if (m_didStartAnimations) {\n        m_didStartAnimations = false;\n        if (m_owner)\n            m_owner->notifyAnimationStarted(time);\n    }\n\n    size_t listSize = m_sublayers.size();\n    for (size_t i = 0; i < listSize; ++i)\n        m_sublayers[i]->notifyAnimationsStarted(time);\n\n    listSize = m_overlays.size();\n    for (size_t i = 0; i < listSize; ++i)\n        m_overlays[i]->notifyAnimationsStarted(time);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int sdp_probe(AVProbeData *p1)\n\n{\n\n    const char *p = p1->buf, *p_end = p1->buf + p1->buf_size;\n\n\n\n    /* we look for a line beginning \"c=IN IP\" */\n\n    while (p < p_end && *p != '\\0') {\n\n        if (p + sizeof(\"c=IN IP\") - 1 < p_end &&\n\n            av_strstart(p, \"c=IN IP\", NULL))\n\n            return AVPROBE_SCORE_EXTENSION;\n\n\n\n        while (p < p_end - 1 && *p != '\\n') p++;\n\n        if (++p >= p_end)\n\n            break;\n\n        if (*p == '\\r')\n\n            p++;\n\n    }\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void qemu_cpu_kick(void *env)\n\n{\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static const TPMDriverOps *tpm_driver_find_by_type(enum TpmType type)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < TPM_MAX_DRIVERS && be_drivers[i] != NULL; i++) {\n\n        if (be_drivers[i]->type == type) {\n\n            return be_drivers[i];\n\n        }\n\n    }\n\n    return NULL;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "GF_Err btrt_Size(GF_Box *s)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tptr->size += 12;\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void opl3_panning(int dev, int voice, int value)\n{\n\tdevc->voc[voice].panning = value;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int jas_iccgetuint(jas_stream_t *in, int n, ulonglong *val)\nstatic int jas_iccgetuint(jas_stream_t *in, int n, jas_ulonglong *val)\n {\n \tint i;\n \tint c;\n\tjas_ulonglong v;\n \tv = 0;\n \tfor (i = n; i > 0; --i) {\n \t\tif ((c = jas_stream_getc(in)) == EOF)\n\t\t\treturn -1;\n\t\tv = (v << 8) | c;\n\t}\n\t*val = v;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "vu_queue_fill(VuDev *dev, VuVirtq *vq,\n\n              const VuVirtqElement *elem,\n\n              unsigned int len, unsigned int idx)\n\n{\n\n    struct vring_used_elem uelem;\n\n\n\n    if (unlikely(dev->broken)) {\n\n        return;\n\n    }\n\n\n\n    vu_log_queue_fill(dev, vq, elem, len);\n\n\n\n    idx = (idx + vq->used_idx) % vq->vring.num;\n\n\n\n    uelem.id = elem->index;\n\n    uelem.len = len;\n\n    vring_used_write(dev, vq, &uelem, idx);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void EventBindings::AttachFilteredEvent(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK_EQ(2, args.Length());\n  CHECK(args[0]->IsString());\n  CHECK(args[1]->IsObject());\n\n  std::string event_name = *v8::String::Utf8Value(args[0]);\n  if (!context()->HasAccessOrThrowError(event_name))\n    return;\n\n  std::unique_ptr<base::DictionaryValue> filter;\n  {\n    std::unique_ptr<content::V8ValueConverter> converter(\n        content::V8ValueConverter::create());\n    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(\n        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));\n    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {\n      args.GetReturnValue().Set(static_cast<int32_t>(-1));\n      return;\n    }\n     filter = base::DictionaryValue::From(std::move(filter_value));\n   }\n \n  base::DictionaryValue* filter_weak = filter.get();\n   int id = g_event_filter.Get().AddEventMatcher(\n       event_name, ParseEventMatcher(std::move(filter)));\n   attached_matcher_ids_.insert(id);\n \n   std::string extension_id = context()->GetExtensionID();\n   if (AddFilter(event_name, extension_id, *filter_weak)) {\n     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());\n    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(\n        extension_id, event_name, *filter_weak, lazy));\n  }\n\n  args.GetReturnValue().Set(static_cast<int32_t>(id));\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void blk_cleanup_queue(struct request_queue *q)\n{\n\t/* mark @q DYING, no new request or merges will be allowed afterwards */\n\tmutex_lock(&q->sysfs_lock);\n\tblk_set_queue_dying(q);\n\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOXMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_DYING, q);\n\tmutex_unlock(&q->sysfs_lock);\n\n\t/*\n\t * Drain all requests queued before DYING marking. Set DEAD flag to\n\t * prevent that q->request_fn() gets invoked after draining finished.\n\t */\n\tblk_freeze_queue(q);\n\n\trq_qos_exit(q);\n\n\tblk_queue_flag_set(QUEUE_FLAG_DEAD, q);\n\n\t/* for synchronous bio-based driver finish in-flight integrity i/o */\n\tblk_flush_integrity();\n\n\t/* @q won't process any more request, flush async actions */\n\tdel_timer_sync(&q->backing_dev_info->laptop_mode_wb_timer);\n\tblk_sync_queue(q);\n\n\tif (queue_is_mq(q))\n\t\tblk_mq_exit_queue(q);\n\n\tpercpu_ref_exit(&q->q_usage_counter);\n\n\t/* @q is and will stay empty, shutdown and put */\n\tblk_put_queue(q);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool CanOptimize(const NodeDef& node) const {\n    // TODO(ezhulenev): check if AccumulateNV2 can be supported too\n    if (!IsAdd(node) && !IsAddN(node)) {\n      return false;\n    }\n    if (IsInPreserveSet(node) || IsMarkedWithTag(node, kAddOpsRewriteTag)) {\n      return false;\n    }\n    // TODO(ezhulenev): relax this condition for root node\n    return !(IsDrivenByControlDependency(node) ||\n             DrivesControlDependency(node));\n  }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "uint64_t ThreadCommand::pc() const {\n  uint64_t entry = 0;\n  switch(architecture_) {\n    case CPU_TYPES::CPU_TYPE_X86:\n      {\n        entry = reinterpret_cast<const details::x86_thread_state_t*>(state_.data())->eip;\n        break;\n      }\n\n    case CPU_TYPES::CPU_TYPE_X86_64:\n      {\n        entry = reinterpret_cast<const details::x86_thread_state64_t*>(state_.data())->rip;\n        break;\n      }\n\n    case CPU_TYPES::CPU_TYPE_ARM:\n      {\n        entry = reinterpret_cast<const details::arm_thread_state_t*>(state_.data())->r15;\n        break;\n      }\n\n    case CPU_TYPES::CPU_TYPE_ARM64:\n      {\n        entry = reinterpret_cast<const details::arm_thread_state64_t*>(state_.data())->pc;\n        break;\n      }\n    default:\n      {\n        LIEF_ERR(\"Unknown architecture\");\n      }\n  }\n  return entry;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    Tensor* argmax = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, out_shape, &argmax));\n\n    LaunchMaxPoolingWithArgmax<Device, T, Targmax>::launch(\n        context, params, tensor_in, output, argmax, propagate_nans_,\n        include_batch_in_index_);\n  }",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "BluetoothApiSocket* BluetoothSocketAsyncApiFunction::GetSocket(\n    int api_resource_id) {\n  return manager_->Get(extension_id(), api_resource_id);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void cpudef_init(void)\n{\n#if defined(cpudef_setup)\n    cpudef_setup(); /* parse cpu definitions in target config file */\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int shash_ahash_mcryptd_final(struct ahash_request *req,\n\t\t\t      struct shash_desc *desc)\n{\n\tstruct crypto_shash *tfm = desc->tfm;\n\tstruct shash_alg *shash = crypto_shash_alg(tfm);\n\n\t/* alignment is to be done by multi-buffer crypto algorithm if needed */\n\n\treturn shash->final(desc, req->result);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "sshkey_load_file(int fd, struct sshbuf *blob)\n{\n \tu_char buf[1024];\n \tsize_t len;\n \tstruct stat st;\n\tint r;\n \n \tif (fstat(fd, &st) < 0)\n \t\treturn SSH_ERR_SYSTEM_ERROR;\n \tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n \t    st.st_size > MAX_KEY_FILE_SIZE)\n \t\treturn SSH_ERR_INVALID_FORMAT;\n \tfor (;;) {\n \t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n \t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "compare_vote_rs(const vote_routerstatus_t *a, const vote_routerstatus_t *b)\n{\n  int r;\n  tor_assert(a);\n  tor_assert(b);\n\n  if ((r = fast_memcmp(a->status.identity_digest, b->status.identity_digest,\n                  DIGEST_LEN)))\n    return r;\n  if ((r = fast_memcmp(a->status.descriptor_digest,\n                       b->status.descriptor_digest,\n                       DIGEST_LEN)))\n    return r;\n  if ((r = (int)(b->status.published_on - a->status.published_on)))\n    return r;\n  if ((r = strcmp(b->status.nickname, a->status.nickname)))\n    return r;\n  if ((r = (((int)b->status.addr) - ((int)a->status.addr))))\n    return r;\n  if ((r = (((int)b->status.or_port) - ((int)a->status.or_port))))\n    return r;\n  if ((r = (((int)b->status.dir_port) - ((int)a->status.dir_port))))\n    return r;\n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "xmlXPathIsInf(double val) {\n#ifdef isinf\n    return isinf(val) ? (val > 0 ? 1 : -1) : 0;\n#else\n    if (val >= INFINITY)\n        return 1;\n    if (val <= -INFINITY)\n        return -1;\n    return 0;\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void PageFormAnalyserLogger::Flush() {\n  std::string text;\n  for (ConsoleLevel level : {kError, kWarning, kVerbose}) {\n    for (LogEntry& entry : node_buffer_[level]) {\n       text.clear();\n       text += \"[DOM] \";\n       text += entry.message;\n      for (unsigned i = 0; i < entry.nodes.size(); ++i)\n        text += \" %o\";\n \n       blink::WebConsoleMessage message(level, blink::WebString::FromUTF8(text));\n      message.nodes = std::move(entry.nodes);  // avoids copying node vectors.\n       frame_->AddMessageToConsole(message);\n     }\n   }\n  node_buffer_.clear();\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)\n{\n\tBUG_ON(!head);\n\tspin_lock(&sysctl_lock);\n\tif (!use_table(head))\n\t\thead = ERR_PTR(-ENOENT);\n\tspin_unlock(&sysctl_lock);\n\treturn head;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int journal_remote_handle_raw_source(\n                sd_event_source *event,\n                int fd,\n                uint32_t revents,\n                RemoteServer *s) {\n\n        RemoteSource *source;\n        int r;\n\n        /* Returns 1 if there might be more data pending,\n         * 0 if data is currently exhausted, negative on error.\n         */\n\n        assert(fd >= 0 && fd < (ssize_t) s->sources_size);\n        source = s->sources[fd];\n        assert(source->importer.fd == fd);\n\n        r = process_source(source, s->compress, s->seal);\n        if (journal_importer_eof(&source->importer)) {\n                size_t remaining;\n\n                log_debug(\"EOF reached with source %s (fd=%d)\",\n                          source->importer.name, source->importer.fd);\n\n                remaining = journal_importer_bytes_remaining(&source->importer);\n                if (remaining > 0)\n                        log_notice(\"Premature EOF. %zu bytes lost.\", remaining);\n                remove_source(s, source->importer.fd);\n                log_debug(\"%zu active sources remaining\", s->active);\n                return 0;\n        } else if (r == -E2BIG) {\n                log_notice(\"Entry too big, skipped\");\n                return 1;\n        } else if (r == -EAGAIN) {\n                return 0;\n        } else if (r < 0) {\n                log_debug_errno(r, \"Closing connection: %m\");\n                remove_source(s, fd);\n                return 0;\n        } else\n                return 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        if (WriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            continue;\n        }\n        if (WriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n    }\n    rfbReleaseClientIterator(iterator);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, DriveInfo *dinfo, int unit)\n\n{\n\n    const char *driver;\n\n    DeviceState *dev;\n\n\n\n    driver = bdrv_is_sg(dinfo->bdrv) ? \"scsi-generic\" : \"scsi-disk\";\n\n    dev = qdev_create(&bus->qbus, driver);\n\n    qdev_prop_set_uint32(dev, \"scsi-id\", unit);\n\n    qdev_prop_set_drive(dev, \"drive\", dinfo);\n\n    qdev_init(dev);\n\n    return DO_UPCAST(SCSIDevice, qdev, dev);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "   Returns the block size of the algorithm */\nPHP_FUNCTION(mcrypt_module_get_algo_block_size)\n{\n\tMCRYPT_GET_MODE_DIR_ARGS(algorithms_dir)\n\t\n\tRETURN_LONG(mcrypt_module_get_algo_block_size(module, dir));",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline int offset_in_addr(struct f2fs_inode *i)\n{\n\treturn (i->i_inline & F2FS_EXTRA_ATTR) ?\n\t\t\t(le16_to_cpu(i->i_extra_isize) / sizeof(__le32)) : 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "GF_Box *paen_New()\n{\n\tISOM_DECL_BOX_ALLOC(FDPartitionEntryBox, GF_ISOM_BOX_TYPE_PAEN);\n\treturn (GF_Box *)tmp;",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "jpc_pchg_t *jpc_pchglist_get(jpc_pchglist_t *pchglist, int pchgno)\n{\n\treturn pchglist->pchgs[pchgno];\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void ShutdownHostProcess() {\n    DCHECK(context_->ui_task_runner()->BelongsToCurrentThread());\n\n    config_watcher_.reset();\n    daemon_channel_.reset();\n    desktop_environment_factory_.reset();\n    host_user_interface_.reset();\n\n    if (policy_watcher_.get()) {\n      base::WaitableEvent done_event(true, false);\n      policy_watcher_->StopWatching(&done_event);\n      done_event.Wait();\n      policy_watcher_.reset();\n    }\n\n    context_.reset();\n  }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void net_slirp_cleanup(NetClientState *nc)\n\n{\n\n    SlirpState *s = DO_UPCAST(SlirpState, nc, nc);\n\n\n\n    slirp_cleanup(s->slirp);\n\n    qemu_remove_exit_notifier(&s->exit_notifier);\n\n    slirp_smb_cleanup(s);\n\n    QTAILQ_REMOVE(&slirp_stacks, s, entry);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static bool write_header(FILE *fp)\n\n{\n\n    static const TraceRecord header = {\n\n        .event = HEADER_EVENT_ID,\n\n        .timestamp_ns = HEADER_MAGIC,\n\n        .x1 = HEADER_VERSION,\n\n    };\n\n\n\n    return fwrite(&header, sizeof header, 1, fp) == 1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline u32 __flow_hash_from_keys(struct flow_keys *keys, u32 keyval)\n{\n\tu32 hash;\n\n\t__flow_hash_consistentify(keys);\n\n\thash = __flow_hash_words(flow_keys_hash_start(keys),\n\t\t\t\t flow_keys_hash_length(keys), keyval);\n\tif (!hash)\n\t\thash = 1;\n\n\treturn hash;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Box_pitm::derive_box_version()\n{\n  if (m_item_ID <= 0xFFFF) {\n    set_version(0);\n  }\n  else {\n    set_version(1);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void FrameLoader::didLayout(LayoutMilestones milestones)\n{\n    m_client->dispatchDidLayout(milestones);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "inline StreamBase::StreamBase(Environment* env) : env_(env) {\n  PushStreamListener(&default_listener_);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "_nm_singleton_instance_weak_cb(gpointer data, GObject *where_the_object_was)\n{\n    nm_assert(g_slist_find(_singletons, where_the_object_was));\n\n    _singletons = g_slist_remove(_singletons, where_the_object_was);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "PyParser_Delete(parser_state *ps)\n{\n    /* NB If you want to save the parse tree,\n       you must set p_tree to NULL before calling delparser! */\n    PyNode_Free(ps->p_tree);\n    PyMem_FREE(ps);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static zval* date_clone_immutable(zval *object TSRMLS_DC)\n{\n\tzval *new_object;\n\n\tALLOC_ZVAL(new_object);\n\tZ_OBJVAL_P(new_object) = date_object_clone_date(object TSRMLS_CC);\n\tZ_SET_REFCOUNT_P(new_object, 1);\n\tZ_SET_ISREF_P(new_object);\n\tZ_TYPE_P(new_object) = IS_OBJECT;\n\n\treturn new_object;",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int ebml_read_binary(AVIOContext *pb, int length, EbmlBin *bin)\n\n{\n\n    av_free(bin->data);\n\n    if (!(bin->data = av_malloc(length)))\n\n        return AVERROR(ENOMEM);\n\n\n\n    bin->size = length;\n\n    bin->pos  = avio_tell(pb);\n\n    if (avio_read(pb, bin->data, length) != length) {\n\n        av_freep(&bin->data);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) {\n  for (int page_index : visible_pages_) {\n     if (pages_[page_index]->GetPage() == page)\n       return page_index;\n   }\n  return -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void vnc_read_when(VncState *vs, VncReadEvent *func, size_t expecting)\n{\n    vs->read_handler = func;\n    vs->read_handler_expect = expecting;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "RenderViewHost* InterstitialPage::CreateRenderViewHost() {\n  RenderViewHost* render_view_host = new RenderViewHost(\n      SiteInstance::CreateSiteInstance(tab()->profile()),\n      this, MSG_ROUTING_NONE, kInvalidSessionStorageNamespaceId);\n  return render_view_host;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int blkid_partition_set_name(blkid_partition par,\n\t\tconst unsigned char *name, size_t len)\n{\n\tif (!par)\n\t\treturn -1;\n\n\tset_string(par->name, sizeof(par->name), name, len);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void stb_phys(AddressSpace *as, hwaddr addr, uint32_t val)\n{\n    address_space_stb(as, addr, val, MEMTXATTRS_UNSPECIFIED, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "perf_output_sample_regs(struct perf_output_handle *handle,\n\t\t\tstruct pt_regs *regs, u64 mask)\n{\n\tint bit;\n\tDECLARE_BITMAP(_mask, 64);\n\n\tbitmap_from_u64(_mask, mask);\n\tfor_each_set_bit(bit, _mask, sizeof(mask) * BITS_PER_BYTE) {\n\t\tu64 val;\n\n\t\tval = perf_reg_value(regs, bit);\n\t\tperf_output_put(handle, val);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t */\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t */\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tif (test_thread_flag(TIF_SYSCALL_TRACE)\n\t\t\t&& (current->ptrace & PT_PTRACED))\n\t\tdo_syscall_trace();\n\n#if 0\n\tif (unlikely(current->audit_context))\n\t\taudit_syscall_entry(current, AUDIT_ARCH_XTENSA..);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int sco_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n\n \tif (!addr || addr->sa_family != AF_BLUETOOTH)\n \t\treturn -EINVAL;\n \n \tlock_sock(sk);\n \n \tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tbacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);\n\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "uint32_t TiffIfdMakernote::doSize() const\n    {\n        return sizeHeader() + ifd_.size();\n    } // TiffIfdMakernote::doSize",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "gst_rtsp_connection_connect (GstRTSPConnection * conn, GTimeVal * timeout)\n{\n  GstRTSPResult result;\n  GstRTSPMessage response;\n\n  memset (&response, 0, sizeof (response));\n  gst_rtsp_message_init (&response);\n\n  result = gst_rtsp_connection_connect_with_response (conn, timeout, &response);\n\n  gst_rtsp_message_unset (&response);\n\n  return result;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int RGWPostObj_ObjStore_S3::get_tags()\n{\n  string tags_str;\n  if (part_str(parts, \"tagging\", &tags_str)) {\n    RGWObjTagsXMLParser parser;\n    if (!parser.init()){\n      ldout(s->cct, 0) << \"Couldn't init RGWObjTags XML parser\" << dendl;\n      err_msg = \"Server couldn't process the request\";\n      return -EINVAL; // TODO: This class of errors in rgw code should be a 5XX error\n    }\n    if (!parser.parse(tags_str.c_str(), tags_str.size(), 1)) {\n      ldout(s->cct,0 ) << \"Invalid Tagging XML\" << dendl;\n      err_msg = \"Invalid Tagging XML\";\n      return -EINVAL;\n    }\n\n    RGWObjTagSet_S3 *obj_tags_s3;\n    RGWObjTagging_S3 *tagging;\n\n    tagging = static_cast<RGWObjTagging_S3 *>(parser.find_first(\"Tagging\"));\n    obj_tags_s3 = static_cast<RGWObjTagSet_S3 *>(tagging->find_first(\"TagSet\"));\n    if(!obj_tags_s3){\n      return -ERR_MALFORMED_XML;\n    }\n\n    RGWObjTags obj_tags;\n    int r = obj_tags_s3->rebuild(obj_tags);\n    if (r < 0)\n      return r;\n\n    bufferlist tags_bl;\n    obj_tags.encode(tags_bl);\n    ldout(s->cct, 20) << \"Read \" << obj_tags.count() << \"tags\" << dendl;\n    attrs[RGW_ATTR_TAGS] = tags_bl;\n  }\n\n\n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "my_decimal *Item_cache_decimal::val_decimal(my_decimal *val)\n{\n  DBUG_ASSERT(fixed);\n  if (!has_value())\n    return NULL;\n  return &decimal_value;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "BROTLI_BOOL BrotliDecoderHuffmanTreeGroupInit(BrotliDecoderState* s,\n    HuffmanTreeGroup* group, uint32_t alphabet_size_max,\n    uint32_t alphabet_size_limit, uint32_t ntrees) {\n  /* Pack two allocations into one */\n  const size_t max_table_size =\n      kMaxHuffmanTableSize[(alphabet_size_limit + 31) >> 5];\n  const size_t code_size = sizeof(HuffmanCode) * ntrees * max_table_size;\n  const size_t htree_size = sizeof(HuffmanCode*) * ntrees;\n  /* Pointer alignment is, hopefully, wider than sizeof(HuffmanCode). */\n  HuffmanCode** p = (HuffmanCode**)BROTLI_DECODER_ALLOC(s,\n      code_size + htree_size);\n  group->alphabet_size_max = (uint16_t)alphabet_size_max;\n  group->alphabet_size_limit = (uint16_t)alphabet_size_limit;\n  group->num_htrees = (uint16_t)ntrees;\n  group->htrees = p;\n  group->codes = (HuffmanCode*)(&p[ntrees]);\n  return !!p;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static ExprList *exprListAppendList(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to append. Might be NULL */\n  ExprList *pAppend,      /* List of values to append. Might be NULL */\n  int bIntToNull\n){\n  if( pAppend ){\n    int i;\n    int nInit = pList ? pList->nExpr : 0;\n    for(i=0; i<pAppend->nExpr; i++){\n      Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);\n      if( bIntToNull && pDup && pDup->op==TK_INTEGER ){\n        pDup->op = TK_NULL;\n        pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);\n      }\n      pList = sqlite3ExprListAppend(pParse, pList, pDup);\n      if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;\n    }\n  }\n  return pList;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void RendererSchedulerImpl::Shutdown() {\n  if (main_thread_only().was_shutdown)\n    return;\n\n  base::TimeTicks now = tick_clock()->NowTicks();\n  main_thread_only().metrics_helper.OnRendererShutdown(now);\n\n  task_queue_throttler_.reset();\n  idle_helper_.Shutdown();\n  helper_.Shutdown();\n  main_thread_only().was_shutdown = true;\n  main_thread_only().rail_mode_observer = nullptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int alloc_profile_is_valid(u64 flags, int extended)\n{\n\tu64 mask = (extended ? BTRFS_EXTENDED_PROFILE_MASK :\n\t\t\t       BTRFS_BLOCK_GROUP_PROFILE_MASK);\n\n\tflags &= ~BTRFS_BLOCK_GROUP_TYPE_MASK;\n\n\t/* 1) check that all other bits are zeroed */\n\tif (flags & ~mask)\n\t\treturn 0;\n\n\t/* 2) see if profile is reduced */\n\tif (flags == 0)\n\t\treturn !extended; /* \"0\" is valid for usual profiles */\n\n\t/* true if exactly one bit set */\n\treturn is_power_of_2(flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int virtio_rng_load_device(VirtIODevice *vdev, QEMUFile *f,\n\n                                  int version_id)\n\n{\n\n    /* We may have an element ready but couldn't process it due to a quota\n\n     * limit.  Make sure to try again after live migration when the quota may\n\n     * have been reset.\n\n     */\n\n    virtio_rng_process(VIRTIO_RNG(vdev));\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "new_fixup(struct archive_write_disk *a, const char *pathname)\n{\n\tstruct fixup_entry *fe;\n\n\tfe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));\n\tif (fe == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for a fixup\");\n\t\treturn (NULL);\n\t}\n\tfe->next = a->fixup_list;\n\ta->fixup_list = fe;\n\tfe->fixup = 0;\n\tfe->mode = 0;\n\tfe->name = strdup(pathname);\n\treturn (fe);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline UBool objectEquals(const UObject* a, const UObject* b) {\n    // LATER: return *a == *b;\n    return *((const Measure*) a) == *((const Measure*) b);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void jit_free_defer(struct work_struct *arg)\n{\n\tmodule_free(NULL, arg);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "MutableCSSPropertyValueSet* SVGElement::AnimatedSMILStyleProperties() const {\n  if (HasSVGRareData())\n    return SvgRareData()->AnimatedSMILStyleProperties();\n  return nullptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "~SharedPtr()\n\t{\n\t\tif (T *p = m_ptr) p->release();\n\t}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void ext4_xattr_block_csum_set(struct inode *inode,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tBHDR(bh)->h_checksum = ext4_xattr_block_csum(inode,\n\t\t\t\t\t\tbh->b_blocknr, BHDR(bh));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int ssl_undefined_function(SSL *s)\n{\n    SSLerr(SSL_F_SSL_UNDEFINED_FUNCTION, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n    return (0);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static gint conv_euctojis(gchar *outbuf, gint outlen, const gchar *inbuf)\n{\n\tconst guchar *in = inbuf;\n\tguchar *out = outbuf;\n\tJISState state = JIS_ASCII;\n\n\twhile (*in != '\\0') {\n\t\tif (IS_ASCII(*in)) {\n\t\t\tK_OUT();\n\t\t\t*out++ = *in++;\n\t\t} else if (iseuckanji(*in)) {\n\t\t\tif (iseuckanji(*(in + 1))) {\n\t\t\t\tK_IN();\n\t\t\t\t*out++ = *in++ & 0x7f;\n\t\t\t\t*out++ = *in++ & 0x7f;\n\t\t\t} else {\n\t\t\t\tK_OUT();\n\t\t\t\t*out++ = SUBST_CHAR;\n\t\t\t\tin++;\n\t\t\t\tif (*in != '\\0' && !IS_ASCII(*in)) {\n\t\t\t\t\t*out++ = SUBST_CHAR;\n\t\t\t\t\tin++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (iseuchwkana1(*in)) {\n\t\t\tif (iseuchwkana2(*(in + 1))) {\n\t\t\t\tif (prefs_common.allow_jisx0201_kana) {\n\t\t\t\t\tHW_IN();\n\t\t\t\t\tin++;\n\t\t\t\t\t*out++ = *in++ & 0x7f;\n\t\t\t\t} else {\n\t\t\t\t\tguchar jis_ch[2];\n\t\t\t\t\tgint len;\n\n\t\t\t\t\tif (iseuchwkana1(*(in + 2)) &&\n\t\t\t\t\t    iseuchwkana2(*(in + 3)))\n\t\t\t\t\t\tlen = conv_jis_hantozen\n\t\t\t\t\t\t\t(jis_ch,\n\t\t\t\t\t\t\t *(in + 1), *(in + 3));\n\t\t\t\t\telse\n\t\t\t\t\t\tlen = conv_jis_hantozen\n\t\t\t\t\t\t\t(jis_ch,\n\t\t\t\t\t\t\t *(in + 1), '\\0');\n\t\t\t\t\tif (len == 0)\n\t\t\t\t\t\tin += 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\tK_IN();\n\t\t\t\t\t\tin += len * 2;\n\t\t\t\t\t\t*out++ = jis_ch[0];\n\t\t\t\t\t\t*out++ = jis_ch[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tK_OUT();\n\t\t\t\tin++;\n\t\t\t\tif (*in != '\\0' && !IS_ASCII(*in)) {\n\t\t\t\t\t*out++ = SUBST_CHAR;\n\t\t\t\t\tin++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (iseucaux(*in)) {\n\t\t\tin++;\n\t\t\tif (iseuckanji(*in) && iseuckanji(*(in + 1))) {\n\t\t\t\tAUX_IN();\n\t\t\t\t*out++ = *in++ & 0x7f;\n\t\t\t\t*out++ = *in++ & 0x7f;\n\t\t\t} else {\n\t\t\t\tK_OUT();\n\t\t\t\tif (*in != '\\0' && !IS_ASCII(*in)) {\n\t\t\t\t\t*out++ = SUBST_CHAR;\n\t\t\t\t\tin++;\n\t\t\t\t\tif (*in != '\\0' && !IS_ASCII(*in)) {\n\t\t\t\t\t\t*out++ = SUBST_CHAR;\n\t\t\t\t\t\tin++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tK_OUT();\n\t\t\t*out++ = SUBST_CHAR;\n\t\t\tin++;\n\t\t}\n\t}\n\n\tK_OUT();\n\t*out = '\\0';\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static MonoReflectionType*\nmono_reflection_type_resolve_user_types (MonoReflectionType *type)\n{\n\tif (!type || type->type)\n\t\treturn type;\n\n\tif (is_usertype (type)) {\n\t\ttype = mono_reflection_type_get_underlying_system_type (type);\n\t\tif (is_usertype (type))\n\t\t\tmono_raise_exception (mono_get_exception_not_supported (\"User defined subclasses of System.Type are not yet supported22\"));\n\t}\n\n\treturn type;",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "PPC_OP(check_reservation)\n\n{\n\n    if ((uint32_t)env->reserve == (uint32_t)(T0 & ~0x00000003))\n\n        env->reserve = -1;\n\n    RETURN();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void netdev_init_one_queue(struct net_device *dev,\n\t\t\t\t  struct netdev_queue *queue, void *_unused)\n{\n\t/* Initialize queue lock */\n\tspin_lock_init(&queue->_xmit_lock);\n\tnetdev_set_xmit_lockdep_class(&queue->_xmit_lock, dev->type);\n\tqueue->xmit_lock_owner = -1;\n\tnetdev_queue_numa_node_write(queue, NUMA_NO_NODE);\n\tqueue->dev = dev;\n#ifdef CONFIG_BQL\n\tdql_init(&queue->dql, HZ);\n#endif",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void test_nesting(void)\n\n{\n\n    Coroutine *root;\n\n    NestData nd = {\n\n        .n_enter  = 0,\n\n        .n_return = 0,\n\n        .max      = 128,\n\n    };\n\n\n\n    root = qemu_coroutine_create(nest);\n\n    qemu_coroutine_enter(root, &nd);\n\n\n\n    /* Must enter and return from max nesting level */\n\n    g_assert_cmpint(nd.n_enter, ==, nd.max);\n\n    g_assert_cmpint(nd.n_return, ==, nd.max);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Render_Gray_Glyph( RAS_ARG )\n  {\n    FT_UNUSED_RASTER;\n\n    return FT_THROW( Unsupported );\n  }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline void debug_hrtimer_deactivate(struct hrtimer *timer) { }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static const char* string() { static const char *const s = \"float\"; return s; }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "  explicit DataFormatDimMapOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string src_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n    string dst_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n    OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Source format must of length 4 or 5, received \"\n                    \"src_format = \",\n                    src_format)));\n    OP_REQUIRES(\n        context, dst_format.size() == 4 || dst_format.size() == 5,\n        errors::InvalidArgument(strings::StrCat(\n            \"Destination format must of length 4 or 5, received dst_format = \",\n            dst_format)));\n    dst_idx_ = Tensor(DT_INT32, {static_cast<int64>(src_format.size())});\n    for (int i = 0; i < src_format.size(); ++i) {\n      for (int j = 0; j < dst_format.size(); ++j) {\n        if (dst_format[j] == src_format[i]) {\n          dst_idx_.vec<int>()(i) = j;\n          break;\n        }\n      }\n    }\n  }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void vmmouse_reset(DeviceState *d)\n{\n    VMMouseState *s = container_of(d, VMMouseState, dev.qdev);\n    s->status = 0xffff;\n    s->queue_size = VMMOUSE_QUEUE_SIZE;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int groups_max(void)\n{\n#if defined(SYSCONF_SC_NGROUPS_MAX)\n\tint ret = sysconf(_SC_NGROUPS_MAX);\n\treturn (ret == -1) ? NGROUPS_MAX : ret;\n#else\n\treturn NGROUPS_MAX;\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void KeepVideoFrameAlive(const scoped_refptr<VideoFrame>& frame) {}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "QPDF::resolve(int objid, int generation)\n{\n    // Check object cache before checking xref table.  This allows us\n    // to insert things into the object cache that don't actually\n    // exist in the file.\n    QPDFObjGen og(objid, generation);\n    if (! this->obj_cache.count(og))\n    {\n\tif (! this->xref_table.count(og))\n\t{\n\t    // PDF spec says unknown objects resolve to the null object.\n\t    return new QPDF_Null;\n\t}\n\n\tQPDFXRefEntry const& entry = this->xref_table[og];\n\tswitch (entry.getType())\n\t{\n\t  case 1:\n\t    {\n\t\tqpdf_offset_t offset = entry.getOffset();\n\t\t// Object stored in cache by readObjectAtOffset\n\t\tint aobjid;\n\t\tint ageneration;\n\t\tQPDFObjectHandle oh =\n\t\t    readObjectAtOffset(true, offset, \"\", objid, generation,\n\t\t\t\t       aobjid, ageneration);\n\t    }\n\t    break;\n\n\t  case 2:\n\t    resolveObjectsInStream(entry.getObjStreamNumber());\n\t    break;\n\n\t  default:\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), \"\", 0,\n\t\t\t  \"object \" +\n\t\t\t  QUtil::int_to_string(objid) + \"/\" +\n\t\t\t  QUtil::int_to_string(generation) +\n\t\t\t  \" has unexpected xref entry type\");\n\t}\n    }\n\n    return this->obj_cache[og].object;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static ssize_t removable_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", (int)IS_ENABLED(CONFIG_MEMORY_HOTREMOVE));\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "XML_GetErrorCode(XML_Parser parser) {\n  if (parser == NULL)\n    return XML_ERROR_INVALID_ARGUMENT;\n  return parser->m_errorCode;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "vmxnet3_write_config(PCIDevice *pci_dev, uint32_t addr, uint32_t val, int len)\n{\n    pci_default_write_config(pci_dev, addr, val, len);\n    msix_write_config(pci_dev, addr, val, len);\n    msi_write_config(pci_dev, addr, val, len);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int afGetFileFormat (AFfilehandle file, int *version)\n{\n\tif (!_af_filehandle_ok(file))\n\t\treturn -1;\n\n\tif (version != NULL)\n\t{\n\t\tif (_af_units[file->fileFormat].getversion)\n\t\t\t*version = _af_units[file->fileFormat].getversion(file);\n\t\telse\n\t\t\t*version = 0;\n\t}\n\n\treturn file->fileFormat;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bufOptRemove(int *opt, char **arg)\n{\n\tDEFiRet;\n\tbufOpt_t *pBuf;\n\n\tif(bufOptRoot == NULL)\n\t\tABORT_FINALIZE(RS_RET_END_OF_LINKEDLIST);\n\tpBuf = bufOptRoot;\n\n\t*opt = pBuf->optchar;\n\t*arg = pBuf->arg;\n\n\tbufOptRoot = pBuf->pNext;\n\tfree(pBuf);\n\nfinalize_it:\n\tRETiRet;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline int mxf_read_utf16_string(AVIOContext *pb, int size, char** str, int be)\n\n{\n\n    int ret;\n\n    size_t buf_size;\n\n\n\n    if (size < 0)\n\n        return AVERROR(EINVAL);\n\n\n\n    buf_size = size + size / 2 + 1;\n\n    *str = av_malloc(buf_size);\n\n    if (!*str)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (be)\n\n        ret = avio_get_str16be(pb, size, *str, buf_size);\n\n    else\n\n        ret = avio_get_str16le(pb, size, *str, buf_size);\n\n\n\n    if (ret < 0) {\n\n        av_freep(str);\n\n        return ret;\n\n    }\n\n\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline void write_IRQreg (openpic_t *opp, int n_IRQ,\n\n                                 uint32_t reg, uint32_t val)\n\n{\n\n    uint32_t tmp;\n\n\n\n    switch (reg) {\n\n    case IRQ_IPVP:\n\n        /* NOTE: not fully accurate for special IRQs, but simple and\n\n           sufficient */\n\n        /* ACTIVITY bit is read-only */\n\n        opp->src[n_IRQ].ipvp =\n\n            (opp->src[n_IRQ].ipvp & 0x40000000) |\n\n            (val & 0x800F00FF);\n\n        openpic_update_irq(opp, n_IRQ);\n\n        DPRINTF(\"Set IPVP %d to 0x%08x -> 0x%08x\\n\",\n\n                n_IRQ, val, opp->src[n_IRQ].ipvp);\n\n        break;\n\n    case IRQ_IDE:\n\n        tmp = val & 0xC0000000;\n\n        tmp |= val & ((1 << MAX_CPU) - 1);\n\n        opp->src[n_IRQ].ide = tmp;\n\n        DPRINTF(\"Set IDE %d to 0x%08x\\n\", n_IRQ, opp->src[n_IRQ].ide);\n\n        break;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void do_device_add(Monitor *mon, const QDict *qdict)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    opts = qemu_opts_parse(&qemu_device_opts,\n\n                           qdict_get_str(qdict, \"config\"), \"driver\");\n\n    if (opts && !qdev_device_help(opts))\n\n        qdev_device_add(opts);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void blk_remove_bs(BlockBackend *blk)\n\n{\n\n    BlockDriverState *bs;\n\n    ThrottleTimers *tt;\n\n\n\n    notifier_list_notify(&blk->remove_bs_notifiers, blk);\n\n    if (blk->public.throttle_group_member.throttle_state) {\n\n        tt = &blk->public.throttle_group_member.throttle_timers;\n\n        bs = blk_bs(blk);\n\n        bdrv_drained_begin(bs);\n\n        throttle_timers_detach_aio_context(tt);\n\n        bdrv_drained_end(bs);\n\n    }\n\n\n\n    blk_update_root_state(blk);\n\n\n\n    bdrv_root_unref_child(blk->root);\n\n    blk->root = NULL;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static TT_F26Dot6  Project_y( EXEC_OPS TT_F26Dot6  Vx, TT_F26Dot6  Vy )\n  { (void)exc; (void)Vx;\n    return Vy;\n  }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "std::unique_ptr<OperationPass<FuncOp>> CreateOptimizePass(\n    bool enable_canonicalization) {\n  return std::make_unique<OptimizePass>(enable_canonicalization);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void Inspect::operator()(Placeholder_Selector_Ptr s)\n  {\n    append_token(s->name(), s);\n    if (s->has_line_break()) append_optional_linefeed();\n    if (s->has_line_break()) append_indentation();\n\n  }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "xfs_fs_freeze(\n\tstruct super_block\t*sb)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\txfs_icache_disable_reclaim(mp);\n\txfs_save_resvblks(mp);\n\txfs_quiesce_attr(mp);\n\treturn xfs_sync_sb(mp, true);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static MemTxResult memory_region_write_accessor(MemoryRegion *mr,\n\n                                                hwaddr addr,\n\n                                                uint64_t *value,\n\n                                                unsigned size,\n\n                                                unsigned shift,\n\n                                                uint64_t mask,\n\n                                                MemTxAttrs attrs)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = (*value >> shift) & mask;\n\n    if (mr->subpage) {\n\n        trace_memory_region_subpage_write(get_cpu_index(), mr, addr, tmp, size);\n\n\n\n\n\n\n    } else if (TRACE_MEMORY_REGION_OPS_WRITE_ENABLED) {\n\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n\n        trace_memory_region_ops_write(get_cpu_index(), mr, abs_addr, tmp, size);\n\n    }\n\n    mr->ops->write(mr->opaque, addr, tmp, size);\n\n    return MEMTX_OK;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "PCIBus *pci_grackle_init(uint32_t base, qemu_irq *pic)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    GrackleState *d;\n\n\n\n    dev = qdev_create(NULL, \"grackle\");\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    d = FROM_SYSBUS(GrackleState, s);\n\n    d->host_state.bus = pci_register_bus(&d->busdev.qdev, \"pci\",\n\n                                         pci_grackle_set_irq,\n\n                                         pci_grackle_map_irq,\n\n                                         pic, 0, 4);\n\n\n\n    pci_create_simple(d->host_state.bus, 0, \"grackle\");\n\n\n\n    sysbus_mmio_map(s, 0, base);\n\n    sysbus_mmio_map(s, 1, base + 0x00200000);\n\n\n\n    return d->host_state.bus;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "SendIncrementalFramebufferUpdateRequest(rfbClient* client)\n{\n\treturn SendFramebufferUpdateRequest(client,\n\t\t\tclient->updateRect.x, client->updateRect.y,\n\t\t\tclient->updateRect.w, client->updateRect.h, TRUE);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void destroy_parameters(opj_decompress_parameters* parameters)\n{\n    if (parameters) {\n        if (parameters->precision) {\n            free(parameters->precision);\n            parameters->precision = NULL;\n        }\n\n        free(parameters->comps_indices);\n        parameters->comps_indices = NULL;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "MagickExport MagickBooleanType IsOptionMember(const char *option,\n  const char *options)\n{\n  char\n    **option_list,\n    *string;\n\n  int\n    number_options;\n\n  MagickBooleanType\n    member;\n\n  register ssize_t\n    i;\n\n  /*\n    Is option a member of the options list?\n  */\n  if (options == (const char *) NULL)\n    return(MagickFalse);\n  string=ConstantString(options);\n  (void) SubstituteString(&string,\",\",\" \");\n  option_list=StringToArgv(string,&number_options);\n  string=DestroyString(string);\n  if (option_list == (char **) NULL)\n    return(MagickFalse);\n  member=MagickFalse;\n  for (i=1; i < (ssize_t) number_options; i++)\n  {\n    if ((*option_list[i] == '!') &&\n        (LocaleCompare(option,option_list[i]+1) == 0))\n      break;\n    if (GlobExpression(option,option_list[i],MagickTrue) != MagickFalse)\n      {\n        member=MagickTrue;\n        break;\n      }\n    option_list[i]=DestroyString(option_list[i]);\n  }\n  for ( ; i < (ssize_t) number_options; i++)\n    option_list[i]=DestroyString(option_list[i]);\n  option_list=(char **) RelinquishMagickMemory(option_list);\n  return(member);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "Zone* runtime_zone() { return &runtime_zone_; }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int pam_prompt(pam_handle_t *pamh, int style, char **response, char *fmt, ...)\n{\n  int rv;\n  struct pam_conv *conv;\n  struct pam_message msg;\n  struct pam_response *resp;\n  /* struct pam_message *(msgp[1]) = { &msg}; */\n  struct pam_message *(msgp[1]);\n  msgp[0] = &msg;\n  va_list va;\n  char text[128];\n\n  va_start(va, fmt);\n  vsnprintf(text, sizeof text, fmt, va);\n  va_end(va);\n\n  msg.msg_style = style;\n  msg.msg = text;\n  rv = pam_get_item(pamh, PAM_CONV, &conv);\n  if (rv != PAM_SUCCESS)\n    return rv;\n  if ((conv == NULL) || (conv->conv == NULL))\n    return PAM_CRED_INSUFFICIENT;\n  rv = conv->conv(1, msgp, &resp, conv->appdata_ptr);\n  if (rv != PAM_SUCCESS)\n    return rv;\n  if ((resp == NULL) || (resp[0].resp == NULL))\n    return !response ? PAM_SUCCESS : PAM_CRED_INSUFFICIENT;\n  if (response) {\n     *response = strdup(resp[0].resp);\n  }\n  /* overwrite memory and release it */\n  memset(resp[0].resp, 0, strlen(resp[0].resp));\n  free(&resp[0]);\n  return PAM_SUCCESS;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "R_API RRBNode *r_rbnode_prev(RRBNode *node) {\n\tr_return_val_if_fail (node, NULL);\n\tif (node->link[0]) {\n\t\tnode = node->link[0];\n\t\twhile (node->link[1]) {\n\t\t\tnode = node->link[1];\n\t\t}\n\t\treturn node;\n\t}\n\tRRBNode *parent = node->parent;\n\twhile (parent && parent->link[0] == node) {\n\t\tnode = parent;\n\t\tparent = node->parent;\n\t}\n\treturn parent;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "srs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\n\t/* We had better go around this loop exactly twice! */\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n\tr[4]=bn_mul_words(    &(r[0]),a,4,b[0]);\n\tr[5]=bn_mul_add_words(&(r[1]),a,4,b[1]);\n\tr[6]=bn_mul_add_words(&(r[2]),a,4,b[2]);\n\tr[7]=bn_mul_add_words(&(r[3]),a,4,b[3]);\n\t}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool ExtensionService::ComponentExtensionInfo::Equals(\n    const ComponentExtensionInfo& other) const {\n  return other.manifest == manifest && other.root_directory == root_directory;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "bool simulator_initialized() { return simulator_initialized_; }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void cirrus_bitblt_rop_nop(CirrusVGAState *s,\n                                  uint32_t dstaddr, const uint8_t *src,\n                                  int dstpitch,int srcpitch,\n                                  int bltwidth,int bltheight)\n{\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "channel_pre_connecting(Channel *c, fd_set *readset, fd_set *writeset)\n{\n\tdebug3(\"channel %d: waiting for connection\", c->self);\n\tFD_SET(c->sock, writeset);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void Item_subselect::init_expr_cache_tracker(THD *thd)\n{\n  if(!expr_cache)\n    return;\n\n  Explain_query *qw= thd->lex->explain;\n  DBUG_ASSERT(qw);\n  Explain_node *node= qw->get_node(unit->first_select()->select_number);\n  if (!node)\n    return;\n  DBUG_ASSERT(expr_cache->type() == Item::EXPR_CACHE_ITEM);\n  node->cache_tracker= ((Item_cache_wrapper *)expr_cache)->init_tracker(qw->mem_root);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void mp_decode_frame_helper(MotionPixelsContext *mp, GetBitContext *gb)\n{\n    YuvPixel p;\n    int y, y0;\n    for (y = 0; y < mp->avctx->height; ++y) {\n        if (mp->changes_map[y * mp->avctx->width] != 0) {\n            memset(mp->gradient_scale, 1, sizeof(mp->gradient_scale));\n            p = mp_get_yuv_from_rgb(mp, 0, y);\n        } else {\n            p.y += mp_gradient(mp, 0, mp_get_vlc(mp, gb));\n            p.y = av_clip(p.y, 0, 31);\n            if ((y & 3) == 0) {\n                p.v += mp_gradient(mp, 1, mp_get_vlc(mp, gb));\n                p.v = av_clip(p.v, -32, 31);\n                p.u += mp_gradient(mp, 2, mp_get_vlc(mp, gb));\n                p.u = av_clip(p.u, -32, 31);\n            }\n            mp->vpt[y] = p;\n            mp_set_rgb_from_yuv(mp, 0, y, &p);\n        }\n    }\n    for (y0 = 0; y0 < 2; ++y0)\n        for (y = y0; y < mp->avctx->height; y += 2)\n            mp_decode_line(mp, gb, y);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline u32 F(u32 x, u32 y, u32 z)\n{\n\treturn (x & y) | ((~x) & z);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "g_file_real_append_to_finish (GFile         *file,\n                              GAsyncResult  *res,\n                              GError       **error)\n{\n  g_return_val_if_fail (g_task_is_valid (res, file), NULL);\n\n  return g_task_propagate_pointer (G_TASK (res), error);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\n\tBuffer *buf, int *err, gchar **err_info)\n{\n\tint\tpkt_len;\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\n\t\treturn FALSE;\n\n\tif (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/* Parse the header */\n\tpkt_len = parse_cosine_rec_hdr(phdr, line, err, err_info);\n\tif (pkt_len == -1)\n\t\treturn FALSE;\n\n\t/* Convert the ASCII hex dump to binary data */\n\treturn parse_cosine_hex_dump(wth->random_fh, phdr, pkt_len, buf, err,\n\t    err_info);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "const char* XMLRPC_RequestSetMethodName(XMLRPC_REQUEST request, const char* methodName) {\n   if(request) {\n      simplestring_clear(&request->methodName);\n      simplestring_add(&request->methodName, methodName);\n      return request->methodName.str;\n   }\n   return NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline void json_print_item_str(WriterContext *wctx,\n\n                                       const char *key, const char *value,\n\n                                       const char *indent)\n\n{\n\n    char *key_esc = json_escape_str(key);\n\n    char *value_esc = json_escape_str(value);\n\n\n\n    printf(\"%s\\\"%s\\\": \\\"%s\\\"\", indent,\n\n           key_esc   ? key_esc   : \"\",\n\n           value_esc ? value_esc : \"\");\n\n    av_free(key_esc);\n\n    av_free(value_esc);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int invalidateTempStorage(Parse *pParse){\n  sqlite3 *db = pParse->db;\n  if( db->aDb[1].pBt!=0 ){\n    if( !db->autoCommit || sqlite3BtreeIsInReadTrans(db->aDb[1].pBt) ){\n      sqlite3ErrorMsg(pParse, \"temporary storage cannot be changed \"\n        \"from within a transaction\");\n      return SQLITE_ERROR;\n    }\n    sqlite3BtreeClose(db->aDb[1].pBt);\n    db->aDb[1].pBt = 0;\n    sqlite3ResetAllSchemasOfConnection(db);\n  }\n  return SQLITE_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static ssize_t driver_override_show(struct device *_dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\n\treturn sprintf(buf, \"%s\\n\", dev->driver_override);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "SendKeyEvent(rfbClient* client, uint32_t key, rfbBool down)\n{\n  rfbKeyEventMsg ke;\n\n  if (!SupportsClient2Server(client, rfbKeyEvent)) return TRUE;\n\n  memset(&ke, 0, sizeof(ke));\n  ke.type = rfbKeyEvent;\n  ke.down = down ? 1 : 0;\n  ke.key = rfbClientSwap32IfLE(key);\n  return WriteToRFBServer(client, (char *)&ke, sz_rfbKeyEventMsg);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "XvQueryAdaptors(\n    Display *dpy,\n    Window window,\n    unsigned int *p_nAdaptors,\n    XvAdaptorInfo **p_pAdaptors)\n{\n    XExtDisplayInfo *info = xv_find_display(dpy);\n    xvQueryAdaptorsReq *req;\n    xvQueryAdaptorsReply rep;\n     size_t size;\n     unsigned int ii, jj;\n     char *name;\n     XvAdaptorInfo *pas = NULL, *pa;\n     XvFormat *pfs, *pf;\n     char *buffer = NULL;\n        char *buffer;\n        char *string;\n        xvAdaptorInfo *pa;\n        xvFormat *pf;\n    } u;",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "str_case_equal (gconstpointer v1, gconstpointer v2)\n{\n  const char *string1 = v1;\n  const char *string2 = v2;\n\n  return g_ascii_strcasecmp (string1, string2) == 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void stsc_del(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void vnc_init_state(VncState *vs)\n\n{\n\n    vs->initialized = true;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    vs->last_x = -1;\n\n    vs->last_y = -1;\n\n\n\n    vs->as.freq = 44100;\n\n    vs->as.nchannels = 2;\n\n    vs->as.fmt = AUD_FMT_S16;\n\n    vs->as.endianness = 0;\n\n\n\n    qemu_mutex_init(&vs->output_mutex);\n\n    vs->bh = qemu_bh_new(vnc_jobs_bh, vs);\n\n\n\n    QTAILQ_INSERT_HEAD(&vd->clients, vs, next);\n\n\n\n    graphic_hw_update(vd->dcl.con);\n\n\n\n    vnc_write(vs, \"RFB 003.008\\n\", 12);\n\n    vnc_flush(vs);\n\n    vnc_read_when(vs, protocol_version, 12);\n\n    reset_keys(vs);\n\n    if (vs->vd->lock_key_sync)\n\n        vs->led = qemu_add_led_event_handler(kbd_leds, vs);\n\n\n\n    vs->mouse_mode_notifier.notify = check_pointer_type_change;\n\n    qemu_add_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n\n\n\n    /* vs might be free()ed here */\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static struct node* lookup_node_and_path_by_id_locked(struct fuse* fuse, __u64 nid,\n char* buf, size_t bufsize)\n{\n struct node* node = lookup_node_by_id_locked(fuse, nid);\n if (node && get_node_path_locked(node, buf, bufsize) < 0) {\n        node = NULL;\n }\n return node;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void rc4030_reset(DeviceState *dev)\n\n{\n\n    rc4030State *s = RC4030(dev);\n\n    int i;\n\n\n\n    s->config = 0x410; /* some boards seem to accept 0x104 too */\n\n    s->revision = 1;\n\n    s->invalid_address_register = 0;\n\n\n\n    memset(s->dma_regs, 0, sizeof(s->dma_regs));\n\n    rc4030_dma_tt_update(s, 0, 0);\n\n\n\n    s->remote_failed_address = s->memory_failed_address = 0;\n\n    s->cache_maint = 0;\n\n    s->cache_ptag = s->cache_ltag = 0;\n\n    s->cache_bmask = 0;\n\n\n\n    s->memory_refresh_rate = 0x18186;\n\n    s->nvram_protect = 7;\n\n    for (i = 0; i < 15; i++)\n\n        s->rem_speed[i] = 7;\n\n    s->imr_jazz = 0x10; /* XXX: required by firmware, but why? */\n\n    s->isr_jazz = 0;\n\n\n\n    s->itr = 0;\n\n\n\n    qemu_irq_lower(s->timer_irq);\n\n    qemu_irq_lower(s->jazz_bus_irq);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "bool Browser::PreHandleGestureEvent(content::WebContents* source,\n                                    const blink::WebGestureEvent& event) {\n  if (app_name() == DevToolsWindow::kDevToolsApp)\n    return event.type == blink::WebGestureEvent::GesturePinchBegin ||\n           event.type == blink::WebGestureEvent::GesturePinchUpdate ||\n           event.type == blink::WebGestureEvent::GesturePinchEnd;\n\n  return false;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int sony_init_ff(struct sony_sc *sc)\n{\n\tstruct hid_input *hidinput = list_entry(sc->hdev->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *input_dev = hidinput->input;\n\n\tinput_set_capability(input_dev, EV_FF, FF_RUMBLE);\n\treturn input_ff_create_memless(input_dev, NULL, sony_play_effect);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int domain_context_mapping_cb(struct pci_dev *pdev,\n\t\t\t\t     u16 alias, void *opaque)\n{\n\tstruct domain_context_mapping_data *data = opaque;\n\n\treturn domain_context_mapping_one(data->domain, data->iommu,\n\t\t\t\t\t  PCI_BUS_NUM(alias), alias & 0xff);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void xlnx_zynqmp_class_init(ObjectClass *oc, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    dc->props = xlnx_zynqmp_props;\n    dc->realize = xlnx_zynqmp_realize;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "streq_nocase_uprcase(const char *str1,\n                     const char *str2)\n{\n   while (*str1 && *str2) {\n      if (*str1 != uprcase(*str2))\n         return FALSE;\n      str1++;\n      str2++;\n   }\n   return *str1 == 0 && *str2 == 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void cpu_cgroup_fork(struct task_struct *task)\n{\n\tsched_move_task(task);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void pdf_run_sc_shade(fz_context *ctx, pdf_processor *proc, const char *name, fz_shade *shade)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpr->dev->flags &= ~FZ_DEVFLAG_FILLCOLOR_UNDEFINED;\n\tpdf_set_shade(ctx, pr, PDF_FILL, shade);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void scsi_write_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_write_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->iov.iov_len / 512;\n    if (n) {\n        if (s->tray_open) {\n            scsi_write_complete(r, -ENOMEDIUM);\n        }\n        qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n        bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n        r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n                                   scsi_write_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_write_complete(r, -ENOMEM);\n        }\n    } else {\n        /* Invoke completion routine to fetch data from host.  */\n        scsi_write_complete(r, 0);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "pci_set_cfgdata32(struct pci_vdev *dev, int offset, uint32_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\t*(uint32_t *)(dev->cfgdata + offset) = val;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void   nullParcelReleaseFunction (const uint8_t* data, size_t dataSize,\n const size_t* objects, size_t objectsSize,\n void* cookie) {\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bus_acquired_handler (GDBusConnection *connection,\n                      const gchar     *name,\n                      gpointer         user_data)\n{\n    g_dbus_connection_call (connection,\n                            IBUS_SERVICE_PORTAL,\n                            IBUS_PATH_IBUS,\n                            \"org.freedesktop.DBus.Peer\",\n                            \"Ping\",\n                            g_variant_new (\"()\"),\n                            G_VARIANT_TYPE (\"()\"),\n                            G_DBUS_CALL_FLAGS_NONE,\n                            -1,\n                            NULL /* cancellable */,\n                            (GAsyncReadyCallback)\n                                    _server_connect_start_portal_cb,\n                            NULL);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void nl80211_send_disassoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DISASSOCIATE, gfp);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void sisusb_kill_all_busy(struct sisusb_usb_data *sisusb)\n{\n\tint i;\n\n\tif (sisusb_all_free(sisusb))\n\t\treturn;\n\n\tfor (i = 0; i < sisusb->numobufs; i++) {\n\n\t\tif (sisusb->urbstatus[i] & SU_URB_BUSY)\n\t\t\tusb_kill_urb(sisusb->sisurbout[i]);\n\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void xhci_intx_update(XHCIState *xhci)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    int level = 0;\n\n    if (msix_enabled(pci_dev) ||\n        msi_enabled(pci_dev)) {\n        return;\n    }\n\n    if (xhci->intr[0].iman & IMAN_IP &&\n        xhci->intr[0].iman & IMAN_IE &&\n        xhci->usbcmd & USBCMD_INTE) {\n        level = 1;\n    }\n\n    trace_usb_xhci_irq_intx(level);\n    pci_set_irq(pci_dev, level);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int print_uint32(DeviceState *dev, Property *prop, char *dest, size_t len)\n\n{\n\n    uint32_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    return snprintf(dest, len, \"%\" PRIu32, *ptr);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "enum dc_status dce100_validate_plane(const struct dc_plane_state *plane_state, struct dc_caps *caps)\n{\n\n\tif (plane_state->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\treturn DC_OK;\n\n\treturn DC_FAIL_SURFACE_VALIDATE;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "js_Function *jsC_compilefunction(js_State *J, js_Ast *prog)\n{\n\treturn newfun(J, prog->line, prog->a, prog->b, prog->c, 0, J->default_strict);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static ssize_t active_time_ms_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct wakeup_source *ws = dev_get_drvdata(dev);\n\tktime_t active_time =\n\t\tws->active ? ktime_sub(ktime_get(), ws->last_time) : 0;\n\n\treturn sprintf(buf, \"%lld\\n\", ktime_to_ms(active_time));\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void vorbis_cleanup(AVFormatContext *s, int idx)\n{\n    struct ogg *ogg = s->priv_data;\n    struct ogg_stream *os = ogg->streams + idx;\n    struct oggvorbis_private *priv = os->private;\n    int i;\n    if (os->private)\n        for (i = 0; i < 3; i++)\n            av_freep(&priv->packet[i]);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static RtreeDValue cellGrowth(Rtree *pRtree, RtreeCell *p, RtreeCell *pCell){\n  RtreeDValue area;\n  RtreeCell cell;\n  memcpy(&cell, p, sizeof(RtreeCell));\n  area = cellArea(pRtree, &cell);\n  cellUnion(pRtree, &cell, pCell);\n  return (cellArea(pRtree, &cell)-area);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void cleanup_key_data(context, count, data)\n    krb5_context   context;\n    int                    count;\n    krb5_key_data        * data;\n{\n    int i, j;\n\n    for (i = 0; i < count; i++)\n        for (j = 0; j < data[i].key_data_ver; j++)\n            if (data[i].key_data_length[j])\n                krb5_db_free(context, data[i].key_data_contents[j]);\n    krb5_db_free(context, data);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "PrintText (session *sess, char *text)\n{\n\tPrintTextTimeStamp (sess, text, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void emulator_set_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_gdt(emul_to_vcpu(ctxt), dt);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "gdev_mjc_paper_size(gx_device *dev)\n{\n  int width = dev->MediaSize[0];\n  int height = dev->MediaSize[1];\n\n  if (width == 1190 && height == 1684)\n    return PAPER_SIZE_A2;\n  else\n    return PAPER_SIZE_A4;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static uint16_t mini_header_get_msg_type(SpiceDataHeaderOpaque *header)\n{\n    return ((SpiceMiniDataHeader *)header->data)->type;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "    void copyBytes(InStream* is, int length) {\n      while (length > 0) {\n        int n = check(1, length);\n        is->readBytes(ptr, n);\n        ptr += n;\n        length -= n;\n      }\n    }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void tg3_tx_recover(struct tg3 *tp)\n{\n\tBUG_ON(tg3_flag(tp, MBOX_WRITE_REORDER) ||\n\t       tp->write32_tx_mbox == tg3_write_indirect_mbox);\n\n\tnetdev_warn(tp->dev,\n\t\t    \"The system may be re-ordering memory-mapped I/O \"\n\t\t    \"cycles to the network device, attempting to recover. \"\n\t\t    \"Please report the problem to the driver maintainer \"\n\t\t    \"and include system chipset information.\\n\");\n\n\tspin_lock(&tp->lock);\n\ttg3_flag_set(tp, TX_RECOVERY_PENDING);\n\tspin_unlock(&tp->lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void sweep() {\n    if (iter.name) {\n      xmlFree(iter.name);\n    }\n    if (iter.nsprefix) {\n      xmlFree(iter.nsprefix);\n    }\n    if (xpath) {\n      xmlXPathFreeContext(xpath);\n    }\n  }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int afIdentifyFD (int fd)\n{\n\tFILE\t\t*fp;\n\tAFvirtualfile\t*vf;\n\tint\t\tresult;\n\n\t/*\n\t\tDuplicate the file descriptor since otherwise the\n\t\toriginal file descriptor would get closed when we close\n\t\tthe virtual file below.\n\t*/\n\tfd = dup(fd);\n\tvf = new File(fd, File::ReadAccess);\n\n\tresult = _af_identify(vf, NULL);\n\n\taf_fclose(vf);\n\n\treturn result;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\treturn -ENOSYS;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "get_matching_model_microcode(int cpu, unsigned long start,\n\t\t\t     void *data, size_t size,\n\t\t\t     struct mc_saved_data *mc_saved_data,\n\t\t\t     unsigned long *mc_saved_in_initrd,\n\t\t\t     struct ucode_cpu_info *uci)\n{\n\tu8 *ucode_ptr = data;\n\tunsigned int leftover = size;\n\tenum ucode_state state = UCODE_OK;\n\tunsigned int mc_size;\n\tstruct microcode_header_intel *mc_header;\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n \tunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\n \tint i;\n \n\twhile (leftover) {\n \t\tmc_header = (struct microcode_header_intel *)ucode_ptr;\n \n \t\tmc_size = get_totalsize(mc_header);\n\t\tif (!mc_size || mc_size > leftover ||\n\t\t\tmicrocode_sanity_check(ucode_ptr, 0) < 0)\n\t\t\tbreak;\n\n\t\tleftover -= mc_size;\n\n\t\t/*\n\t\t * Since APs with same family and model as the BSP may boot in\n\t\t * the platform, we need to find and save microcode patches\n\t\t * with the same family and model as the BSP.\n\t\t */\n\t\tif (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=\n\t\t\t UCODE_OK) {\n\t\t\tucode_ptr += mc_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\t_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\n\n\t\tucode_ptr += mc_size;\n\t}\n\n\tif (leftover) {\n\t\tstate = UCODE_ERROR;\n\t\tgoto out;\n\t}\n\n\tif (mc_saved_count == 0) {\n\t\tstate = UCODE_NFOUND;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < mc_saved_count; i++)\n\t\tmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\n\n\tmc_saved_data->mc_saved_count = mc_saved_count;\nout:\n\treturn state;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static bool io_wq_files_match(struct io_wq_work *work, void *data)\n{\n\tstruct files_struct *files = data;\n\n\treturn work->files == files;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "CLG_LogCommandAccess(IPAddr *client, CLG_Command_Type type, time_t now)\n{\n  uint32_t ip6[4];\n  Node *node;\n\n  if (active) {\n    switch (client->family) {\n      case IPADDR_INET4:\n        node = (Node *) find_subnet(&top_subnet4, &client->addr.in4, 1, 0);\n        break;\n      case IPADDR_INET6:\n        split_ip6(client, ip6);\n        node = (Node *) find_subnet(&top_subnet6, ip6, 4, 0);\n        break;\n      default:\n        assert(0);\n    }\n\n    node->ip_addr = *client;\n    node->last_cmd_hit = now;\n    switch (type) {\n      case CLG_CMD_AUTH:\n        ++node->cmd_hits_auth;\n        break;\n      case CLG_CMD_NORMAL:\n        ++node->cmd_hits_normal;\n        break;\n      case CLG_CMD_BAD_PKT:\n        ++node->cmd_hits_bad;\n        break;\n      default:\n        CROAK(\"Impossible\");\n        break;\n    }\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void Dispatcher::clear( const Parser::Clear *act )\n{\n  params.clear();\n  dispatch_chars.clear();\n  parsed = false;\n  act->handled = true;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "isLogicalOp2(int n, SWF_ACTION *actions,int maxn)\n{\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\tcase SWFACTION_LOGICALNOT:\n\tcase SWFACTION_PUSHDUP:\n\tcase SWFACTION_IF:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "context_complete (void *opaque, int *err)\n{\n  struct context_helper *h = opaque;\n  h->err = *err;\n  FREE_CALLBACK (h->context);\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "PHP_FUNCTION(imagechar)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void mce_reset(void)\n{\n\tcpu_missing = 0;\n\tatomic_set(&mce_fake_panicked, 0);\n\tatomic_set(&mce_executing, 0);\n\tatomic_set(&mce_callin, 0);\n\tatomic_set(&global_nwo, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void __skb_warn_lro_forwarding(const struct sk_buff *skb)\n{\n\tnet_warn_ratelimited(\"%s: received packets cannot be forwarded while LRO is enabled\\n\",\n\t\t\t     skb->dev->name);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "validate_stmts(asdl_seq *seq)\n{\n    int i;\n    for (i = 0; i < asdl_seq_LEN(seq); i++) {\n        stmt_ty stmt = asdl_seq_GET(seq, i);\n        if (stmt) {\n            if (!validate_stmt(stmt))\n                return 0;\n        }\n        else {\n            PyErr_SetString(PyExc_ValueError,\n                            \"None disallowed in statement list\");\n            return 0;\n        }\n    }\n    return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int __init iommu_init_mempool(void)\n{\n\tint ret;\n\tret = iova_cache_get();\n\tif (ret)\n\t\treturn ret;\n\n\tret = iommu_domain_cache_init();\n\tif (ret)\n\t\tgoto domain_error;\n\n\tret = iommu_devinfo_cache_init();\n\tif (!ret)\n\t\treturn ret;\n\n\tkmem_cache_destroy(iommu_domain_cache);\ndomain_error:\n\tiova_cache_put();\n\n\treturn -ENOMEM;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline void set_system_intr_gate(unsigned int n, void *addr)\n{\n\tBUG_ON((unsigned)n > 0xFF);\n\t_set_gate(n, GATE_INTERRUPT, addr, 0x3, 0, __KERNEL_CS);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "explicit ConnectionRequest(scoped_refptr<IndexedDBDatabase> db) : db_(db) {}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "content::RenderFrameHost* ElectronBrowserHandlerImpl::GetRenderFrameHost() {\n  return content::RenderFrameHost::FromID(render_process_id_, render_frame_id_);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void gen_sync(DisasContext *ctx)\n\n{\n\n    uint32_t l = (ctx->opcode >> 21) & 3;\n\n\n\n    /*\n\n     * We may need to check for a pending TLB flush.\n\n     *\n\n     * We do this on ptesync (l == 2) on ppc64 and any sync pn ppc32.\n\n     *\n\n     * Additionally, this can only happen in kernel mode however so\n\n     * check MSR_PR as well.\n\n     */\n\n    if (((l == 2) || !(ctx->insns_flags & PPC_64B)) && !ctx->pr) {\n\n        gen_check_tlb_flush(ctx);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int ax88179_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct sk_buff *ax_skb;\n\tint pkt_cnt;\n\tu32 rx_hdr;\n\tu16 hdr_off;\n\tu32 *pkt_hdr;\n\n\t/* This check is no longer done by usbnet */\n\tif (skb->len < dev->net->hard_header_len)\n\t\treturn 0;\n\n\tskb_trim(skb, skb->len - 4);\n\trx_hdr = get_unaligned_le32(skb_tail_pointer(skb));\n\n\tpkt_cnt = (u16)rx_hdr;\n\thdr_off = (u16)(rx_hdr >> 16);\n\tpkt_hdr = (u32 *)(skb->data + hdr_off);\n\n\twhile (pkt_cnt--) {\n\t\tu16 pkt_len;\n\n\t\tle32_to_cpus(pkt_hdr);\n\t\tpkt_len = (*pkt_hdr >> 16) & 0x1fff;\n\n\t\t/* Check CRC or runt packet */\n\t\tif ((*pkt_hdr & AX_RXHDR_CRC_ERR) ||\n\t\t    (*pkt_hdr & AX_RXHDR_DROP_ERR)) {\n\t\t\tskb_pull(skb, (pkt_len + 7) & 0xFFF8);\n\t\t\tpkt_hdr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pkt_cnt == 0) {\n\t\t\tskb->len = pkt_len;\n\t\t\t/* Skip IP alignment pseudo header */\n\t\t\tskb_pull(skb, 2);\n\t\t\tskb_set_tail_pointer(skb, skb->len);\n\t\t\tskb->truesize = pkt_len + sizeof(struct sk_buff);\n\t\t\tax88179_rx_checksum(skb, pkt_hdr);\n\t\t\treturn 1;\n\t\t}\n\n\t\tax_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (ax_skb) {\n\t\t\tax_skb->len = pkt_len;\n\t\t\t/* Skip IP alignment pseudo header */\n\t\t\tskb_pull(ax_skb, 2);\n\t\t\tskb_set_tail_pointer(ax_skb, ax_skb->len);\n\t\t\tax_skb->truesize = pkt_len + sizeof(struct sk_buff);\n\t\t\tax88179_rx_checksum(ax_skb, pkt_hdr);\n\t\t\tusbnet_skb_return(dev, ax_skb);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\n\t\tskb_pull(skb, (pkt_len + 7) & 0xFFF8);\n\t\tpkt_hdr++;\n\t}\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "virtual void didFailProvisionalLoad(WebFrame* frame, const WebURLError& error)\n    {\n        frame->loadHTMLString(\"This should appear\", toKURL(\"data:text/html,chromewebdata\"), error.unreachableURL, true);\n        runPendingTasks();\n    }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int nbd_open(BlockDriverState *bs, QDict *options, int flags,\n\n                    Error **errp)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    char *export = NULL;\n\n    int result, sock;\n\n    Error *local_err = NULL;\n\n\n\n    /* Pop the config into our state object. Exit if invalid. */\n\n    nbd_config(s, options, &export, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* establish TCP connection, return error if it fails\n\n     * TODO: Configurable retry-until-timeout behaviour.\n\n     */\n\n    sock = nbd_establish_connection(bs, errp);\n\n    if (sock < 0) {\n\n\n        return sock;\n\n    }\n\n\n\n    /* NBD handshake */\n\n    result = nbd_client_init(bs, sock, export, errp);\n\n\n    return result;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void qemu_set_log(int log_flags, bool use_own_buffers)\n\n{\n\n    qemu_loglevel = log_flags;\n\n    if (qemu_loglevel && !qemu_logfile) {\n\n        qemu_logfile = fopen(logfilename, log_append ? \"a\" : \"w\");\n\n        if (!qemu_logfile) {\n\n            perror(logfilename);\n\n            _exit(1);\n\n        }\n\n        /* must avoid mmap() usage of glibc by setting a buffer \"by hand\" */\n\n        if (use_own_buffers) {\n\n            static char logfile_buf[4096];\n\n\n\n            setvbuf(qemu_logfile, logfile_buf, _IOLBF, sizeof(logfile_buf));\n\n        } else {\n\n#if defined(_WIN32)\n\n            /* Win32 doesn't support line-buffering, so use unbuffered output. */\n\n            setvbuf(qemu_logfile, NULL, _IONBF, 0);\n\n#else\n\n            setvbuf(qemu_logfile, NULL, _IOLBF, 0);\n\n#endif\n\n            log_append = 1;\n\n        }\n\n    }\n\n    if (!qemu_loglevel && qemu_logfile) {\n\n        fclose(qemu_logfile);\n\n        qemu_logfile = NULL;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int zstd_compress(struct transaction_t *txn __attribute__((unused)),\n                           unsigned flags __attribute__((unused)),\n                           const char *buf __attribute__((unused)),\n                           unsigned len __attribute__((unused)))\n{\n    fatal(\"Zstandard Compression requested, but not available\", EX_SOFTWARE);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "AwMainDelegate::CreateContentBrowserClient() {\n  content_browser_client_.reset(new AwContentBrowserClient(this));\n  return content_browser_client_.get();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void RENAME(uyvytoyuv422)(uint8_t *ydst, uint8_t *udst, uint8_t *vdst, const uint8_t *src,\n\n                                 int width, int height,\n\n                                 int lumStride, int chromStride, int srcStride)\n\n{\n\n    int y;\n\n    const int chromWidth = FF_CEIL_RSHIFT(width, 1);\n\n\n\n    for (y=0; y<height; y++) {\n\n        RENAME(extract_even)(src+1, ydst, width);\n\n        RENAME(extract_even2)(src, udst, vdst, chromWidth);\n\n\n\n        src += srcStride;\n\n        ydst+= lumStride;\n\n        udst+= chromStride;\n\n        vdst+= chromStride;\n\n    }\n\n    __asm__(\n\n            EMMS\"       \\n\\t\"\n\n            SFENCE\"     \\n\\t\"\n\n            ::: \"memory\"\n\n        );\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool CrostiniUpgrader::CanUpgrade() {\n  return false;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static Bool wgt_enum_files(void *cbck, char *file_name, char *file_path, GF_FileEnumInfo *file_info)\n{\n\tWGTEnum *wgt = (WGTEnum *)cbck;\n\n\tif (!strcmp(wgt->root_file, file_path)) return 0;\n\t/*remove CVS stuff*/\n\tif (strstr(file_path, \".#\")) return 0;\n\tgf_list_add(wgt->imports, gf_strdup(file_path) );\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int codeCompare(\n  Parse *pParse,    /* The parsing (and code generating) context */\n  Expr *pLeft,      /* The left operand */\n  Expr *pRight,     /* The right operand */\n  int opcode,       /* The comparison opcode */\n  int in1, int in2, /* Register holding operands */\n  int dest,         /* Jump here if true.  */\n  int jumpIfNull,   /* If true, jump if either operand is NULL */\n  int isCommuted    /* The comparison has been commuted */\n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n\n  if( isCommuted ){\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n  }else{\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  }\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline void ct_show_zone(struct seq_file *s, const struct nf_conn *ct,\n\t\t\t\tint dir)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n{\n\tconst struct aodv_hello *ah;\n\n\tswitch (ep->type) {\n\tcase AODV_EXT_HELLO:\n\t\tah = (const struct aodv_hello *)(const void *)ep;\n\t\tND_TCHECK(*ah);\n\t\tif (length < sizeof(struct aodv_hello))\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n\t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n\t\tbreak;\n\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int generic_packet(struct nf_conn *ct,\n\t\t\t  const struct sk_buff *skb,\n\t\t\t  unsigned int dataoff,\n\t\t\t  enum ip_conntrack_info ctinfo,\n\t\t\t  u_int8_t pf,\n\t\t\t  unsigned int hooknum,\n\t\t\t  unsigned int *timeout)\n{\n\tnf_ct_refresh_acct(ct, ctinfo, skb, *timeout);\n\treturn NF_ACCEPT;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int proc_sys_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\treturn !PROC_I(d_inode(dentry))->sysctl->unregistering;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "    bool getBase64Row(char* ptr, int indent, char* &beg, char* &end)\n    {\n        beg = end = ptr = skipSpaces(ptr, 0, INT_MAX);\n        if (!ptr || !*ptr)\n            return false; // end of file\n\n        if (ptr - fs->bufferStart() != indent)\n            return false; // end of base64 data\n\n        /* find end */\n        while(cv_isprint(*ptr)) /* no check for base64 string */\n            ++ptr;\n        if (*ptr == '\\0')\n            CV_PARSE_ERROR_CPP(\"Unexpected end of line\");\n\n        end = ptr;\n        return true;\n    }",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void hfs_btree_close(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node;\n\tint i;\n\n\tif (!tree)\n\t\treturn;\n\n\tfor (i = 0; i < NODE_HASH_SIZE; i++) {\n\t\twhile ((node = tree->node_hash[i])) {\n\t\t\ttree->node_hash[i] = node->next_hash;\n\t\t\tif (atomic_read(&node->refcnt))\n\t\t\t\tprintk(KERN_ERR \"hfs: node %d:%d still has %d user(s)!\\n\",\n\t\t\t\t\tnode->tree->cnid, node->this, atomic_read(&node->refcnt));\n\t\t\thfs_bnode_free(node);\n\t\t\ttree->node_hash_cnt--;\n\t\t}\n\t}\n\tiput(tree->inode);\n\tkfree(tree);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void print_header(void)\n{\n\tif (!cgi_waspost()) {\n\t\tprintf(\"Expires: 0\\r\\n\");\n\t}\n\tprintf(\"Content-type: text/html\\r\\n\\r\\n\");\n\n\tif (!include_html(\"include/header.html\")) {\n\t\tprintf(\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 3.2//EN\\\">\\n\");\n\t\tprintf(\"<HTML>\\n<HEAD>\\n<TITLE>Samba Web Administration Tool</TITLE>\\n</HEAD>\\n<BODY background=\\\"/swat/images/background.jpg\\\">\\n\\n\");\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void get_seg(SegmentCache *lhs, const struct kvm_segment *rhs)\n\n{\n\n    lhs->selector = rhs->selector;\n\n    lhs->base = rhs->base;\n\n    lhs->limit = rhs->limit;\n\n    lhs->flags = (rhs->type << DESC_TYPE_SHIFT) |\n\n                 (rhs->present * DESC_P_MASK) |\n\n                 (rhs->dpl << DESC_DPL_SHIFT) |\n\n                 (rhs->db << DESC_B_SHIFT) |\n\n                 (rhs->s * DESC_S_MASK) |\n\n                 (rhs->l << DESC_L_SHIFT) |\n\n                 (rhs->g * DESC_G_MASK) |\n\n                 (rhs->avl * DESC_AVL_MASK);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "rsvg_new_filter_primitive_diffuse_lighting (void)\n{\n    RsvgFilterPrimitiveDiffuseLighting *filter;\n    filter = g_new (RsvgFilterPrimitiveDiffuseLighting, 1);\n    _rsvg_node_init (&filter->super.super);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =\n        filter->super.height.factor = 'n';\n    filter->surfaceScale = 1;\n    filter->diffuseConstant = 1;\n    filter->dx = 1;\n    filter->dy = 1;\n    filter->lightingcolour = 0xFFFFFFFF;\n    filter->super.render = &rsvg_filter_primitive_diffuse_lighting_render;\n    filter->super.super.free = &rsvg_filter_primitive_diffuse_lighting_free;\n    filter->super.super.set_atts = rsvg_filter_primitive_diffuse_lighting_set_atts;\n    return (RsvgNode *) filter;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "virtual status_t setPropertyByteArray(String8 const &name,\n Vector<uint8_t> const &value) const {\n Parcel data, reply;\n        data.writeInterfaceToken(IDrm::getInterfaceDescriptor());\n\n        data.writeString8(name);\n        writeVector(data, value);\n status_t status = remote()->transact(SET_PROPERTY_BYTE_ARRAY, data, &reply);\n if (status != OK) {\n return status;\n }\n\n return reply.readInt32();\n }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "ptr_t GC_unix_get_mem(word bytes)\n{\n# if defined(MMAP_SUPPORTED)\n    /* By default, we try both sbrk and mmap, in that order.    */\n    static GC_bool sbrk_failed = FALSE;\n    ptr_t result = 0;\n\n    if (!sbrk_failed) result = GC_unix_sbrk_get_mem(bytes);\n    if (0 == result) {\n        sbrk_failed = TRUE;\n        result = GC_unix_mmap_get_mem(bytes);\n    }\n    if (0 == result) {\n        /* Try sbrk again, in case sbrk memory became available.        */\n        result = GC_unix_sbrk_get_mem(bytes);\n    }\n    return result;\n# else /* !MMAP_SUPPORTED */\n    return GC_unix_sbrk_get_mem(bytes);\n# endif\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "f_histadd(typval_T *argvars UNUSED, typval_T *rettv)\n{\n#ifdef FEAT_CMDHIST\n    int\t\thistype;\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n#endif\n\n    rettv->vval.v_number = FALSE;\n    if (check_restricted() || check_secure())\n\treturn;\n#ifdef FEAT_CMDHIST\n    str = tv_get_string_chk(&argvars[0]);\t/* NULL on type error */\n    histype = str != NULL ? get_histtype(str) : -1;\n    if (histype >= 0)\n    {\n\tstr = tv_get_string_buf(&argvars[1], buf);\n\tif (*str != NUL)\n\t{\n\t    init_history();\n\t    add_to_history(histype, str, FALSE, NUL);\n\t    rettv->vval.v_number = TRUE;\n\t    return;\n\t}\n    }\n#endif\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int ntop_interface_release_host_alert(lua_State* vm) {\n  return ntop_interface_engage_release_host_alert(vm, false /* release */);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "virtual ~PendingCommentCallback() \n        {\n            xmlFree(s);\n        }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "bool Item_sum_avg::fix_length_and_dec()\n{\n  if (Item_sum_sum::fix_length_and_dec())\n    return TRUE;\n  maybe_null=null_value=1;\n  prec_increment= current_thd->variables.div_precincrement;\n  if (Item_sum_avg::result_type() == DECIMAL_RESULT)\n  {\n    int precision= args[0]->decimal_precision() + prec_increment;\n    decimals= MY_MIN(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);\n    max_length= my_decimal_precision_to_length_no_truncation(precision,\n                                                             decimals,\n                                                             unsigned_flag);\n    f_precision= MY_MIN(precision+DECIMAL_LONGLONG_DIGITS, DECIMAL_MAX_PRECISION);\n    f_scale=  args[0]->decimals;\n    dec_bin_size= my_decimal_get_binary_size(f_precision, f_scale);\n  }\n  else\n  {\n    decimals= MY_MIN(args[0]->decimals + prec_increment,\n                     FLOATING_POINT_DECIMALS);\n    max_length= MY_MIN(args[0]->max_length + prec_increment, float_length(decimals));\n  }\n  return FALSE;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t      unsigned long addr, int new_below)\n{\n\tif (mm->map_count >= sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\treturn __split_vma(mm, vma, addr, new_below);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bool CjfifDecode::GetDecodeStatus()\r\n{\r\n\treturn m_bImgOK;\r\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "XFontStruct *XLoadQueryFont(\n   register Display *dpy,\n   _Xconst char *name)\n{\n    XFontStruct *font_result;\n    register long nbytes;\n    Font fid;\n    xOpenFontReq *req;\n    unsigned long seq;\n#ifdef USE_XF86BIGFONT\n    XF86BigfontCodes *extcodes = _XF86BigfontCodes(dpy);\n#endif\n\n    if (_XF86LoadQueryLocaleFont(dpy, name, &font_result, (Font *)0))\n      return font_result;\n    LockDisplay(dpy);\n    GetReq(OpenFont, req);\n    seq = dpy->request; /* Can't use extended sequence number here */\n    nbytes = req->nbytes = (CARD16) (name ? strlen(name) : 0);\n    req->fid = fid = XAllocID(dpy);\n    req->length += (nbytes+3)>>2;\n    Data (dpy, name, nbytes);\n    font_result = NULL;\n#ifdef USE_XF86BIGFONT\n    if (extcodes) {\n\tfont_result = _XF86BigfontQueryFont(dpy, extcodes, fid, seq);\n\tseq = 0;\n    }\n#endif\n    if (!font_result)\n\tfont_result = _XQueryFont(dpy, fid, seq);\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return font_result;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\n{\n\tint r;\n\tsigset_t sigsaved;\n\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\n\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {\n\t\tkvm_vcpu_block(vcpu);\n\t\tclear_bit(KVM_REQ_UNHALT, &vcpu->requests);\n\t\tr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (vcpu->mmio_needed) {\n\t\tmemcpy(vcpu->mmio_data, kvm_run->mmio.data, 8);\n\t\tkvm_set_mmio_data(vcpu);\n\t\tvcpu->mmio_read_completed = 1;\n\t\tvcpu->mmio_needed = 0;\n\t}\n\tr = __vcpu_run(vcpu, kvm_run);\nout:\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn r;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool Backtrace::VerifyReadWordArgs(uintptr_t ptr, word_t* out_value) {\n if (ptr & (sizeof(word_t)-1)) {\n    BACK_LOGW(\"invalid pointer %p\", reinterpret_cast<void*>(ptr));\n *out_value = static_cast<word_t>(-1);\n return false;\n }\n return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int msg_parse_fetch (IMAP_HEADER *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS (s);\n\n    if (ascii_strncasecmp (\"FLAGS\", s, 5) == 0)\n    {\n      if ((s = msg_parse_flags (h, s)) == NULL)\n        return -1;\n    }\n    else if (ascii_strncasecmp (\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS (s);\n      if (mutt_atoui (s, &h->data->uid) < 0)\n        return -1;\n\n      s = imap_next_word (s);\n    }\n    else if (ascii_strncasecmp (\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS (s);\n      if (*s != '\\\"')\n      {\n        dprint (1, (debugfile, \"msg_parse_fetch(): bogus INTERNALDATE entry: %s\\n\", s));\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; /* skip past the trailing \" */\n      *ptmp = 0;\n      h->received = imap_parse_date (tmp);\n    }\n    else if (ascii_strncasecmp (\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS (s);\n      ptmp = tmp;\n      while (isdigit ((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = 0;\n      if (mutt_atol (tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if (!ascii_strncasecmp (\"BODY\", s, 4) ||\n      !ascii_strncasecmp (\"RFC822.HEADER\", s, 13))\n    {\n      /* handle above, in msg_fetch_header */\n      return -2;\n    }\n    else if (*s == ')')\n      s++; /* end of request */\n    else if (*s)\n    {\n      /* got something i don't understand */\n      imap_error (\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n\n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "SWFInput_readSBits(SWFInput input, int number)\n {\n \tint num = SWFInput_readBits(input, number);\n \n\tif ( num & (1<<(number-1)) )\n \t\treturn num - (1<<number);\n \telse\n \t\treturn num;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static GList *get_option_value_list(char *value, GDHCPOptionType type)\n{\n\tchar *pos = value;\n\tGList *list = NULL;\n\n\tif (!pos)\n\t\treturn NULL;\n\n\tif (type == OPTION_STRING)\n\t\treturn g_list_append(list, g_strdup(value));\n\n\twhile ((pos = strchr(pos, ' '))) {\n\t\t*pos = '\\0';\n\n\t\tlist = g_list_append(list, g_strdup(value));\n\n\t\tvalue = ++pos;\n\t}\n\n\tlist = g_list_append(list, g_strdup(value));\n\n\treturn list;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "mrb_gc_protect(mrb_state *mrb, mrb_value obj)\n{\n  if (mrb_immediate_p(obj)) return;\n  gc_protect(mrb, &mrb->gc, mrb_basic_ptr(obj));\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void Document::DidLoadAllImports() {\n  if (!HaveScriptBlockingStylesheetsLoaded())\n    return;\n  DidLoadAllScriptBlockingResources();\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static ssize_t pmcraid_show_drv_version(\n\tstruct device *dev,\n\tstruct device_attribute *attr,\n\tchar *buf\n)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"version: %s\\n\",\n\t\t\tPMCRAID_DRIVER_VERSION);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void __init acpi_set_irq_model_ioapic(void)\n{\n\tacpi_irq_model = ACPI_IRQ_MODEL_IOAPIC;\n\t__acpi_register_gsi = acpi_register_gsi_ioapic;\n\t__acpi_unregister_gsi = acpi_unregister_gsi_ioapic;\n\tacpi_ioapic = 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "const AtomicString& Document::RequiredCSP() {\n  if (!Loader())\n    return g_null_atom;\n  return frame_->Loader().RequiredCSP();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void WebRuntimeFeatures::enablePeerConnection(bool enable)\n{\n    RuntimeEnabledFeatures::setPeerConnectionEnabled(enable);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)\n{\n    size_t retlen;\n    int truncated;\n\n    _dopr(&buf, NULL, &n, &retlen, &truncated, format, args);\n\n    if (truncated)\n        /*\n         * In case of truncation, return -1 like traditional snprintf.\n         * (Current drafts for ISO/IEC 9899 say snprintf should return the\n         * number of characters that would have been written, had the buffer\n         * been large enough.)\n         */\n        return -1;\n    else\n        return (retlen <= INT_MAX) ? (int)retlen : -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int fixup_exception(struct pt_regs *regs)\n{\n\tconst struct exception_table_entry *fixup;\n\tunsigned long new_ip;\n\n#ifdef CONFIG_PNPBIOS\n\tif (unlikely(SEGMENT_IS_PNP_CODE(regs->cs))) {\n\t\textern u32 pnp_bios_fault_eip, pnp_bios_fault_esp;\n\t\textern u32 pnp_bios_is_utter_crap;\n\t\tpnp_bios_is_utter_crap = 1;\n\t\tprintk(KERN_CRIT \"PNPBIOS fault.. attempting recovery.\\n\");\n\t\t__asm__ volatile(\n\t\t\t\"movl %0, %%esp\\n\\t\"\n\t\t\t\"jmp *%1\\n\\t\"\n\t\t\t: : \"g\" (pnp_bios_fault_esp), \"g\" (pnp_bios_fault_eip));\n\t\tpanic(\"do_trap: can't hit this\");\n\t}\n#endif\n\n\tfixup = search_exception_tables(regs->ip);\n\tif (fixup) {\n\t\tnew_ip = ex_fixup_addr(fixup);\n\n\t\tif (fixup->fixup - fixup->insn >= 0x7ffffff0 - 4) {\n\t\t\t/* Special hack for uaccess_err */\n\t\t\tcurrent_thread_info()->uaccess_err = 1;\n\t\t\tnew_ip -= 0x7ffffff0;\n\t\t}\n\t\tregs->ip = new_ip;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void WebContentsImpl::OnFindReply(int request_id,\n                                  int number_of_matches,\n                                  const gfx::Rect& selection_rect,\n                                  int active_match_ordinal,\n                                  bool final_update) {\n  if (delegate_) {\n    delegate_->FindReply(this, request_id, number_of_matches, selection_rect,\n                         active_match_ordinal, final_update);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void nfs_dentry_handle_enoent(struct dentry *dentry)\n{\n\tif (simple_positive(dentry))\n\t\td_delete(dentry);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void RGBGrayEncoder::reset() {\n  str->reset();\n  bufPtr = bufEnd = buf;\n  eof = gFalse;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void initialize(const string &path, bool owner) {\n\t\tTRACE_POINT();\n\t\tthis->path  = path;\n\t\tthis->owner = owner;\n\t\t\n\t\t/* Create the server instance directory. We only need to write to this\n\t\t * directory for these reasons:\n\t\t * 1. Initial population of structure files (structure_version.txt, instance.pid).\n\t\t * 2. Creating/removing a generation directory.\n\t\t * 3. Removing the entire server instance directory (after all\n\t\t *    generations are removed).\n\t\t *\n\t\t * 1 and 2 are done by the helper server during initialization and before lowering\n\t\t * privilege. 3 is done during helper server shutdown by a cleanup process that's\n\t\t * running as the same user the helper server was running as before privilege\n\t\t * lowering.\n\t\t * Therefore, we make the directory only writable by the user the helper server\n\t\t * was running as before privilege is lowered. Everybody else has read and execute\n\t\t * rights though, because we want admin tools to be able to list the available\n\t\t * generations no matter what user they're running as.\n\t\t */\n\t\tmakeDirTree(path, \"u=rwx,g=rx,o=rx\");\n\t}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void unterminated_dict_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"{'abc':32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "std::wstring GetClientStateMediumKeyPathForBinaries() {\n  return GetBinariesClientStateMediumKeyPath();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)\n{\n    buffer_verify(buffer);\n\n    if (data == NULL) {\n        return -1;\n    }\n\n    if (buffer->used + len < len) {\n        return -1;\n    }\n\n    if (buffer->allocated < (buffer->used + len)) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n        if (realloc_buffer(buffer, buffer->used + len) < 0) {\n            return -1;\n        }\n    }\n\n    memcpy(buffer->data + buffer->used, data, len);\n    buffer->used += len;\n    buffer_verify(buffer);\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void Item_ref_null_helper::print(String *str, enum_query_type query_type)\n{\n  str->append(STRING_WITH_LEN(\"<ref_null_helper>(\"));\n  if (ref)\n    (*ref)->print(str, query_type);\n  else\n    str->append('?');\n  str->append(')');\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void RGWCORSRule::format_exp_headers(string& s) {\n  s = \"\";\n  for (const auto& header : exposable_hdrs) {\n    if (s.length() > 0)\n      s.append(\",\");\n    // these values are sent to clients in a 'Access-Control-Expose-Headers'\n    // response header, so we escape '\\n' to avoid header injection\n    boost::replace_all_copy(std::back_inserter(s), header, \"\\n\", \"\\\\n\");\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void pci_edu_realize(PCIDevice *pdev, Error **errp)\n\n{\n\n    EduState *edu = DO_UPCAST(EduState, pdev, pdev);\n\n    uint8_t *pci_conf = pdev->config;\n\n\n\n    timer_init_ms(&edu->dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);\n\n\n\n    qemu_mutex_init(&edu->thr_mutex);\n\n    qemu_cond_init(&edu->thr_cond);\n\n    qemu_thread_create(&edu->thread, \"edu\", edu_fact_thread,\n\n                       edu, QEMU_THREAD_JOINABLE);\n\n\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n\n\n    if (msi_init(pdev, 0, 1, true, false, errp)) {\n\n        return;\n\n    }\n\n\n\n    memory_region_init_io(&edu->mmio, OBJECT(edu), &edu_mmio_ops, edu,\n\n                    \"edu-mmio\", 1 << 20);\n\n    pci_register_bar(pdev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &edu->mmio);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int __init aio_setup(void)\n{\n\tstatic struct file_system_type aio_fs = {\n\t\t.name\t\t= \"aio\",\n\t\t.mount\t\t= aio_mount,\n\t\t.kill_sb\t= kill_anon_super,\n\t};\n\taio_mnt = kern_mount(&aio_fs);\n\tif (IS_ERR(aio_mnt))\n\t\tpanic(\"Failed to create aio fs mount.\");\n\n\tkiocb_cachep = KMEM_CACHE(aio_kiocb, SLAB_HWCACHE_ALIGN|SLAB_PANIC);\n\tkioctx_cachep = KMEM_CACHE(kioctx,SLAB_HWCACHE_ALIGN|SLAB_PANIC);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void ssl_set_dbg( ssl_context *ssl,\n                  void (*f_dbg)(void *, int, const char *),\n                  void  *p_dbg )\n{\n    ssl->f_dbg      = f_dbg;\n    ssl->p_dbg      = p_dbg;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void SFS_ArrayDeref(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tSFS_AddString(parser, \"[\");\n\tSFS_CompoundExpression(parser);\n\tSFS_AddString(parser, \"]\");\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void fib6_free_table(struct fib6_table *table)\n{\n\tinetpeer_invalidate_tree(&table->tb6_peers);\n\tkfree(table);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void print_samplesref(AVFilterBufferRef *samplesref)\n\n{\n\n    const AVFilterBufferRefAudioProps *props = samplesref->audio;\n\n    const int n = props->nb_samples * av_get_channel_layout_nb_channels(props->channel_layout);\n\n    const uint16_t *p     = (uint16_t*)samplesref->data[0];\n\n    const uint16_t *p_end = p + n;\n\n\n\n    while (p < p_end) {\n\n        fputc(*p    & 0xff, stdout);\n\n        fputc(*p>>8 & 0xff, stdout);\n\n        p++;\n\n    }\n\n    fflush(stdout);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "char* _single_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n\n    if ( !in )\n    {\n        return in;\n    }\n\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc( len + 1 );\n\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n\n    return chr;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "GF_Box *trgr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupBox, GF_ISOM_BOX_TYPE_TRGR);\n\ttmp->groups = gf_list_new();\n\tif (!tmp->groups) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "} catch (const Exiv2::AnyError& e) {\n        std::cerr << \"Exiv2 exception in insert action for file \" << path << \":\\n\" << e << \"\\n\";\n        return 1;\n    }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n\n    return retval;\n}                               /* end usm_malloc_usmStateReference() */",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void cblk_destroy(jpc_enc_cblk_t *cblk)\n{\n\tuint_fast16_t passno;\n\tjpc_enc_pass_t *pass;\n\tif (cblk->passes) {\n\t\tfor (passno = 0, pass = cblk->passes; passno < cblk->numpasses;\n\t\t  ++passno, ++pass) {\n\t\t\tpass_destroy(pass);\n\t\t}\n\t\tjas_free(cblk->passes);\n\t}\n\tif (cblk->stream) {\n\t\tjas_stream_close(cblk->stream);\n\t}\n\tif (cblk->mqenc) {\n\t\tjpc_mqenc_destroy(cblk->mqenc);\n\t}\n\tif (cblk->data) {\n\t\tjas_seq2d_destroy(cblk->data);\n\t}\n\tif (cblk->flags) {\n\t\tjas_seq2d_destroy(cblk->flags);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void AuthenticatorBlePowerOnManualSheetModel::OnBluetoothPoweredStateChanged() {\n  dialog_model()->OnSheetModelDidChange();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "R_API ut64 rbin_java_verification_info_calc_size(RBinJavaVerificationObj *se) {\n\tut64 sz = 1;\n\tif (!se) {\n\t\treturn 0;\n\t}\n\t// r_buf_read_at (bin->b, offset, (ut8*)(&se->tag), 1)\n\tswitch (se->tag) {\n\tcase R_BIN_JAVA_STACKMAP_OBJECT:\n\t\t// r_buf_read_at (bin->b, offset+1, (ut8*)buf, 2)\n\t\tsz += 2;\n\t\tbreak;\n\tcase R_BIN_JAVA_STACKMAP_UNINIT:\n\t\t// r_buf_read_at (bin->b, offset+1, (ut8*)buf, 2)\n\t\tsz += 2;\n\t\tbreak;\n\t}\n\treturn sz;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int64_t yr_object_get_integer(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* integer_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    integer_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    integer_obj = object;\n\n  va_end(args);\n\n  if (integer_obj == NULL)\n    return UNDEFINED;\n\n  assertf(integer_obj->type == OBJECT_TYPE_INTEGER,\n          \"type of \\\"%s\\\" is not integer\\n\", field);\n\n  return integer_obj->value.i;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "GF_Err m4ds_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tchar *enc_ods;\n\tu32 enc_od_size;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tenc_ods = NULL;\n\tenc_od_size = 0;\n\te = gf_odf_desc_list_write(ptr->descriptors, &enc_ods, &enc_od_size);\n\tif (e) return e;\n\tif (enc_od_size) {\n\t\tgf_bs_write_data(bs, enc_ods, enc_od_size);\n\t\tgf_free(enc_ods);\n\t}\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int fastVarFree(Jsi_Interp *interp, void *ptr) {\n    FastVar *fv = ptr;\n    Jsi_Value *v = fv->var.lval;\n    if (v) {\n        //printf(\"FV FREE: %p (%d/%d)\\n\", fv, v->refCnt, v->vt == JSI_VT_OBJECT?v->d.obj->refcnt:-99);\n        //Jsi_DecrRefCount(interp, v);\n    }\n    return JSI_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void __exit ux500_cryp_mod_fini(void)\n{\n\tpr_debug(\"[%s] is called!\", __func__);\n\tplatform_driver_unregister(&cryp_driver);\n\treturn;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void sum_update(const char *p, int32 len)\n{\n\tswitch (cursum_type) {\n\t  case CSUM_MD5:\n\t\tmd5_update(&md, (uchar *)p, len);\n\t\tbreak;\n          case CSUM_MD4:\n          case CSUM_MD4_OLD:\n          case CSUM_MD4_BUSTED:\n                if (len + sumresidue < CSUM_CHUNK) {\n                        memcpy(md.buffer + sumresidue, p, len);\n                        sumresidue += len;\n\t\t}\n\n\t\tif (sumresidue) {\n\t\t\tint32 i = CSUM_CHUNK - sumresidue;\n\t\t\tmemcpy(md.buffer + sumresidue, p, i);\n\t\t\tmdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);\n\t\t\tlen -= i;\n\t\t\tp += i;\n\t\t}\n\n\t\twhile (len >= CSUM_CHUNK) {\n\t\t\tmdfour_update(&md, (uchar *)p, CSUM_CHUNK);\n\t\t\tlen -= CSUM_CHUNK;\n\t\t\tp += CSUM_CHUNK;\n\t\t}\n\n\t\tsumresidue = len;\n\t\tif (sumresidue)\n\t\t\tmemcpy(md.buffer, p, sumresidue);\n\t\tbreak;\n\t  case CSUM_NONE:\n\t\tbreak;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int __init genhd_device_init(void)\n{\n\tint error;\n\n\tblock_class.dev_kobj = sysfs_dev_block_kobj;\n\terror = class_register(&block_class);\n\tif (unlikely(error))\n\t\treturn error;\n\tbdev_map = kobj_map_init(base_probe, &block_class_lock);\n\tblk_dev_init();\n\n\tregister_blkdev(BLOCK_EXT_MAJOR, \"blkext\");\n\n\t/* create top-level block dir */\n\tif (!sysfs_deprecated)\n\t\tblock_depr = kobject_create_and_add(\"block\", NULL);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int64_t wav_seek_tag(AVIOContext *s, int64_t offset, int whence)\n\n{\n\n    return avio_seek(s, offset + (offset & 1), whence);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "struct heif_error heif_encoder::alloc()\n{\n  if (encoder == nullptr) {\n    struct heif_error error = plugin->new_encoder(&encoder);\n    // TODO: error handling\n    return error;\n  }\n\n  struct heif_error err = { heif_error_Ok, heif_suberror_Unspecified, kSuccess };\n  return err;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void scsi_req_dequeue(SCSIRequest *req)\n\n{\n\n    trace_scsi_req_dequeue(req->dev->id, req->lun, req->tag);\n\n    if (req->enqueued) {\n\n        QTAILQ_REMOVE(&req->dev->requests, req, next);\n\n        req->enqueued = false;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags)\n{\n    int ret = get_buffer_internal(avctx, frame, flags);\n    if (ret < 0)\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n    return ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void esp_dma_done(ESPState *s)\n{\n    s->rregs[ESP_RSTAT] |= STAT_TC;\n    s->rregs[ESP_RINTR] |= INTR_BS;\n    s->rregs[ESP_RSEQ] = 0;\n    s->rregs[ESP_RFLAGS] = 0;\n    esp_set_tc(s, 0);\n    esp_raise_irq(s);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tmm->context.asce_limit = STACK_TOP_MAX;\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n{\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\n\tif (!nb_pack) nb_pack = 1;\n\tif (stts->nb_entries) {\n\t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n\t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (stts->nb_entries==stts->alloc_size) {\n\t\tALLOC_INC(stts->alloc_size);\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t}\n\tstts->entries[stts->nb_entries].sampleCount = nb_pack;\n\tstts->entries[stts->nb_entries].sampleDelta = duration;\n\tstts->nb_entries++;\n\tif (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;\n\treturn GF_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int dev_gso_segment(struct sk_buff *skb, int features)\n{\n\tstruct sk_buff *segs;\n\n\tsegs = skb_gso_segment(skb, features);\n\n\t/* Verifying header integrity only. */\n\tif (!segs)\n\t\treturn 0;\n\n\tif (IS_ERR(segs))\n\t\treturn PTR_ERR(segs);\n\n\tskb->next = segs;\n\tDEV_GSO_CB(skb)->destructor = skb->destructor;\n\tskb->destructor = dev_gso_skb_destructor;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void ServiceWorkerPaymentInstrument::RecordUse() {\n  NOTIMPLEMENTED();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int ecb_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t       struct scatterlist *src, unsigned int nbytes)\n{\n\treturn glue_ecb_crypt_128bit(&camellia_dec, desc, dst, src, nbytes);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int __init acpi_custom_method_init(void)\n{\n\tif (!acpi_debugfs_dir)\n\t\treturn -ENOENT;\n\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (!cm_dentry)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void fuse_request_send_background(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait(fc, req);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "gfx::ImageSkia ServiceWorkerPaymentInstrument::icon_image_skia() const {\n  return icon_image_;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "onigenc_mb4_is_code_ctype(OnigEncoding enc, OnigCodePoint code,\n\t\t\t  unsigned int ctype)\n{\n  if (code < 128)\n    return ONIGENC_IS_ASCII_CODE_CTYPE(code, ctype);\n  else {\n    if (CTYPE_IS_WORD_GRAPH_PRINT(ctype)) {\n      return (ONIGENC_CODE_TO_MBCLEN(enc, code) > 1 ? TRUE : FALSE);\n    }\n  }\n\n  return FALSE;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int ecb_aes_encrypt(struct blkcipher_desc *desc,\n\t\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t\t   unsigned int nbytes)\n{\n\tstruct s390_aes_ctx *sctx = crypto_blkcipher_ctx(desc->tfm);\n\tstruct blkcipher_walk walk;\n\n\tif (unlikely(need_fallback(sctx->key_len)))\n\t\treturn fallback_blk_enc(desc, dst, src, nbytes);\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\treturn ecb_aes_crypt(desc, sctx->enc, sctx->key, &walk);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "xmlFreeSaveCtxt(xmlSaveCtxtPtr ctxt)\n{\n    if (ctxt == NULL) return;\n    if (ctxt->encoding != NULL)\n        xmlFree((char *) ctxt->encoding);\n    if (ctxt->buf != NULL)\n        xmlOutputBufferClose(ctxt->buf);\n    xmlFree(ctxt);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "JVM_InitializeSocketLibrary(void)\n{\n\tTrc_SC_InitializeSocketLibrary();\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "Variant HHVM_FUNCTION(current,\n                      VRefParam refParam) {\n  return iter_op_impl<NoCow>(\n    refParam,\n    &ArrayData::current,\n    s___current,\n    false\n  );\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "__poll_t psi_trigger_poll(void **trigger_ptr,\n\t\t\t\tstruct file *file, poll_table *wait)\n{\n\t__poll_t ret = DEFAULT_POLLMASK;\n\tstruct psi_trigger *t;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI;\n\n\trcu_read_lock();\n\n\tt = rcu_dereference(*(void __rcu __force **)trigger_ptr);\n\tif (!t) {\n\t\trcu_read_unlock();\n\t\treturn DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI;\n\t}\n\tkref_get(&t->refcount);\n\n\trcu_read_unlock();\n\n\tpoll_wait(file, &t->event_wait, wait);\n\n\tif (cmpxchg(&t->event, 1, 0) == 1)\n\t\tret |= EPOLLPRI;\n\n\tkref_put(&t->refcount, psi_trigger_destroy);\n\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "char ssl3_cbc_record_digest_supported(const EVP_MD_CTX *ctx)\n\t{\n\tswitch (ctx->digest->type)\n\t\t{\n\t\tcase NID_md5:\n\t\tcase NID_sha1:\n\t\tcase NID_sha224:\n\t\tcase NID_sha256:\n\t\tcase NID_sha384:\n\t\tcase NID_sha512:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void CServer::SendRconCmdRem(const IConsole::CCommandInfo *pCommandInfo, int ClientID)\n{\n\tCMsgPacker Msg(NETMSG_RCON_CMD_REM);\n\tMsg.AddString(pCommandInfo->m_pName, 256);\n\tSendMsgEx(&Msg, MSGFLAG_VITAL, ClientID, true);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "iscsi_process_read(void *arg)\n{\n    IscsiLun *iscsilun = arg;\n    struct iscsi_context *iscsi = iscsilun->iscsi;\n\n    iscsi_service(iscsi, POLLIN);\n    iscsi_set_events(iscsilun);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int prepareForShutdown() {\n    redisLog(REDIS_WARNING,\"User requested shutdown, saving DB...\");\n    /* Kill the saving child if there is a background saving in progress.\n       We want to avoid race conditions, for instance our saving child may\n       overwrite the synchronous saving did by SHUTDOWN. */\n    if (server.bgsavechildpid != -1) {\n        redisLog(REDIS_WARNING,\"There is a live saving child. Killing it!\");\n        kill(server.bgsavechildpid,SIGKILL);\n        rdbRemoveTempFile(server.bgsavechildpid);\n    }\n    if (server.appendonly) {\n        /* Append only file: fsync() the AOF and exit */\n        aof_fsync(server.appendfd);\n        if (server.vm_enabled) unlink(server.vm_swap_file);\n    } else if (server.saveparamslen > 0) {\n        /* Snapshotting. Perform a SYNC SAVE and exit */\n        if (rdbSave(server.dbfilename) != REDIS_OK) {\n            /* Ooops.. error saving! The best we can do is to continue\n             * operating. Note that if there was a background saving process,\n             * in the next cron() Redis will be notified that the background\n             * saving aborted, handling special stuff like slaves pending for\n             * synchronization... */\n            redisLog(REDIS_WARNING,\"Error trying to save the DB, can't exit\");\n            return REDIS_ERR;\n        }\n    } else {\n        redisLog(REDIS_WARNING,\"Not saving DB.\");\n    }\n    if (server.daemonize) unlink(server.pidfile);\n    redisLog(REDIS_WARNING,\"Server exit now, bye bye...\");\n    return REDIS_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int jas_cmpxformseq_resize(jas_cmpxformseq_t *pxformseq, int n)\n{\n\tjas_cmpxform_t **p;\n\tassert(n >= pxformseq->numpxforms);\n\tp = (!pxformseq->pxforms) ? jas_malloc(n * sizeof(jas_cmpxform_t *)) :\n\t  jas_realloc(pxformseq->pxforms, n * sizeof(jas_cmpxform_t *));\n\tif (!p) {\n\t\treturn -1;\n\t}\n\tpxformseq->pxforms = p;\n\tpxformseq->maxpxforms = n;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int _snd_timer_stop(struct snd_timer_instance * timeri,\n\t\t\t   int keep_flag, int event)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n \t\tif (!keep_flag) {\n \t\t\tspin_lock_irqsave(&slave_active_lock, flags);\n \t\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n \t\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n \t\t}\n \t\tgoto __end;\n\t}\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\tif (!keep_flag)\n\t\ttimeri->flags &=\n\t\t\t~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n      __end:\n\tif (event != SNDRV_TIMER_EVENT_RESOLUTION)\n\t\tsnd_timer_notify1(timeri, event);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "MagickExport MagickBooleanType DrawImage(Image *image,const DrawInfo *draw_info,\n  ExceptionInfo *exception)\n{\n  return(RenderMVGContent(image,draw_info,0,exception));\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int verify_aead(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_ALG_AEAD];\n\tstruct xfrm_algo_aead *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < aead_len(algp))\n\t\treturn -EINVAL;\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int neigh_fill_info(struct sk_buff *skb, struct neighbour *n,\n\t\t\t   u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tunsigned long now = jiffies;\n\tunsigned char *b = skb->tail;\n\tstruct nda_cacheinfo ci;\n\tint locked = 0;\n\tu32 probes;\n\tstruct nlmsghdr *nlh = NLMSG_NEW(skb, pid, seq, event,\n\t\t\t\t\t sizeof(struct ndmsg), flags);\n\tstruct ndmsg *ndm = NLMSG_DATA(nlh);\n\n\tndm->ndm_family\t = n->ops->family;\n\tndm->ndm_flags\t = n->flags;\n\tndm->ndm_type\t = n->type;\n\tndm->ndm_ifindex = n->dev->ifindex;\n\tRTA_PUT(skb, NDA_DST, n->tbl->key_len, n->primary_key);\n\tread_lock_bh(&n->lock);\n\tlocked\t\t = 1;\n\tndm->ndm_state\t = n->nud_state;\n\tif (n->nud_state & NUD_VALID)\n\t\tRTA_PUT(skb, NDA_LLADDR, n->dev->addr_len, n->ha);\n\tci.ndm_used\t = now - n->used;\n\tci.ndm_confirmed = now - n->confirmed;\n\tci.ndm_updated\t = now - n->updated;\n\tci.ndm_refcnt\t = atomic_read(&n->refcnt) - 1;\n\tprobes = atomic_read(&n->probes);\n\tread_unlock_bh(&n->lock);\n\tlocked\t\t = 0;\n\tRTA_PUT(skb, NDA_CACHEINFO, sizeof(ci), &ci);\n\tRTA_PUT(skb, NDA_PROBES, sizeof(probes), &probes);\n\tnlh->nlmsg_len\t = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tif (locked)\n\t\tread_unlock_bh(&n->lock);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\t/*\n\t * Copy the config data.\n\t * For the firmware name, keep a local copy of the string,\n \t * in order to avoid troubles during device release.\n \t */\n \tkfree(priv->ctrl.fname);\n \tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n \tif (p->fname) {\n \t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n \t\tif (priv->ctrl.fname == NULL)\n\t\t\trc = -ENOMEM;\n \t}\n \n \t/*\n\t * If firmware name changed, frees firmware. As free_firmware will\n\t * reset the status to NO_FIRMWARE, this forces a new request_firmware\n\t */\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void sungem_send_packet(SunGEMState *s, const uint8_t *buf,\n                               int size)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n    if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) {\n        nc->info->receive(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string )\n{\n\tint i = 0;\n\tcJSON *c = object->child;\n\twhile ( c && cJSON_strcasecmp( c->string, string ) ) {\n\t\t++i;\n\t\tc = c->next;\n\t}\n\tif ( c )\n\t\treturn cJSON_DetachItemFromArray( object, i );\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int vhost_verify_ring_mappings(struct vhost_dev *dev,\n\n                                      uint64_t start_addr,\n\n                                      uint64_t size)\n\n{\n\n    int i;\n\n    for (i = 0; i < dev->nvqs; ++i) {\n\n        struct vhost_virtqueue *vq = dev->vqs + i;\n\n        hwaddr l;\n\n        void *p;\n\n\n\n        if (!ranges_overlap(start_addr, size, vq->ring_phys, vq->ring_size)) {\n\n            continue;\n\n        }\n\n        l = vq->ring_size;\n\n        p = cpu_physical_memory_map(vq->ring_phys, &l, 1);\n\n        if (!p || l != vq->ring_size) {\n\n            fprintf(stderr, \"Unable to map ring buffer for ring %d\\n\", i);\n\n            return -ENOMEM;\n\n        }\n\n        if (p != vq->ring) {\n\n            fprintf(stderr, \"Ring buffer relocated for ring %d\\n\", i);\n\n            return -EBUSY;\n\n        }\n\n        cpu_physical_memory_unmap(p, l, 0, 0);\n\n    }\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "ElectronBrowserHandlerImpl::ElectronBrowserHandlerImpl(\n    content::RenderFrameHost* frame_host,\n    mojo::PendingReceiver<mojom::ElectronBrowser> receiver)\n    : render_process_id_(frame_host->GetProcess()->GetID()),\n      render_frame_id_(frame_host->GetRoutingID()) {\n  content::WebContents* web_contents =\n      content::WebContents::FromRenderFrameHost(frame_host);\n  DCHECK(web_contents);\n  content::WebContentsObserver::Observe(web_contents);\n\n  receiver_.Bind(std::move(receiver));\n  receiver_.set_disconnect_handler(base::BindOnce(\n      &ElectronBrowserHandlerImpl::OnConnectionError, GetWeakPtr()));\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline struct ip_tunnel __rcu **ipip_bucket(struct ipip_net *ipn,\n\t\tstruct ip_tunnel *t)\n{\n\treturn __ipip_bucket(ipn, &t->parms);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int __net_init genl_pernet_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t\t= genl_rcv,\n\t\t.flags\t\t= NL_CFG_F_NONROOT_RECV,\n\t\t.bind\t\t= genl_bind,\n\t\t.unbind\t\t= genl_unbind,\n\t};\n\n\t/* we'll bump the group number right afterwards */\n\tnet->genl_sock = netlink_kernel_create(net, NETLINK_GENERIC, &cfg);\n\n\tif (!net->genl_sock && net_eq(net, &init_net))\n\t\tpanic(\"GENL: Cannot initialize generic netlink\\n\");\n\n\tif (!net->genl_sock)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "for (size_t i = 0; i < len; i++) {\n    if (src[i] == ',') {\n      dest[i + shift++] = '\\\\';\n    }\n    dest[i + shift] = src[i];\n  }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int xts_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t       struct scatterlist *src, unsigned int nbytes)\n{\n\tstruct camellia_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\n\tbe128 buf[2 * 4];\n\tstruct xts_crypt_req req = {\n\t\t.tbuf = buf,\n\t\t.tbuflen = sizeof(buf),\n\n\t\t.tweak_ctx = &ctx->tweak_ctx,\n\t\t.tweak_fn = XTS_TWEAK_CAST(camellia_enc_blk),\n\t\t.crypt_ctx = &ctx->crypt_ctx,\n\t\t.crypt_fn = encrypt_callback,\n\t};\n\n\treturn xts_crypt(desc, dst, src, nbytes, &req);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int ndpi_load_category(struct ndpi_detection_module_struct *ndpi_struct, const char *ip_or_name,\n                       ndpi_protocol_category_t category) {\n  int rv;\n\n  /* Try to load as IP address first */\n  rv = ndpi_load_ip_category(ndpi_struct, ip_or_name, category);\n\n  if(rv < 0) {\n    /* IP load failed, load as hostname */\n    rv = ndpi_load_hostname_category(ndpi_struct, ip_or_name, category);\n  }\n\n  return(rv);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "compute_U_value_R2(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.4 from the PDF 1.7 Reference Manual\n\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    char udata[key_bytes];\n    pad_or_truncate_password_V4(\"\", udata);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 1, false);\n    return std::string(udata, key_bytes);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    /* should be the case, see cirrus_bitblt_start */\n    assert(s->cirrus_blt_width > 0);\n    assert(s->cirrus_blt_height > 0);\n    if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                              s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n    if (blit_region_is_unsafe(s, s->cirrus_blt_srcpitch,\n                              s->cirrus_blt_srcaddr & s->cirrus_addr_mask)) {\n    return false;",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void OpenPDFInReaderView::OnMouseReleased(const ui::MouseEvent& event) {\n  if (event.IsOnlyLeftMouseButton() && HitTestPoint(event.location()))\n    ShowBubble();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int i_head = i->head;\n\tsize_t off;\n\n\tif (unlikely(bytes > i->count))\n\t\tbytes = i->count;\n\n\tif (unlikely(!bytes))\n\t\treturn 0;\n\n\tif (!sanity(i))\n\t\treturn 0;\n\n\toff = i->iov_offset;\n\tbuf = &pipe->bufs[i_head & p_mask];\n\tif (off) {\n\t\tif (offset == off && buf->page == page) {\n\t\t\t/* merge with the last one */\n\t\t\tbuf->len += bytes;\n\t\t\ti->iov_offset += bytes;\n\t\t\tgoto out;\n\t\t}\n\t\ti_head++;\n\t\tbuf = &pipe->bufs[i_head & p_mask];\n\t}\n\tif (pipe_full(i_head, p_tail, pipe->max_usage))\n\t\treturn 0;\n\n\tbuf->ops = &page_cache_pipe_buf_ops;\n\tget_page(page);\n\tbuf->page = page;\n\tbuf->offset = offset;\n\tbuf->len = bytes;\n\n\tpipe->head = i_head + 1;\n\ti->iov_offset = offset + bytes;\n\ti->head = i_head;\nout:\n\ti->count -= bytes;\n\treturn bytes;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void *record_one_cpu(struct mdesc_handle *hp, u64 mp, int cpuid,\n\t\t\t    void *arg)\n{\n\tncpus_probed++;\n#ifdef CONFIG_SMP\n\tset_cpu_present(cpuid, true);\n#endif\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void MenuGtk::AppendMenuItem(int command_id, GtkWidget* menu_item) {\n  g_object_set_data(G_OBJECT(menu_item), \"menu-id\",\n                    reinterpret_cast<void*>(command_id));\n\n  g_signal_connect(G_OBJECT(menu_item), \"activate\",\n                   G_CALLBACK(OnMenuItemActivated), this);\n\n  gtk_widget_show(menu_item);\n  gtk_menu_shell_append(GTK_MENU_SHELL(menu_.get()), menu_item);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static struct kvm_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "check_offset(char *memory, int total_size, char *name, void *offset, int size)\n{\n\tint need_size = (int) ((char *) offset - memory + size);\n\n\t/*debug(\"check_offset: size=%x vs %x offset=%x size=%x\\n\",\n\t\tneed_size, total_size, (char *) offset - memory, size);*/\n\n\tif (need_size < 0 || need_size > total_size) {\n\t\twarn(_(\"%s: premature end\"), name);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static const char *req_user_field(request_rec *r)\n{\n    return r->user;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "recv_and_process_client_pkt(void /*int fd*/)\n{\n\tssize_t          size;\n\tlen_and_sockaddr *to;\n\tstruct sockaddr  *from;\n\tmsg_t            msg;\n\tuint8_t          query_status;\n\tl_fixedpt_t      query_xmttime;\n\n\tto = get_sock_lsa(G_listen_fd);\n\tfrom = xzalloc(to->len);\n\n\tsize = recv_from_to(G_listen_fd, &msg, sizeof(msg), MSG_DONTWAIT, from, &to->u.sa, to->len);\n\tif (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE) {\n\t\tchar *addr;\n\t\tif (size < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tgoto bail;\n\t\t\tbb_perror_msg_and_die(\"recv\");\n\t\t}\n\t\taddr = xmalloc_sockaddr2dotted_noport(from);\n\t\tbb_error_msg(\"malformed packet received from %s: size %u\", addr, (int)size);\n\t\tfree(addr);\n \t\tgoto bail;\n \t}\n \n \tquery_status = msg.m_status;\n \tquery_xmttime = msg.m_xmttime;\n\tmsg.m_ppoll = G.poll_exp;\n\tmsg.m_precision_exp = G_precision_exp;\n\t/* this time was obtained between poll() and recv() */\n\tmsg.m_rectime = d_to_lfp(G.cur_time);\n\tmsg.m_xmttime = d_to_lfp(gettime1900d()); /* this instant */\n\tif (G.peer_cnt == 0) {\n\t\t/* we have no peers: \"stratum 1 server\" mode. reftime = our own time */\n\t\tG.reftime = G.cur_time;\n\t}\n\tmsg.m_reftime = d_to_lfp(G.reftime);\n\tmsg.m_orgtime = query_xmttime;\n\tmsg.m_rootdelay = d_to_sfp(G.rootdelay);\n\tmsg.m_rootdisp = d_to_sfp(G.rootdisp);\n\tmsg.m_refid = G.refid; // (version > (3 << VERSION_SHIFT)) ? G.refid : G.refid3;\n\n\t/* We reply from the local address packet was sent to,\n\t * this makes to/from look swapped here: */\n\tdo_sendto(G_listen_fd,\n\t\t/*from:*/ &to->u.sa, /*to:*/ from, /*addrlen:*/ to->len,\n\t\t&msg, size);\n\n bail:\n\tfree(to);\n\tfree(from);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void gen_tlbsync(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    GEN_PRIV;\n\n#else\n\n    CHK_HV;\n\n\n\n    /* tlbsync is a nop for server, ptesync handles delayed tlb flush,\n\n     * embedded however needs to deal with tlbsync. We don't try to be\n\n     * fancy and swallow the overhead of checking for both.\n\n     */\n\n    gen_check_tlb_flush(ctx);\n\n#endif /* defined(CONFIG_USER_ONLY) */\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void InputMethodBase::OnInputMethodChanged() const {\n   TextInputClient* client = GetTextInputClient();\n  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)\n     client->OnInputMethodChanged();\n }",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); /* Padding */\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, Stream_Pointer(irp->input), Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); /* Padding */\n\treturn irp->Complete(irp);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int nr_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *sax = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tlock_sock(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 1;\n\t\tsax->fsa_ax25.sax25_call   = nr->user_addr;\n\t\tsax->fsa_digipeater[0]     = nr->dest_addr;\n\t\t*uaddr_len = sizeof(struct full_sockaddr_ax25);\n\t} else {\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 0;\n\t\tsax->fsa_ax25.sax25_call   = nr->source_addr;\n\t\t*uaddr_len = sizeof(struct sockaddr_ax25);\n\t}\n\trelease_sock(sk);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void FrameLoader::committedLoad(DocumentLoader* loader, const char* data, int length)\n{\n    if (ArchiveFactory::isArchiveMimeType(loader->response().mimeType()))\n        return;\n    m_client->committedLoad(loader, data, length);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int X509_cmp_time(ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n    ASN1_TIME atm;\n    long offset;\n    char buff1[24], buff2[24], *p;\n    int i, j;\n\n    p = buff1;\n    i = ctm->length;\n    str = (char *)ctm->data;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n            return 0;\n        memcpy(p, str, 10);\n        p += 10;\n        str += 10;\n    } else {\n        if (i < 13)\n            return 0;\n        memcpy(p, str, 12);\n        p += 12;\n        str += 12;\n    }\n\n    if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n        *(p++) = '0';\n        *(p++) = '0';\n    } else {\n        *(p++) = *(str++);\n        *(p++) = *(str++);\n        /* Skip any fractional seconds... */\n        if (*str == '.') {\n            str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n        }\n\n    }\n    *(p++) = 'Z';\n    *(p++) = '\\0';\n\n    if (*str == 'Z')\n        offset = 0;\n    else {\n        if ((*str != '+') && (*str != '-'))\n            return 0;\n        offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n        offset += (str[3] - '0') * 10 + (str[4] - '0');\n        if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           /* cf. RFC 2459 */\n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 /* wait a second then return younger :-) */\n        return -1;\n    else\n        return i;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "shell_gtk_embed_new (ShellEmbeddedWindow *window)\n{\n  g_return_val_if_fail (SHELL_IS_EMBEDDED_WINDOW (window), NULL);\n\n  return g_object_new (SHELL_TYPE_GTK_EMBED,\n                       \"window\", window,\n                       NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int jsi_nodeDepth(Jsi_TreeEntry* hPtr) {\n    int d = 0;\n    while (hPtr->parent != NULL) {\n        d++;\n        hPtr = hPtr->parent;\n    }\n    return d;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n{\n    CURLState *s = ((CURLState*)opaque);\n    size_t realsize = size * nmemb;\n    int i;\n\n    DPRINTF(\"CURL: Just reading %zd bytes\\n\", realsize);\n\n    if (!s || !s->orig_buf)\n        goto read_end;\n\n    memcpy(s->orig_buf + s->buf_off, ptr, realsize);\n    s->buf_off += realsize;\n\n    for(i=0; i<CURL_NUM_ACB; i++) {\n        CURLAIOCB *acb = s->acb[i];\n\n        if (!acb)\n            continue;\n\n        if ((s->buf_off >= acb->end)) {\n            qemu_iovec_from_buf(acb->qiov, 0, s->orig_buf + acb->start,\n                                acb->end - acb->start);\n            acb->common.cb(acb->common.opaque, 0);\n            qemu_aio_release(acb);\n            s->acb[i] = NULL;\n        }\n    }\n\nread_end:\n    return realsize;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "ZEND_API int zend_declare_property(zend_class_entry *ce, const char *name, int name_length, zval *property, int access_type TSRMLS_DC) /* {{{ */\n{\n\treturn zend_declare_property_ex(ce, name, name_length, property, access_type, NULL, 0 TSRMLS_CC);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int modbus_set_socket(modbus_t *ctx, int s)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    ctx->s = s;\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){\n    explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));\n    SAFE_FREE(cipher->aes_key);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void Browser::InProgressDownloadResponse(bool cancel_downloads) {\n  if (cancel_downloads) {\n    cancel_download_confirmation_state_ = RESPONSE_RECEIVED;\n    chrome::CloseWindow(this);\n    return;\n  }\n\n  cancel_download_confirmation_state_ = NOT_PROMPTED;\n\n  chrome::ShowDownloads(this);\n\n  if (IsFastTabUnloadEnabled())\n    fast_unload_controller_->CancelWindowClose();\n  else\n    unload_controller_->CancelWindowClose();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "av_cold void ff_mlz_init_dict(void* context, MLZ *mlz) {\n\n    mlz->dict = av_malloc_array(TABLE_SIZE, sizeof(*mlz->dict));\n\n\n\n    mlz->flush_code            = FLUSH_CODE;\n\n    mlz->current_dic_index_max = DIC_INDEX_INIT;\n\n    mlz->dic_code_bit          = CODE_BIT_INIT;\n\n    mlz->bump_code             = (DIC_INDEX_INIT - 1);\n\n    mlz->next_code             = FIRST_CODE;\n\n    mlz->freeze_flag           = 0;\n\n    mlz->context               = context;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ContentEncoding::ContentEncryption::~ContentEncryption() {\n  delete[] key_id;\n  delete[] signature;\n  delete[] sig_key_id;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void elv_rqhash_del(struct request_queue *q, struct request *rq)\n{\n\tif (ELV_ON_HASH(rq))\n\t\t__elv_rqhash_del(rq);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void nvme_rw_cb(void *opaque, int ret)\n\n{\n\n    NvmeRequest *req = opaque;\n\n    NvmeSQueue *sq = req->sq;\n\n    NvmeCtrl *n = sq->ctrl;\n\n    NvmeCQueue *cq = n->cq[sq->cqid];\n\n\n\n    block_acct_done(blk_get_stats(n->conf.blk), &req->acct);\n\n    if (!ret) {\n\n        req->status = NVME_SUCCESS;\n\n    } else {\n\n        req->status = NVME_INTERNAL_DEV_ERROR;\n\n    }\n\n    if (req->has_sg) {\n\n        qemu_sglist_destroy(&req->qsg);\n\n    }\n\n    nvme_enqueue_req_completion(cq, req);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "GF_Err odtt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OMADRMTransactionTrackingBox *ptr = (GF_OMADRMTransactionTrackingBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->TransactionID, 16);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\n\ttimer = &pit->pit_state.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "BlockDriverAIOCB *dma_bdrv_io(\n\n    BlockDriverState *bs, QEMUSGList *sg, uint64_t sector_num,\n\n    DMAIOFunc *io_func, BlockDriverCompletionFunc *cb,\n\n    void *opaque, bool to_dev)\n\n{\n\n    DMAAIOCB *dbs = qemu_aio_get(&dma_aio_pool, bs, cb, opaque);\n\n\n\n    dbs->acb = NULL;\n\n    dbs->bs = bs;\n\n    dbs->sg = sg;\n\n    dbs->sector_num = sector_num;\n\n    dbs->sg_cur_index = 0;\n\n    dbs->sg_cur_byte = 0;\n\n    dbs->to_dev = to_dev;\n\n    dbs->io_func = io_func;\n\n    dbs->bh = NULL;\n\n    qemu_iovec_init(&dbs->iov, sg->nsg);\n\n    dma_bdrv_cb(dbs, 0);\n\n    if (!dbs->acb) {\n\n        qemu_aio_release(dbs);\n\n        return NULL;\n\n    }\n\n    return &dbs->common;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static ssize_t runtime_enabled_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tif (dev->power.disable_depth && (dev->power.runtime_auto == false))\n\t\treturn sprintf(buf, \"disabled & forbidden\\n\");\n\tif (dev->power.disable_depth)\n\t\treturn sprintf(buf, \"disabled\\n\");\n\tif (dev->power.runtime_auto == false)\n\t\treturn sprintf(buf, \"forbidden\\n\");\n\treturn sprintf(buf, \"enabled\\n\");\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; // This is currently the only return code.\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "FWCfgState *fw_cfg_init_io_dma(uint32_t iobase, uint32_t dma_iobase,\n\n                                AddressSpace *dma_as)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *sbd;\n\n    FWCfgIoState *ios;\n\n    FWCfgState *s;\n\n    bool dma_requested = dma_iobase && dma_as;\n\n\n\n    dev = qdev_create(NULL, TYPE_FW_CFG_IO);\n\n    if (!dma_requested) {\n\n        qdev_prop_set_bit(dev, \"dma_enabled\", false);\n\n    }\n\n\n\n    fw_cfg_init1(dev);\n\n\n\n    sbd = SYS_BUS_DEVICE(dev);\n\n    ios = FW_CFG_IO(dev);\n\n    sysbus_add_io(sbd, iobase, &ios->comb_iomem);\n\n\n\n    s = FW_CFG(dev);\n\n\n\n    if (s->dma_enabled) {\n\n        /* 64 bits for the address field */\n\n        s->dma_as = dma_as;\n\n        s->dma_addr = 0;\n\n        sysbus_add_io(sbd, dma_iobase, &s->dma_iomem);\n\n    }\n\n\n\n    return s;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    CString sModPath, sTmp;\n\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static FILE* msg_cache_put (IMAP_DATA* idata, HEADER* h)\n{\n  char id[_POSIX_PATH_MAX];\n\n  if (!idata || !h)\n    return NULL;\n\n  idata->bcache = msg_cache_open (idata);\n  snprintf (id, sizeof (id), \"%u-%u\", idata->uid_validity, HEADER_DATA(h)->uid);\n  return mutt_bcache_put (idata->bcache, id, 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "const std::vector<Box_ipma::PropertyAssociation>* Box_ipma::get_properties_for_item_ID(uint32_t itemID) const\n{\n  for (const auto& entry : m_entries) {\n    if (entry.item_ID == itemID) {\n      return &entry.associations;\n    }\n  }\n\n  return nullptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "_dbus_header_byteswap (DBusHeader *header,\n                        int         new_order)\n {\n   if (header->byte_order == new_order)\n     return;\n \n   _dbus_marshal_byteswap (&_dbus_header_signature_str,\n                           0, header->byte_order,\n                           new_order,\n                           &header->data, 0);\n \n   header->byte_order = new_order;\n }",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline void dentry_rcuwalk_invalidate(struct dentry *dentry)\n{\n\tlockdep_assert_held(&dentry->d_lock);\n\t/* Go through am invalidation barrier */\n\twrite_seqcount_invalidate(&dentry->d_seq);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static ssize_t show_tabletPointerMode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\tmap_val_to_str(pointer_mode_map,\n\t\t\t\t\taiptek->curSetting.pointerMode));\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void TiffVisitor::visitBinaryArrayEnd(TiffBinaryArray* /*object*/)\n    {\n    }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void tq_thaw(struct thread_q *tq)\n{\n\ttq_freezethaw(tq, false);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "size_t SSL_get_finished(const SSL *s, void *buf, size_t count)\n{\n    size_t ret = 0;\n\n    if (s->s3 != NULL) {\n        ret = s->s3->tmp.finish_md_len;\n        if (count > ret)\n            count = ret;\n        memcpy(buf, s->s3->tmp.finish_md, count);\n    }\n    return ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\n\tline += 3; /* skip \"ng \" */\n\tif (!(ptr = strchr(line, ' ')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nout_err:\n\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void compute_antialias_integer(MPADecodeContext *s,\n\n                              GranuleDef *g)\n\n{\n\n    int32_t *ptr, *csa;\n\n    int n, i;\n\n\n\n    /* we antialias only \"long\" bands */\n\n    if (g->block_type == 2) {\n\n        if (!g->switch_point)\n\n            return;\n\n        /* XXX: check this for 8000Hz case */\n\n        n = 1;\n\n    } else {\n\n        n = SBLIMIT - 1;\n\n    }\n\n    \n\n    ptr = g->sb_hybrid + 18;\n\n    for(i = n;i > 0;i--) {\n\n        int tmp0, tmp1, tmp2;\n\n        csa = &csa_table[0][0];\n\n#define INT_AA(j) \\\n\n            tmp0 = 4*(ptr[-1-j]);\\\n\n            tmp1 = 4*(ptr[   j]);\\\n\n            tmp2= MULH(tmp0 + tmp1, csa[0+4*j]);\\\n\n            ptr[-1-j] = tmp2 - MULH(tmp1, csa[2+4*j]);\\\n\n            ptr[   j] = tmp2 + MULH(tmp0, csa[3+4*j]);\n\n\n\n        INT_AA(0)\n\n        INT_AA(1)\n\n        INT_AA(2)\n\n        INT_AA(3)\n\n        INT_AA(4)\n\n        INT_AA(5)\n\n        INT_AA(6)\n\n        INT_AA(7)\n\n            \n\n        ptr += 18;       \n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "rfbSendBell(rfbScreenInfoPtr rfbScreen)\n{\n    rfbClientIteratorPtr i;\n    rfbClientPtr cl;\n    rfbBellMsg b;\n\n    i = rfbGetClientIterator(rfbScreen);\n    while((cl=rfbClientIteratorNext(i))) {\n\tb.type = rfbBell;\n\tif (WriteExact(cl, (char *)&b, sz_rfbBellMsg) < 0) {\n\t    rfbLogPerror(\"rfbSendBell: write\");\n\t    rfbCloseClient(cl);\n\t}\n    }\n    rfbReleaseClientIterator(i);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "pch_name (enum nametype type)\n{\n  return type == NONE ? NULL : p_name[type];\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int jpeg_read_close(AVFormatContext *s1)\n\n{\n\n    JpegContext *s = s1->priv_data;\n\n    av_free(s);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist; */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\t/*printf(\"found! %d\\n\", (int)(t - p->t));*/\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\t/* update Location ! */\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n \t\t\t\tif(!tmp)\t/* allocation error */\n \t\t\t\t{\n \t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n \t\t\t\t\tfree(p);\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\t/* TODO : check p->headers[HEADER_LOCATION].l */\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t/* add */\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "flush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t/* Reject paths like \".git\\\" */\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\n\t/* Reject paths like '.git ' or '.git.' */\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "template<typename T>\n    CImgDisplay& assign(const CImgList<T>& list,\n                        const char *const title=0, const unsigned int normalization=3,\n                        const bool is_fullscreen=false, const bool is_closed=false) {\n      _no_display_exception();\n      return assign(list._width,list._width,title,normalization,is_fullscreen,is_closed);",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "   This function decrypts the crypttext */\nPHP_FUNCTION(mcrypt_enc_get_supported_key_sizes)\n{\n\tint i, count = 0;\n\tint *key_sizes;\n\t\n\tMCRYPT_GET_TD_ARG\n\tarray_init(return_value);\n\n\tkey_sizes = mcrypt_enc_get_supported_key_sizes(pm->td, &count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tadd_index_long(return_value, i, key_sizes[i]);\n\t}\n\n\tmcrypt_free(key_sizes);",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int open_self_cmdline(void *cpu_env, int fd)\n\n{\n\n    int fd_orig = -1;\n\n    bool word_skipped = false;\n\n\n\n    fd_orig = open(\"/proc/self/cmdline\", O_RDONLY);\n\n    if (fd_orig < 0) {\n\n        return fd_orig;\n\n    }\n\n\n\n    while (true) {\n\n        ssize_t nb_read;\n\n        char buf[128];\n\n        char *cp_buf = buf;\n\n\n\n        nb_read = read(fd_orig, buf, sizeof(buf));\n\n        if (nb_read < 0) {\n\n            fd_orig = close(fd_orig);\n\n            return -1;\n\n        } else if (nb_read == 0) {\n\n            break;\n\n        }\n\n\n\n        if (!word_skipped) {\n\n            /* Skip the first string, which is the path to qemu-*-static\n\n               instead of the actual command. */\n\n            cp_buf = memchr(buf, 0, sizeof(buf));\n\n            if (cp_buf) {\n\n                /* Null byte found, skip one string */\n\n                cp_buf++;\n\n                nb_read -= cp_buf - buf;\n\n                word_skipped = true;\n\n            }\n\n        }\n\n\n\n        if (word_skipped) {\n\n            if (write(fd, cp_buf, nb_read) != nb_read) {\n\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return close(fd_orig);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void ModuleSystem::ClobberExistingNativeHandler(const std::string& name) {\n  NativeHandlerMap::iterator existing_handler = native_handler_map_.find(name);\n  if (existing_handler != native_handler_map_.end()) {\n    clobbered_native_handlers_.push_back(std::move(existing_handler->second));\n    native_handler_map_.erase(existing_handler);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int dtls1_is_timer_expired(SSL *s)\n{\n    struct timeval timeleft;\n\n    /* Get time left until timeout, return false if no timer running */\n    if (dtls1_get_timeout(s, &timeleft) == NULL) {\n        return 0;\n    }\n\n    /* Return false if timer is not expired yet */\n    if (timeleft.tv_sec > 0 || timeleft.tv_usec > 0) {\n        return 0;\n    }\n\n    /* Timer expired, so return true */\n    return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool extractPages (const char *srcFileName, const char *destFileName) {\n  char pathName[4096];\n  GooString *gfileName = new GooString (srcFileName);\n  PDFDoc *doc = new PDFDoc (gfileName, NULL, NULL, NULL);\n\n  if (!doc->isOk()) {\n    error(errSyntaxError, -1, \"Could not extract page(s) from damaged file ('{0:s}')\", srcFileName);\n    return false;\n  }\n\n  if (firstPage == 0 && lastPage == 0) {\n    firstPage = 1;\n    lastPage = doc->getNumPages();\n  }\n  if (lastPage == 0)\n    lastPage = doc->getNumPages();\n  if (firstPage == 0)\n   if (firstPage == 0)\n     firstPage = 1;\n   if (firstPage != lastPage && strstr(destFileName, \"%d\") == NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' must contain '%%d' if more than one page should be extracted\", destFileName);\n     return false;\n   }\n   for (int pageNo = firstPage; pageNo <= lastPage; pageNo++) {\n     snprintf (pathName, sizeof (pathName) - 1, destFileName, pageNo);\n     GooString *gpageName = new GooString (pathName);\n\t{\n\t  printUsage (\"pdfseparate\", \"<PDF-sourcefile> <PDF-pattern-destfile>\",\n\t\t      argDesc);\n\t}\n      if (printVersion || printHelp)\n\texitCode = 0;\n      goto err0;\n    }\n  globalParams = new GlobalParams();\n  ok = extractPages (argv[1], argv[2]);\n  if (ok) {\n    exitCode = 0;\n  }\n  delete globalParams;\n\nerr0:\n\n  return exitCode;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "onig_get_contents_end_by_callout_args(OnigCalloutArgs* args)\n{\n  int num;\n  CalloutListEntry* e;\n\n  num = args->num;\n  e = onig_reg_callout_list_at(args->regex, num);\n  if (IS_NULL(e)) return 0;\n  if (e->of == ONIG_CALLOUT_OF_CONTENTS) {\n    return e->u.content.end;\n  }\n\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void i40e_irq_affinity_release(struct kref *ref) {}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* relative to root mount point */\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n {\n \t/* The ftrace function trace is allowed only for root. */\n \tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n \t\treturn -EPERM;\n \n \t/* No tracing, just counting, so no obvious leak */\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\t/* Some events are ok to be traced by non-root users... */\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * ...otherwise raw tracepoint data can be a severe data leak,\n\t * only allow root to have these.\n\t */\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n                      X509 **pissuer, int *pscore, unsigned int *preasons,\n                      STACK_OF(X509_CRL) *crls)\n{\n    int i, crl_score, best_score = *pscore;\n    unsigned int reasons, best_reasons = 0;\n    X509 *x = ctx->current_cert;\n    X509_CRL *crl, *best_crl = NULL;\n    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n         crl = sk_X509_CRL_value(crls, i);\n         reasons = *preasons;\n         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n        if (crl_score < best_score)\n             continue;\n         /* If current CRL is equivalent use it if it is newer */\n        if (crl_score == best_score) {\n             int day, sec;\n             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),\n                                X509_CRL_get_lastUpdate(crl)) == 0)\n                continue;\n            /*\n             * ASN1_TIME_diff never returns inconsistent signs for |day|\n             * and |sec|.\n             */\n            if (day <= 0 && sec <= 0)\n                continue;\n        }\n        best_crl = crl;\n        best_crl_issuer = crl_issuer;\n        best_score = crl_score;\n        best_reasons = reasons;\n    }\n\n    if (best_crl) {\n        if (*pcrl)\n            X509_CRL_free(*pcrl);\n        *pcrl = best_crl;\n        *pissuer = best_crl_issuer;\n        *pscore = best_score;\n        *preasons = best_reasons;\n        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n        if (*pdcrl) {\n            X509_CRL_free(*pdcrl);\n            *pdcrl = NULL;\n        }\n        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n    }\n\n    if (best_score >= CRL_SCORE_VALID)\n        return 1;\n\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n \t\treturn -ENOMEM;\n \tsize = roundup(size, PAGE_SIZE);\n \tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0)\n \t\treturn ret;\n \tbo->dumb = false;\n \tvirtio_gpu_init_ttm_placement(bo, pinned);\n \n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\t/* ttm_bo_init failure will call the destroy */\n\tif (ret != 0)\n\t\treturn ret;\n\n\t*bo_ptr = bo;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int kvmppc_remove_spapr_tce(void *table, int fd, uint32_t window_size)\n\n{\n\n    long len;\n\n\n\n    if (fd < 0) {\n\n        return -1;\n\n    }\n\n\n\n    len = (window_size / SPAPR_VIO_TCE_PAGE_SIZE)*sizeof(VIOsPAPR_RTCE);\n\n    if ((munmap(table, len) < 0) ||\n\n        (close(fd) < 0)) {\n\n        fprintf(stderr, \"KVM: Unexpected error removing KVM SPAPR TCE \"\n\n                \"table: %s\", strerror(errno));\n\n        /* Leak the table */\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void cgsleep_spec(struct timespec *ts_diff, const struct timespec *ts_start)\n{\n\tstruct timespec now;\n\n\ttimeraddspec(ts_diff, ts_start);\n\tcgtimer_time(&now);\n\ttimersubspec(ts_diff, &now);\n\tif (unlikely(ts_diff->tv_sec < 0))\n\t\treturn;\n\tnanosleep(ts_diff, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline int pages_identical(struct page *page1, struct page *page2)\n{\n\treturn !memcmp_pages(page1, page2);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "_tiffReadProc(thandle_t hdata, tdata_t buf, tsize_t size) {\n    TIFFSTATE *state = (TIFFSTATE *)hdata;\n    tsize_t to_read;\n\n    TRACE((\"_tiffReadProc: %d \\n\", (int)size));\n    dump_state(state);\n\n    to_read = min(size, min(state->size, (tsize_t)state->eof) - (tsize_t)state->loc);\n    TRACE((\"to_read: %d\\n\", (int)to_read));\n\n    _TIFFmemcpy(buf, (UINT8 *)state->data + state->loc, to_read);\n    state->loc += (toff_t)to_read;\n\n    TRACE((\"location: %u\\n\", (uint)state->loc));\n    return to_read;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "  AES128GCM_OnWireTxHandler(CephContext* const cct,\n\t\t\t    const key_t& key,\n\t\t\t    const nonce_t& nonce)\n    : cct(cct),\n      ectx(EVP_CIPHER_CTX_new(), EVP_CIPHER_CTX_free),\n      nonce(nonce) {\n    ceph_assert_always(ectx);\n    ceph_assert_always(key.size() * CHAR_BIT == 128);\n\n    if (1 != EVP_EncryptInit_ex(ectx.get(), EVP_aes_128_gcm(),\n\t\t\t        nullptr, nullptr, nullptr)) {\n      throw std::runtime_error(\"EVP_EncryptInit_ex failed\");\n    }\n\n    if(1 != EVP_EncryptInit_ex(ectx.get(), nullptr, nullptr,\n\t\t\t       key.data(), nullptr)) {\n      throw std::runtime_error(\"EVP_EncryptInit_ex failed\");\n    }\n  }",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "flatpak_context_add_devices (FlatpakContext       *context,\n                             FlatpakContextDevices devices)\n{\n  context->devices_valid |= devices;\n  context->devices |= devices;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void setLineColor(Color8888* dst, Color8888 color, int width) {\n for (; width > 0; width--, dst++) {\n *dst = color;\n }\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tUINT16 i;\n\tBYTE* rle;\n\tUINT32 planeSize;\n\tUINT32 originalSize;\n\trle = context->Planes;\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\toriginalSize = context->OrgByteCount[i];\n\t\tplaneSize = context->PlaneByteCount[i];\n\n\t\tif (planeSize == 0)\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\telse if (planeSize < originalSize)\n\t\t\tnsc_rle_decode(rle, context->priv->PlaneBuffers[i], originalSize);\n\t\telse\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\n\t\trle += planeSize;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void release() { this->execute_on_destruction = false; }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline void ClearSlabFrozen(struct page *page)\n{\n\tpage->flags &= ~FROZEN;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int nfc_genl_device_added(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_DEVICE_ADDED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nfc_genl_setup_device_added(dev, msg))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool desc_ring_set_size(DescRing *ring, uint32_t size)\n\n{\n\n    int i;\n\n\n\n    if (size < 2 || size > 0x10000 || (size & (size - 1))) {\n\n        DPRINTF(\"ERROR: ring[%d] size (%d) not a power of 2 \"\n\n                \"or in range [2, 64K]\\n\", ring->index, size);\n\n        return false;\n\n    }\n\n\n\n    for (i = 0; i < ring->size; i++) {\n\n        g_free(ring->info[i].buf);\n\n    }\n\n\n\n    ring->size = size;\n\n    ring->head = ring->tail = 0;\n\n\n\n    ring->info = g_realloc(ring->info, size * sizeof(DescInfo));\n\n    if (!ring->info) {\n\n        return false;\n\n    }\n\n\n\n    memset(ring->info, 0, size * sizeof(DescInfo));\n\n\n\n    for (i = 0; i < size; i++) {\n\n        ring->info[i].ring = ring;\n\n    }\n\n\n\n    return true;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool SetExtendedFileAttribute(const char* path,\n                              const char* name,\n                               const char* value,\n                               size_t value_size,\n                               int flags) {\n//// On Chrome OS, there is no component that can validate these extended\n//// attributes so there is no need to set them.\n   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);\n   int result = setxattr(path, name, value, value_size, flags);\n   if (result) {\n     DPLOG(ERROR) << \"Could not set extended attribute \" << name << \" on file \"\n                  << path;\n     return false;\n   }\n   return true;\n }",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "rsvg_new_defs (void)\n{\n    RsvgNodeGroup *group;\n    group = g_new (RsvgNodeGroup, 1);\n    _rsvg_node_init (&group->super);\n    group->super.draw = _rsvg_node_draw_nothing;\n    group->super.set_atts = rsvg_node_group_set_atts;\n    return &group->super;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "    __attribute__((no_sanitize (\"undefined\")))\n#endif\n{\n    _value = cast(other).value();\n\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int bmp_read_palette(gdImagePtr im, gdIOCtxPtr infile, int count, int read_four)\n{\n\tint i;\n\tint r, g, b, z;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (\n\t\t    !gdGetByte(&b, infile) ||\n\t\t    !gdGetByte(&g, infile) ||\n\t\t    !gdGetByte(&r, infile) ||\n\t\t    (read_four && !gdGetByte(&z, infile))\n\t\t) {\n\t\t\treturn 1;\n\t\t}\n\t\tim->red[i] = r;\n\t\tim->green[i] = g;\n\t\tim->blue[i] = b;\n\t\tim->open[i] = 1;\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "FindReference(const std::vector<std::shared_ptr<Ope>> &args,\n                const std::vector<std::string> &params)\n      : args_(args), params_(params) {}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "cJSON *cJSON_CreateIntArray( int64_t *numbers, int count )",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "sockaddr_inet(short family, inet_address_t *addr)\n{\n    SOCKADDR_INET sa_inet;\n    ZeroMemory(&sa_inet, sizeof(sa_inet));\n    sa_inet.si_family = family;\n    if (family == AF_INET)\n    {\n        sa_inet.Ipv4.sin_addr = addr->ipv4;\n    }\n    else if (family == AF_INET6)\n    {\n        sa_inet.Ipv6.sin6_addr = addr->ipv6;\n    }\n    return sa_inet;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "Chapters::Chapters(Segment* pSegment, long long payload_start,\n                   long long payload_size, long long element_start,\n                   long long element_size)\n    : m_pSegment(pSegment),\n      m_start(payload_start),\n      m_size(payload_size),\n      m_element_start(element_start),\n      m_element_size(element_size),\n      m_editions(NULL),\n      m_editions_size(0),\n      m_editions_count(0) {}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedmemalign(size_t alignment, size_t bytes) THROWSPEC\t\t\t\t\t\t\t\t{ return nedpmemalign((nedpool *) 0, alignment, bytes); }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void cd_read_sector_cb(void *opaque, int ret)\n\n{\n\n    IDEState *s = opaque;\n\n\n\n    block_acct_done(blk_get_stats(s->blk), &s->acct);\n\n\n\n#ifdef DEBUG_IDE_ATAPI\n\n    printf(\"cd_read_sector_cb: lba=%d ret=%d\\n\", s->lba, ret);\n\n#endif\n\n\n\n    if (ret < 0) {\n\n        ide_atapi_io_error(s, ret);\n\n        return;\n\n    }\n\n\n\n    if (s->cd_sector_size == 2352) {\n\n        cd_data_to_raw(s->io_buffer, s->lba);\n\n    }\n\n\n\n    s->lba++;\n\n    s->io_buffer_index = 0;\n\n    s->status &= ~BUSY_STAT;\n\n\n\n    ide_atapi_cmd_reply_end(s);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void do_inject_mce(Monitor *mon, const QDict *qdict)\n\n{\n\n    CPUState *cenv;\n\n    int cpu_index = qdict_get_int(qdict, \"cpu_index\");\n\n    int bank = qdict_get_int(qdict, \"bank\");\n\n    uint64_t status = qdict_get_int(qdict, \"status\");\n\n    uint64_t mcg_status = qdict_get_int(qdict, \"mcg_status\");\n\n    uint64_t addr = qdict_get_int(qdict, \"addr\");\n\n    uint64_t misc = qdict_get_int(qdict, \"misc\");\n\n\n\n    for (cenv = first_cpu; cenv != NULL; cenv = cenv->next_cpu)\n\n        if (cenv->cpu_index == cpu_index && cenv->mcg_cap) {\n\n            cpu_inject_x86_mce(cenv, bank, status, mcg_status, addr, misc);\n\n            break;\n\n        }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static jboolean startDiscoveryNative(JNIEnv* env, jobject obj) {\n    ALOGV(\"%s:\",__FUNCTION__);\n\n    jboolean result = JNI_FALSE;\n if (!sBluetoothInterface) return result;\n\n int ret = sBluetoothInterface->start_discovery();\n    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;\n return result;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static unsigned int addr_hash_test(const u32 *mask, const u8 *addr)\n{\n\tint n = ether_crc(ETH_ALEN, addr) >> 26;\n\treturn mask[n >> 5] & (1 << (n & 31));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static MagickBooleanType IsRLE(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\122\\314\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void *netdev_alloc_frag(unsigned int fragsz)\n{\n\treturn __netdev_alloc_frag(fragsz, GFP_ATOMIC | __GFP_COLD);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int check_map_access(struct bpf_verifier_env *env, u32 regno, int off,\n\t\t\t    int size)\n{\n\tstruct bpf_map *map = env->cur_state.regs[regno].map_ptr;\n\n\tif (off < 0 || size <= 0 || off + size > map->value_size) {\n\t\tverbose(\"invalid access to map value, value_size=%d off=%d size=%d\\n\",\n\t\t\tmap->value_size, off, size);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static __always_inline void amd_set_core_ssb_state(unsigned long tifn)\n{\n\tu64 msr = x86_amd_ls_cfg_base | ssbd_tif_to_amd_ls_cfg(tifn);\n\n\twrmsrl(MSR_AMD64_LS_CFG, msr);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int des3_ede_setkey(struct crypto_tfm *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct des3_ede_ctx *dctx = crypto_tfm_ctx(tfm);\n\tu32 *flags = &tfm->crt_flags;\n\tu32 *expkey = dctx->expkey;\n\n\treturn __des3_ede_setkey(expkey, flags, key, keylen);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "follow_huge_pud(struct mm_struct *mm, unsigned long address,\n\t\tpud_t *pud, int flags)\n{\n\tif (flags & (FOLL_GET | FOLL_PIN))\n\t\treturn NULL;\n\n\treturn pte_page(*(pte_t *)pud) + ((address & ~PUD_MASK) >> PAGE_SHIFT);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int dtls1_listen(SSL *s, struct sockaddr *client)\n{\n    int ret;\n\n    SSL_set_options(s, SSL_OP_COOKIE_EXCHANGE);\n    s->d1->listen = 1;\n\n    ret = SSL_accept(s);\n    if (ret <= 0)\n        return ret;\n\n    (void)BIO_dgram_get_peer(SSL_get_rbio(s), client);\n    return 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "GetDataBlock (FILE   *fd,\n              guchar *buf)\n{\n  guchar count;\n\n  if (! ReadOK (fd, &count, 1))\n    {\n      g_message (\"Error in getting DataBlock size\");\n      return -1;\n    }\n\n  ZeroDataBlock = count == 0;\n\n  if ((count != 0) && (! ReadOK (fd, buf, count)))\n    {\n      g_message (\"Error in reading DataBlock\");\n      return -1;\n    }\n\n  return count;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static xmlNodePtr to_xml_time(encodeTypePtr type, zval *data, int style, xmlNodePtr parent TSRMLS_DC)\n{\n\t/* TODO: microsecconds */\n\treturn to_xml_datetime_ex(type, data, \"%H:%M:%S\", style, parent TSRMLS_CC);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "print_syscall_ret_addr(const struct syscallname *name, abi_long ret)\n\n{\n\n    char *errstr = NULL;\n\n\n\n    if (ret == -1) {\n\n        errstr = target_strerror(errno);\n\n    }\n\n    if ((ret == -1) && errstr) {\n\n        gemu_log(\" = -1 errno=%d (%s)\\n\", errno, errstr);\n\n    } else {\n\n        gemu_log(\" = 0x\" TARGET_ABI_FMT_lx \"\\n\", ret);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int __init atalk_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&ddp_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sock_register(&atalk_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\n\tddp_dl = register_snap_client(ddp_snap_id, atalk_rcv);\n\tif (!ddp_dl)\n\t\tprintk(atalk_err_snap);\n\n\tdev_add_pack(&ltalk_packet_type);\n\tdev_add_pack(&ppptalk_packet_type);\n\n\trc = register_netdevice_notifier(&ddp_notifier);\n\tif (rc)\n\t\tgoto out_sock;\n\n\taarp_proto_init();\n\trc = atalk_proc_init();\n\tif (rc)\n\t\tgoto out_aarp;\n\n\trc = atalk_register_sysctl();\n\tif (rc)\n\t\tgoto out_proc;\nout:\n\treturn rc;\nout_proc:\n\tatalk_proc_exit();\nout_aarp:\n\taarp_cleanup_module();\n\tunregister_netdevice_notifier(&ddp_notifier);\nout_sock:\n\tdev_remove_pack(&ppptalk_packet_type);\n\tdev_remove_pack(&ltalk_packet_type);\n\tunregister_snap_client(ddp_dl);\n\tsock_unregister(PF_APPLETALK);\nout_proto:\n\tproto_unregister(&ddp_proto);\n\tgoto out;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "smp_fetch_capture_req_ver(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                          const struct arg *args, struct sample *smp, const char *kw)\n{\n\tstruct http_txn *txn = l7;\n\n\tif (txn->req.msg_state < HTTP_MSG_HDR_FIRST)\n\t\treturn 0;\n\n\tif (txn->req.flags & HTTP_MSGF_VER_11)\n\t\tsmp->data.str.str = \"HTTP/1.1\";\n\telse\n\t\tsmp->data.str.str = \"HTTP/1.0\";\n\n\tsmp->data.str.len = 8;\n\tsmp->type  = SMP_T_STR;\n\tsmp->flags = SMP_F_CONST;\n\treturn 1;\n\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static size_t DestroyEdge(PolygonInfo *polygon_info,\n  const size_t edge)\n{\n  assert(edge < polygon_info->number_edges);\n  polygon_info->edges[edge].points=(PointInfo *) RelinquishMagickMemory(\n    polygon_info->edges[edge].points);\n  polygon_info->number_edges--;\n  if (edge < polygon_info->number_edges)\n    (void) CopyMagickMemory(polygon_info->edges+edge,polygon_info->edges+edge+1,\n      (size_t) (polygon_info->number_edges-edge)*sizeof(*polygon_info->edges));\n  return(polygon_info->number_edges);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void RenderFrameImpl::didNavigateWithinPage(blink::WebLocalFrame* frame,\n    const blink::WebHistoryItem& item,\n    blink::WebHistoryCommitType commit_type) {\n  DCHECK(!frame_ || frame_ == frame);\n  didCreateDataSource(frame, frame->dataSource());\n\n  DocumentState* document_state =\n      DocumentState::FromDataSource(frame->dataSource());\n  NavigationState* new_state = document_state->navigation_state();\n  new_state->set_was_within_same_page(true);\n\n  didCommitProvisionalLoad(frame, item, commit_type);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int flags) {\n    if (cg == NULL) return NULL;\n    int refresh = !(flags & SLC_NO_REFRESH);\n    streamConsumer *consumer = raxFind(cg->consumers,(unsigned char*)name,\n                                       sdslen(name));\n    if (consumer == raxNotFound) return NULL;\n    if (refresh) consumer->seen_time = mstime();\n    return consumer;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Magick::Image::waveletDenoise(const double threshold_,\n  const double softness_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=WaveletDenoiseImage(constImage(),threshold_,softness_,\n    exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int bdrv_discard(BlockDriverState *bs, int64_t sector_num, int nb_sectors)\n\n{\n\n    Coroutine *co;\n\n    DiscardCo rwco = {\n\n        .bs = bs,\n\n        .sector_num = sector_num,\n\n        .nb_sectors = nb_sectors,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_discard_co_entry(&rwco);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_discard_co_entry);\n\n        qemu_coroutine_enter(co, &rwco);\n\n        while (rwco.ret == NOT_DONE) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n\n\n    return rwco.ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void __exit sha1_sparc64_mod_fini(void)\n{\n\tcrypto_unregister_shash(&alg);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                size_t mincodes, size_t numcodes, unsigned maxbitlen)\n{\n  unsigned error = 0;\n  while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; /*trim zeroes*/\n  tree->maxbitlen = maxbitlen;\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n  tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n  if(!tree->lengths) return 83; /*alloc fail*/\n  /*initialize all lengths to 0*/\n  memset(tree->lengths, 0, numcodes * sizeof(unsigned));\n\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "rfbBool SendXvpMsg(rfbClient* client, uint8_t version, uint8_t code)\n{\n    rfbXvpMsg xvp;\n\n    if (!SupportsClient2Server(client, rfbXvp)) return TRUE;\n    xvp.type = rfbXvp;\n    xvp.pad = 0;\n    xvp.version = version;\n    xvp.code = code;\n\n    if (!WriteToRFBServer(client, (char *)&xvp, sz_rfbXvpMsg))\n        return FALSE;\n\n    return TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void IPCThreadState::incWeakHandle(int32_t handle)\n{\n    LOG_REMOTEREFS(\"IPCThreadState::incWeakHandle(%d)\\n\", handle);\n    mOut.writeInt32(BC_INCREFS);\n    mOut.writeInt32(handle);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void encode_share_access(struct xdr_stream *xdr, int open_flags)\n {\n \t__be32 *p;\n \n \tRESERVE_SPACE(8);\n\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {\n \t\tcase FMODE_READ:\n \t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n \t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n \t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n \t\t\tbreak;\n \t\tdefault:\n\t\t\tBUG();\n \t}\n \tWRITE32(0);\t\t/* for linux, share_deny = 0 always */\n }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "Eina_Bool ewk_frame_reload(Evas_Object* ewkFrame)\n{\n    EWK_FRAME_SD_GET_OR_RETURN(ewkFrame, smartData, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->frame, false);\n    smartData->frame->loader()->reload();\n    return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "timestamp_check (hive_h *h, hive_node_h node, int64_t timestamp)\n{\n  if (timestamp < 0) {\n    SET_ERRNO (EINVAL,\n               \"negative time reported at %zu: %\" PRIi64, node, timestamp);\n    return -1;\n  }\n\n  return timestamp;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "KURL Document::CompleteURLWithOverride(const String& url,\n                                       const KURL& base_url_override) const {\n  DCHECK(base_url_override.IsEmpty() || base_url_override.IsValid());\n\n  if (url.IsNull())\n    return KURL();\n  if (!Encoding().IsValid())\n    return KURL(base_url_override, url);\n  return KURL(base_url_override, url, Encoding());\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void vmx_hwapic_isr_update(struct kvm *kvm, int isr)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (isr == -1)\n\t\tisr = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = status >> 8;\n\tif (isr != old) {\n\t\tstatus &= 0xff;\n\t\tstatus |= isr << 8;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int r3d_read_rdvo(AVFormatContext *s, Atom *atom)\n\n{\n\n    R3DContext *r3d = s->priv_data;\n\n    AVStream *st = s->streams[0];\n\n    int i;\n\n\n\n    r3d->video_offsets_count = (atom->size - 8) / 4;\n\n    r3d->video_offsets = av_malloc(atom->size);\n\n    if (!r3d->video_offsets)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < r3d->video_offsets_count; i++) {\n\n        r3d->video_offsets[i] = avio_rb32(s->pb);\n\n        if (!r3d->video_offsets[i]) {\n\n            r3d->video_offsets_count = i;\n\n            break;\n\n        }\n\n        av_dlog(s, \"video offset %d: %#x\\n\", i, r3d->video_offsets[i]);\n\n    }\n\n\n\n    if (st->r_frame_rate.num)\n\n        st->duration = av_rescale_q(r3d->video_offsets_count,\n\n                                    (AVRational){st->r_frame_rate.den,\n\n                                                 st->r_frame_rate.num},\n\n                                    st->time_base);\n\n    av_dlog(s, \"duration %\"PRId64\"\\n\", st->duration);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static bool bnx2x_is_contextless_ramrod(int cmd, int cmd_type)\n{\n\tif ((cmd_type == NONE_CONNECTION_TYPE) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_FORWARD_SETUP) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_CLASSIFICATION_RULES) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_FILTER_RULES) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_MULTICAST_RULES) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_SET_MAC) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_RSS_UPDATE))\n\t\treturn true;\n\telse\n\t\treturn false;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "path_isopen(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\n\tPG_RETURN_BOOL(!path->closed);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void free_recv_msg(struct ipmi_recv_msg *msg)\n{\n\tatomic_dec(&recv_msg_inuse_count);\n\tkfree(msg);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int LibRaw::ljpeg_start(struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset(jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp), fgetc(ifp)) != 0xd8)\n    return 0;\n  do\n  {\n    if (feof(ifp))\n      return 0;\n    if (cnt++ > 1024)\n      return 0; // 1024 tags limit\n    if (!fread(data, 2, 2, ifp))\n      return 0;\n    tag = data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00)\n      return 0;\n    fread(data, 1, len, ifp);\n    switch (tag)\n    {\n    case 0xffc3: // start of frame; lossless, Huffman\n      jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n    case 0xffc1:\n    case 0xffc0:\n      jh->algo = tag & 0xff;\n      jh->bits = data[0];\n      jh->high = data[1] << 8 | data[2];\n      jh->wide = data[3] << 8 | data[4];\n      jh->clrs = data[5] + jh->sraw;\n      if (len == 9 && !dng_version)\n        getc(ifp);\n      break;\n    case 0xffc4: // define Huffman tables\n      if (info_only)\n        break;\n      for (dp = data; dp < data + len && !((c = *dp++) & -20);)\n        jh->free[c] = jh->huff[c] = make_decoder_ref(&dp);\n      break;\n    case 0xffda: // start of scan\n      jh->psv = data[1 + data[0] * 2];\n      jh->bits -= data[3 + data[0] * 2] & 15;\n      break;\n    case 0xffdb:\n      FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2];\n      break;\n    case 0xffdd:\n      jh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide ||\n      !jh->clrs)\n    return 0;\n  if (info_only)\n    return 1;\n  if (!jh->huff[0])\n    return 0;\n  FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c];\n  if (jh->sraw)\n  {\n    FORC(4) jh->huff[2 + c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0];\n  }\n  jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4);\n  merror(jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int nfs_page_async_flush(struct nfs_pageio_descriptor *pgio,\n\t\t\t\tstruct page *page, bool nonblock)\n{\n\tstruct nfs_page *req;\n\tint ret = 0;\n\n\treq = nfs_find_and_lock_request(page, nonblock);\n\tif (!req)\n\t\tgoto out;\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\n\tnfs_set_page_writeback(page);\n\tWARN_ON_ONCE(test_bit(PG_CLEAN, &req->wb_flags));\n\n\tret = 0;\n\tif (!nfs_pageio_add_request(pgio, req)) {\n\t\tnfs_redirty_request(req);\n\t\tret = pgio->pg_error;\n\t}\nout:\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "inline uint32_t byteswap(uint32_t value) { return _af_byteswap_int32(value); }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "enum AVPixelFormat ff_thread_get_format(AVCodecContext *avctx, const enum AVPixelFormat *fmt)\n{\n    return avctx->get_format(avctx, fmt);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)\n{\n\tTIFFDirEntry* m;\n\tuint16 n;\n\t(void) tif;\n\tfor (m=dir, n=0; n<dircount; m++, n++)\n\t{\n\t\tif (m->tdir_tag==tagid)\n\t\t\treturn(m);\n\t}\n\treturn(0);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void pcie_pci_bridge_reset(DeviceState *qdev)\n\n{\n\n    PCIDevice *d = PCI_DEVICE(qdev);\n\n    pci_bridge_reset(qdev);\n\n    msi_reset(d);\n\n    shpc_reset(d);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n   struct mailimf_group * group;\n   int r;\n   int res;\n \n   cur_token = * indx;\n \n  mailbox_list = NULL;\n\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n       res = r;\n       goto free_display_name;\n     }\n     break;\n   default:\n     res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n\n  * indx = cur_token;\n  * result = group;\n\n  return MAILIMF_NO_ERROR;\n\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline void cris_ftag_d(unsigned int x)\n\n{\n\n\tregister unsigned int v asm(\"$r10\") = x;\n\n\tasm (\"ftagd\\t[%0]\\n\" : : \"r\" (v) );\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void PrintChar(int c)\n{\n\tif (curr->w_stringp >= curr->w_string + MAXSTR - 1)\n\t\tPrintFlush();\n\t*(curr->w_stringp)++ = c;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void color_esycc_to_rgb(opj_image_t *image)\n{\n\tint y, cb, cr, sign1, sign2, val;\n\tunsigned int w, h, max, i;\n\tint flip_value = (1 << (image->comps[0].prec-1));\n\tint max_value = (1 << image->comps[0].prec) - 1;\n\t\n\tif(image->numcomps < 3) return;\n\t\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\t\n\tsign1 = (int)image->comps[1].sgnd;\n\tsign2 = (int)image->comps[2].sgnd;\n\t\n\tmax = w * h;\n\t\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\t\n\t\ty = image->comps[0].data[i]; cb = image->comps[1].data[i]; cr = image->comps[2].data[i];\n\t\t\n\t\tif( !sign1) cb -= flip_value;\n\t\tif( !sign2) cr -= flip_value;\n\t\t\n\t\tval = (int)\n\t\t((float)y - (float)0.0000368 * (float)cb\n\t\t + (float)1.40199 * (float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[0].data[i] = val;\n\t\t\n\t\tval = (int)\n\t\t((float)1.0003 * (float)y - (float)0.344125 * (float)cb\n\t\t - (float)0.7141128 * (float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[1].data[i] = val;\n\t\t\n\t\tval = (int)\n\t\t((float)0.999823 * (float)y + (float)1.77204 * (float)cb\n\t\t - (float)0.000008 *(float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[2].data[i] = val;\n\t}\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\n}/* color_esycc_to_rgb() */",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void free_address (ADDRESS *a)\n{\n  FREE(&a->personal);\n  FREE(&a->mailbox);\n#ifdef EXACT_ADDRESS\n  FREE(&a->val);\n#endif\n  FREE(&a);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void cdrom_sysctl_register(void)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void uninit_opts(void)\n\n{\n\n    int i;\n\n    for (i = 0; i < AVMEDIA_TYPE_NB; i++)\n\n        av_freep(&avcodec_opts[i]);\n\n    av_freep(&avformat_opts->key);\n\n    av_freep(&avformat_opts);\n\n#if CONFIG_SWSCALE\n\n    av_freep(&sws_opts);\n\n#endif\n\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n\tint status = BLKIF_RSP_OKAY;\n\tstruct block_device *bdev = blkif->vbd.bdev;\n\tunsigned long secure;\n\n\tblkif->st_ds_req++;\n\n\txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\n\terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n\t\t\t\t   req->u.discard.nr_sectors,\n\t\t\t\t   GFP_KERNEL, secure);\n\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n\t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void tcmu_glfs_close(struct tcmu_device *dev)\n{\n\tstruct glfs_state *gfsp = tcmu_get_dev_private(dev);\n\n\tglfs_close(gfsp->gfd);\n\tgluster_cache_refresh(gfsp->fs, tcmu_get_path(dev));\n\tgluster_free_server(&gfsp->hosts);\n\tfree(gfsp);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int netdev_refcnt_read(const struct net_device *dev)\n{\n\tint i, refcnt = 0;\n\n\tfor_each_possible_cpu(i)\n\t\trefcnt += *per_cpu_ptr(dev->pcpu_refcnt, i);\n\treturn refcnt;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "R_API void r_bin_java_stack_frame_free(void /*RBinJavaStackMapFrame*/ *o) {\n\tRBinJavaStackMapFrame *obj = o;\n\tif (obj) {\n\t\tr_list_free (obj->local_items);\n\t\tr_list_free (obj->stack_items);\n\t\tfree (obj->metas);\n\t\tfree (obj);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void tpm_gen_interrupt(struct tpm_chip *chip)\n{\n\tstruct\ttpm_cmd_t tpm_cmd;\n\tssize_t rc;\n\n\ttpm_cmd.header.in = tpm_getcap_header;\n\ttpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\n\ttpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\n\ttpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;\n\n\trc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\n\t\t\t\"attempting to determine the timeouts\");\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "JsvIsInternalChecker jsvGetInternalFunctionCheckerFor(JsVar *v) {\n  if (jsvIsFunction(v)) return jsvIsInternalFunctionKey;\n  if (jsvIsObject(v)) return jsvIsInternalObjectKey;\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "R_API bool r_socket_connect (RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {\n\treturn false;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void ImageLoader::timerFired(Timer<ImageLoader>*)\n{\n    m_element->deref();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int qcrypto_cipher_encrypt(QCryptoCipher *cipher,\n                           const void *in,\n                           void *out,\n                           size_t len,\n                           Error **errp)\n{\n    QCryptoCipherBuiltin *ctxt = cipher->opaque;\n    return ctxt->encrypt(cipher, in, out, len, errp);",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline void RENAME(palToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width, uint32_t *pal)\n\n{\n\n\tint i;\n\n        assert(src1 == src2);\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tint p= pal[src1[i]];\n\n\n\n\t\tdstU[i]= p>>8;\n\n\t\tdstV[i]= p>>16;\n\n\t}\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void blk_free_queue_rcu(struct rcu_head *rcu_head)\n{\n\tstruct request_queue *q = container_of(rcu_head, struct request_queue,\n\t\t\t\t\t       rcu_head);\n\tkmem_cache_free(blk_requestq_cachep, q);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n \t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n {\n \tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n \n \tif (1 + wlen > MAX_XFER_SIZE) {\n \t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n \t\treturn -EOPNOTSUPP;\n \t}\n \n\two = (rbuf == NULL || rlen == 0); /* write-only */\n \n \tmutex_lock(&d->data_mutex);\n \tst->data[0] = cmd;\n \tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n \n \tmutex_unlock(&d->data_mutex);\n \treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "ram_addr_t migration_bitmap_find_dirty(RAMState *rs, RAMBlock *rb,\n\n                                       ram_addr_t start,\n\n                                       ram_addr_t *ram_addr_abs)\n\n{\n\n    unsigned long base = rb->offset >> TARGET_PAGE_BITS;\n\n    unsigned long nr = base + (start >> TARGET_PAGE_BITS);\n\n    uint64_t rb_size = rb->used_length;\n\n    unsigned long size = base + (rb_size >> TARGET_PAGE_BITS);\n\n    unsigned long *bitmap;\n\n\n\n    unsigned long next;\n\n\n\n    bitmap = atomic_rcu_read(&rs->ram_bitmap)->bmap;\n\n    if (rs->ram_bulk_stage && nr > base) {\n\n        next = nr + 1;\n\n    } else {\n\n        next = find_next_bit(bitmap, size, nr);\n\n    }\n\n\n\n    *ram_addr_abs = next << TARGET_PAGE_BITS;\n\n    return (next - base) << TARGET_PAGE_BITS;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Inspect::operator()(String_Constant_Ptr s)\n  {\n    append_token(s->value(), s);\n  }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "AP4_SubtitleSampleEntry::ToSampleDescription()\n{\n    // create a sample description\n    return new AP4_SubtitleSampleDescription(m_Type,\n                                             m_Namespace.GetChars(),\n                                             m_SchemaLocation.GetChars(),\n                                             m_ImageMimeType.GetChars());\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void error_setg(Error **errp, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);\n\n    va_end(ap);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "transport_write_reset(int options)\n{\nif (!(options & topt_continuation)) chunk_ptr = deliver_out_buffer;\nnl_partial_match = -1;\nnl_check_length = nl_escape_length = 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "Field *get_tmp_table_field() { return 0; }",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int hllMerge(uint8_t *max, robj *hll) {\n    struct hllhdr *hdr = hll->ptr;\n    int i;\n\n    if (hdr->encoding == HLL_DENSE) {\n        uint8_t val;\n\n        for (i = 0; i < HLL_REGISTERS; i++) {\n            HLL_DENSE_GET_REGISTER(val,hdr->registers,i);\n            if (val > max[i]) max[i] = val;\n        }\n    } else {\n        uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);\n        long runlen, regval;\n\n        p += HLL_HDR_SIZE;\n        i = 0;\n        while(p < end) {\n            if (HLL_SPARSE_IS_ZERO(p)) {\n                runlen = HLL_SPARSE_ZERO_LEN(p);\n                i += runlen;\n                p++;\n            } else if (HLL_SPARSE_IS_XZERO(p)) {\n                runlen = HLL_SPARSE_XZERO_LEN(p);\n                i += runlen;\n                p += 2;\n            } else {\n                runlen = HLL_SPARSE_VAL_LEN(p);\n                regval = HLL_SPARSE_VAL_VALUE(p);\n                while(runlen--) {\n                    if (regval > max[i]) max[i] = regval;\n                    i++;\n                }\n                p++;\n            }\n        }\n        if (i != HLL_REGISTERS) return C_ERR;\n    }\n    return C_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static char *jas_iccsigtostr(int sig, char *buf)\n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\tbufptr = buf;\n\tfor (n = 4; n > 0; --n) {\n\t\tc = (sig >> 24) & 0xff;\n\t\tif (isalpha(c) || isdigit(c)) {\n\t\t\t*bufptr++ = c;\n\t\t}\n\t\tsig <<= 8;\n\t}\n\t*bufptr = '\\0';\n\treturn buf;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "  ptr_t GC_unix_get_mem(word bytes)\n  {\n    return GC_unix_mmap_get_mem(bytes);\n  }",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n\n    if (item_len != 18) {\n         avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n         return AVERROR_PATCHWELCOME;\n     }\n    if (item_num > 65536) {\n         av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n         return AVERROR_INVALIDDATA;\n     }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "BGD_DECLARE(void) gdImageTiff(gdImagePtr im, FILE *outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) return;\n\tgdImageTiffCtx(im, out); /* what's an fg again? */\n\tout->gd_free(out);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static double mp_list_stats(_cimg_math_parser& mp) {\n        const unsigned int\n          ind = (unsigned int)cimg::mod((int)_mp_arg(2),mp.listin.width()),\n          k = (unsigned int)mp.opcode[3];\n        if (!mp.list_stats) mp.list_stats.assign(mp.listin._width);\n        if (!mp.list_stats[ind]) mp.list_stats[ind].assign(1,14,1,1,0).fill(mp.listin[ind].get_stats(),false);\n        return mp.list_stats(ind,k);",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void rundebug()\n  {\n  }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "rfbReleaseClientIterator(rfbClientIteratorPtr iterator)\n{\n  if(iterator->next) rfbDecrClientRef(iterator->next);\n  free(iterator);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int handle_e_ident(ELFOBJ *bin) {\n\treturn !strncmp ((char *)bin->ehdr.e_ident, ELFMAG, SELFMAG) ||\n\t\t   !strncmp ((char *)bin->ehdr.e_ident, CGCMAG, SCGCMAG);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "get_text_gray_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr) sinfo;\n  FILE * infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n\n  ptr = source->pub.buffer[0];\n  for (col = cinfo->image_width; col > 0; col--) {\n    *ptr++ = rescale[read_pbm_integer(cinfo, infile)];\n  }\n  return 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ofputil_protocol_is_valid(enum ofputil_protocol protocol)\n{\n    return protocol & OFPUTIL_P_ANY && is_pow2(protocol);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,\n\n    bool is_read)\n\n{\n\n    BlockErrorAction action = blk_get_error_action(req->dev->blk,\n\n                                                   is_read, error);\n\n    VirtIOBlock *s = req->dev;\n\n\n\n    if (action == BLOCK_ERROR_ACTION_STOP) {\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n    } else if (action == BLOCK_ERROR_ACTION_REPORT) {\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);\n\n        block_acct_done(blk_get_stats(s->blk), &req->acct);\n\n        virtio_blk_free_request(req);\n\n    }\n\n\n\n    blk_error_action(s->blk, action, is_read, error);\n\n    return action != BLOCK_ERROR_ACTION_IGNORE;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ModuleExport void UnregisterLABELImage(void)\n{\n  (void) UnregisterMagickInfo(\"LABEL\");\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int vid_probe(AVProbeData *p)\n{\n    // little-endian VID tag, file starts with \"VID\\0\"\n    if (AV_RL32(p->buf) != MKTAG('V', 'I', 'D', 0))\n        return 0;\n    return AVPROBE_SCORE_MAX;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void skb_release_head_state(struct sk_buff *skb)\n{\n\tskb_dst_drop(skb);\n#ifdef CONFIG_XFRM\n\tsecpath_put(skb->sp);\n#endif\n\tif (skb->destructor) {\n\t\tWARN_ON(in_irq());\n\t\tskb->destructor(skb);\n\t}\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tnf_conntrack_put(skb_nfct(skb));\n#endif\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\tnf_bridge_put(skb->nf_bridge);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n\n{\n\n    struct Vmxnet3_TxCompDesc txcq_descr;\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n\n\n    VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n\n\n\n\n    txcq_descr.txdIdx = tx_ridx;\n\n    txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n\n\n\n    vmxnet3_ring_write_curr_cell(d, &s->txq_descr[qidx].comp_ring, &txcq_descr);\n\n\n\n    /* Flush changes in TX descriptor before changing the counter value */\n\n    smp_wmb();\n\n\n\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int generic_readlink(struct dentry *dentry, char __user *buffer,\n\t\t\t    int buflen)\n{\n\tDEFINE_DELAYED_CALL(done);\n\tstruct inode *inode = d_inode(dentry);\n\tconst char *link = inode->i_link;\n\tint res;\n\n\tif (!link) {\n\t\tlink = inode->i_op->get_link(dentry, inode, &done);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\tres = readlink_copy(buffer, buflen, link);\n\tdo_delayed_call(&done);\n\treturn res;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "lldpd_af_to_lldp_proto(int af)\n{\n    switch (af) {\n    case LLDPD_AF_IPV4:\n        return LLDP_MGMT_ADDR_IP4;\n    case LLDPD_AF_IPV6:\n        return LLDP_MGMT_ADDR_IP6;\n    default:\n        return LLDP_MGMT_ADDR_NONE;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t/* 60 bytes */\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t/* 60 bytes */\n\t__u8 *fp;\n\tint n;\n\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\n\tfp = skb->data;\n \tn = 1;\n \n \tname_len = fp[n++];\n \tmemcpy(name, fp+n, name_len); n+=name_len;\n \tname[name_len] = '\\0';\n \n \tattr_len = fp[n++];\n \tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n \tattr[attr_len] = '\\0';\n \n\tIRDA_DEBUG(4, \"LM-IAS: Looking up %s: %s\\n\", name, attr);\n\tobj = irias_find_object(name);\n\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Object %s not found\\n\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"LM-IAS: found %s, id=%d\\n\", obj->name, obj->id);\n\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Attribute %s not found\\n\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\n\t/* We have a match; send the value.  */\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "connection_half_edge_compare_bsearch(const void *key, const void **member)\n{\n  const half_edge_t *e2;\n  tor_assert(key);\n  tor_assert(member && *(half_edge_t**)member);\n  e2 = *(const half_edge_t **)member;\n\n  return *(const streamid_t*)key - e2->stream_id;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tbool strict = env->strict_alignment;\n\tconst char *pointer_desc = \"\";\n\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\t/* Special case, because of NET_IP_ALIGN. Given metadata sits\n\t\t * right in front, treat it the very same way.\n\t\t */\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n \t\tbreak;\n \tcase PTR_TO_STACK:\n \t\tpointer_desc = \"stack \";\n \t\tbreak;\n \tdefault:\n \t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int myregread(RAnalEsil *esil, const char *name, ut64 *val, int *len) {\n\tAeaStats *stats = esil->user;\n\tif (!IS_DIGIT (*name)) {\n\t\tif (!contains (stats->inputregs, name)) {\n\t\t\tif (!contains (stats->regwrite, name)) {\n\t\t\t\tr_list_push (stats->inputregs, strdup (name));\n\t\t\t}\n\t\t}\n\t\tif (!contains (stats->regs, name)) {\n\t\t\tr_list_push (stats->regs, strdup (name));\n\t\t}\n\t\tif (!contains (stats->regread, name)) {\n\t\t\tr_list_push (stats->regread, strdup (name));\n\t\t}\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int versioninfo_cb(void *opaque, uint32_t type, uint32_t name, uint32_t lang, uint32_t rva) {\n    struct vinfo_list *vlist = (struct vinfo_list *)opaque;\n\n    cli_dbgmsg(\"versioninfo_cb: type: %x, name: %x, lang: %x, rva: %x\\n\", type, name, lang, rva);\n    vlist->rvas[vlist->count] = rva;\n    if(++vlist->count == sizeof(vlist->rvas) / sizeof(vlist->rvas[0]))\n\treturn 1;\n    return 0;",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "long do_rt_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_rt_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_ulong r0;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_rt_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->gregs[15];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    target_to_host_sigset(&blocked, &frame->uc.tuc_sigmask);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->uc.tuc_mcontext, &r0))\n\n        goto badframe;\n\n\n\n    if (do_sigaltstack(frame_addr +\n\n\t\t       offsetof(struct target_rt_sigframe, uc.tuc_stack),\n\n\t\t       0, get_sp_from_cpustate(regs)) == -EFAULT)\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "GF_Box *moov_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieBox, GF_ISOM_BOX_TYPE_MOOV);\n\ttmp->trackList = gf_list_new();\n\tif (!tmp->trackList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void set_k_acc(struct SYMBOL *s)\n{\n\tint i, j, nacc;\n\tchar accs[8], pits[8];\n\tstatic char sharp_tb[8] = {26, 23, 27, 24, 21, 25, 22};\n\tstatic char flat_tb[8] = {22, 25, 21, 24, 20, 23, 26};\n\n\tif (s->u.key.sf > 0) {\n\t\tfor (nacc = 0; nacc < s->u.key.sf; nacc++) {\n\t\t\taccs[nacc] = A_SH;\n\t\t\tpits[nacc] = sharp_tb[nacc];\n\t\t}\n\t} else {\n\t\tfor (nacc = 0; nacc < -s->u.key.sf; nacc++) {\n\t\t\taccs[nacc] = A_FT;\n\t\t\tpits[nacc] = flat_tb[nacc];\n\t\t}\n\t}\n\tfor (i = 0; i < s->u.key.nacc; i++) {\n\t\tfor (j = 0; j < nacc; j++) {\n//\t\t\tif ((pits[j] - s->u.key.pits[i]) % 7 == 0) {\n\t\t\tif (pits[j] == s->u.key.pits[i]) {\n\t\t\t\taccs[j] = s->u.key.accs[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == nacc) {\n\t\t\taccs[j] = s->u.key.accs[i];\n\t\t\tpits[j] = s->u.key.pits[i];\n\t\t\tnacc++;\t\t/* cannot overflow */\n\t\t}\n\t}\n\tfor (i = 0; i < nacc; i++) {\n\t\ts->u.key.accs[i] = accs[i];\n\t\ts->u.key.pits[i] = pits[i];\n\t}\n\ts->u.key.nacc = nacc;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void smb2cli_conn_set_io_priority(struct smbXcli_conn *conn,\n\t\t\t\t  uint8_t io_priority)\n{\n\tconn->smb2.io_priority = io_priority;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static struct entry *tstat_lookup(struct entry *entry, char *comm)\n{\n\tstruct entry **head, *curr, *prev;\n\n\thead = tstat_hashentry(entry);\n\tcurr = *head;\n\n\t/*\n\t * The fastpath is when the entry is already hashed,\n\t * we do this with the lookup lock held, but with the\n\t * table lock not held:\n\t */\n\twhile (curr) {\n\t\tif (match_entries(curr, entry))\n\t\t\treturn curr;\n\n\t\tcurr = curr->next;\n\t}\n\t/*\n\t * Slowpath: allocate, set up and link a new hash entry:\n\t */\n\tprev = NULL;\n\tcurr = *head;\n\n\traw_spin_lock(&table_lock);\n\t/*\n\t * Make sure we have not raced with another CPU:\n\t */\n\twhile (curr) {\n\t\tif (match_entries(curr, entry))\n\t\t\tgoto out_unlock;\n\n\t\tprev = curr;\n\t\tcurr = curr->next;\n\t}\n\n\tcurr = alloc_entry();\n\tif (curr) {\n\t\t*curr = *entry;\n\t\tcurr->count = 0;\n\t\tcurr->next = NULL;\n\t\tmemcpy(curr->comm, comm, TASK_COMM_LEN);\n\n\t\tsmp_mb(); /* Ensure that curr is initialized before insert */\n\n\t\tif (prev)\n\t\t\tprev->next = curr;\n\t\telse\n\t\t\t*head = curr;\n\t}\n out_unlock:\n\traw_spin_unlock(&table_lock);\n\n\treturn curr;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int LibRaw::have_fpdata()\n{\n  return imgdata.rawdata.float_image || imgdata.rawdata.float3_image ||\n         imgdata.rawdata.float4_image;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "ssize_t pt_getxattr(FsContext *ctx, const char *path, const char *name,\n                    void *value, size_t size)\n{\n    return local_getxattr_nofollow(ctx, path, name, value, size);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "TfLiteStatus ReluEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const ReluOpData* data = reinterpret_cast<ReluOpData*>(node->user_data);\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      optimized_ops::Relu(GetTensorShape(input), GetTensorData<float>(input),\n                          GetTensorShape(output), GetTensorData<float>(output));\n    } break;\n    // TODO(renjieliu): We may revisit the quantization calculation logic,\n    // the unbounded upper limit is actually hard to quantize.\n    case kTfLiteUInt8: {\n      QuantizedReluX<uint8_t>(0.0f, std::numeric_limits<float>::infinity(),\n                              input, output, data);\n    } break;\n    case kTfLiteInt8: {\n      QuantizedReluX<int8_t>(0.0f, std::numeric_limits<float>::infinity(),\n                             input, output, data);\n    } break;\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Only float32 & int8/uint8 is supported currently, got %s.\",\n          TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static MemoryRegionSection *address_space_lookup_region(AddressSpaceDispatch *d,\n\n                                                        hwaddr addr,\n\n                                                        bool resolve_subpage)\n\n{\n\n    MemoryRegionSection *section = atomic_read(&d->mru_section);\n\n    subpage_t *subpage;\n\n    bool update;\n\n\n\n    if (section && section != &d->map.sections[PHYS_SECTION_UNASSIGNED] &&\n\n        section_covers_addr(section, addr)) {\n\n        update = false;\n\n    } else {\n\n        section = phys_page_find(d, addr);\n\n        update = true;\n\n    }\n\n    if (resolve_subpage && section->mr->subpage) {\n\n        subpage = container_of(section->mr, subpage_t, iomem);\n\n        section = &d->map.sections[subpage->sub_section[SUBPAGE_IDX(addr)]];\n\n    }\n\n    if (update) {\n\n        atomic_set(&d->mru_section, section);\n\n    }\n\n    return section;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void ssl_session_free( ssl_session *session )\n{\n    if( session == NULL )\n        return;\n\n#if defined(POLARSSL_X509_CRT_PARSE_C)\n    if( session->peer_cert != NULL )\n    {\n        x509_crt_free( session->peer_cert );\n        polarssl_free( session->peer_cert );\n    }\n#endif\n\n#if defined(POLARSSL_SSL_SESSION_TICKETS)\n    polarssl_free( session->ticket );\n#endif\n\n    polarssl_zeroize( session, sizeof( ssl_session ) );\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "request_find_from_trans_id(struct evdns_base *base, u16 trans_id) {\n\tstruct request *req = REQ_HEAD(base, trans_id);\n\tstruct request *const started_at = req;\n\n\tASSERT_LOCKED(base);\n\n\tif (req) {\n\t\tdo {\n\t\t\tif (req->trans_id == trans_id) return req;\n\t\t\treq = req->next;\n\t\t} while (req != started_at);\n\t}\n\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int pva_probe(AVProbeData * pd) {\n    const unsigned char *buf = pd->buf;\n    int len = pva_check(buf);\n\n    if (len < 0)\n        return 0;\n\n    if (pd->buf_size >= len + 8 &&\n        pva_check(buf + len) >= 0)\n        return AVPROBE_SCORE_EXTENSION;\n\n    return AVPROBE_SCORE_MAX / 4;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\n\tif (id < 0)\n\t\treturn NULL;\n\n\trcu_read_lock();\n \tspin_lock_bh(&net->nsid_lock);\n \tpeer = idr_find(&net->netns_ids, id);\n \tif (peer)\n\t\tget_net(peer);\n \tspin_unlock_bh(&net->nsid_lock);\n \trcu_read_unlock();\n \n\treturn peer;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "reg_match_pos(VALUE re, VALUE *strp, long pos)\n{\n    VALUE str = *strp;\n\n    if (NIL_P(str)) {\n\trb_backref_set(Qnil);\n\treturn -1;\n    }\n    *strp = str = reg_operand(str, TRUE);\n    if (pos != 0) {\n\tif (pos < 0) {\n\t    VALUE l = rb_str_length(str);\n\t    pos += NUM2INT(l);\n\t    if (pos < 0) {\n\t\treturn pos;\n\t    }\n\t}\n\tpos = rb_str_offset(str, pos);\n    }\n    return rb_reg_search(re, str, pos, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteTensor* hits;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 1, &hits));\n  const TfLiteTensor* lookup;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &lookup));\n  const TfLiteTensor* key;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &key));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &value));\n\n  const int num_rows = SizeOfDimension(value, 0);\n  const int row_bytes = value->bytes / num_rows;\n  void* pointer = nullptr;\n  DynamicBuffer buf;\n\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = -1;\n    pointer = bsearch(&(lookup->data.i32[i]), key->data.i32, num_rows,\n                      sizeof(int32_t), greater);\n    if (pointer != nullptr) {\n      idx = (reinterpret_cast<char*>(pointer) - (key->data.raw)) /\n            sizeof(int32_t);\n    }\n\n    if (idx >= num_rows || idx < 0) {\n      if (output->type == kTfLiteString) {\n        buf.AddString(nullptr, 0);\n      } else {\n        memset(output->data.raw + i * row_bytes, 0, row_bytes);\n      }\n      hits->data.uint8[i] = 0;\n    } else {\n      if (output->type == kTfLiteString) {\n        buf.AddString(GetString(value, idx));\n      } else {\n        memcpy(output->data.raw + i * row_bytes,\n               value->data.raw + idx * row_bytes, row_bytes);\n      }\n      hits->data.uint8[i] = 1;\n    }\n  }\n  if (output->type == kTfLiteString) {\n    buf.WriteToTensorAsVector(output);\n  }\n\n  return kTfLiteOk;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "Fty make_adaptor(F fn, R (*)(SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static ssize_t queue_nomerges_show(struct request_queue *q, char *page)\n{\n\treturn queue_var_show((blk_queue_nomerges(q) << 1) |\n\t\t\t       blk_queue_noxmerges(q), page);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void CommandBufferProxyImpl::AddDeletionObserver(DeletionObserver* observer) {\n  std::unique_ptr<base::AutoLock> lock;\n  if (lock_)\n    lock.reset(new base::AutoLock(*lock_));\n  deletion_observers_.AddObserver(observer);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int xmlrpc_unregister_method(const char *method)\n{\n\treturn_val_if_fail(method != NULL, XMLRPC_ERR_PARAMS);\n\n\tmowgli_patricia_delete(XMLRPCCMD, method);\n\n\treturn XMLRPC_ERR_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void diff_words_append(char *line, unsigned long len,\n\t\tstruct diff_words_buffer *buffer)\n{\n\tif (buffer->text.size + len > buffer->alloc) {\n\t\tbuffer->alloc = (buffer->text.size + len) * 3 / 2;\n\t\tbuffer->text.ptr = xrealloc(buffer->text.ptr, buffer->alloc);\n\t}\n\tline++;\n\tlen--;\n\tmemcpy(buffer->text.ptr + buffer->text.size, line, len);\n\tbuffer->text.size += len;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static bool vmx_exception_injected(struct kvm_vcpu *vcpu)\n{\n\treturn false;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "png_colorspace_check_xy(png_XYZ *XYZ, const png_xy *xy)\n{\n   int result;\n   png_xy xy_test;\n\n   /* As a side-effect this routine also returns the XYZ endpoints. */\n   result = png_XYZ_from_xy(XYZ, xy);\n   if (result != 0)\n      return result;\n\n   result = png_xy_from_XYZ(&xy_test, XYZ);\n   if (result != 0)\n      return result;\n\n   if (png_colorspace_endpoints_match(xy, &xy_test,\n       5/*actually, the math is pretty accurate*/) != 0)\n      return 0;\n\n   /* Too much slip */\n   return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "uint8_t* cli_bcapi_buffer_pipe_write_get(struct cli_bc_ctx *ctx, int32_t id, uint32_t size)\n{\n    struct bc_buffer *b = get_buffer(ctx, id);\n    if (!b || size > cli_bcapi_buffer_pipe_write_avail(ctx, id) || !size)\n\treturn NULL;\n    if (!b->data)\n\treturn NULL;\n    return b->data + b->write_cursor;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "gst_h264_slice_parse_dec_ref_pic_marking (GstH264SliceHdr * slice,\n    GstH264NalUnit * nalu, NalReader * nr)\n{\n  GstH264DecRefPicMarking *dec_ref_pic_m;\n  guint start_pos;\n\n  GST_DEBUG (\"parsing \\\"Decoded reference picture marking\\\"\");\n\n  start_pos = nal_reader_get_pos (nr);\n\n  dec_ref_pic_m = &slice->dec_ref_pic_marking;\n\n  if (nalu->idr_pic_flag) {\n    READ_UINT8 (nr, dec_ref_pic_m->no_output_of_prior_pics_flag, 1);\n    READ_UINT8 (nr, dec_ref_pic_m->long_term_reference_flag, 1);\n  } else {\n    READ_UINT8 (nr, dec_ref_pic_m->adaptive_ref_pic_marking_mode_flag, 1);\n    if (dec_ref_pic_m->adaptive_ref_pic_marking_mode_flag) {\n      guint32 mem_mgmt_ctrl_op;\n      GstH264RefPicMarking *refpicmarking;\n\n      dec_ref_pic_m->n_ref_pic_marking = 0;\n      while (1) {\n        refpicmarking =\n            &dec_ref_pic_m->ref_pic_marking[dec_ref_pic_m->n_ref_pic_marking];\n\n        READ_UE (nr, mem_mgmt_ctrl_op);\n        if (mem_mgmt_ctrl_op == 0)\n          break;\n\n        refpicmarking->memory_management_control_operation = mem_mgmt_ctrl_op;\n\n        if (mem_mgmt_ctrl_op == 1 || mem_mgmt_ctrl_op == 3)\n          READ_UE (nr, refpicmarking->difference_of_pic_nums_minus1);\n\n        if (mem_mgmt_ctrl_op == 2)\n          READ_UE (nr, refpicmarking->long_term_pic_num);\n\n        if (mem_mgmt_ctrl_op == 3 || mem_mgmt_ctrl_op == 6)\n          READ_UE (nr, refpicmarking->long_term_frame_idx);\n\n        if (mem_mgmt_ctrl_op == 4)\n          READ_UE (nr, refpicmarking->max_long_term_frame_idx_plus1);\n\n        dec_ref_pic_m->n_ref_pic_marking++;\n      }\n    }\n  }\n\n  dec_ref_pic_m->bit_size = nal_reader_get_pos (nr) - start_pos;\n\n  return TRUE;\n\nerror:\n  GST_WARNING (\"error parsing \\\"Decoded reference picture marking\\\"\");\n  return FALSE;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void rt6_remove_prefsrc(struct inet6_ifaddr *ifp)\n{\n\tstruct net *net = dev_net(ifp->idev->dev);\n\tstruct arg_dev_net_ip adni = {\n\t\t.dev = ifp->idev->dev,\n\t\t.net = net,\n\t\t.addr = &ifp->addr,\n\t};\n\tfib6_clean_all(net, fib6_remove_prefsrc, 0, &adni);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool RenderLayerScrollableArea::isScrollCornerVisible() const\n{\n    return !scrollCornerRect().isEmpty();\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "libxlDomainShutdownHandleRestart(libxlDriverPrivate *driver,\n                                 virDomainObj *vm)\n{\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    if (libxlDomainStartNew(driver, vm, false) < 0) {\n        VIR_ERROR(_(\"Failed to restart VM '%s': %s\"),\n                  vm->def->name, virGetLastErrorMessage());\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void TypedUrlModelAssociator::AbortAssociation() {\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline bool regime_is_user(CPUARMState *env, ARMMMUIdx mmu_idx)\n\n{\n\n    switch (mmu_idx) {\n\n    case ARMMMUIdx_S1SE0:\n\n    case ARMMMUIdx_S1NSE0:\n\n\n        return true;\n\n    default:\n\n        return false;\n\n    case ARMMMUIdx_S12NSE0:\n\n    case ARMMMUIdx_S12NSE1:\n\n        g_assert_not_reached();\n\n    }\n\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static irqreturn_t fsl_hv_state_change_isr(int irq, void *data)\n{\n\tunsigned int status;\n\tstruct doorbell_isr *dbisr = data;\n\tint ret;\n\n\t/* It's still a doorbell, so add it to all the queues. */\n\tfsl_hv_queue_doorbell(dbisr->doorbell);\n\n\t/* Determine the new state, and if it's stopped, notify the clients. */\n\tret = fh_partition_get_status(dbisr->partition, &status);\n\tif (!ret && (status == FH_PARTITION_STOPPED))\n\t\treturn IRQ_WAKE_THREAD;\n\n\treturn IRQ_HANDLED;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void nested_flush_cached_shadow_vmcs12(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct vmcs12 *vmcs12)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!nested_cpu_has_shadow_vmcs(vmcs12) ||\n\t    vmcs12->vmcs_link_pointer == -1ull)\n\t\treturn;\n\n\tkvm_write_guest(vmx->vcpu.kvm, vmcs12->vmcs_link_pointer,\n\t\t\tget_shadow_vmcs12(vcpu), VMCS12_SIZE);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "RendererSchedulerImpl::CompositorThreadOnly::CompositorThreadOnly()\n    : last_input_type(blink::WebInputEvent::kUndefined),\n      main_thread_seems_unresponsive(false) {}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t/* If userspace annotates copy, clips must come in pairs */\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n \t}\n \n \tif (num_clips && clips_ptr) {\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void RenderView::OnToggleSpellCheck() {\n  if (!webview())\n    return;\n\n  WebFrame* frame = webview()->focusedFrame();\n  frame->enableContinuousSpellChecking(\n      !frame->isContinuousSpellCheckingEnabled());\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "TfLiteStatus EluEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      optimized_ops::Elu(GetTensorShape(input), GetTensorData<float>(input),\n                         GetTensorShape(output), GetTensorData<float>(output));\n      return kTfLiteOk;\n    } break;\n    case kTfLiteInt8: {\n      OpData* data = reinterpret_cast<OpData*>(node->user_data);\n      EvalUsingLookupTable(data, input, output);\n      return kTfLiteOk;\n    } break;\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Only float32 and int8 is supported currently, got %s.\",\n          TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline int ohci_put_ed(OHCIState *ohci,\n\n                              uint32_t addr, struct ohci_ed *ed)\n\n{\n\n    return put_dwords(ohci, addr, (uint32_t *)ed, sizeof(*ed) >> 2);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const\n {\n    if (m_allowStar)\n         return true;\n \n     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;\n \n     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))\n         return true;\n \n    for (size_t i = 0; i < m_list.size(); ++i) {\n        if (m_list[i].matches(effectiveURL, redirectStatus))\n            return true;\n    }\n    return false;\n }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void ff_jref_idct_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n\n{\n\n    ff_j_rev_dct(block);\n\n    ff_put_pixels_clamped(block, dest, line_size);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int open_port(struct inode *inode, struct file *filp)\n{\n\treturn capable(CAP_SYS_RAWIO) ? 0 : -EPERM;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "adv_error adv_png_write(\n\tunsigned pix_width, unsigned pix_height, unsigned pix_pixel,\n\tconst unsigned char* pix_ptr, int pix_pixel_pitch, int pix_scanline_pitch,\n\tconst unsigned char* pal_ptr, unsigned pal_size,\n\tadv_bool fast,\n\tadv_fz* f, unsigned* count)\n{\n\tif (adv_png_write_signature(f, count) != 0) {\n\t\treturn -1;\n\t}\n\n\treturn adv_png_write_raw(\n\t\tpix_width, pix_height, pix_pixel,\n\t\tpix_ptr, pix_pixel_pitch, pix_scanline_pitch,\n\t\tpal_ptr, pal_size,\n\t\t0, 0,\n\t\tfast,\n\t\tf, count\n\t);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int loop_exit_cb(int id, void *ptr, void *data)\n{\n\tstruct loop_device *lo = ptr;\n\n\tloop_remove(lo);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int interp(RA144Context *ractx, int16_t *out, int a,\n\n                  int copyold, int energy)\n\n{\n\n    int work[10];\n\n    int b = NBLOCKS - a;\n\n    int i;\n\n\n\n    // Interpolate block coefficients from the this frame's forth block and\n\n    // last frame's forth block.\n\n    for (i=0; i<30; i++)\n\n        out[i] = (a * ractx->lpc_coef[0][i] + b * ractx->lpc_coef[1][i])>> 2;\n\n\n\n    if (eval_refl(work, out, ractx)) {\n\n        // The interpolated coefficients are unstable, copy either new or old\n\n        // coefficients.\n\n        int_to_int16(out, ractx->lpc_coef[copyold]);\n\n        return rescale_rms(ractx->lpc_refl_rms[copyold], energy);\n\n    } else {\n\n        return rescale_rms(rms(work), energy);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void alloc_file_image(MemBuffer &mb, off_t size)\n{\n    assert(mem_size_valid_bytes(size));\n    if (mb.getVoidPtr() == NULL) {\n        mb.alloc(size);\n    } else {\n        assert(size <= (off_t) mb.getSize());\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int frameCount() { return m_frameCount; }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "XFixesCreateRegionFromGC (Display *dpy, GC gc)\n{\n    XFixesExtDisplayInfo\t\t*info = XFixesFindDisplay (dpy);\n    xXFixesCreateRegionFromGCReq\t*req;\n    XserverRegion\t\t\tregion;\n\n    XFixesCheckExtension (dpy, info, 0);\n    LockDisplay (dpy);\n    GetReq (XFixesCreateRegionFromGC, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesCreateRegionFromGC;\n    region = req->region = XAllocID (dpy);\n    req->gc = gc->gid;\n    UnlockDisplay (dpy);\n    SyncHandle();\n    return region;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)\n{\n\tstruct hidp_connadd_req ca;\n\tstruct hidp_conndel_req cd;\n\tstruct hidp_connlist_req cl;\n\tstruct hidp_conninfo ci;\n\tstruct socket *csock;\n\tstruct socket *isock;\n\tint err;\n\n\tBT_DBG(\"cmd %x arg %p\", cmd, argp);\n\n\tswitch (cmd) {\n\tcase HIDPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\n\t\tcsock = sockfd_lookup(ca.ctrl_sock, &err);\n\t\tif (!csock)\n\t\t\treturn err;\n\n\t\tisock = sockfd_lookup(ca.intr_sock, &err);\n\t\tif (!isock) {\n \t\t\tsockfd_put(csock);\n \t\t\treturn err;\n \t\t}\n \n \t\terr = hidp_connection_add(&ca, csock, isock);\n \t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\terr = -EFAULT;\n\n\t\tsockfd_put(csock);\n\t\tsockfd_put(isock);\n\n\t\treturn err;\n\n\tcase HIDPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn hidp_connection_del(&cd);\n\n\tcase HIDPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = hidp_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tcase HIDPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\terr = hidp_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\t}\n\n\treturn -EINVAL;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void fsl_imx31_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    dc->realize = fsl_imx31_realize;\n\n\n\n    dc->desc = \"i.MX31 SOC\";\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void pcrypt_aead_givenc(struct padata_priv *padata)\n{\n\tstruct pcrypt_request *preq = pcrypt_padata_request(padata);\n\tstruct aead_givcrypt_request *req = pcrypt_request_ctx(preq);\n\n\tpadata->info = crypto_aead_givencrypt(req);\n\n\tif (padata->info == -EINPROGRESS)\n\t\treturn;\n\n\tpadata_do_serial(padata);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int cmp_intervals(const void *a, const void *b)\n\n{\n\n    const Interval *i1 = a;\n\n    const Interval *i2 = b;\n\n    int64_t ts_diff = i1->start_ts - i2->start_ts;\n\n    int ret;\n\n\n\n    ret = ts_diff > 0 ? 1 : ts_diff < 0 ? -1 : 0;\n\n    return ret == 0 ? i1->index - i2->index : ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int rtnl_group_changelink(const struct sk_buff *skb,\n\t\tstruct net *net, int group,\n\t\tstruct ifinfomsg *ifm,\n\t\tstruct nlattr **tb)\n{\n\tstruct net_device *dev, *aux;\n\tint err;\n\n\tfor_each_netdev_safe(net, dev, aux) {\n\t\tif (dev->group == group) {\n\t\t\terr = do_setlink(skb, dev, ifm, tb, NULL, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "filter_count_width(int c, void* data)\n{\n\t(*(int *)data) += (is_fullwidth(c) ? 2: 1);\n\treturn c;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "GF_Err vmhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\tptr->reserved = gf_bs_read_u64(bs);\n\treturn GF_OK;",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static git_tree_entry *alloc_entry(const char *filename)\n{\n\tgit_tree_entry *entry = NULL;\n\tsize_t filename_len = strlen(filename);\n\n\tentry = git__malloc(sizeof(git_tree_entry) + filename_len + 1);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmemset(entry, 0x0, sizeof(git_tree_entry));\n\tmemcpy(entry->filename, filename, filename_len);\n\tentry->filename[filename_len] = 0;\n\tentry->filename_len = filename_len;\n\n\treturn entry;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "cgi_sort_variables(void)\n{\n  if (form_count < 2)\n    return;\n\n  qsort(form_vars, (size_t)form_count, sizeof(_cgi_var_t),\n        (int (*)(const void *, const void *))cgi_compare_variables);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static pyc_object *get_unicode_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (unicode size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tret->type = TYPE_UNICODE;\n\tret->data = get_bytes(buffer, n);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "explicit PdfCompositorTestService(const std::string& creator)\n      : PdfCompositorService(creator) {}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static bool qvirtio_pci_get_config_isr_status(QVirtioDevice *d)\n\n{\n\n    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;\n\n    uint32_t data;\n\n\n\n    if (dev->pdev->msix_enabled) {\n\n        g_assert_cmpint(dev->config_msix_entry, !=, -1);\n\n        if (qpci_msix_masked(dev->pdev, dev->config_msix_entry)) {\n\n            /* No ISR checking should be done if masked, but read anyway */\n\n            return qpci_msix_pending(dev->pdev, dev->config_msix_entry);\n\n        } else {\n\n            data = readl(dev->config_msix_addr);\n\n            writel(dev->config_msix_addr, 0);\n\n            return data == dev->config_msix_data;\n\n        }\n\n    } else {\n\n        return qpci_io_readb(dev->pdev, dev->addr + QVIRTIO_PCI_ISR_STATUS) & 2;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "gboolean tcmulib_callback(GIOChannel *source,\n\t\t\t  GIOCondition condition,\n\t\t\t  gpointer data)\n{\n\tstruct tcmulib_context *ctx = data;\n\n\ttcmulib_master_fd_ready(ctx);\n\n\treturn TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "stack_max_size_read(struct file *filp, char __user *ubuf,\n\t\t    size_t count, loff_t *ppos)\n{\n\tunsigned long *ptr = filp->private_data;\n\tchar buf[64];\n\tint r;\n\n\tr = snprintf(buf, sizeof(buf), \"%ld\\n\", *ptr);\n\tif (r > sizeof(buf))\n\t\tr = sizeof(buf);\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, r);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "_stable_id_append(GString *str, const char *substitution)\n{\n    if (!substitution)\n        substitution = \"\";\n    g_string_append_printf(str, \"=%zu{%s}\", strlen(substitution), substitution);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int qcow_write(BlockDriverState *bs, int64_t sector_num,\n\n                      const uint8_t *buf, int nb_sectors)\n\n{\n\n    Coroutine *co;\n\n    AioContext *aio_context = bdrv_get_aio_context(bs);\n\n    QcowWriteCo data = {\n\n        .bs         = bs,\n\n        .sector_num = sector_num,\n\n        .buf        = buf,\n\n        .nb_sectors = nb_sectors,\n\n        .ret        = -EINPROGRESS,\n\n    };\n\n    co = qemu_coroutine_create(qcow_write_co_entry);\n\n    qemu_coroutine_enter(co, &data);\n\n    while (data.ret == -EINPROGRESS) {\n\n        aio_poll(aio_context, true);\n\n    }\n\n    return data.ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void checkServerNegotiation(const BSONObj& input, const std::vector<std::string>& expected) {\n    auto registry = buildRegistry();\n    MessageCompressorManager manager(&registry);\n\n    BSONObjBuilder serverOutput;\n    manager.serverNegotiate(input, &serverOutput);\n    checkNegotiationResult(serverOutput.done(), expected);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "init_disasm (struct disassemble_info *info)\n\n{\n\n  const struct s390_opcode *opcode;\n\n  const struct s390_opcode *opcode_end;\n\n\n\n  memset (opc_index, 0, sizeof (opc_index));\n\n  opcode_end = s390_opcodes + s390_num_opcodes;\n\n  for (opcode = s390_opcodes; opcode < opcode_end; opcode++)\n\n    {\n\n      opc_index[(int) opcode->opcode[0]] = opcode - s390_opcodes;\n\n      while ((opcode < opcode_end) &&\n\n\t     (opcode[1].opcode[0] == opcode->opcode[0]))\n\n\topcode++;\n\n    }\n\n\n\n#ifdef QEMU_DISABLE\n\n  switch (info->mach)\n\n    {\n\n    case bfd_mach_s390_31:\n\n      current_arch_mask = 1 << S390_OPCODE_ESA;\n\n      break;\n\n    case bfd_mach_s390_64:\n\n      current_arch_mask = 1 << S390_OPCODE_ZARCH;\n\n      break;\n\n    default:\n\n      abort ();\n\n    }\n\n#endif /* QEMU_DISABLE */\n\n\n\n  init_flag = 1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int netdev_set_tc_queue(struct net_device *dev, u8 tc, u16 count, u16 offset)\n{\n\tif (tc >= dev->num_tc)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_XPS\n\tnetif_reset_xps_queues(dev, offset, count);\n#endif\n\tdev->tc_to_txq[tc].count = count;\n\tdev->tc_to_txq[tc].offset = offset;\n\treturn 0;",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "cifs_lock_init(__u64 offset, __u64 length, __u8 type)\n{\n\tstruct cifsLockInfo *lock =\n\t\tkmalloc(sizeof(struct cifsLockInfo), GFP_KERNEL);\n\tif (!lock)\n\t\treturn lock;\n\tlock->offset = offset;\n\tlock->length = length;\n\tlock->type = type;\n\tlock->pid = current->tgid;\n\tINIT_LIST_HEAD(&lock->blist);\n\tinit_waitqueue_head(&lock->block_q);\n\treturn lock;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static av_cold int pcx_end(AVCodecContext *avctx) {\n\n    PCXContext *s = avctx->priv_data;\n\n\n\n    if(s->picture.data[0])\n\n        avctx->release_buffer(avctx, &s->picture);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void tcg_prologue_init(TCGContext *s)\n{\n    /* init global prologue and epilogue */\n    s->code_buf = s->code_gen_prologue;\n    s->code_ptr = s->code_buf;\n    tcg_target_qemu_prologue(s);\n    flush_icache_range((tcg_target_ulong)s->code_buf,\n                       (tcg_target_ulong)s->code_ptr);",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)\n{\n    return nic->ncs + queue_index;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void skb_free_head(struct sk_buff *skb)\n{\n\tunsigned char *head = skb->head;\n\n\tif (skb->head_frag)\n\t\tskb_free_frag(head);\n\telse\n\t\tkfree(head);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline void softusb_read_pmem(MilkymistSoftUsbState *s,\n\n        uint32_t offset, uint8_t *buf, uint32_t len)\n\n{\n\n    if (offset + len >= s->pmem_size) {\n\n        error_report(\"milkymist_softusb: read pmem out of bounds \"\n\n                \"at offset 0x%x, len %d\", offset, len);\n\n\n        return;\n\n    }\n\n\n\n    memcpy(buf, s->pmem_ptr + offset, len);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static ssize_t queue_wc_show(struct request_queue *q, char *page)\n{\n\tif (test_bit(QUEUE_FLAG_WC, &q->queue_flags))\n\t\treturn sprintf(page, \"write back\\n\");\n\n\treturn sprintf(page, \"write through\\n\");\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\n\twhile (isspace(*numstr))\n\t\tnumstr++;\n\n\tif (*numstr == '-')\n\t\treturn -EINVAL;\n\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno == ERANGE && uli == ULONG_MAX)\n\t\treturn -ERANGE;\n\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "vncProperties::SaveInt(HKEY key, LPCSTR valname, LONG val)\r\n{\r\n\tRegSetValueEx(key, valname, 0, REG_DWORD, (LPBYTE) &val, sizeof(val));\r\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "shiftAnchorPosition(AnchorList *al, HmarkerList *hl, int line, int pos,\n\t\t    int shift)\n{\n    Anchor *a;\n    size_t b, e, s = 0;\n    int cmp;\n\n    if (al == NULL || al->nanchor == 0)\n\treturn;\n\n    s = al->nanchor / 2;\n    for (b = 0, e = al->nanchor - 1; b <= e; s = (b + e + 1) / 2) {\n\ta = &al->anchors[s];\n\tcmp = onAnchor(a, line, pos);\n\tif (cmp == 0)\n\t    break;\n\telse if (cmp > 0)\n\t    b = s + 1;\n\telse if (s == 0)\n\t    break;\n\telse\n\t    e = s - 1;\n    }\n    for (; s < al->nanchor; s++) {\n\ta = &al->anchors[s];\n\tif (a->start.line > line)\n\t    break;\n\tif (a->start.pos > pos) {\n\t    a->start.pos += shift;\n\t    if (hl->marks[a->hseq].line == line)\n\t\thl->marks[a->hseq].pos = a->start.pos;\n\t}\n\tif (a->end.pos >= pos)\n\t    a->end.pos += shift;\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "rdpsnddbg_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tstatic char *rest = NULL;\n\tchar *buf;\n\n\tpkglen = s->end - s->p;\n\t/* str_handle_lines requires null terminated strings */\n\tbuf = (char *) xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\n\tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);\n\n\txfree(buf);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "bool VariableUnserializer::matchString(folly::StringPiece str) {\n  const char* p = m_buf;\n  assertx(p <= m_end);\n  int total = 0;\n  if (*p == 'S') {\n    total = 2 + 8 + 1;\n    if (p + total > m_end) return false;\n    p++;\n    if (*p++ != ':') return false;\n    auto const sd = *reinterpret_cast<StringData*const*>(p);\n    assertx(sd->isStatic());\n    if (str.compare(sd->slice()) != 0) return false;\n    p += size_t(8);\n  } else {\n    const auto ss = str.size();\n    if (ss >= 100) return false;\n    int digits = ss >= 10 ? 2 : 1;\n    total = 2 + digits + 2 + ss + 2;\n    if (p + total > m_end) return false;\n    if (*p++ != 's') return false;\n    if (*p++ != ':') return false;\n    if (digits == 2) {\n      if (*p++ != '0' + ss/10) return false;\n      if (*p++ != '0' + ss%10) return false;\n    } else {\n      if (*p++ != '0' + ss) return false;\n    }\n    if (*p++ != ':') return false;\n    if (*p++ != '\\\"') return false;\n    if (memcmp(p, str.data(), ss)) return false;\n    p += ss;\n    if (*p++ != '\\\"') return false;\n  }\n  if (*p++ != ';') return false;\n  assertx(m_buf + total == p);\n  m_buf = p;\n  return true;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "archive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\treturn archive_wstring_append_from_mbs_in_codepage(dest, p, len, NULL);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "GfxICCBasedColorSpace::~GfxICCBasedColorSpace()\n{\n    delete alt;\n#ifdef USE_CMS\n    if (psCSA)\n        gfree(psCSA);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int __init init_default_flow_dissectors(void)\n{\n\tskb_flow_dissector_init(&flow_keys_dissector,\n\t\t\t\tflow_keys_dissector_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_dissector_keys));\n\tskb_flow_dissector_init(&flow_keys_dissector_symmetric,\n\t\t\t\tflow_keys_dissector_symmetric_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_dissector_symmetric_keys));\n\tskb_flow_dissector_init(&flow_keys_buf_dissector,\n\t\t\t\tflow_keys_buf_dissector_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_buf_dissector_keys));\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void FinalizeRoundKey(const unsigned int *ciphertext,\n  const unsigned int *key,unsigned char *plaintext)\n{\n  unsigned char\n    *p;\n\n  unsigned int\n    i,\n    j;\n\n  unsigned int\n    value;\n\n  /*\n    The round key is XORed with the result of the mix-column transformation.\n  */\n  p=plaintext;\n  for (i=0; i < 4; i++)\n  {\n    value=ciphertext[i] ^ key[i];\n    for (j=0; j < 4; j++)\n      *p++=(unsigned char) ((value >> (8*j)) & 0xff);\n  }\n  /*\n    Reset registers.\n  */\n  value=0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "char *vnc_display_local_addr(DisplayState *ds)\n{\n    VncDisplay *vs = vnc_display;\n    \n    return vnc_socket_local_addr(\"%s:%s\", vs->lsock);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "dns_message_renderrelease(dns_message_t *msg, unsigned int space) {\n\tREQUIRE(DNS_MESSAGE_VALID(msg));\n\tREQUIRE(space <= msg->reserved);\n\n\tmsg->reserved -= space;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "String WebPageSerializerImpl::preActionBeforeSerializeEndTag(\n    const Element* element, SerializeDomParam* param, bool* needSkip)\n{\n    String result;\n\n    *needSkip = false;\n    if (!param->isHTMLDocument)\n        return result;\n    if (param->skipMetaElement == element) {\n        *needSkip = true;\n    } else if (isHTMLScriptElement(*element) || isHTMLScriptElement(*element)) {\n        ASSERT(param->isInScriptOrStyleTag);\n        param->isInScriptOrStyleTag = false;\n    }\n\n    return result;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void ricon(char *name, char *comment, char *onclick) {\n   rsprintf\n           (\"<img align=\\\"middle\\\" name=\\\"%s\\\" src=\\\"icons/elc_%s.png\\\" alt=\\\"%s\\\" title=\\\"%s\\\" border=\\\"0\\\"\\n\",\n            name, name, comment, comment);\n   rsprintf(\" onclick=\\\"%s\\\"\", onclick);\n   rsprintf(\" onmousedown=\\\"document.images.%s.src='icons/eld_%s.png'\\\"\\n\", name, name);\n   rsprintf(\" onmouseup=\\\"document.images.%s.src='icons/elc_%s.png'\\\"\\n\", name, name);\n   rsprintf(\" onmouseover=\\\"this.style.cursor='pointer';\\\" />\\n\");\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void co_read_response(void *opaque)\n\n{\n\n    BDRVSheepdogState *s = opaque;\n\n\n\n    if (!s->co_recv) {\n\n        s->co_recv = qemu_coroutine_create(aio_read_response);\n\n    }\n\n\n\n    qemu_coroutine_enter(s->co_recv, opaque);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void js_currentfunction(js_State *J)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP] = STACK[BOT-1];\n\t++TOP;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "test_bson_clear (void)\n{\n   bson_t *doc = NULL;\n\n   bson_clear (&doc);\n   BSON_ASSERT (doc == NULL);\n\n   doc = bson_new ();\n   BSON_ASSERT (doc != NULL);\n   bson_clear (&doc);\n   BSON_ASSERT (doc == NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {\n  const std::string yaml_string = R\"EOF(\n  stat_prefix: ingress_http\n  server_header_transformation: APPEND_IF_ABSENT\n  route_config:\n    name: local_route\n  http_filters:\n  - name: envoy.filters.http.router\n  )EOF\";\n\n  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))\n      .WillOnce(Invoke(&context_.runtime_loader_.snapshot_,\n                       &Runtime::MockSnapshot::featureEnabledDefault));\n  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,\n                                     date_provider_, route_config_provider_manager_,\n                                     scoped_routes_config_provider_manager_, http_tracer_manager_,\n                                     filter_config_provider_manager_);\n  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,\n            config.serverHeaderTransformation());\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void pred8x8_dc_rv40_c(uint8_t *src, int stride){\n\n    int i;\n\n    int dc0=0;\n\n\n\n    for(i=0;i<4; i++){\n\n        dc0+= src[-1+i*stride] + src[i-stride];\n\n        dc0+= src[4+i-stride];\n\n        dc0+= src[-1+(i+4)*stride];\n\n    }\n\n    dc0= 0x01010101*((dc0 + 8)>>4);\n\n\n\n    for(i=0; i<4; i++){\n\n        ((uint32_t*)(src+i*stride))[0]= dc0;\n\n        ((uint32_t*)(src+i*stride))[1]= dc0;\n\n    }\n\n    for(i=4; i<8; i++){\n\n        ((uint32_t*)(src+i*stride))[0]= dc0;\n\n        ((uint32_t*)(src+i*stride))[1]= dc0;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void tcm_loop_check_stop_free(struct se_cmd *se_cmd)\n{\n\t/*\n\t * Do not release struct se_cmd's containing a valid TMR\n\t * pointer.  These will be released directly in tcm_loop_device_reset()\n\t * with transport_generic_free_cmd().\n\t */\n\tif (se_cmd->se_tmr_req)\n\t\treturn;\n\t/*\n\t * Release the struct se_cmd, which will make a callback to release\n\t * struct tcm_loop_cmd * in tcm_loop_deallocate_core_cmd()\n\t */\n\ttransport_generic_free_cmd(se_cmd, 0, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "Module::Module() :\n\tm_sink(NULL)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "gst_date_time_new_now_utc (void)\n{\n  return gst_date_time_new_from_g_date_time (g_date_time_new_now_utc ());\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int __init crypto_cbc_module_init(void)\n{\n\treturn crypto_register_template(&crypto_cbc_tmpl);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int perf_config(config_fn_t fn, void *data)\n{\n\tint ret = 0, found = 0;\n\tchar *repo_config = NULL;\n\tconst char *home = NULL;\n\n\t/* Setting $PERF_CONFIG makes perf read _only_ the given config file. */\n\tif (config_exclusive_filename)\n\t\treturn perf_config_from_file(fn, config_exclusive_filename, data);\n\tif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\n\t\tret += perf_config_from_file(fn, perf_etc_perfconfig(),\n\t\t\t\t\t    data);\n\t\tfound += 1;\n\t}\n\n\thome = getenv(\"HOME\");\n\tif (perf_config_global() && home) {\n\t\tchar *user_config = strdup(mkpath(\"%s/.perfconfig\", home));\n\t\tif (!access(user_config, R_OK)) {\n\t\t\tret += perf_config_from_file(fn, user_config, data);\n\t\t\tfound += 1;\n\t\t}\n\t\tfree(user_config);\n\t}\n\n\trepo_config = perf_pathdup(\"config\");\n\tif (!access(repo_config, R_OK)) {\n\t\tret += perf_config_from_file(fn, repo_config, data);\n\t\tfound += 1;\n\t}\n\tfree(repo_config);\n\tif (found == 0)\n\t\treturn -1;\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int virtio_scsi_vring_init(VirtIOSCSI *s, VirtQueue *vq, int n)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    int rc;\n\n\n\n    /* Set up virtqueue notify */\n\n    rc = k->set_host_notifier(qbus->parent, n, true);\n\n    if (rc != 0) {\n\n        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\",\n\n                rc);\n\n        s->dataplane_fenced = true;\n\n        return rc;\n\n    }\n\n\n\n    virtio_queue_aio_set_host_notifier_handler(vq, s->ctx, true, true);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void tcp_ecn_openreq_child(struct tcp_sock *tp,\n\t\t\t\t  const struct request_sock *req)\n{\n\ttp->ecn_flags = inet_rsk(req)->ecn_ok ? TCP_ECN_OK : 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static ssize_t print_cpu_modalias(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tssize_t n;\n\tu32 i;\n\n\tn = sprintf(buf, \"cpu:type:\" CPU_FEATURE_TYPEFMT \":feature:\",\n\t\t    CPU_FEATURE_TYPEVAL);\n\n\tfor (i = 0; i < MAX_CPU_FEATURES; i++)\n\t\tif (cpu_have_feature(i)) {\n\t\t\tif (PAGE_SIZE < n + sizeof(\",XXXX\\n\")) {\n\t\t\t\tWARN(1, \"CPU features overflow page\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn += sprintf(&buf[n], \",%04X\", i);\n\t\t}\n\tbuf[n++] = '\\n';\n\treturn n;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int tcp_sendpage(struct sock *sk, struct page *page, int offset,\n\t\t size_t size, int flags)\n{\n\tssize_t res;\n\n\tif (!(sk->sk_route_caps & NETIF_F_SG) ||\n\t    !sk_check_csum_caps(sk))\n\t\treturn sock_no_sendpage(sk->sk_socket, page, offset, size,\n\t\t\t\t\tflags);\n\n\tlock_sock(sk);\n\n\ttcp_rate_check_app_limited(sk);  /* is sending application-limited? */\n\n\tres = do_tcp_sendpages(sk, page, offset, size, flags);\n\trelease_sock(sk);\n\treturn res;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n     case blink::WebBackForwardCommit:\n       if (!provisional_entry_)\n         return;\n      current_entry_.reset(provisional_entry_.release());\n       if (HistoryEntry::HistoryNode* node =\n               current_entry_->GetHistoryNodeForFrame(frame)) {\n         node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p, 0, min_size + AV_INPUT_BUFFER_PADDING_SIZE);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t}\n\treturn GF_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong datalen;\n\n\tdatalen = parse_iv2((*p) + 2, p);\n\n\t(*p) += 2;\n\n\tif (datalen < 0 || (*p) + datalen >= max) {\n\t\tzend_error(E_WARNING, \"Insufficient data for unserializing - %ld required, %ld present\", datalen, (long)(max - (*p)));\n\t\treturn 0;\n\t}\n\n\tif (ce->unserialize == NULL) {\n\t\tzend_error(E_WARNING, \"Class %s has no unserializer\", ce->name);\n\t\tobject_init_ex(*rval, ce);\n\t} else if (ce->unserialize(rval, ce, (const unsigned char*)*p, datalen, (zend_unserialize_data *)var_hash TSRMLS_CC) != SUCCESS) {\n\t\treturn 0;\n\t}\n\n\t(*p) += datalen;\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void utab_unlock(int fd)\n{\n\tif (fd >= 0) {\n\t\tDBG(UPDATE, mnt_debug(\"unlocking utab\"));\n\t\tclose(fd);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int XMLRPC_AddValueToVector(XMLRPC_VALUE target, XMLRPC_VALUE source) {\n   if(target && source) {\n      if(target->type == xmlrpc_vector && target->v && \n         target->v->q && target->v->type != xmlrpc_vector_none) {\n\n         /* guard against putting value of unknown type into vector */\n         switch(source->type) {\n            case xmlrpc_empty:\n            case xmlrpc_base64:\n            case xmlrpc_boolean:\n            case xmlrpc_datetime:\n            case xmlrpc_double:\n            case xmlrpc_int:\n            case xmlrpc_string:\n            case xmlrpc_vector:\n               /* Guard against putting a key/val pair into an array vector */\n               if( !(source->id.len && target->v->type == xmlrpc_vector_array) ) {\n\t\t\t\t\tif (isDuplicateEntry (target, source)\n\t\t\t\t\t\t || Q_PushTail (target->v->q, XMLRPC_CopyValue (source))) {\n                     return 1;\n                  }\n               }\n               else {\n\t\t\t\t\tfprintf (stderr,\n\t\t\t\t\t\t\t\t\"xmlrpc: attempted to add key/val pair to vector of type array\\n\");\n               }\n               break;\n            default:\n\t\t\t\tfprintf (stderr,\n\t\t\t\t\t\t\t\"xmlrpc: attempted to add value of unknown type to vector\\n\");\n               break;\n         }\n      }\n   }\n   return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "passIsComma ()\n{\n  pass_Codes passCode = passGetScriptToken ();\n  if (passCode != pass_comma)\n    {\n      compileError (passNested, \"',' expected\");\n      return 0;\n    }\n  return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "ChangeListLoader::ChangeListLoader(\n    base::SequencedTaskRunner* blocking_task_runner,\n    ResourceMetadata* resource_metadata,\n    JobScheduler* scheduler,\n    DriveServiceInterface* drive_service)\n    : blocking_task_runner_(blocking_task_runner),\n      resource_metadata_(resource_metadata),\n      scheduler_(scheduler),\n      drive_service_(drive_service),\n      loaded_(false),\n      weak_ptr_factory_(this) {\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void erase_entry(struct ctl_table_header *head, struct ctl_table *entry)\n{\n\tstruct rb_node *node = &head->node[entry - head->ctl_table].node;\n\n\trb_erase(node, &head->parent->root);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void RenderView::LogNavigationState(const NavigationState* state,\n                                    const WebDataSource* ds) const {\n  if (logging::LOG_INFO < logging::GetMinLogLevel())\n    return;\n\n  DCHECK(state);\n  DCHECK(ds);\n  GURL url(ds->request().url());\n  Time start = state->start_load_time();\n  Time finish = state->finish_load_time();\n  LOG(INFO) << \"PLT: \"\n            << (finish - start).InMilliseconds()\n            << \"ms \"\n            << url.spec();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int ram_save_target_page(MigrationState *ms, QEMUFile *f,\n\n                                RAMBlock *block, ram_addr_t offset,\n\n                                bool last_stage,\n\n                                uint64_t *bytes_transferred,\n\n                                ram_addr_t dirty_ram_abs)\n\n{\n\n    int res = 0;\n\n\n\n    /* Check the pages is dirty and if it is send it */\n\n    if (migration_bitmap_clear_dirty(dirty_ram_abs)) {\n\n        unsigned long *unsentmap;\n\n        if (compression_switch && migrate_use_compression()) {\n\n            res = ram_save_compressed_page(f, block, offset,\n\n                                           last_stage,\n\n                                           bytes_transferred);\n\n        } else {\n\n            res = ram_save_page(f, block, offset, last_stage,\n\n                                bytes_transferred);\n\n        }\n\n\n\n        if (res < 0) {\n\n            return res;\n\n        }\n\n        unsentmap = atomic_rcu_read(&migration_bitmap_rcu)->unsentmap;\n\n        if (unsentmap) {\n\n            clear_bit(dirty_ram_abs >> TARGET_PAGE_BITS, unsentmap);\n\n        }\n\n        last_sent_block = block;\n\n    }\n\n\n\n    return res;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int ocfs2_expand_nonsparse_inode(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *di_bh,\n\t\t\t\t\tloff_t pos, unsigned len,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc)\n{\n\tint ret;\n\tloff_t newsize = pos + len;\n\n\tBUG_ON(ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)));\n\n\tif (newsize <= i_size_read(inode))\n\t\treturn 0;\n\n\tret = ocfs2_extend_no_holes(inode, di_bh, newsize, pos);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\twc->w_first_new_cpos =\n\t\tocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode));\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static struct sock *nr_find_peer(unsigned char index, unsigned char id,\n\tax25_address *dest)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&nr_list_lock);\n\tsk_for_each(s, &nr_list) {\n\t\tstruct nr_sock *nr = nr_sk(s);\n\n\t\tif (nr->your_index == index && nr->your_id == id &&\n\t\t    !ax25cmp(&nr->dest_addr, dest)) {\n\t\t\tbh_lock_sock(s);\n\t\t\tgoto found;\n\t\t}\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&nr_list_lock);\n\treturn s;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "private int\ncvt_double(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(d, (double));",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool NodeIsOnCpuOrGpu(const NodeDef* node) const {\n    using absl::StrContains;\n\n    string task;\n    string device;\n\n    return DeviceNameUtils::SplitDeviceName(node->device(), &task, &device) &&\n           (StrContains(device, DEVICE_CPU) || StrContains(device, DEVICE_GPU));\n  }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int ff_v4l2_m2m_codec_init(AVCodecContext *avctx)\n\n{\n\n    int ret = AVERROR(EINVAL);\n\n    struct dirent *entry;\n\n    char node[PATH_MAX];\n\n    DIR *dirp;\n\n\n\n    V4L2m2mContext *s = avctx->priv_data;\n\n    s->avctx = avctx;\n\n\n\n    dirp = opendir(\"/dev\");\n\n    if (!dirp)\n\n        return AVERROR(errno);\n\n\n\n    for (entry = readdir(dirp); entry; entry = readdir(dirp)) {\n\n\n\n        if (strncmp(entry->d_name, \"video\", 5))\n\n            continue;\n\n\n\n        snprintf(node, sizeof(node), \"/dev/%s\", entry->d_name);\n\n        av_log(s->avctx, AV_LOG_DEBUG, \"probing device %s\\n\", node);\n\n        strncpy(s->devname, node, strlen(node) + 1);\n\n        ret = v4l2_probe_driver(s);\n\n        if (!ret)\n\n                break;\n\n    }\n\n\n\n    closedir(dirp);\n\n\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Could not find a valid device\\n\");\n\n        memset(s->devname, 0, sizeof(s->devname));\n\n\n\n        return ret;\n\n    }\n\n\n\n    av_log(s->avctx, AV_LOG_INFO, \"Using device %s\\n\", node);\n\n\n\n    return v4l2_configure_contexts(s);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int __init ibwdt_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO PFX\n\t\t\"WDT driver for IB700 single board computer initialising.\\n\");\n\n\terr = platform_driver_register(&ibwdt_driver);\n\tif (err)\n\t\treturn err;\n\n\tibwdt_platform_device = platform_device_register_simple(DRV_NAME,\n\t\t\t\t\t\t\t\t-1, NULL, 0);\n\tif (IS_ERR(ibwdt_platform_device)) {\n\t\terr = PTR_ERR(ibwdt_platform_device);\n\t\tgoto unreg_platform_driver;\n\t}\n\n\treturn 0;\n\nunreg_platform_driver:\n\tplatform_driver_unregister(&ibwdt_driver);\n\treturn err;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void xfrm_state_fini(struct net *net)\n{\n\tunsigned int sz;\n\n\tflush_work(&net->xfrm.state_hash_work);\n\tflush_work(&xfrm_state_gc_work);\n\txfrm_state_flush(net, IPSEC_PROTO_ANY, false, true);\n\n\tWARN_ON(!list_empty(&net->xfrm.state_all));\n\n\tsz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head);\n\tWARN_ON(!hlist_empty(net->xfrm.state_byspi));\n\txfrm_hash_free(net->xfrm.state_byspi, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_bysrc));\n\txfrm_hash_free(net->xfrm.state_bysrc, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_bydst));\n\txfrm_hash_free(net->xfrm.state_bydst, sz);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "xps_insert_font(xps_document *doc, char *name, fz_font *font)\n{\n\txps_font_cache *cache = fz_malloc_struct(doc->ctx, xps_font_cache);\n\tcache->name = fz_strdup(doc->ctx, name);\n\tcache->font = fz_keep_font(doc->ctx, font);\n\tcache->next = doc->font_table;\n\tdoc->font_table = cache;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "rend_max_intro_circs_per_period(unsigned int n_intro_points_wanted)\n{\n  /* Allow all but one of the initial connections to fail and be\n   * retried. (If all fail, we *want* to wait, because something is broken.) */\n  tor_assert(n_intro_points_wanted <= NUM_INTRO_POINTS_MAX);\n  return (int)(2*n_intro_points_wanted + NUM_INTRO_POINTS_EXTRA);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int ssh_scp_integer_mode(const char *mode){\n\tint value=strtoul(mode,NULL,8) & 0xffff;\n\treturn value;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void virtio_queue_set_notification(VirtQueue *vq, int enable)\n\n{\n\n    vq->notification = enable;\n\n    if (vq->vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\n        vring_avail_event(vq, vring_avail_idx(vq));\n\n    } else if (enable) {\n\n        vring_used_flags_unset_bit(vq, VRING_USED_F_NO_NOTIFY);\n\n    } else {\n\n        vring_used_flags_set_bit(vq, VRING_USED_F_NO_NOTIFY);\n\n\n\n\n\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int _nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_readlink args = {\n\t\t.fh       = NFS_FH(inode),\n\t\t.pgbase\t  = pgbase,\n\t\t.pglen    = pglen,\n\t\t.pages    = &page,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READLINK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = NULL,\n\t};\n\n\treturn rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = s;\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(s);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "MagickExport MagickBooleanType RegisterStaticModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent];\n\n  PolicyRights\n    rights;\n\n  const CoderInfo\n    *p;\n\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  /*\n    Assign module name from alias.\n  */\n  assert(module != (const char *) NULL);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=ReadPolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module_name) == 0)\n      {\n        if (MagickModules[i].registered == MagickFalse)\n          {\n            (void) (MagickModules[i].register_module)();\n            MagickModules[i].registered=MagickTrue;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int av_asrc_buffer_add_buffer(AVFilterContext *ctx,\n\n                              uint8_t *buf, int buf_size, int sample_rate,\n\n                              int sample_fmt, int64_t channel_layout, int planar,\n\n                              int64_t pts, int av_unused flags)\n\n{\n\n    uint8_t *data[8];\n\n    int linesize[8];\n\n    int nb_channels = av_get_channel_layout_nb_channels(channel_layout),\n\n        nb_samples  = buf_size / nb_channels / av_get_bytes_per_sample(sample_fmt);\n\n\n\n    av_samples_fill_arrays(data, linesize,\n\n                           buf, nb_channels, nb_samples,\n\n                           sample_fmt, 16);\n\n\n\n    return av_asrc_buffer_add_samples(ctx,\n\n                                      data, linesize, nb_samples,\n\n                                      sample_rate,\n\n                                      sample_fmt, channel_layout, planar,\n\n                                      pts, flags);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void fanout_release(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f;\n\n\tf = po->fanout;\n\tif (!f)\n\t\treturn;\n\n\tmutex_lock(&fanout_mutex);\n\tpo->fanout = NULL;\n\n\tif (atomic_dec_and_test(&f->sk_ref)) {\n\t\tlist_del(&f->list);\n\t\tdev_remove_pack(&f->prot_hook);\n\t\tfanout_release_data(f);\n\t\tkfree(f);\n\t}\n\tmutex_unlock(&fanout_mutex);\n\n\tif (po->rollover)\n\t\tkfree_rcu(po->rollover, rcu);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void acct_clear_integrals(struct task_struct *tsk)\n{\n\ttsk->acct_stimexpd = 0;\n\ttsk->acct_rss_mem1 = 0;\n\ttsk->acct_vm_mem1 = 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void senc_box_del(GF_Box *s)\n{\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *)s;\n\twhile (gf_list_count(ptr->samp_aux_info)) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, 0);\n\t\tif (sai) gf_isom_cenc_samp_aux_info_del(sai);\n\t\tgf_list_rem(ptr->samp_aux_info, 0);\n\t}\n\tif (ptr->samp_aux_info) gf_list_del(ptr->samp_aux_info);\n\tgf_free(s);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "PrioritizedChoice(const std::vector<std::shared_ptr<Ope>> &opes)\n      : opes_(opes) {}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static always_inline void gen_op_subfeo (void)\n\n{\n\n    gen_op_move_T2_T0();\n\n    gen_op_subfe();\n\n    gen_op_check_subfo();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void gray_to_rgb(fz_context *ctx, const fz_colorspace *cs, const float *gray, float *rgb)\n{\n\trgb[0] = gray[0];\n\trgb[1] = gray[0];\n\trgb[2] = gray[0];\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int *load_mixer_volumes(char *name, int *levels, int present)\n{\n\tint             i, n;\n\n\tfor (i = 0; i < num_mixer_volumes; i++) {\n\t\tif (strcmp(name, mixer_vols[i].name) == 0) {\n\t\t\tif (present)\n\t\t\t\tmixer_vols[i].num = i;\n\t\t\treturn mixer_vols[i].levels;\n\t\t}\n\t}\n\tif (num_mixer_volumes >= MAX_MIXER_DEV) {\n\t\tprintk(KERN_ERR \"Sound: Too many mixers (%s)\\n\", name);\n\t\treturn levels;\n\t}\n\tn = num_mixer_volumes++;\n\n\tstrcpy(mixer_vols[n].name, name);\n\n\tif (present)\n\t\tmixer_vols[n].num = n;\n\telse\n\t\tmixer_vols[n].num = -1;\n\n\tfor (i = 0; i < 32; i++)\n\t\tmixer_vols[n].levels[i] = levels[i];\n\treturn mixer_vols[n].levels;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int snd_usb_mixer_add_control(struct usb_mixer_elem_list *list,\n\t\t\t      struct snd_kcontrol *kctl)\n{\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\tint err;\n\n\twhile (snd_ctl_find_id(mixer->chip->card, &kctl->id))\n\t\tkctl->id.index++;\n\terr = snd_ctl_add(mixer->chip->card, kctl);\n\tif (err < 0) {\n\t\tusb_audio_dbg(mixer->chip, \"cannot add control (err = %d)\\n\",\n\t\t\t      err);\n\t\treturn err;\n\t}\n\tlist->kctl = kctl;\n\tlist->next_id_elem = mixer->id_elems[list->id];\n\tmixer->id_elems[list->id] = list;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int oma_read_seek(struct AVFormatContext *s,\n\n                         int stream_index, int64_t timestamp, int flags)\n\n{\n\n    OMAContext *oc = s->priv_data;\n\n    int err = ff_pcm_read_seek(s, stream_index, timestamp, flags);\n\n\n\n    if (!oc->encrypted)\n\n        return err;\n\n\n\n    /* readjust IV for CBC */\n\n    if (err || avio_tell(s->pb) < oc->content_start)\n\n        goto wipe;\n\n    if ((err = avio_seek(s->pb, -8, SEEK_CUR)) < 0)\n\n        goto wipe;\n\n    if ((err = avio_read(s->pb, oc->iv, 8)) < 8) {\n\n        if (err >= 0)\n\n            err = AVERROR_EOF;\n\n        goto wipe;\n\n    }\n\n\n\n    return 0;\n\nwipe:\n\n    memset(oc->iv, 0, 8);\n\n    return err;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "virtual int lock() { return 1; } /* success */",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tsize_t olen;\n\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "evdev_log_msg(struct evdev_device *device,\n\t      enum libinput_log_priority priority,\n\t      const char *format,\n\t      ...)\n{\n\tva_list args;\n\tchar buf[1024];\n\n\tif (!is_logged(evdev_libinput_context(device), priority))\n\t\treturn;\n\n\t/* Anything info and above is user-visible, use the device name */\n\tsnprintf(buf,\n\t\t sizeof(buf),\n\t\t \"%-7s - %s%s%s\",\n\t\t evdev_device_get_sysname(device),\n\t\t (priority > LIBINPUT_LOG_PRIORITY_DEBUG) ?  device->devname : \"\",\n\t\t (priority > LIBINPUT_LOG_PRIORITY_DEBUG) ?  \": \" : \"\",\n\t\t format);\n\n\tva_start(args, format);\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n\tlog_msg_va(evdev_libinput_context(device), priority, buf, args);\n#pragma GCC diagnostic pop\n\tva_end(args);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int hns_roce_setup_mtu_mac(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tu8 i;\n\n\tfor (i = 0; i < hr_dev->caps.num_ports; i++) {\n\t\tif (hr_dev->hw->set_mtu)\n\t\t\thr_dev->hw->set_mtu(hr_dev, hr_dev->iboe.phy_port[i],\n\t\t\t\t\t    hr_dev->caps.max_mtu);\n\t\tret = hns_roce_set_mac(hr_dev, i,\n\t\t\t\t       hr_dev->iboe.netdevs[i]->dev_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "JBIG2Bitmap::JBIG2Bitmap(Guint segNumA, int wA, int hA):\n  JBIG2Segment(segNumA)\n{\n  w = wA;\n  h = hA;\n  line = (wA + 7) >> 3;\n\n  if (w <= 0 || h <= 0 || line <= 0 || h >= (INT_MAX - 1) / line) {\n    error(-1, \"invalid width/height\");\n    data = NULL;\n     return;\n   }\n  data = (Guchar *)gmallocn(h, line + 1);\n   data[h * line] = 0;\n }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "cert_hostcheck(const char *match_pattern, const char *hostname)\n{\n  if(!match_pattern || !*match_pattern ||\n      !hostname || !*hostname) /* sanity check */\n    return 0;\n\n  if(Curl_raw_equal(hostname, match_pattern)) /* trivial case */\n    return 1;\n\n  if(hostmatch(hostname,match_pattern) == HOST_MATCH)\n    return 1;\n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int rtw_wx_get_rate(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tu16 max_rate = 0;\n\n\tmax_rate = rtw_get_cur_max_rate(rtw_netdev_priv(dev));\n\n\tif (max_rate == 0)\n\t\treturn -EPERM;\n\n\twrqu->bitrate.fixed = 0;\t/* no auto select */\n\twrqu->bitrate.value = max_rate * 100000;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "compute_U_value_R3(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.5 from the PDF 1.7 Reference Manual\n\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    MD5 md5;\n    md5.encodeDataIncrementally(\n\tpad_or_truncate_password_V4(\"\").c_str(), key_bytes);\n    md5.encodeDataIncrementally(data.getId1().c_str(),\n                                data.getId1().length());\n    MD5::Digest digest;\n    md5.digest(digest);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(digest, sizeof(MD5::Digest),\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 20, false);\n    char result[key_bytes];\n    memcpy(result, digest, sizeof(MD5::Digest));\n    // pad with arbitrary data -- make it consistent for the sake of\n    // testing\n    for (unsigned int i = sizeof(MD5::Digest); i < key_bytes; ++i)\n    {\n\tresult[i] = static_cast<char>((i * i) % 0xff);\n    }\n    return std::string(result, key_bytes);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void _rtl_rx_pre_process(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct sk_buff *_skb;\n\tstruct sk_buff_head rx_queue;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tskb_queue_head_init(&rx_queue);\n\tif (rtlusb->usb_rx_segregate_hdl)\n\t\trtlusb->usb_rx_segregate_hdl(hw, skb, &rx_queue);\n\tWARN_ON(skb_queue_empty(&rx_queue));\n\twhile (!skb_queue_empty(&rx_queue)) {\n\t\t_skb = skb_dequeue(&rx_queue);\n\t\t_rtl_usb_rx_process_agg(hw, _skb);\n\t\tieee80211_rx(hw, _skb);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int nbd_client_co_preadv(BlockDriverState *bs, uint64_t offset,\n\n                         uint64_t bytes, QEMUIOVector *qiov, int flags)\n\n{\n\n    NBDRequest request = {\n\n        .type = NBD_CMD_READ,\n\n        .from = offset,\n\n        .len = bytes,\n\n    };\n\n\n\n    assert(bytes <= NBD_MAX_BUFFER_SIZE);\n\n    assert(!flags);\n\n\n\n    return nbd_co_request(bs, &request, qiov);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static mainfunc_t subcmd_get(const char *cmd, const struct subcommand *cb)\n{\n\tfor (; cb->name != NULL; ++cb)\n\t\tif (strcmp(cb->name, cmd) == 0)\n\t\t\treturn cb->main;\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "PHP_FUNCTION(mb_eregi)\n{\n\t_php_mb_regex_ereg_exec(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void ctr_crypt_final(struct blkcipher_desc *desc,\n\t\t\t    struct blkcipher_walk *walk)\n{\n\tstruct cast5_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\n\tu8 *ctrblk = walk->iv;\n\tu8 keystream[CAST5_BLOCK_SIZE];\n\tu8 *src = walk->src.virt.addr;\n\tu8 *dst = walk->dst.virt.addr;\n\tunsigned int nbytes = walk->nbytes;\n\n\t__cast5_encrypt(ctx, keystream, ctrblk);\n\tcrypto_xor(keystream, src, nbytes);\n\tmemcpy(dst, keystream, nbytes);\n\n\tcrypto_inc(ctrblk, CAST5_BLOCK_SIZE);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void NumberFormatTest::expect2(NumberFormat* fmt, const Formattable& n,\n                               const UnicodeString& exp,\n                               UErrorCode status) {\n    if (fmt == NULL || U_FAILURE(status)) {\n        dataerrln(\"FAIL: NumberFormat constructor\");\n    } else {\n        expect2(*fmt, n, exp);\n    }\n    delete fmt;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void *stbi__malloc(size_t size)\n{\n    return STBI_MALLOC(size);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static const char * r_cmd_java_consumetok (const char *str1, const char b, size_t len) {\n\tconst char *p = str1;\n\tsize_t i = 0;\n\tif (!p) {\n\t\treturn p;\n\t}\n\tif (len == -1) {\n\t\tlen = strlen (str1);\n\t}\n\tfor ( ; i < len; i++,p++) {\n\t\tif (*p != b) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int ip_ra_control(struct sock *sk, unsigned char on,\n\t\t  void (*destructor)(struct sock *))\n{\n\tstruct ip_ra_chain *ra, *new_ra;\n\tstruct ip_ra_chain __rcu **rap;\n\tstruct net *net = sock_net(sk);\n\n\tif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\treturn -EINVAL;\n\n\tnew_ra = on ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n\n\tmutex_lock(&net->ipv4.ra_mutex);\n\tfor (rap = &net->ipv4.ra_chain;\n\t     (ra = rcu_dereference_protected(*rap,\n\t\t\tlockdep_is_held(&net->ipv4.ra_mutex))) != NULL;\n\t     rap = &ra->next) {\n\t\tif (ra->sk == sk) {\n\t\t\tif (on) {\n\t\t\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\t\t\tkfree(new_ra);\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\t\t\t/* dont let ip_call_ra_chain() use sk again */\n\t\t\tra->sk = NULL;\n\t\t\tRCU_INIT_POINTER(*rap, ra->next);\n\t\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\n\t\t\tif (ra->destructor)\n\t\t\t\tra->destructor(sk);\n\t\t\t/*\n\t\t\t * Delay sock_put(sk) and kfree(ra) after one rcu grace\n\t\t\t * period. This guarantee ip_call_ra_chain() dont need\n\t\t\t * to mess with socket refcounts.\n\t\t\t */\n\t\t\tra->saved_sk = sk;\n\t\t\tcall_rcu(&ra->rcu, ip_ra_destroy_rcu);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!new_ra) {\n\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\treturn -ENOBUFS;\n\t}\n\tnew_ra->sk = sk;\n\tnew_ra->destructor = destructor;\n\n\tRCU_INIT_POINTER(new_ra->next, ra);\n\trcu_assign_pointer(*rap, new_ra);\n\tsock_hold(sk);\n\tmutex_unlock(&net->ipv4.ra_mutex);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "QDict *qdict_get_qdict(const QDict *qdict, const char *key)\n\n{\n\n    return qobject_to_qdict(qdict_get_obj(qdict, key, QTYPE_QDICT));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void l2cap_do_start(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tif (conn->hcon->type == LE_LINK) {\n\t\tl2cap_le_start(chan);\n\t\treturn;\n\t}\n\n\tif (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)) {\n\t\tl2cap_request_info(conn);\n\t\treturn;\n\t}\n\n\tif (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))\n\t\treturn;\n\n\tif (l2cap_chan_check_security(chan, true) &&\n\t    __l2cap_no_conn_pending(chan))\n\t\tl2cap_start_connection(chan);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len)) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)\n\n{\n\n    int size, l;\n\n\n\n    if (f->is_write) {\n\n        abort();\n\n    }\n\n\n\n    size = size1;\n\n    while (size > 0) {\n\n        l = f->buf_size - f->buf_index;\n\n        if (l == 0) {\n\n            qemu_fill_buffer(f);\n\n            l = f->buf_size - f->buf_index;\n\n            if (l == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (l > size) {\n\n            l = size;\n\n        }\n\n        memcpy(buf, f->buf + f->buf_index, l);\n\n        f->buf_index += l;\n\n        buf += l;\n\n        size -= l;\n\n    }\n\n    return size1 - size;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "validGlxScreen(ClientPtr client, int screen, __GLXscreen **pGlxScreen, int *err)\n{\n     /*\n     ** Check if screen exists.\n     */\n    if (screen >= screenInfo.numScreens) {\n \tclient->errorValue = screen;\n \t*err = BadValue;\n \treturn FALSE;\n    }\n    *pGlxScreen = glxGetScreen(screenInfo.screens[screen]);\n\n    return TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void Document::elementDataCacheClearTimerFired(Timer<Document>*)\n{\n    m_elementDataCache.clear();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "png_create_info_struct(png_structp png_ptr)\n{\n   png_infop info_ptr;\n\n   png_debug(1, \"in png_create_info_struct\");\n\n   if (png_ptr == NULL)\n      return (NULL);\n\n#ifdef PNG_USER_MEM_SUPPORTED\n   info_ptr = (png_infop)png_create_struct_2(PNG_STRUCT_INFO,\n      png_ptr->malloc_fn, png_ptr->mem_ptr);\n#else\n   info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);\n#endif\n   if (info_ptr != NULL)\n      png_info_init_3(&info_ptr, png_sizeof(png_info));\n\n   return (info_ptr);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void _xml_endNamespaceDeclHandler(void *userData, const XML_Char *prefix)\n{\n\txml_parser *parser = (xml_parser *)userData;\n\n\tif (parser && !Z_ISUNDEF(parser->endNamespaceDeclHandler)) {\n\t\tzval retval, args[2];\n\n\t\tZVAL_COPY(&args[0], &parser->index);\n\t\t_xml_xmlchar_zval(prefix, 0, parser->target_encoding, &args[1]);\n\t\txml_call_handler(parser, &parser->endNamespaceDeclHandler, parser->endNamespaceDeclPtr, 2, args, &retval);\n\t\tzval_ptr_dtor(&retval);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "SPR_AddToGroup(struct rx_call *call, afs_int32 aid, afs_int32 gid)\n{\n    afs_int32 code;\n    afs_int32 cid = ANONYMOUSID;\n\n    code = addToGroup(call, aid, gid, &cid);\n    osi_auditU(call, PTS_AdToGrpEvent, code, AUD_ID, gid, AUD_ID, aid,\n\t       AUD_END);\n    ViceLog(5, (\"PTS_AddToGroup: code %d cid %d gid %d aid %d\\n\", code, cid, gid, aid));\n    return code;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "rsvg_new_group (void)\n{\n    RsvgNodeGroup *group;\n    group = g_new (RsvgNodeGroup, 1);\n    _rsvg_node_init (&group->super);\n    group->super.draw = _rsvg_node_draw_children;\n    group->super.set_atts = rsvg_node_group_set_atts;\n    return &group->super;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n\n    // Create copy for insertion into Staging Area\n    Tensor key(*key_tensor);\n\n    // Create the tuple to store\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n\n    // Store the tuple in the map\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void qobject_input_type_uint64(Visitor *v, const char *name,\n\n                                      uint64_t *obj, Error **errp)\n\n{\n\n    /* FIXME: qobject_to_qint mishandles values over INT64_MAX */\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    QInt *qint;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qint = qobject_to_qint(qobj);\n\n    if (!qint) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"integer\");\n\n        return;\n\n    }\n\n\n\n    *obj = qint_get_int(qint);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "equal_h (const struct ecc_modulo *p,\n\t const mp_limb_t *x1, const mp_limb_t *z1,\n\t const mp_limb_t *x2, const mp_limb_t *z2,\n\t mp_limb_t *scratch)\n{\n#define t0 scratch\n#define t1 (scratch + p->size)\n\n  ecc_mod_mul (p, t0, x1, z2, t0);\n  if (mpn_cmp (t0, p->m, p->size) >= 0)\n    mpn_sub_n (t0, t0, p->m, p->size);\n\n  ecc_mod_mul (p, t1, x2, z1, t1);\n  if (mpn_cmp (t1, p->m, p->size) >= 0)\n    mpn_sub_n (t1, t1, p->m, p->size);\n\n  return mpn_cmp (t0, t1, p->size) == 0;\n\n#undef t0\n#undef t1\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void rawmidi_release_priv(struct snd_rawmidi_file *rfile)\n{\n\tstruct snd_rawmidi *rmidi;\n\n\trmidi = rfile->rmidi;\n\tmutex_lock(&rmidi->open_mutex);\n\tif (rfile->input) {\n\t\tclose_substream(rmidi, rfile->input, 1);\n\t\trfile->input = NULL;\n\t}\n\tif (rfile->output) {\n\t\tclose_substream(rmidi, rfile->output, 1);\n\t\trfile->output = NULL;\n\t}\n\trfile->rmidi = NULL;\n\tmutex_unlock(&rmidi->open_mutex);\n\twake_up(&rmidi->open_wait);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Hybrid_type_traits_decimal::add(Hybrid_type *val, Field *f) const\n{\n  my_decimal_add(E_DEC_FATAL_ERROR,\n                 &val->dec_buf[val->used_dec_buf_no ^ 1],\n                 &val->dec_buf[val->used_dec_buf_no],\n                 f->val_decimal(&val->dec_buf[2]));\n  val->used_dec_buf_no^= 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int manager_watch_idle_pipe(Manager *m) {\n        int r;\n\n        assert(m);\n\n        if (m->idle_pipe_event_source)\n                return 0;\n\n        if (m->idle_pipe[2] < 0)\n                return 0;\n\n        r = sd_event_add_io(m->event, &m->idle_pipe_event_source, m->idle_pipe[2], EPOLLIN, manager_dispatch_idle_pipe_fd, m);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to watch idle pipe: %m\");\n\n        return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void fpm_scoreboard_child_use(struct fpm_scoreboard_s *scoreboard, int child_index, pid_t pid) /* {{{ */\n{\n\tstruct fpm_scoreboard_proc_s *proc;\n\tfpm_scoreboard = scoreboard;\n\tfpm_scoreboard_i = child_index;\n\tproc = fpm_scoreboard_proc_get(scoreboard, child_index);\n\tif (!proc) {\n\t\treturn;\n\t}\n\tproc->pid = pid;\n\tproc->start_epoch = time(NULL);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void scrub_recheck_block_checksum(struct scrub_block *sblock)\n{\n\tsblock->header_error = 0;\n\tsblock->checksum_error = 0;\n\tsblock->generation_error = 0;\n\n\tif (sblock->pagev[0]->flags & BTRFS_EXTENT_FLAG_DATA)\n\t\tscrub_checksum_data(sblock);\n\telse\n\t\tscrub_checksum_tree_block(sblock);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void rxe_mem_init(int access, struct rxe_mem *mem)\n{\n\tu32 lkey = mem->pelem.index << 8 | rxe_get_key();\n\tu32 rkey = (access & IB_ACCESS_REMOTE) ? lkey : 0;\n\n\tif (mem->pelem.pool->type == RXE_TYPE_MR) {\n\t\tmem->ibmr.lkey\t\t= lkey;\n\t\tmem->ibmr.rkey\t\t= rkey;\n\t}\n\n\tmem->lkey\t\t= lkey;\n\tmem->rkey\t\t= rkey;\n\tmem->state\t\t= RXE_MEM_STATE_INVALID;\n\tmem->type\t\t= RXE_MEM_TYPE_NONE;\n\tmem->map_shift\t\t= ilog2(RXE_BUF_PER_MAP);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    /* a text value can't be change if the file is not loaded */\n    /* returns NULL if the name is not found; otherwise nonzero */\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n\n//FIXME: else: what to do with still-unsaved data in the widget??\n        dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data(/* don't update selected event */ 0);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int nfs4_lookup_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\treturn __nfs_lookup_revalidate(dentry, flags,\n\t\t\tnfs4_do_lookup_revalidate);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void uninit(struct vf_instance *vf)\n\n{\n\n        free(vf->priv);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "SPL_METHOD(MultipleIterator, current)\n{\n\tspl_SplObjectStorage        *intern;\n\tintern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_multiple_iterator_get_all(intern, SPL_MULTIPLE_ITERATOR_GET_ALL_CURRENT, return_value TSRMLS_CC);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static struct audit_chunk *find_chunk(struct node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline int ip6_frags_sysctl_register(void)\n{\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static const char *check_secret(int module, const char *user, const char *group,\n\t\t\t\tconst char *challenge, const char *pass)\n{\n\tchar line[1024];\n        char pass2[MAX_DIGEST_LEN*2];\n        const char *fname = lp_secrets_file(module);\n        STRUCT_STAT st;\n       int fd, ok = 1;\n        int user_len = strlen(user);\n        int group_len = group ? strlen(group) : 0;\n        char *err;\n \n       if (!fname || !*fname || (fd = open(fname, O_RDONLY)) < 0)\n                return \"no secrets file\";\n \n       if (do_fstat(fd, &st) == -1) {\n                rsyserr(FLOG, errno, \"fstat(%s)\", fname);\n                ok = 0;\n        } else if (lp_strict_modes(module)) {\n\t\t\trprintf(FLOG, \"secrets file must not be other-accessible (see strict modes option)\\n\");\n\t\t\tok = 0;\n\t\t} else if (MY_UID() == 0 && st.st_uid != 0) {\n\t\t\trprintf(FLOG, \"secrets file must be owned by root when running as root (see strict modes)\\n\");\n\t\t\tok = 0;\n\t\t}\n                }",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t       struct kvm_io_device *dev)\n{\n\tint i;\n\tstruct kvm_io_bus *new_bus, *bus;\n\n\tbus = kvm_get_bus(kvm, bus_idx);\n\tif (!bus)\n\t\treturn;\n\n\tfor (i = 0; i < bus->dev_count; i++)\n\t\tif (bus->range[i].dev == dev) {\n\t\t\tbreak;\n\t\t}\n\n\tif (i == bus->dev_count)\n\t\treturn;\n\n\tnew_bus = kmalloc(struct_size(bus, range, bus->dev_count - 1),\n\t\t\t  GFP_KERNEL_ACCOUNT);\n\tif (!new_bus)  {\n\t\tpr_err(\"kvm: failed to shrink bus, removing it completely\\n\");\n\t\tgoto broken;\n\t}\n\n\tmemcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));\n\tnew_bus->dev_count--;\n\tmemcpy(new_bus->range + i, bus->range + i + 1,\n\t       (new_bus->dev_count - i) * sizeof(struct kvm_io_range));\n\nbroken:\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\tkfree(bus);\n\treturn;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int tecmp0 (const void *_a, const void *_b)\n{\n\tstruct tree_entry *a = *((struct tree_entry**)_a);\n\tstruct tree_entry *b = *((struct tree_entry**)_b);\n\treturn base_name_compare(\n\t\ta->name->str_dat, a->name->str_len, a->versions[0].mode,\n\t\tb->name->str_dat, b->name->str_len, b->versions[0].mode);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "brcmf_parse_tlvs(const void *buf, int buflen, uint key)\n{\n\tconst struct brcmf_tlv *elt = buf;\n\tint totlen = buflen;\n\n\t/* find tagged parameter */\n\twhile (totlen >= TLV_HDR_LEN) {\n\t\tint len = elt->len;\n\n\t\t/* validate remaining totlen */\n\t\tif ((elt->id == key) && (totlen >= (len + TLV_HDR_LEN)))\n\t\t\treturn elt;\n\n\t\telt = (struct brcmf_tlv *)((u8 *)elt + (len + TLV_HDR_LEN));\n\t\ttotlen -= (len + TLV_HDR_LEN);\n\t}\n\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "BPMDetect::BPMDetect(int numChannels, int aSampleRate) :\r\n    beat_lpf(_LPF_coeffs)\r\n{\r\n    beats.reserve(250); // initial reservation to prevent frequent reallocation\r\n\r\n    this->sampleRate = aSampleRate;\r\n    this->channels = numChannels;\r\n\r\n    decimateSum = 0;\r\n    decimateCount = 0;\r\n\r\n    // choose decimation factor so that result is approx. 1000 Hz\r\n    decimateBy = sampleRate / TARGET_SRATE;\r\n    assert(decimateBy > 0);\r\n    assert(INPUT_BLOCK_SIZE < decimateBy * DECIMATED_BLOCK_SIZE);\r\n\r\n    // Calculate window length & starting item according to desired min & max bpms\r\n    windowLen = (60 * sampleRate) / (decimateBy * MIN_BPM);\r\n    windowStart = (60 * sampleRate) / (decimateBy * MAX_BPM_RANGE);\r\n\r\n    assert(windowLen > windowStart);\r\n\r\n    // allocate new working objects\r\n    xcorr = new float[windowLen];\r\n    memset(xcorr, 0, windowLen * sizeof(float));\r\n\r\n    pos = 0;\r\n    peakPos = 0;\r\n    peakVal = 0;\r\n    init_scaler = 1;\r\n    beatcorr_ringbuffpos = 0;\r\n    beatcorr_ringbuff = new float[windowLen];\r\n    memset(beatcorr_ringbuff, 0, windowLen * sizeof(float));\r\n\r\n    // allocate processing buffer\r\n    buffer = new FIFOSampleBuffer();\r\n    // we do processing in mono mode\r\n    buffer->setChannels(1);\r\n    buffer->clear();\r\n\r\n    // calculate hamming windows\r\n    hamw = new float[XCORR_UPDATE_SEQUENCE];\r\n    hamming(hamw, XCORR_UPDATE_SEQUENCE);\r\n    hamw2 = new float[XCORR_UPDATE_SEQUENCE / 2];\r\n    hamming(hamw2, XCORR_UPDATE_SEQUENCE / 2);\r\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int opfnstenv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    level = strtoul(tokens[2].value, NULL, 10);\n    if (level == 0) {\n        settings.slab_automove = 0;\n    } else if (level == 1 || level == 2) {\n        settings.slab_automove = level;\n    } else {\n        out_string(c, \"ERROR\");\n        return;\n    }\n    out_string(c, \"OK\");\n    return;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void isis_notif_version_skew(const struct isis_circuit *circuit,\n\t\t\t     uint8_t version, const char *raw_pdu,\n\t\t\t     size_t raw_pdu_len)\n{\n\tconst char *xpath = \"/frr-isisd:version-skew\";\n\tstruct list *arguments = yang_data_list_new();\n\tchar xpath_arg[XPATH_MAXLEN];\n\tstruct yang_data *data;\n\tstruct isis_area *area = circuit->area;\n\n\tnotif_prep_instance_hdr(xpath, area, \"default\", arguments);\n\tnotif_prepr_iface_hdr(xpath, circuit, arguments);\n\tsnprintf(xpath_arg, sizeof(xpath_arg), \"%s/protocol-version\", xpath);\n\tdata = yang_data_new_uint8(xpath_arg, version);\n\tlistnode_add(arguments, data);\n\tsnprintf(xpath_arg, sizeof(xpath_arg), \"%s/raw-pdu\", xpath);\n\tdata = yang_data_new(xpath_arg, raw_pdu);\n\tlistnode_add(arguments, data);\n\n\thook_call(isis_hook_version_skew, circuit, version, raw_pdu,\n\t\t  raw_pdu_len);\n\n\tnb_notification_send(xpath, arguments);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline void out_reg(IVState *s, enum Reg reg, unsigned v)\n\n{\n\n    const char *name = reg2str(reg);\n\n    QTestState *qtest = global_qtest;\n\n\n\n    global_qtest = s->qtest;\n\n    g_test_message(\"%x -> *%s\\n\", v, name);\n\n    qpci_io_writel(s->dev, s->reg_base + reg, v);\n\n    global_qtest = qtest;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int my_kill(int pid, int sig)\n{\n#ifdef __WIN__\n  HANDLE proc;\n  if ((proc= OpenProcess(SYNCHRONIZE|PROCESS_TERMINATE, FALSE, pid)) == NULL)\n    return -1;\n  if (sig == 0)\n  {\n    DWORD wait_result= WaitForSingleObject(proc, 0);\n    CloseHandle(proc);\n    return wait_result == WAIT_OBJECT_0?-1:0;\n  }\n  (void)TerminateProcess(proc, 201);\n  CloseHandle(proc);\n  return 1;\n#else\n  return kill(pid, sig);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void PgfImage::writeMetadata()\n    {\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n\n        doWriteMetadata(*tempIo); // may throw\n        io_->close();\n        io_->transfer(*tempIo); // may throw\n\n    } // PgfImage::writeMetadata",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int rc4_hmac_md5_einit(void *ctx, const unsigned char *key,\n                              size_t keylen, const unsigned char *iv,\n                              size_t ivlen, const OSSL_PARAM params[])\n{\n    if (!ossl_cipher_generic_einit(ctx, key, keylen, iv, ivlen, NULL))\n        return 0;\n    return rc4_hmac_md5_set_ctx_params(ctx, params);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int guest_get_network_stats(const char *name,\n\n                       GuestNetworkInterfaceStat *stats)\n\n{\n\n    DWORD if_index = 0;\n\n    MIB_IFROW a_mid_ifrow;\n\n    memset(&a_mid_ifrow, 0, sizeof(a_mid_ifrow));\n\n    if_index = get_interface_index(name);\n\n    a_mid_ifrow.dwIndex = if_index;\n\n    if (NO_ERROR == GetIfEntry(&a_mid_ifrow)) {\n\n        stats->rx_bytes = a_mid_ifrow.dwInOctets;\n\n        stats->rx_packets = a_mid_ifrow.dwInUcastPkts;\n\n        stats->rx_errs = a_mid_ifrow.dwInErrors;\n\n        stats->rx_dropped = a_mid_ifrow.dwInDiscards;\n\n        stats->tx_bytes = a_mid_ifrow.dwOutOctets;\n\n        stats->tx_packets = a_mid_ifrow.dwOutUcastPkts;\n\n        stats->tx_errs = a_mid_ifrow.dwOutErrors;\n\n        stats->tx_dropped = a_mid_ifrow.dwOutDiscards;\n\n        return 0;\n\n    }\n\n    return -1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int get_bool(QEMUFile *f, void *pv, size_t size)\n{\n    bool *v = pv;\n    *v = qemu_get_byte(f);\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "**/\n    T& atN(const int pos, const int x, const int y, const int z, const int c, const T& out_value) {\n      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "uint64_t HELPER(neon_abdl_s64)(uint32_t a, uint32_t b)\n\n{\n\n    uint64_t result;\n\n    DO_ABD(result, a, b, int32_t);\n\n    return result;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int niu_get_ethtool_tcam_all(struct niu *np,\n\t\t\t\t    struct ethtool_rxnfc *nfc,\n\t\t\t\t    u32 *rule_locs)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_tcam_entry *tp;\n\tint i, idx, cnt;\n\tu16 n_entries;\n\tunsigned long flags;\n\n\n\t/* put the tcam size here */\n\tnfc->data = tcam_get_size(np);\n\n\tniu_lock_parent(np, flags);\n\tn_entries = nfc->rule_cnt;\n\tfor (cnt = 0, i = 0; i < nfc->data; i++) {\n\t\tidx = tcam_get_index(np, i);\n\t\ttp = &parent->tcam[idx];\n\t\tif (!tp->valid)\n\t\t\tcontinue;\n\t\trule_locs[cnt] = i;\n\t\tcnt++;\n\t}\n\tniu_unlock_parent(np, flags);\n\n\tif (n_entries != cnt) {\n\t\t/* print warning, this should not happen */\n\t\tnetdev_info(np->dev, \"niu%d: In %s(): n_entries[%d] != cnt[%d]!!!\\n\",\n\t\t\t    np->parent->index, __func__, n_entries, cnt);\n\t}\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int pdf_width(struct pdf_doc *pdf)\n{\n    return pdf->width;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size)\n{\n\tunsigned long cons_pos, prod_pos, new_prod_pos, flags;\n\tu32 len, pg_off;\n\tstruct bpf_ringbuf_hdr *hdr;\n\n\tif (unlikely(size > RINGBUF_MAX_RECORD_SZ))\n\t\treturn NULL;\n\n\tlen = round_up(size + BPF_RINGBUF_HDR_SZ, 8);\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\n\tif (in_nmi()) {\n\t\tif (!spin_trylock_irqsave(&rb->spinlock, flags))\n\t\t\treturn NULL;\n\t} else {\n\t\tspin_lock_irqsave(&rb->spinlock, flags);\n\t}\n\n\tprod_pos = rb->producer_pos;\n\tnew_prod_pos = prod_pos + len;\n\n\t/* check for out of ringbuf space by ensuring producer position\n\t * doesn't advance more than (ringbuf_size - 1) ahead\n\t */\n\tif (new_prod_pos - cons_pos > rb->mask) {\n\t\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\t\treturn NULL;\n\t}\n\n\thdr = (void *)rb->data + (prod_pos & rb->mask);\n\tpg_off = bpf_ringbuf_rec_pg_off(rb, hdr);\n\thdr->len = size | BPF_RINGBUF_BUSY_BIT;\n\thdr->pg_off = pg_off;\n\n\t/* pairs with consumer's smp_load_acquire() */\n\tsmp_store_release(&rb->producer_pos, new_prod_pos);\n\n\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\n\treturn (void *)hdr + BPF_RINGBUF_HDR_SZ;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "xmlBufCCat(xmlBufPtr buf, const char *str) {\n    const char *cur;\n\n    if ((buf == NULL) || (buf->error))\n        return(-1);\n    CHECK_COMPAT(buf)\n    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;\n    if (str == NULL) {\n#ifdef DEBUG_BUFFER\n        xmlGenericError(xmlGenericErrorContext,\n\t\t\"xmlBufCCat: str == NULL\\n\");\n#endif\n\treturn -1;\n    }\n    for (cur = str;*cur != 0;cur++) {\n        if (buf->use  + 10 >= buf->size) {\n            if (!xmlBufResize(buf, buf->use+10)){\n\t\txmlBufMemoryError(buf, \"growing buffer\");\n                return XML_ERR_NO_MEMORY;\n            }\n        }\n        buf->content[buf->use++] = *cur;\n    }\n    buf->content[buf->use] = 0;\n    UPDATE_COMPAT(buf)\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static char *vnc_socket_local_addr(const char *format, int fd) {\n\n    struct sockaddr_storage sa;\n\n    socklen_t salen;\n\n\n\n    salen = sizeof(sa);\n\n    if (getsockname(fd, (struct sockaddr*)&sa, &salen) < 0)\n\n        return NULL;\n\n\n\n    return addr_to_string(format, &sa, salen);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline unsigned long level_mask(int level)\n{\n\treturn -1UL << level_to_offset_bits(level);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "GF_Err schm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SchemeTypeBox *p;\n\tp = (GF_SchemeTypeBox *)a;\n\tgf_isom_box_dump_start(a, \"SchemeTypeBox\", trace);\n\tfprintf(trace, \"scheme_type=\\\"%s\\\" scheme_version=\\\"%d\\\" \", gf_4cc_to_str(p->scheme_type), p->scheme_version);\n\tif (p->URI) fprintf(trace, \"scheme_uri=\\\"%s\\\"\", p->URI);\n\tfprintf(trace, \">\\n\");\n\n\tgf_isom_box_dump_done(\"SchemeTypeBox\", a, trace);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "GF_Err nmhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "smb2_echo_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->callback_data;\n\tstruct smb2_echo_rsp *smb2 = (struct smb2_echo_rsp *)mid->resp_buf;\n\tunsigned int credits_received = 1;\n\n\tif (mid->mid_state == MID_RESPONSE_RECEIVED)\n\t\tcredits_received = le16_to_cpu(smb2->hdr.CreditRequest);\n\n\tDeleteMidQEntry(mid);\n\tadd_credits(server, credits_received, CIFS_ECHO_OP);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "_gdm_display_set_session_type (GdmDisplay *self,\n                               const char *session_type)\n{\n        GdmDisplayPrivate *priv;\n\n        priv = gdm_display_get_instance_private (self);\n        g_debug (\"GdmDisplay: session type: %s\", session_type);\n        g_free (priv->session_type);\n        priv->session_type = g_strdup (session_type);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "nghttp2_stream *nghttp2_session_find_stream(nghttp2_session *session,\n                                            int32_t stream_id) {\n  if (stream_id == 0) {\n    return &session->root;\n  }\n\n  return nghttp2_session_get_stream_raw(session, stream_id);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "MODRET set_timeoutlogin(cmd_rec *cmd) {\n  int timeout = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (pr_str_get_duration(cmd->argv[1], &timeout) < 0) {\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"error parsing timeout value '\",\n      cmd->argv[1], \"': \", strerror(errno), NULL));\n  }\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(int));\n  *((int *) c->argv[0]) = timeout;\n\n  return PR_HANDLED(cmd);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void vfio_put_device(VFIOPCIDevice *vdev)\n\n{\n\n    g_free(vdev->vbasedev.name);\n\n    if (vdev->msix) {\n\n\n        g_free(vdev->msix);\n\n        vdev->msix = NULL;\n\n    }\n\n    vfio_put_base_device(&vdev->vbasedev);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "**/\n    bool is_empty() const {\n      return (!_data || !_width);",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void ehci_trace_qh(EHCIQueue *q, target_phys_addr_t addr, EHCIqh *qh)\n\n{\n\n    trace_usb_ehci_qh(q, addr, qh->next,\n\n                      qh->current_qtd, qh->next_qtd, qh->altnext_qtd,\n\n                      get_field(qh->epchar, QH_EPCHAR_RL),\n\n                      get_field(qh->epchar, QH_EPCHAR_MPLEN),\n\n                      get_field(qh->epchar, QH_EPCHAR_EPS),\n\n                      get_field(qh->epchar, QH_EPCHAR_EP),\n\n                      get_field(qh->epchar, QH_EPCHAR_DEVADDR),\n\n                      (bool)(qh->epchar & QH_EPCHAR_C),\n\n                      (bool)(qh->epchar & QH_EPCHAR_H),\n\n                      (bool)(qh->epchar & QH_EPCHAR_DTC),\n\n                      (bool)(qh->epchar & QH_EPCHAR_I));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *param, const unsigned char *ip,\n    size_t iplen)\n{\n\tif (iplen != 0 && iplen != 4 && iplen != 16)\n\t\treturn 0;\n\treturn int_x509_param_set1((char **)&param->id->ip, &param->id->iplen,\n\t    (char *)ip, iplen);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void ieee80211_rx_mgmt_disassoc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tu16 reason_code;\n\n\tsdata_assert_lock(sdata);\n\n\tif (len < 24 + 2)\n\t\treturn;\n\n\tif (!ifmgd->associated ||\n\t    !ether_addr_equal(mgmt->bssid, ifmgd->associated->bssid))\n\t\treturn;\n\n\treason_code = le16_to_cpu(mgmt->u.disassoc.reason_code);\n\n\tsdata_info(sdata, \"disassociated from %pM (Reason: %u=%s)\\n\",\n\t\t   mgmt->sa, reason_code,\n\t\t   ieee80211_get_reason_code_string(reason_code));\n\n\tieee80211_set_disassoc(sdata, 0, 0, false, NULL);\n\n\tieee80211_report_disconnect(sdata, (u8 *)mgmt, len, false, reason_code);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tput_inotify_watch(&chunk->watch);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int sol_read_packet(AVFormatContext *s,\n\n                          AVPacket *pkt)\n\n{\n\n    int ret;\n\n\n\n    if (s->pb->eof_reached)\n\n        return AVERROR(EIO);\n\n    ret= av_get_packet(s->pb, pkt, MAX_SIZE);\n\n\n\n    pkt->stream_index = 0;\n\n\n\n    /* note: we need to modify the packet size here to handle the last\n\n       packet */\n\n    pkt->size = ret;\n\n    return 0;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void ftrace_ops_no_ops(unsigned long ip, unsigned long parent_ip)\n{\n\t__ftrace_ops_list_func(ip, parent_ip, NULL, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "zone_activate(int zone_index)\n{\n\tint              last_zone;\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\tlast_zone = s_current_zone;\n\ts_current_zone = zone_index;\n\tscript_run(zone->script, true);\n\ts_current_zone = last_zone;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline int media_is_cd(IDEState *s)\n{\n    return (media_present(s) && s->nb_sectors <= CD_MAX_SECTORS);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void bnx2x_post_dmae(struct bnx2x *bp, struct dmae_command *dmae, int idx)\n{\n\tu32 cmd_offset;\n\tint i;\n\n\tcmd_offset = (DMAE_REG_CMD_MEM + sizeof(struct dmae_command) * idx);\n\tfor (i = 0; i < (sizeof(struct dmae_command)/4); i++) {\n\t\tREG_WR(bp, cmd_offset + i*4, *(((u32 *)dmae) + i));\n\t}\n\tREG_WR(bp, dmae_reg_go_c[idx], 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint, addr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tint fput_needed;\n\n\tif (len > INT_MAX)\n\t\tlen = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tiov.iov_base = buff;\n\tiov.iov_len = len;\n\tmsg.msg_name = NULL;\n\tiov_iter_init(&msg.msg_iter, WRITE, &iov, 1, len);\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tif (addr) {\n\t\terr = move_addr_to_kernel(addr, addr_len, &address);\n\t\tif (err < 0)\n\t\t\tgoto out_put;\n\t\tmsg.msg_name = (struct sockaddr *)&address;\n\t\tmsg.msg_namelen = addr_len;\n\t}\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tmsg.msg_flags = flags;\n\terr = sock_sendmsg(sock, &msg, len);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "KEYVALUE* AddAvailableSampleID(cmsIT8* it8, const char* Key)\n{\n    return AddToList(it8, &it8->ValidSampleID, Key, NULL, NULL, WRITE_UNCOOKED);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void* Jsi_CurrentThread(void) { return NULL; }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "struct razer_report razer_chroma_extended_matrix_set_custom_frame2(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data, size_t packetLength)\n{\n    const size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);\n    // Some devices need a specific packet length, most devices are happy with 0x47\n    // e.g. the Mamba Elite needs a \"row_length + 5\" packet length\n    const size_t data_length = (packetLength != 0) ? packetLength : row_length + 5;\n    struct razer_report report = get_razer_report(0x0F, 0x03, data_length);\n\n    report.transaction_id.id = 0x3F;\n\n    // printk(KERN_ALERT \"razerkbd: Row ID: %d, Start: %d, Stop: %d, row length: %d\\n\", row_index, start_col, stop_col, (unsigned char)row_length);\n\n    report.arguments[2] = row_index;\n    report.arguments[3] = start_col;\n    report.arguments[4] = stop_col;\n    memcpy(&report.arguments[5], rgb_data, row_length);\n\n    return report;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "tt_face_set_sbit_strike( TT_Face          face,\n                           FT_Size_Request  req,\n                           FT_ULong*        astrike_index )\n  {\n    return FT_Match_Size( (FT_Face)face, req, 0, astrike_index );\n  }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void *bpf_hash_map_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_hash_map_info *info = seq->private;\n\n\t++*pos;\n\t++info->skip_elems;\n\treturn bpf_hash_map_seq_find_next(info, v);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "XmpTextValue::XmpTextValue()\n        : XmpValue(xmpText)\n    {\n    }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n\n    /*\n     * PSK parameters:\n      *\n      * opaque psk_identity_hint<0..2^16-1>;\n      */\n     len = (*p)[0] << 8 | (*p)[1];\n     *p += 2;\n \n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    /*\n     * Note: we currently ignore the PKS identity hint, as we only allow one\n     * PSK to be provisionned on the client. This could be changed later if\n     * someone needs that feature.\n     */\n    *p += len;\n    ret = 0;\n\n    return( ret );\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "bool PM_io_parser<PMDEC>::read_hedge(Halfedge_handle e)\n{ // syntax: index { opposite, prev, next, vertex, face, mark }\n  int n, eo, epr, ene, v, f; bool m;\n  if ( !(in >> n) ||\n       !check_sep(\"{\") ||\n       !(in >> eo) || !check_sep(\",\") ||\n       !(in >> epr) || !check_sep(\",\") ||\n       !(in >> ene) || !check_sep(\",\") ||\n       !(in >> v) || !check_sep(\",\") ||\n       !(in >> f) || !check_sep(\",\") ||\n       !(in >> m) || !check_sep(\"}\") )\n    return false;\n  CGAL_assertion_msg\n     (eo >= 0 || (std::size_t) eo < en || epr >= 0 || (std::size_t) epr < en || ene >= 0 || (std::size_t) ene < en ||\n      v >= 0 || (std::size_t) v < vn || f >= 0 || (std::size_t) f < fn ,\n      \"wrong index in read_hedge\");\n\n  // precond: objects exist!\n  CGAL_assertion(EI[e->opposite()]);\n  e->set_prev(Halfedge_of[epr]);\n  e->set_next(Halfedge_of[ene]);\n  e->set_vertex(Vertex_of[v]);\n  e->set_face(Face_of[f]);\n  mark(e) = m;\n  return true;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "i_alloc_struct_array_immovable(gs_memory_t * mem, uint num_elements,\n                           gs_memory_type_ptr_t pstype, client_name_t cname)\n{\n    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;\n    obj_header_t *obj;\n\n#ifdef MEMENTO\n    if (Memento_failThisEvent())\n        return NULL;\n#endif\n\n    ALLOC_CHECK_SIZE(mem,pstype);\n    obj = alloc_obj(imem,\n                    (ulong) num_elements * pstype->ssize,\n                    pstype, ALLOC_IMMOVABLE | ALLOC_DIRECT, cname);\n    if_debug7m('A', mem, \"[a%d|+<.]%s %s*(%lu=%u*%u) = 0x%lx\\n\",\n               alloc_trace_space(imem), client_name_string(cname),\n               struct_type_name_string(pstype),\n               (ulong) num_elements * pstype->ssize,\n               num_elements, pstype->ssize, (ulong) obj);\n    return (char *)obj;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int handle_monitor_trap(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline unsigned short ScaleQuantumToShort(const Quantum quantum)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((unsigned short) (257UL*quantum));\n#else\n  if (quantum <= 0.0)\n    return(0);\n  if ((257.0*quantum) >= 65535.0)\n    return(65535);\n  return((unsigned short) (257.0*quantum+0.5));\n#endif\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\n\thid_set_drvdata(hdev, priv);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\n\treturn 0;\nerr_free:\n\tkfree(priv);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "PHPAPI pcre* pcre_get_compiled_regex(char *regex, pcre_extra **extra, int *preg_options TSRMLS_DC)\n{\n\tpcre_cache_entry * pce = pcre_get_compiled_regex_cache(regex, strlen(regex) TSRMLS_CC);\n\n\tif (extra) {\n\t\t*extra = pce ? pce->extra : NULL;\n\t}\n\tif (preg_options) {\n\t\t*preg_options = pce ? pce->preg_options : 0;\n\t}\n\t\n\treturn pce ? pce->re : NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "scoped_ptr<RenderWidgetHostIterator> RenderWidgetHost::GetRenderWidgetHosts() {\n  scoped_ptr<RenderWidgetHostIteratorImpl> hosts(\n      new RenderWidgetHostIteratorImpl());\n  for (auto& it : g_routing_id_widget_map.Get()) {\n    RenderWidgetHost* widget = it.second;\n\n    RenderViewHost* rvh = RenderViewHost::From(widget);\n    if (!rvh) {\n      hosts->Add(widget);\n      continue;\n    }\n\n    if (static_cast<RenderViewHostImpl*>(rvh)->is_active())\n      hosts->Add(widget);\n  }\n\n  return std::move(hosts);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void SafeBrowsingBlockingPage::OverrideRendererPrefs(\n      content::RendererPreferences* prefs) {\n  Profile* profile = Profile::FromBrowserContext(\n      web_contents_->GetBrowserContext());\n  renderer_preferences_util::UpdateFromSystemSettings(prefs, profile);\n }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void _WM_do_meta_instrumentname(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "convert_to_unix_filename(char *filename)\n{\n\tchar *p;\n\n\twhile ((p = strchr(filename, '\\\\')))\n\t{\n\t\t*p = '/';\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "v8::Local<v8::Object> SafeBuiltins::GetError() const {\n  return Load(\"Error\", context_->v8_context());\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "spell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t/* TRUE for the prefix tree */\n    int\t\tprefixcnt)\t/* when \"prefixtree\" is TRUE: prefix count */\n{\n    int\t\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    /* The tree size was computed when writing the file, so that we can\n     * allocate it as one long block. <nodecount> */\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len > 0)\n    {\n\t/* Allocate the byte array. */\n\tbp = lalloc((long_u)len, TRUE);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\n\t/* Allocate the index array. */\n\tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t/* Recursively read the tree and store it in the array. */\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int ntop_load_dump_prefs(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  ntop_interface->loadDumpPrefs();\n\n  return(CONST_LUA_OK);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "get_meaningful_restriction_threshold(void)\n{\n  int32_t pct = networkstatus_get_param(NULL,\n                                        \"guard-meaningful-restriction-percent\",\n                                        DFLT_MEANINGFUL_RESTRICTION_PERCENT,\n                                        1, INT32_MAX);\n  return pct / 100.0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void RenderWidgetHostImpl::DecrementInFlightEventCount() {\n  if (decrement_in_flight_event_count() <= 0) {\n    StopHangMonitorTimeout();\n  } else {\n    if (!is_hidden_)\n      RestartHangMonitorTimeout();\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "    void AuthorizationSession::addAuthorizedPrincipal(Principal* principal) {\n\n        // Log out any already-logged-in user on the same database as \"principal\".\n        logoutDatabase(principal->getName().getDB().toString());  // See SERVER-8144.\n\n        _authenticatedPrincipals.add(principal);\n        if (!principal->isImplicitPrivilegeAcquisitionEnabled())\n            return;\n        _acquirePrivilegesForPrincipalFromDatabase(ADMIN_DBNAME, principal->getName());\n        principal->markDatabaseAsProbed(ADMIN_DBNAME);\n        const std::string dbname = principal->getName().getDB().toString();\n        _acquirePrivilegesForPrincipalFromDatabase(dbname, principal->getName());\n        principal->markDatabaseAsProbed(dbname);\n        _externalState->onAddAuthorizedPrincipal(principal);\n    }",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "      TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    auto findices = indices.flat<int>();\n\n    // Return values at specified indices\n    for (std::size_t i = 0; i < findices.dimension(0); ++i) {\n      std::size_t index = findices(i);\n\n      TF_RETURN_IF_ERROR(check_index(key, index));\n\n      // Insist on a value present at the specified index\n      if (!(*map_tuple)[index].has_value()) {\n        return Status(errors::InvalidArgument(\n            \"Tensor at index '\", index, \"' for key '\", key.scalar<int64>()(),\n            \"' has already been removed.\"));\n      }\n\n      // Copy the contained tensor and\n      // remove from the OptionalTuple\n      output->push_back((*map_tuple)[index].value());\n\n      // Clear out the entry if we're not copying (moving)\n      if (!copy) {\n        (*map_tuple)[index].reset();\n      }\n    }\n\n    return Status::OK();\n  }",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int ax25_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tax25_dev *ax25_dev;\n\n\tif (sk == NULL)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tsock_orphan(sk);\n\tax25 = sk_to_ax25(sk);\n\tax25_dev = ax25->ax25_dev;\n\tif (ax25_dev) {\n\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\tax25_dev_put(ax25_dev);\n\t}\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tswitch (ax25->state) {\n\t\tcase AX25_STATE_0:\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_1:\n\t\tcase AX25_STATE_2:\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_3:\n\t\tcase AX25_STATE_4:\n\t\t\tax25_clear_queues(ax25);\n\t\t\tax25->n2count = 0;\n\n\t\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\t\t\tcase AX25_PROTO_STD_SIMPLEX:\n\t\t\tcase AX25_PROTO_STD_DUPLEX:\n\t\t\t\tax25_send_control(ax25,\n\t\t\t\t\t\t  AX25_DISC,\n\t\t\t\t\t\t  AX25_POLLON,\n\t\t\t\t\t\t  AX25_COMMAND);\n\t\t\t\tax25_stop_t2timer(ax25);\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\t\tcase AX25_PROTO_DAMA_SLAVE:\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tax25_calculate_t1(ax25);\n\t\t\tax25_start_t1timer(ax25);\n\t\t\tax25->state = AX25_STATE_2;\n\t\t\tsk->sk_state                = TCP_CLOSE;\n\t\t\tsk->sk_shutdown            |= SEND_SHUTDOWN;\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsk->sk_state     = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tax25_destroy_socket(ax25);\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline void tg3_tx_set_bd(struct tg3_tx_buffer_desc *txbd,\n\t\t\t\t dma_addr_t mapping, u32 len, u32 flags,\n\t\t\t\t u32 mss, u32 vlan)\n{\n\ttxbd->addr_hi = ((u64) mapping >> 32);\n\ttxbd->addr_lo = ((u64) mapping & 0xffffffff);\n\ttxbd->len_flags = (len << TXD_LEN_SHIFT) | (flags & 0x0000ffff);\n\ttxbd->vlan_tag = (mss << TXD_MSS_SHIFT) | (vlan << TXD_VLAN_TAG_SHIFT);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "remove_server(char *prefix, char *port)\n{\n    char *old_port            = NULL;\n    struct server *old_server = NULL;\n\n    cork_hash_table_delete(server_table, (void *)port, (void **)&old_port, (void **)&old_server);\n\n    if (old_server != NULL) {\n        destroy_server(old_server);\n        ss_free(old_server);\n    }\n\n    stop_server(prefix, port);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int sc_mutex_lock(const sc_context_t *ctx, void *mutex)\n{\n\tif (ctx == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tif (ctx->thread_ctx != NULL && ctx->thread_ctx->lock_mutex != NULL)\n\t\treturn ctx->thread_ctx->lock_mutex(mutex);\n\telse\n\t\treturn SC_SUCCESS;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void proc_set_tty(struct task_struct *tsk, struct tty_struct *tty)\n{\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__proc_set_tty(tsk, tty);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "decompress_zstd(tvbuff_t *tvb _U_, packet_info *pinfo, int offset _U_, guint32 length _U_, tvbuff_t **decompressed_tvb _U_, int *decompressed_offset _U_)\n{\n    col_append_str(pinfo->cinfo, COL_INFO, \" [zstd compression unsupported]\");\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\terr = compat_get_bitmap(bm, nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, bm, alloc_size);\n\t}\n\n\tif (err)\n\t\treturn -EFAULT;\n\n\treturn sys_set_mempolicy(mode, nm, nr_bits+1);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "String AudioNode::channelInterpretation() const {\n  return Handler().ChannelInterpretation();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "_alloc_gids(int n, gid_t *gids)\n{\n\tgids_t *new;\n\n\tnew = (gids_t *)xmalloc(sizeof(gids_t));\n\tnew->ngids = n;\n\tnew->gids = gids;\n\treturn new;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void dash_free(AVFormatContext *s)\n{\n    DASHContext *c = s->priv_data;\n    int i, j;\n    if (c->as) {\n        for (i = 0; i < c->nb_as; i++)\n            av_dict_free(&c->as[i].metadata);\n        av_freep(&c->as);\n        c->nb_as = 0;\n    }\n    if (!c->streams)\n        return;\n    for (i = 0; i < s->nb_streams; i++) {\n        OutputStream *os = &c->streams[i];\n        if (os->ctx && os->ctx_inited)\n            av_write_trailer(os->ctx);\n        if (os->ctx && os->ctx->pb)\n            ffio_free_dyn_buf(&os->ctx->pb);\n        ff_format_io_close(s, &os->out);\n        if (os->ctx)\n            avformat_free_context(os->ctx);\n        for (j = 0; j < os->nb_segments; j++)\n            av_free(os->segments[j]);\n        av_free(os->segments);\n    }\n    av_freep(&c->streams);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void dm_hash_exit(void)\n{\n\tdm_hash_remove_all(false, false, false);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "hfinfo_same_name_get_prev(const header_field_info *hfinfo)\n{\n\theader_field_info *dup_hfinfo;\n\n\tif (hfinfo->same_name_prev_id == -1)\n\t\treturn NULL;\n\tPROTO_REGISTRAR_GET_NTH(hfinfo->same_name_prev_id, dup_hfinfo);\n\treturn dup_hfinfo;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)\n{\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "spa_bits_to_base64 (uschar *out, const uschar *in, int inlen)\n/* raw bytes in quasi-big-endian order to base 64 string (NUL-terminated) */\n{\n  for (; inlen >= 3; inlen -= 3)\n    {\n      *out++ = base64digits[in[0] >> 2];\n      *out++ = base64digits[((in[0] << 4) & 0x30) | (in[1] >> 4)];\n      *out++ = base64digits[((in[1] << 2) & 0x3c) | (in[2] >> 6)];\n      *out++ = base64digits[in[2] & 0x3f];\n      in += 3;\n    }\n  if (inlen > 0)\n    {\n      uschar fragment;\n\n      *out++ = base64digits[in[0] >> 2];\n      fragment = (in[0] << 4) & 0x30;\n      if (inlen > 1)\n       fragment |= in[1] >> 4;\n      *out++ = base64digits[fragment];\n      *out++ = (inlen < 2) ? '=' : base64digits[(in[1] << 2) & 0x3c];\n      *out++ = '=';\n    }\n  *out = '\\0';\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void ChildThread::Shutdown() {\n   file_system_dispatcher_.reset();\n   quota_dispatcher_.reset();\n  WebFileSystemImpl::DeleteThreadSpecificInstance();\n }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "auto join(const Range& range, const BasicCStringRef<char>& sep)\n    -> ArgJoin<char, decltype(std::begin(range))> {\n  return join(std::begin(range), std::end(range), sep);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void ip_vs_trash_cleanup(struct net *net)\n{\n\tstruct ip_vs_dest *dest, *nxt;\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tlist_for_each_entry_safe(dest, nxt, &ipvs->dest_trash, n_list) {\n\t\tlist_del(&dest->n_list);\n\t\tip_vs_dst_reset(dest);\n\t\t__ip_vs_unbind_svc(dest);\n\t\tfree_percpu(dest->stats.cpustats);\n\t\tkfree(dest);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void dp_cleanup(void)\n{\n\tdp_unregister_genl(ARRAY_SIZE(dp_genl_families));\n\tunregister_netdevice_notifier(&ovs_dp_device_notifier);\n\tunregister_pernet_device(&ovs_net_ops);\n\trcu_barrier();\n\tovs_vport_exit();\n\tovs_flow_exit();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline int rs_cmp(u64 blk, u32 len, struct gfs2_blkreserv *rs)\n{\n\tu64 startblk = gfs2_rbm_to_block(&rs->rs_rbm);\n\n\tif (blk >= startblk + rs->rs_free)\n\t\treturn 1;\n\tif (blk + len - 1 < startblk)\n\t\treturn -1;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "Formattable::Formattable(UnicodeString* stringToAdopt)\n{\n    init();\n    fType = kString;\n    fValue.fString = stringToAdopt;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int __init init_uprobes(void)\n{\n\tint i;\n\n\tfor (i = 0; i < UPROBES_HASH_SZ; i++)\n\t\tmutex_init(&uprobes_mmap_mutex[i]);\n\n\tif (percpu_init_rwsem(&dup_mmap_sem))\n\t\treturn -ENOMEM;\n\n\treturn register_die_notifier(&uprobe_exception_nb);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "_XkbCheckMaskedAtoms(CARD32 *wire, int nAtoms, CARD32 present, int swapped,\n                     Atom *pError)\n{\n    register unsigned i, bit;\n\n    for (i = 0, bit = 1; (i < nAtoms) && (present); i++, bit <<= 1) {\n        if ((present & bit) == 0)\n            continue;\n        if (swapped) {\n            swapl(wire);\n        }\n        if ((((Atom) *wire) != None) && (!ValidAtom(((Atom) *wire)))) {\n            *pError = (Atom) *wire;\n            return NULL;\n        }\n        wire++;\n    }\n    return wire;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(CentralDirectoryRecord) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), central_directory_record_signature, sizeof(central_directory_record_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&made_by_version), buffer.data() + sizeof(central_directory_record_signature), fields_size);\n        name = buffer.data() + sizeof(central_directory_record_signature) + fields_size;\n        extra_data = name + name_length;\n        comment = extra_data + extra_data_length;\n        return true;\n    }",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void SVGImage::resetAnimation()\n{\n    stopAnimation();\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)\n{\n\tkuid_t euid;\n\tkgid_t egid;\n\tint id;\n\tint next_id = ids->next_id;\n\n\tif (size > IPCMNI)\n\t\tsize = IPCMNI;\n\n\tif (ids->in_use >= size)\n\t\treturn -ENOSPC;\n\n\tidr_preload(GFP_KERNEL);\n\n\tspin_lock_init(&new->lock);\n\tnew->deleted = false;\n \trcu_read_lock();\n \tspin_lock(&new->lock);\n \n \tid = idr_alloc(&ids->ipcs_idr, new,\n \t\t       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,\n \t\t       GFP_NOWAIT);\n\tidr_preload_end();\n\tif (id < 0) {\n\t\tspin_unlock(&new->lock);\n\t\trcu_read_unlock();\n\t\treturn id;\n\t}\n \n \tids->in_use++;\n \n\tcurrent_euid_egid(&euid, &egid);\n\tnew->cuid = new->uid = euid;\n\tnew->gid = new->cgid = egid;\n \tif (next_id < 0) {\n \t\tnew->seq = ids->seq++;\n \t\tif (ids->seq > IPCID_SEQ_MAX)\n\t\t\tids->seq = 0;\n\t} else {\n\t\tnew->seq = ipcid_to_seqx(next_id);\n\t\tids->next_id = -1;\n\t}\n\n\tnew->id = ipc_buildid(id, new->seq);\n\treturn id;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "connection_ap_mark_as_waiting_for_renddesc(entry_connection_t *entry_conn)\n{\n  tor_assert(entry_conn);\n\n  connection_ap_mark_as_non_pending_circuit(entry_conn);\n  ENTRY_TO_CONN(entry_conn)->state = AP_CONN_STATE_RENDDESC_WAIT;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int put_v4l2_plane32(struct v4l2_plane __user *up, struct v4l2_plane32 __user *up32,\n\t\t\t    enum v4l2_memory memory)\n{\n\tunsigned long p;\n\n\tif (copy_in_user(up32, up, 2 * sizeof(__u32)) ||\n\t    copy_in_user(&up32->data_offset, &up->data_offset,\n\t\t\t sizeof(up->data_offset)))\n\t\treturn -EFAULT;\n\n\tswitch (memory) {\n\tcase V4L2_MEMORY_MMAP:\n\tcase V4L2_MEMORY_OVERLAY:\n\t\tif (copy_in_user(&up32->m.mem_offset, &up->m.mem_offset,\n\t\t\t\t sizeof(up->m.mem_offset)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase V4L2_MEMORY_USERPTR:\n\t\tif (get_user(p, &up->m.userptr) ||\n\t\t    put_user((compat_ulong_t)ptr_to_compat((__force void *)p),\n\t\t\t     &up32->m.userptr))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase V4L2_MEMORY_DMABUF:\n\t\tif (copy_in_user(&up32->m.fd, &up->m.fd,\n\t\t\t\t sizeof(up->m.fd)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "SPL_METHOD(SplFileObject, getMaxLineLen)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG((long)intern->u.file.max_line_len);\n} /* }}} */",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) {\n    printf(\"%s : Module support not compiled in\\n\", argv[0]);\n    return(0);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "irc_server_get_chanmodes (struct t_irc_server *server)\n{\n    return (server && server->chanmodes) ?\n        server->chanmodes : irc_server_chanmodes_default;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int annot_store_cb(annotate_state_t *astate, void *rock)\n{\n    struct annot_store_rock *arock = rock;\n    return annotate_state_store(astate, arock->entryatts);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "GF_Err maxr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->granularity);\n\tgf_bs_write_u32(bs, ptr->maxDataRate);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "cf2_getSubfont( CFF_Decoder*  decoder )\n  {\n    FT_ASSERT( decoder && decoder->current_subfont );\n\n    return decoder->current_subfont;\n  }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int i2c_ddc_rx(I2CSlave *i2c)\n{\n    I2CDDCState *s = I2CDDC(i2c);\n\n    int value;\n    value = s->edid_blob[s->reg];\n    s->reg++;\n    return value;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline __maybe_unused uint64_t h2_get_n64(const struct buffer *b, int o)\n{\n\treturn readv_n64(b_ptr(b, o), b_end(b) - b_ptr(b, o), b->data);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "hb_ot_layout_table_get_feature_tags (hb_face_t    *face,\n\t\t\t\t     hb_tag_t      table_tag,\n\t\t\t\t     unsigned int *feature_count /* IN/OUT */,\n\t\t\t\t     hb_tag_t     *feature_tags /* OUT */)\n{\n  const GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n\n  return g.get_feature_tags (feature_count, feature_tags);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "cr_input_get_line_num (CRInput const * a_this, glong * a_line_num)\n{\n        g_return_val_if_fail (a_this && PRIVATE (a_this)\n                              && a_line_num, CR_BAD_PARAM_ERROR);\n\n        *a_line_num = PRIVATE (a_this)->line;\n\n        return CR_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void bitmap_clear(unsigned long *map, long start, long nr)\n{\n    unsigned long *p = map + BIT_WORD(start);\n    const long size = start + nr;\n    int bits_to_clear = BITS_PER_LONG - (start % BITS_PER_LONG);\n    unsigned long mask_to_clear = BITMAP_FIRST_WORD_MASK(start);\n    while (nr - bits_to_clear >= 0) {\n        *p &= ~mask_to_clear;\n        nr -= bits_to_clear;\n        bits_to_clear = BITS_PER_LONG;\n        mask_to_clear = ~0UL;\n        p++;\n    }\n    if (nr) {\n        mask_to_clear &= BITMAP_LAST_WORD_MASK(size);\n        *p &= ~mask_to_clear;\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int vnc_display_disable_login(DisplayState *ds)\n\n{\n\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n\n\n\n    if (!vs) {\n\n        return -1;\n\n    }\n\n\n\n    if (vs->password) {\n\n        g_free(vs->password);\n\n    }\n\n\n\n    vs->password = NULL;\n\n    if (vs->auth == VNC_AUTH_NONE) {\n\n        vs->auth = VNC_AUTH_VNC;\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "store_glyph_width(txt_glyph_width_t *pwidth, int wmode, const gs_matrix *scale,\n                  const gs_glyph_info_t *pinfo)\n{\n    double w, v;\n\n    gs_distance_transform(pinfo->width[wmode].x, pinfo->width[wmode].y, scale, &pwidth->xy);\n    if (wmode)\n        w = pwidth->xy.y, v = pwidth->xy.x;\n    else\n        w = pwidth->xy.x, v = pwidth->xy.y;\n    if (v != 0)\n        return 1;\n    pwidth->w = w;\n    gs_distance_transform(pinfo->v.x, pinfo->v.y, scale, &pwidth->v);\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int do_subchannel_work_virtual(SubchDev *sch)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func_virtual(sch);\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "struct dce_i2c_hw *dce120_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdce112_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n \t__be32 spi;\n \n \tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void __bnep_unlink_session(struct bnep_session *s)\n{\n\tlist_del(&s->list);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "T toNumber(const std::vector<char> &data, bool mostSignificantByteFirst)\n  {\n    T sum = 0;\n\n    if(data.size() <= 0) {\n      debug(\"ByteVectorMirror::toNumber<T>() -- data is empty, returning 0\");\n      return sum;\n    }\n\n    uint size = sizeof(T);\n    uint last = data.size() > size ? size - 1 : data.size() - 1;\n\n    for(uint i = 0; i <= last; i++)\n      sum |= (T) uchar(data[i]) << ((mostSignificantByteFirst ? last - i : i) * 8);\n\n    return sum;\n  }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "ulong STDCALL mysql_stmt_param_count(MYSQL_STMT * stmt)\n{\n  DBUG_ENTER(\"mysql_stmt_param_count\");\n  DBUG_RETURN(stmt->param_count);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "proto_tree_add_uint_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,\n\t\t\t   gint start, gint length, guint32 value,\n\t\t\t   const char *format, ...)\n{\n\tproto_item\t  *pi;\n\tva_list\t\t   ap;\n\n\tpi = proto_tree_add_uint(tree, hfindex, tvb, start, length, value);\n\tif (pi != tree) {\n\t\tTRY_TO_FAKE_THIS_REPR(pi);\n\n\t\tva_start(ap, format);\n\t\tproto_tree_set_representation(pi, format, ap);\n\t\tva_end(ap);\n\t}\n\n\treturn pi;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void RenderView::exitFullscreenForNode(const WebKit::WebNode& node) {\n  NOTIMPLEMENTED();\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void KPasswordDlg::blinkTimeout()\n{\n\tblink = !blink;\n\tshowStars();\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "crypto_cert_free_matching_data(krb5_context context,\n                               pkinit_cert_matching_data *md)\n{\n    krb5_principal p;\n    int i;\n\n    if (md == NULL)\n        return EINVAL;\n    if (md->subject_dn)\n        free(md->subject_dn);\n    if (md->issuer_dn)\n        free(md->issuer_dn);\n    if (md->sans) {\n        for (i = 0, p = md->sans[i]; p != NULL; p = md->sans[++i])\n            krb5_free_principal(context, p);\n        free(md->sans);\n    }\n    free(md);\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void __dev_close(struct net_device *dev)\n{\n\tLIST_HEAD(single);\n\n\tlist_add(&dev->close_list, &single);\n\t__dev_close_many(&single);\n\tlist_del(&single);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void spatial_compose53i_dy_buffered(dwt_compose_t *cs, slice_buffer * sb, int width, int height, int stride_line){\n\n    int y= cs->y;\n\n    int mirror0 = mirror(y-1, height-1);\n\n    int mirror1 = mirror(y  , height-1);\n\n    int mirror2 = mirror(y+1, height-1);\n\n    int mirror3 = mirror(y+2, height-1);\n\n\n\n    DWTELEM *b0= cs->b0;\n\n    DWTELEM *b1= cs->b1;\n\n    DWTELEM *b2= slice_buffer_get_line(sb, mirror2 * stride_line);\n\n    DWTELEM *b3= slice_buffer_get_line(sb, mirror3 * stride_line);\n\n\n\n{START_TIMER\n\n        if(mirror1 <= mirror3) vertical_compose53iL0(b1, b2, b3, width);\n\n        if(mirror0 <= mirror2) vertical_compose53iH0(b0, b1, b2, width);\n\nSTOP_TIMER(\"vertical_compose53i*\")}\n\n\n\n{START_TIMER\n\n        if(y-1 >= 0) horizontal_compose53i(b0, width);\n\n        if(mirror0 <= mirror2) horizontal_compose53i(b1, width);\n\nSTOP_TIMER(\"horizontal_compose53i\")}\n\n\n\n    cs->b0 = b2;\n\n    cs->b1 = b3;\n\n    cs->y += 2;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int compat_count(compat_uptr_t __user *argv, int max)\n{\n\tint i = 0;\n\n\tif (argv != NULL) {\n\t\tfor (;;) {\n\t\t\tcompat_uptr_t p;\n\n\t\t\tif (get_user(p, argv))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\t\t\targv++;\n\t\t\tif(++i > max)\n\t\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\treturn i;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "exsltSaxonLineNumberFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n    xmlNodePtr cur = NULL;\n\n    if (nargs == 0) {\n\tcur = ctxt->context->node;\n    } else if (nargs == 1) {\n\txmlXPathObjectPtr obj;\n\txmlNodeSetPtr nodelist;\n\tint i;\n\n\tif ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n\t    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"saxon:line-number() : invalid arg expecting a node-set\\n\");\n\t    ctxt->error = XPATH_INVALID_TYPE;\n\t    return;\n\t}\n\n\tobj = valuePop(ctxt);\n\tnodelist = obj->nodesetval;\n\tif ((nodelist == NULL) || (nodelist->nodeNr <= 0)) {\n\t    xmlXPathFreeObject(obj);\n\t    valuePush(ctxt, xmlXPathNewFloat(-1));\n\t    return;\n\t}\n\tcur = nodelist->nodeTab[0];\n\tfor (i = 1;i < nodelist->nodeNr;i++) {\n\t    int ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n\t    if (ret == -1)\n\t\tcur = nodelist->nodeTab[i];\n\t}\n\txmlXPathFreeObject(obj);\n    } else {\n\txsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"saxon:line-number() : invalid number of args %d\\n\",\n\t\tnargs);\n\tctxt->error = XPATH_INVALID_ARITY;\n\treturn;\n    }\n\n    valuePush(ctxt, xmlXPathNewFloat(xmlGetLineNo(cur)));\n    return;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int hclge_tm_schd_mode_vnet_base_cfg(struct hclge_vport *vport)\n{\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\tu8 i;\n\n\tret = hclge_tm_pri_schd_mode_cfg(hdev, vport->vport_id);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < kinfo->num_tc; i++) {\n\t\tu8 sch_mode = hdev->tm_info.tc_info[i].tc_sch_mode;\n\n\t\tret = hclge_tm_qs_schd_mode_cfg(hdev, vport->qs_offset + i,\n\t\t\t\t\t\tsch_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tint ret;\n\n\tif (unlikely(!out->f_op || !out->f_op->splice_write))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(WRITE, out, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\treturn out->f_op->splice_write(pipe, out, ppos, len, flags);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static ssize_t partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_PARTIAL);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "archive_read_set_switch_callback(struct archive *_a,\n    archive_switch_callback *client_switcher)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n\t    \"archive_read_set_switch_callback\");\n\ta->client.switcher = client_switcher;\n\treturn ARCHIVE_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void ipmi_poll_interface(struct ipmi_user *user)\n{\n\tipmi_poll(user->intf);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "GF_Err ilst_item_box_size(GF_Box *s)\n{\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\n\t/*generic box list*/\n\tif (ptr->child_boxes && !ptr->data) {\n\t}\n\t/*iTune way: data-box-encapsulated box list*/\n\telse if (ptr->data && !ptr->data->qt_style) {\n\t\tu32 pos=0;\n\t\tgf_isom_check_position(s, (GF_Box* ) ptr->data, &pos);\n\t}\n\t/*QT way: raw data*/\n\telse if (ptr->data) {\n\t\tptr->size += ptr->data->dataSize + 4;\n\t}\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "char **XListExtensions(\n    register Display *dpy,\n    int *nextensions)\t/* RETURN */\n{\n\txListExtensionsReply rep;\n\tchar **list = NULL;\n\tchar *ch = NULL;\n\tchar *chend;\n\tint count = 0;\n\tregister unsigned i;\n\tregister int length;\n\t_X_UNUSED register xReq *req;\n\tunsigned long rlen = 0;\n\n\tLockDisplay(dpy);\n\tGetEmptyReq (ListExtensions, req);\n\n\tif (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\n\tif (rep.nExtensions) {\n\t    list = Xmalloc (rep.nExtensions * sizeof (char *));\n\t    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {\n\t\trlen = rep.length << 2;\n\t\tch = Xmalloc (rlen + 1);\n                /* +1 to leave room for last null-terminator */\n\t    }\n\n\t    if ((!list) || (!ch)) {\n\t\tXfree(list);\n\t\tXfree(ch);\n\t\t_XEatDataWords(dpy, rep.length);\n\t\tUnlockDisplay(dpy);\n\t\tSyncHandle();\n\t\treturn (char **) NULL;\n\t    }\n\n\t    _XReadPad (dpy, ch, rlen);\n\t    /*\n \t     * unpack into null terminated strings.\n \t     */\n \t    chend = ch + rlen;\n\t    length = *ch;\n \t    for (i = 0; i < rep.nExtensions; i++) {\n \t\tif (ch + length < chend) {\n \t\t    list[i] = ch+1;  /* skip over length */\n \t\t    ch += length + 1; /* find next length ... */\n\t\t    length = *ch;\n \t\t    *ch = '\\0'; /* and replace with null-termination */\n \t\t    count++;\n \t\t} else\n\t\t    list[i] = NULL;\n\t    }\n\t}\n\n\t*nextensions = count;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (list);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static Token *steal_Token(Token *dst, Token *src)\n{\n    /* Overwrite everything except the next pointers */\n    memcpy((char *)dst + sizeof(Token *), (char *)src + sizeof(Token *),\n\t   sizeof(Token) - sizeof(Token *));\n\n    /* Clear the donor token */\n    memset((char *)src + sizeof(Token *), 0, sizeof(Token) - sizeof(Token *));\n\n    return dst;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "const ASN1_INTEGER *X509_get0_serialNumber(const X509 *a)\n{\n    return &a->cert_info.serialNumber;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int migrate_use_xbzrle(void)\n\n{\n\n    MigrationState *s;\n\n\n\n    s = migrate_get_current();\n\n\n\n    return s->enabled_capabilities[MIGRATION_CAPABILITY_XBZRLE];\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "GF_Err maxr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MAXRBox *p;\n\tp = (GF_MAXRBox *)a;\n\tgf_isom_box_dump_start(a, \"MaxDataRateBox\", trace);\n\tfprintf(trace, \"MaxDataRate=\\\"%d\\\" Granularity=\\\"%d\\\">\\n\", p->maxDataRate, p->granularity);\n\tgf_isom_box_dump_done(\"MaxDataRateBox\", a, trace);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline int track_pfn_vma_new(struct vm_area_struct *vma, pgprot_t *prot,\n\t\t\t\t\tunsigned long pfn, unsigned long size)\n{\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "Packet *PacketGetFromAlloc(void)\n{\n    Packet *p = SCMalloc(SIZE_OF_PACKET);\n    if (unlikely(p == NULL)) {\n        return NULL;\n    }\n\n    memset(p, 0, SIZE_OF_PACKET);\n    PACKET_INITIALIZE(p);\n    p->ReleasePacket = PacketFree;\n    p->flags |= PKT_ALLOC;\n\n    SCLogDebug(\"allocated a new packet only using alloc...\");\n\n    PACKET_PROFILING_START(p);\n    return p;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "seamless_reset_state(void)\n{\n\tif (seamless_rest != NULL)\n\t{\n\t\txfree(seamless_rest);\n\t\tseamless_rest = NULL;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void RenderFrameHostImpl::ResetNavigationRequests() {\n  navigation_request_.reset();\n  same_document_navigation_request_.reset();\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "add_opcode(regex_t* reg, int opcode)\n{\n  BBUF_ADD1(reg, opcode);\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "ProfileSyncService* GetSyncService(Profile* profile) {\n   if (test_sync_service)\n    return test_sync_service;\n  else\n    return profile->GetProfileSyncService();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "get_list_node (GMarkupParseContext *context, gpointer data)\n{\n  GSList *node;\n  if (context->spare_list_nodes != NULL)\n    {\n      node = context->spare_list_nodes;\n      context->spare_list_nodes = g_slist_remove_link (context->spare_list_nodes, node);\n    }\n  else\n    node = g_slist_alloc();\n  node->data = data;\n  return node;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "run_selftests (int algo, int extended, selftest_report_func_t report)\n{\n  gpg_err_code_t ec;\n\n  (void)extended;\n\n  switch (algo)\n    {\n    case GCRY_PK_RSA:\n      ec = selftests_rsa (report);\n      break;\n    default:\n      ec = GPG_ERR_PUBKEY_ALGO;\n      break;\n\n    }\n  return ec;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "next_bss_le(struct brcmf_scan_results *list, struct brcmf_bss_info_le *bss)\n{\n\tif (bss == NULL)\n\t\treturn list->bss_info_le;\n\treturn (struct brcmf_bss_info_le *)((unsigned long)bss +\n\t\t\t\t\t    le32_to_cpu(bss->length));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int checkAttribute(struct MYSOFA_ATTRIBUTE *attribute, char *name,\n\t\tchar *value) {\n\twhile (attribute) {\n\t\tif (!mystrcmp(attribute->name, name)\n\t\t\t\t&& !mystrcmp(attribute->value, value))\n\t\t\treturn MYSOFA_OK;\n\t\tattribute = attribute->next;\n\t}\n\n\treturn MYSOFA_INVALID_FORMAT;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "bool ShouldSupportIetfFormatQuicAltSvc(\n    const VariationParameters& quic_trial_params) {\n  return base::LowerCaseEqualsASCII(\n      GetVariationParam(quic_trial_params, \"support_ietf_format_quic_altsvc\"),\n      \"true\");\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "double GetFrameDeviceScaleFactor(const ToRenderFrameHost& adapter) {\n  double device_scale_factor;\n  const char kGetFrameDeviceScaleFactor[] =\n      \"window.domAutomationController.send(window.devicePixelRatio);\";\n  EXPECT_TRUE(ExecuteScriptAndExtractDouble(adapter, kGetFrameDeviceScaleFactor,\n                                            &device_scale_factor));\n  return device_scale_factor;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void eat_opt_white( const char **pcur )\n{\n   while (**pcur == ' ' || **pcur == '\\t' || **pcur == '\\n')\n      (*pcur)++;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)\n{\n\tif (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))\n\t\treturn -EINVAL;\n\n\tif (args->flags & KVM_IRQFD_FLAG_DEASSIGN)\n\t\treturn kvm_irqfd_deassign(kvm, args);\n\n\treturn kvm_irqfd_assign(kvm, args);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "TEST(BSONValidateFast, Simple0 ) {\n        BSONObj x;\n        ASSERT_OK( validateBSON( x.objdata(), x.objsize() ) );\n\n        x = BSON( \"foo\" << 17 << \"bar\" << \"eliot\" );\n        ASSERT_OK( validateBSON( x.objdata(), x.objsize() ) );\n\n    }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int Camera2Client::getCaptureStreamId() const {\n return mJpegProcessor->getStreamId();\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void vcpu_load(struct kvm_vcpu *vcpu)\n{\n\tint cpu;\n\n\tmutex_lock(&vcpu->mutex);\n\tif (unlikely(vcpu->pid != current->pids[PIDTYPE_PID].pid)) {\n\t\t/* The thread running this VCPU changed. */\n\t\tstruct pid *oldpid = vcpu->pid;\n\t\tstruct pid *newpid = get_task_pid(current, PIDTYPE_PID);\n\t\trcu_assign_pointer(vcpu->pid, newpid);\n\t\tsynchronize_rcu();\n\t\tput_pid(oldpid);\n\t}\n\tcpu = get_cpu();\n\tpreempt_notifier_register(&vcpu->preempt_notifier);\n\tkvm_arch_vcpu_load(vcpu, cpu);\n\tput_cpu();\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int cap_task_setscheduler(struct task_struct *p)\n{\n\treturn cap_safe_nice(p);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static uint32_t GetKeyForEntryImpl(Isolate* isolate,\n Handle<SeededNumberDictionary> dictionary,\n int entry, PropertyFilter filter) {\n DisallowHeapAllocation no_gc;\n Object* raw_key = dictionary->KeyAt(entry);\n if (!dictionary->IsKey(isolate, raw_key)) return kMaxUInt32;\n return FilterKey(dictionary, entry, raw_key, filter);\n }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline __u32 skb_get_rxhash(struct sk_buff *skb)\n{\n\tif (!skb->l4_rxhash)\n\t\t__skb_get_rxhash(skb);\n\n\treturn skb->rxhash;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "ax25_cb *ax25_create_cb(void)\n{\n\tax25_cb *ax25;\n\n\tif ((ax25 = kzalloc(sizeof(*ax25), GFP_ATOMIC)) == NULL)\n\t\treturn NULL;\n\n\tatomic_set(&ax25->refcount, 1);\n\n\tskb_queue_head_init(&ax25->write_queue);\n\tskb_queue_head_init(&ax25->frag_queue);\n\tskb_queue_head_init(&ax25->ack_queue);\n\tskb_queue_head_init(&ax25->reseq_queue);\n\n\tax25_setup_timers(ax25);\n\n\tax25_fillin_cb(ax25, NULL);\n\n\tax25->state = AX25_STATE_0;\n\n\treturn ax25;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int hub_resume(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\thub_activate(hub, HUB_RESUME);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "set_error_string( const char *message )\n{\n\tif ( _globus_error_message ) {\n\t\tfree( const_cast<char *>(_globus_error_message) );\n\t}\n\t_globus_error_message = strdup( message );\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void net_ns_get_ownership(const struct net *net, kuid_t *uid, kgid_t *gid)\n{\n\tif (net) {\n\t\tkuid_t ns_root_uid = make_kuid(net->user_ns, 0);\n\t\tkgid_t ns_root_gid = make_kgid(net->user_ns, 0);\n\n\t\tif (uid_valid(ns_root_uid))\n\t\t\t*uid = ns_root_uid;\n\n\t\tif (gid_valid(ns_root_gid))\n\t\t\t*gid = ns_root_gid;\n\t} else {\n\t\t*uid = GLOBAL_ROOT_UID;\n\t\t*gid = GLOBAL_ROOT_GID;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static rdpPrinterDriver* printer_load_backend(const char* backend)\n{\n\ttypedef rdpPrinterDriver* (*backend_load_t)(void);\n\tunion {\n\t\tPVIRTUALCHANNELENTRY entry;\n\t\tbackend_load_t backend;\n\t} fktconv;\n\n\tfktconv.entry = freerdp_load_channel_addin_entry(\"printer\", backend, NULL, 0);\n\tif (!fktconv.entry)\n\t\treturn NULL;\n\n\treturn fktconv.backend();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const unsigned char *buf, size_t nr)\n{\n\tconst unsigned char *b = buf;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint c;\n\tssize_t retval = 0;\n\n\t/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */\n\tif (L_TOSTOP(tty) && file->f_op->write != redirected_tty_write) {\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\t/* Write out any echoed characters that are still pending */\n\tprocess_echoes(tty);\n\n\tadd_wait_queue(&tty->write_wait, &wait);\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (O_OPOST(tty)) {\n\t\t\twhile (nr > 0) {\n\t\t\t\tssize_t num = process_output_block(tty, b, nr);\n\t\t\t\tif (num < 0) {\n\t\t\t\t\tif (num == -EAGAIN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tretval = num;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tb += num;\n\t\t\t\tnr -= num;\n\t\t\t\tif (nr == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *b;\n\t\t\t\tif (process_output(c, tty) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb++; nr--;\n\t\t\t}\n \t\t\tif (tty->ops->flush_chars)\n \t\t\t\ttty->ops->flush_chars(tty);\n \t\t} else {\n \t\t\twhile (nr > 0) {\n \t\t\t\tc = tty->ops->write(tty, b, nr);\n \t\t\t\tif (c < 0) {\n \t\t\t\t\tretval = c;\n \t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tif (!c)\n\t\t\t\t\tbreak;\n\t\t\t\tb += c;\n\t\t\t\tnr -= c;\n\t\t\t}\n\t\t}\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tup_read(&tty->termios_rwsem);\n\n\t\tschedule();\n\n\t\tdown_read(&tty->termios_rwsem);\n\t}\nbreak_out:\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (b - buf != nr && tty->fasync)\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tup_read(&tty->termios_rwsem);\n\treturn (b - buf) ? b - buf : retval;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static unsigned int name_hash(struct fuse *f, fuse_ino_t parent,\n                              const char *name)\n{\n    unsigned int hash = *name;\n\n    if (hash)\n        for (name += 1; *name != '\\0'; name++)\n            hash = (hash << 5) - hash + *name;\n\n    return (hash + parent) % f->name_table_size;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void CDCCBounce::Disconnected() {\n\tDEBUG(GetSockName() << \" == Disconnected()\");\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n \telse\n \t\tci->hcd = hcd;\n \n \treturn ret;\n }",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static bool AcceptsEditingFocus(const Element& element) {\n  DCHECK(HasEditableStyle(element));\n\n  return element.GetDocument().GetFrame() && RootEditableElement(element);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void pl110_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = pl110_initfn;\n\n    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_pl110;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "Map* empty_object_map() {\n    return context()->native_context()->object_function()->map();\n  }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "CSSStyleSheet::CSSStyleSheet(CSSStyleSheet* parentSheet, const String& href, const KURL& baseURL, const String& charset)\n    : StyleSheet(parentSheet, href, baseURL)\n    , m_doc(parentSheet ? parentSheet->doc() : 0)\n    , m_namespaces(0)\n    , m_charset(charset)\n    , m_loadCompleted(false)\n    , m_strictParsing(!parentSheet || parentSheet->useStrictParsing())\n    , m_isUserStyleSheet(parentSheet ? parentSheet->isUserStyleSheet() : false)\n    , m_hasSyntacticallyValidCSSHeader(true)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void cpu_print_filter(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (is_ready_for_join(pid) == false) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\tprint_cpu(pid);\n\texit(0);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void object_property_add_link(Object *obj, const char *name,\n\n                              const char *type, Object **child,\n\n                              void (*check)(Object *, const char *,\n\n                                            Object *, Error **),\n\n                              ObjectPropertyLinkFlags flags,\n\n                              Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    LinkProperty *prop = g_malloc(sizeof(*prop));\n\n    gchar *full_type;\n\n    ObjectProperty *op;\n\n\n\n    prop->child = child;\n\n    prop->check = check;\n\n    prop->flags = flags;\n\n\n\n    full_type = g_strdup_printf(\"link<%s>\", type);\n\n\n\n    op = object_property_add(obj, name, full_type,\n\n                             object_get_link_property,\n\n                             check ? object_set_link_property : NULL,\n\n                             object_release_link_property,\n\n                             prop,\n\n                             &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        g_free(prop);\n\n        goto out;\n\n    }\n\n\n\n    op->resolve = object_resolve_link_property;\n\n\n\nout:\n\n    g_free(full_type);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "Mutex* debugger_access() { return debugger_access_; }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": " *  */\nPHP_METHOD(DateTimeZone, __set_state)\n{\n\tphp_timezone_obj *tzobj;\n\tzval             *array;\n\tHashTable        *myht;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a\", &array) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tmyht = HASH_OF(array);\n\n\tphp_date_instantiate(date_ce_timezone, return_value TSRMLS_CC);\n\ttzobj = (php_timezone_obj *) zend_object_store_get_object(return_value TSRMLS_CC);\n\tphp_date_timezone_initialize_from_hash(&return_value, &tzobj, myht TSRMLS_CC);",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int64_t qmp_guest_get_time(Error **errp)\n{\n   int ret;\n   qemu_timeval tq;\n\n   ret = qemu_gettimeofday(&tq);\n   if (ret < 0) {\n       error_setg_errno(errp, errno, \"Failed to get time\");\n       return -1;\n   }\n\n   return tq.tv_sec * 1000000000LL + tq.tv_usec * 1000;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "QPDFObjectHandle::parse(PointerHolder<InputSource> input,\n                        std::string const& object_description,\n                        QPDFTokenizer& tokenizer, bool& empty,\n                        StringDecrypter* decrypter, QPDF* context)\n{\n    return parseInternal(input, object_description, tokenizer, empty,\n                         decrypter, context, false, false, false);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int ql_link_down_detect(struct ql3_adapter *qdev)\n{\n\tstruct ql3xxx_port_registers __iomem *port_regs =\n\t\t\tqdev->mem_map_registers;\n\tu32 bitToCheck = 0;\n\tu32 temp;\n\n\tswitch (qdev->mac_index) {\n\tcase 0:\n\t\tbitToCheck = ISP_CONTROL_LINK_DN_0;\n\t\tbreak;\n\tcase 1:\n\t\tbitToCheck = ISP_CONTROL_LINK_DN_1;\n\t\tbreak;\n\t}\n\n\ttemp =\n\t    ql_read_common_reg(qdev, &port_regs->CommonRegs.ispControlStatus);\n\treturn (temp & bitToCheck) != 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "angle_between(const fz_point u, const fz_point v)\n{\n\tfloat det = u.x * v.y - u.y * v.x;\n\tfloat sign = (det < 0 ? -1 : 1);\n\tfloat magu = u.x * u.x + u.y * u.y;\n\tfloat magv = v.x * v.x + v.y * v.y;\n\tfloat udotv = u.x * v.x + u.y * v.y;\n\tfloat t = udotv / (magu * magv);\n\t/* guard against rounding errors when near |1| (where acos will return NaN) */\n\tif (t < -1) t = -1;\n\tif (t > 1) t = 1;\n\treturn sign * acosf(t);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void nfs_fattr_init_names(struct nfs_fattr *fattr,\n\t\tstruct nfs4_string *owner_name,\n\t\tstruct nfs4_string *group_name)\n{\n\tfattr->owner_name = owner_name;\n\tfattr->group_name = group_name;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void vmx_get_gdt(struct kvm_vcpu *vcpu, struct descriptor_table *dt)\n{\n\tdt->limit = vmcs_read32(GUEST_GDTR_LIMIT);\n\tdt->base = vmcs_readl(GUEST_GDTR_BASE);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void snd_usbmidi_novation_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t\tstruct urb *urb)\n{\n\tuint8_t *transfer_buffer;\n\tint count;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\ttransfer_buffer = urb->transfer_buffer;\n\tcount = snd_rawmidi_transmit(ep->ports[0].substream,\n\t\t\t\t     &transfer_buffer[2],\n\t\t\t\t     ep->max_transfer - 2);\n\tif (count < 1) {\n\t\tep->ports[0].active = 0;\n\t\treturn;\n\t}\n\ttransfer_buffer[0] = 0;\n\ttransfer_buffer[1] = count;\n\turb->transfer_buffer_length = 2 + count;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int assigned_device_enable_guest_msix(struct kvm *kvm,\n\t\t\tstruct kvm_assigned_dev_kernel *dev,\n\t\t\tstruct kvm_assigned_irq *irq)\n{\n\tdev->guest_irq = irq->guest_irq;\n\tdev->ack_notifier.gsi = -1;\n\tdev->host_irq_disabled = false;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\n \t/* Limit the size of the queue to prevent DOS attacks */\n \tif (pqueue_size(queue->q) >= 100)\n \t\treturn 0;\n \trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n \titem = pitem_new(priority, rdata);\n \tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\t\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\t\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\n\titem->data = rdata;\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Store bio_dgram_sctp_rcvinfo struct */\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\t\n \tif (!ssl3_setup_buffers(s))\n \t\t{\n \t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n \t\tOPENSSL_free(rdata);\n \t\tpitem_free(item);\n\t\treturn(0);\n \t\t}\n \n \t/* insert should not fail, since duplicates are dropped */\n \tif (pqueue_insert(queue->q, item) == NULL)\n \t\t{\n \t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n \t\tOPENSSL_free(rdata);\n \t\tpitem_free(item);\n\t\treturn(0);\n \t\t}\n \n \treturn(1);\n\t}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int ssl_verify_server_cert(Vio *vio, const char* server_hostname, const char **errptr)\n{\n  SSL *ssl;\n  X509 *server_cert;\n  char *cp1, *cp2;\n  char *buf;\n  DBUG_ENTER(\"ssl_verify_server_cert\");\n  DBUG_PRINT(\"enter\", (\"server_hostname: %s\", server_hostname));\n\n  if (!(ssl= (SSL*)vio->ssl_arg))\n  {\n    *errptr= \"No SSL pointer found\";\n    DBUG_RETURN(1);\n  }\n\n  if (!server_hostname)\n  {\n    *errptr= \"No server hostname supplied\";\n    DBUG_RETURN(1);\n  }\n\n  if (!(server_cert= SSL_get_peer_certificate(ssl)))\n  {\n    *errptr= \"Could not get server certificate\";\n    DBUG_RETURN(1);\n  }\n\n  if (X509_V_OK != SSL_get_verify_result(ssl))\n  {\n    *errptr= \"Failed to verify the server certificate\";\n    X509_free(server_cert);\n    DBUG_RETURN(1);\n  }\n  /*\n    We already know that the certificate exchanged was valid; the SSL library\n    handled that. Now we need to verify that the contents of the certificate\n    are what we expect.\n  */\n\n  buf= X509_NAME_oneline(X509_get_subject_name(server_cert), 0, 0);\n  X509_free (server_cert);\n\n  if (!buf)\n  {\n    *errptr= \"Out of memory\";\n    DBUG_RETURN(1);\n  }\n\n  DBUG_PRINT(\"info\", (\"hostname in cert: %s\", buf));\n  cp1= strstr(buf, \"/CN=\");\n  if (cp1)\n  {\n    cp1+= 4; /* Skip the \"/CN=\" that we found */\n    /* Search for next / which might be the delimiter for email */\n    cp2= strchr(cp1, '/');\n    if (cp2)\n      *cp2= '\\0';\n    DBUG_PRINT(\"info\", (\"Server hostname in cert: %s\", cp1));\n    if (!strcmp(cp1, server_hostname))\n    {\n      free(buf);\n      /* Success */\n      DBUG_RETURN(0);\n    }\n  }\n  *errptr= \"SSL certificate validation failure\";\n  free(buf);\n  DBUG_RETURN(1);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void cloop_close(BlockDriverState *bs)\n\n{\n\n    BDRVCloopState *s = bs->opaque;\n\n    if (s->n_blocks > 0) {\n\n        g_free(s->offsets);\n\n    }\n\n    g_free(s->compressed_block);\n\n    g_free(s->uncompressed_block);\n\n    inflateEnd(&s->zstream);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void HtmlOutputDev::addBackgroundImage(const std::string& img) {\n  backgroundImages.push_back(img);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void __exit mcryptd_exit(void)\n{\n\tmcryptd_fini_queue(&mqueue);\n\tcrypto_unregister_template(&mcryptd_tmpl);\n\tfree_percpu(mcryptd_flist);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "BSONObj spec() {\n        return BSON(\"$ne\" << BSON_ARRAY(1 << \"$a\"));\n    }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "GLvoid StubGLBindBuffer(GLenum target, GLuint buffer) {\n  glBindBuffer(target, buffer);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "TfLiteRegistration* Register_SPACE_TO_BATCH_ND_REF() {\n  static TfLiteRegistration r = {\n      nullptr, nullptr, space_to_batch_nd::Prepare,\n      space_to_batch_nd::Eval<space_to_batch_nd::kReference>};\n  return &r;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void pdf_run_v(fz_context *ctx, pdf_processor *proc, float x2, float y2, float x3, float y3)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tfz_curvetov(ctx, pr->path, x2, y2, x3, y3);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void setPublicSuffix(const blink::WebString& suffix)\n    {\n        m_length = suffix.length();\n    }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int size() const { return size_; }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void socket_start_outgoing_migration(MigrationState *s,\n\n                                            SocketAddress *saddr,\n\n                                            Error **errp)\n\n{\n\n    QIOChannelSocket *sioc = qio_channel_socket_new();\n\n    qio_channel_socket_connect_async(sioc,\n\n                                     saddr,\n\n                                     socket_outgoing_migration,\n\n                                     s,\n\n                                     NULL);\n\n    qapi_free_SocketAddress(saddr);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int Curl_removeHandleFromPipeline(struct Curl_easy *handle,\n                                  struct curl_llist *pipeline)\n{\n  if(pipeline) {\n    struct curl_llist_element *curr;\n\n    curr = pipeline->head;\n    while(curr) {\n      if(curr->ptr == handle) {\n        Curl_llist_remove(pipeline, curr, NULL);\n        return 1; /* we removed a handle */\n      }\n      curr = curr->next;\n    }\n  }\n\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void beep() {\n    fprintf(stderr, \"\\x7\");  // ctrl-G == bell/beep\n    fflush(stderr);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int afSetVirtualPCMMapping (AFfilehandle file, int trackid,\n\tdouble slope, double intercept, double minClip, double maxClip)\n{\n\t_Track\t*track;\n\n\tif (!_af_filehandle_ok(file))\n\t\treturn -1;\n\n\tif ((track = _af_filehandle_get_track(file, trackid)) == NULL)\n\t\treturn -1;\n\n\ttrack->v.pcm.slope = slope;\n\ttrack->v.pcm.intercept = intercept;\n\ttrack->v.pcm.minClip = minClip;\n\ttrack->v.pcm.maxClip = maxClip;\n\n\ttrack->ms->setDirty();\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "ZEND_API zval* ZEND_FASTCALL zend_hash_add_empty_element(HashTable *ht, zend_string *key)\n{\n\tzval dummy;\n\n\tZVAL_NULL(&dummy);\n\treturn zend_hash_add(ht, key, &dummy);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void AppCacheGroup::RemoveCache(AppCache* cache) {\n   DCHECK(cache->associated_hosts().empty());\n   if (cache == newest_complete_cache_) {\n    CancelUpdate();\n     AppCache* tmp_cache = newest_complete_cache_;\n     newest_complete_cache_ = nullptr;\n     tmp_cache->set_owning_group(nullptr);  // may cause this group to be deleted\n   } else {\n     scoped_refptr<AppCacheGroup> protect(this);\n\n    Caches::iterator it =\n        std::find(old_caches_.begin(), old_caches_.end(), cache);\n    if (it != old_caches_.end()) {\n      AppCache* tmp_cache = *it;\n      old_caches_.erase(it);\n      tmp_cache->set_owning_group(nullptr);  // may cause group to be released\n    }\n\n    if (!is_obsolete() && old_caches_.empty() &&\n        !newly_deletable_response_ids_.empty()) {\n      storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);\n      newly_deletable_response_ids_.clear();\n    }\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void cgroup_pressure_release(struct kernfs_open_file *of)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tpsi_trigger_replace(&ctx->psi.trigger, NULL);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void dce100_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\t/* The entry could have been deleted from the\n\t\t\t * list meanwhile and thus the next pointer is\n\t\t\t * no longer valid.  Play it safe and restart\n\t\t\t * the scan.  Forward progress is ensured\n\t\t\t * because we set s->ax25_dev to NULL and we\n\t\t\t * are never passed a NULL 'dev' argument.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ServerInstanceDirTest(): tmpDir(\"server_instance_dir_test.tmp\") {\n\t\t\tparentDir = \"server_instance_dir_test.tmp\";\n\t\t\tnobodyGroup = getPrimaryGroupName(\"nobody\");\n\t\t}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void GfxSeparationColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {\n  double x;\n  double c[gfxColorMaxComps];\n  GfxColor color2;\n  int i;\n\n  x = colToDbl(color->c[0]);\n  func->transform(&x, c);\n  for (i = 0; i < alt->getNComps(); ++i) {\n    color2.c[i] = dblToCol(c[i]);\n  }\n  alt->getRGB(&color2, rgb);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void palette8torgb16(const uint8_t *src, uint8_t *dst, unsigned num_pixels, const uint8_t *palette)\n\n{\n\n\tunsigned i;\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((uint16_t *)dst)[i] = ((uint16_t *)palette)[ src[i] ];\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int perf_default_core_config(const char *var __used, const char *value __used)\n{\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void input_type_enum(Visitor *v, int *obj, const char *strings[],\n\n                     const char *kind, const char *name,\n\n                     Error **errp)\n\n{\n\n    int64_t value = 0;\n\n    char *enum_str;\n\n\n\n    assert(strings);\n\n\n\n    visit_type_str(v, &enum_str, name, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n\n\n    while (strings[value] != NULL) {\n\n        if (strcmp(strings[value], enum_str) == 0) {\n\n            break;\n\n        }\n\n        value++;\n\n    }\n\n\n\n    if (strings[value] == NULL) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, enum_str);\n\n        g_free(enum_str);\n\n        return;\n\n    }\n\n\n\n    g_free(enum_str);\n\n    *obj = value;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "push_attrs(cattr ca, cattrflags caflagsmask)\n{\n  if (cattr_stack_len == lengthof(cattr_stack)) {\n    for (int i = 1; i < cattr_stack_len; i++)\n      cattr_stack[i - 1] = cattr_stack[i];\n    cattr_stack_len--;\n  }\n  //printf(\"push_attrs[%d] %llX\\n\", cattr_stack_len, caflagsmask);\n  cattr_stack[cattr_stack_len].ca = ca;\n  cattr_stack[cattr_stack_len].mask = caflagsmask;\n  cattr_stack_len++;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static uint32_t suov32(CPUTriCoreState *env, int64_t arg)\n\n{\n\n    uint32_t ret;\n\n    int64_t max_pos = UINT32_MAX;\n\n    if (arg > max_pos) {\n\n        env->PSW_USB_V = (1 << 31);\n\n        env->PSW_USB_SV = (1 << 31);\n\n        ret = (target_ulong)max_pos;\n\n    } else {\n\n        if (arg < 0) {\n\n            env->PSW_USB_V = (1 << 31);\n\n            env->PSW_USB_SV = (1 << 31);\n\n            ret = 0;\n\n        } else {\n\n            env->PSW_USB_V = 0;\n\n            ret = (target_ulong)arg;\n\n        }\n\n     }\n\n    env->PSW_USB_AV = arg ^ arg * 2u;\n\n    env->PSW_USB_SAV |= env->PSW_USB_AV;\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void fd_start_incoming_migration(const char *infd, Error **errp)\n\n{\n\n    int fd;\n\n    QEMUFile *f;\n\n\n\n    DPRINTF(\"Attempting to start an incoming migration via fd\\n\");\n\n\n\n    fd = strtol(infd, NULL, 0);\n\n    f = qemu_fdopen(fd, \"rb\");\n\n    if(f == NULL) {\n\n        error_setg_errno(errp, errno, \"failed to open the source descriptor\");\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(fd, NULL, fd_accept_incoming_migration, NULL, f);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "add_node_nocopy(xmlNode * parent, const char *name, xmlNode * child)\n{\n    add_node_copy(parent, child);\n    free_xml(child);\n    return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "//! Access to a pixel value, using Neumann boundary conditions for the X-coordinate \\const.\n    const T& atX(const int x, const int y=0, const int z=0, const int c=0) const {\n      if (is_empty())\n        throw CImgInstanceException(_cimg_instance\n                                    \"atX(): Empty instance.\",\n                                    cimg_instance);\n      return _atX(x,y,z,c);",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void __ref free_initmem(void)\n{\n\te820_reallocate_tables();\n\n\tfree_init_pages(\"unused kernel\",\n\t\t\t(unsigned long)(&__init_begin),\n\t\t\t(unsigned long)(&__init_end));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void rlvl_destroy(jpc_enc_rlvl_t *rlvl)\n{\n\tjpc_enc_band_t *band;\n\tuint_fast16_t bandno;\n\n\tif (rlvl->bands) {\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tband_destroy(band);\n\t\t}\n\t\tjas_free(rlvl->bands);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void kvm_get_pfn(pfn_t pfn)\n{\n\tif (!kvm_is_mmio_pfn(pfn))\n\t\tget_page(pfn_to_page(pfn));\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "poppler_color_copy (PopplerColor *color)\n{\n  PopplerColor *new_color;\n\n  new_color = g_new (PopplerColor, 1);\n  *new_color = *color;\n\n  return new_color;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "GF_Err snro_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->SeqOffset);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "event_raise(uschar * action, const uschar * event, uschar * ev_data)\n{\nuschar * s;\nif (action)\n  {\n  DEBUG(D_deliver)\n    debug_printf(\"Event(%s): event_action=|%s| delivery_IP=%s\\n\",\n      event,\n      action, deliver_host_address);\n\n  event_name = event;\n  event_data = ev_data;\n\n  if (!(s = expand_string(action)) && *expand_string_message)\n    log_write(0, LOG_MAIN|LOG_PANIC,\n      \"failed to expand event_action %s in %s: %s\\n\",\n      event, transport_name, expand_string_message);\n\n  event_name = event_data = NULL;\n\n  /* If the expansion returns anything but an empty string, flag for\n  the caller to modify his normal processing\n  */\n  if (s && *s)\n    {\n    DEBUG(D_deliver)\n      debug_printf(\"Event(%s): event_action returned \\\"%s\\\"\\n\", event, s);\n    return s;\n    }\n  }\nreturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool Discovered_table_list::add_file(const char *fname)\n{\n  bool is_temp= strncmp(fname, STRING_WITH_LEN(tmp_file_prefix)) == 0;\n\n  if (is_temp && !with_temps)\n    return 0;\n\n  char tname[SAFE_NAME_LEN + 1];\n  size_t tlen= filename_to_tablename(fname, tname, sizeof(tname), is_temp);\n  return add_table(tname, tlen);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static double filter_generalized_cubic(const double t)\n{\n\tconst double a = -DEFAULT_FILTER_GENERALIZED_CUBIC;\n\tdouble abs_t = (double)fabs(t);\n\tdouble abs_t_sq = abs_t * abs_t;\n\tif (abs_t < 1) return (a + 2) * abs_t_sq * abs_t - (a + 3) * abs_t_sq + 1;\n\tif (abs_t < 2) return a * abs_t_sq * abs_t - 5 * a * abs_t_sq + 8 * a * abs_t - 4 * a;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "size_t V4L2JpegEncodeAccelerator::EncodedInstance::InputBufferQueuedCount() {\n  return input_buffer_map_.size() - free_input_buffers_.size();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static bool HasAccessorsImpl(JSObject* holder,\n FixedArrayBase* backing_store) {\n FixedArray* parameter_map = FixedArray::cast(backing_store);\n FixedArrayBase* arguments = FixedArrayBase::cast(parameter_map->get(1));\n return ArgumentsAccessor::HasAccessorsImpl(holder, arguments);\n }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "AuthenticatorInsertAndActivateUsbSheetModel::GetOtherTransportsMenuModel() {\n  return other_transports_menu_model_.get();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static Jsi_RC MySqlErrorNoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    int n = mysql_errno(jdb->db);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);\n    return JSI_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "xfs_init_percpu_counters(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\terror;\n\n\terror = percpu_counter_init(&mp->m_icount, 0, GFP_KERNEL);\n\tif (error)\n\t\treturn -ENOMEM;\n\n\terror = percpu_counter_init(&mp->m_ifree, 0, GFP_KERNEL);\n\tif (error)\n\t\tgoto free_icount;\n\n\terror = percpu_counter_init(&mp->m_fdblocks, 0, GFP_KERNEL);\n\tif (error)\n\t\tgoto free_ifree;\n\n\treturn 0;\n\nfree_ifree:\n\tpercpu_counter_destroy(&mp->m_ifree);\nfree_icount:\n\tpercpu_counter_destroy(&mp->m_icount);\n\treturn -ENOMEM;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static double mp_norminf(_cimg_math_parser& mp) {\n        const unsigned int i_end = (unsigned int)mp.opcode[2];\n        switch (i_end - 3) {\n        case 1 : return cimg::abs(_mp_arg(3));\n        case 2 : return std::max(cimg::abs(_mp_arg(3)),cimg::abs(_mp_arg(4)));\n        }\n        double res = 0;\n        for (unsigned int i = 3; i<i_end; ++i) {\n          const double val = cimg::abs(_mp_arg(i));\n          if (val>res) res = val;\n        }\n        return res;",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int socket_peek(int fd, void *data, size_t length)\n{\n\treturn socket_receive_timeout(fd, data, length, MSG_PEEK, RECV_TIMEOUT);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void NavigatorServiceWorker::willDetachGlobalObjectFromFrame()\n{\n    if (m_serviceWorker) {\n        m_serviceWorker->willBeDetachedFromFrame();\n        m_serviceWorker = nullptr;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int retrans_to_secs(u8 retrans, int timeout, int rto_max)\n{\n\tint period = 0;\n\n\tif (retrans > 0) {\n\t\tperiod = timeout;\n\t\twhile (--retrans) {\n\t\t\ttimeout <<= 1;\n\t\t\tif (timeout > rto_max)\n\t\t\t\ttimeout = rto_max;\n\t\t\tperiod += timeout;\n\t\t}\n\t}\n\treturn period;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void mpol_rebind_nodemask(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tnodemask_t tmp;\n\n\tif (pol->flags & MPOL_F_STATIC_NODES)\n\t\tnodes_and(tmp, pol->w.user_nodemask, *nodes);\n\telse if (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\tmpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);\n\telse {\n\t\tnodes_remap(tmp, pol->v.nodes,pol->w.cpuset_mems_allowed,\n\t\t\t\t\t\t\t\t*nodes);\n\t\tpol->w.cpuset_mems_allowed = tmp;\n\t}\n\n\tif (nodes_empty(tmp))\n\t\ttmp = *nodes;\n\n\tpol->v.nodes = tmp;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int32_t gcd(int a, int b)\n{\n  if (a == 0 && b == 0) {\n    return 1;\n  }\n\n  if (a == 0) return b;\n  if (b == 0) return a;\n\n  int32_t h;\n\n  do {\n    h = a % b;\n    a = b;\n    b = h;\n  } while (b != 0);\n\n  return a;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static signed char min() { return ~max(); }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int vnc_tls_initialize(void)\n\n{\n\n    static int tlsinitialized = 0;\n\n\n\n    if (tlsinitialized)\n\n        return 1;\n\n\n\n    if (gnutls_global_init () < 0)\n\n        return 0;\n\n\n\n    /* XXX ought to re-generate diffie-hellman params periodically */\n\n    if (gnutls_dh_params_init (&dh_params) < 0)\n\n        return 0;\n\n    if (gnutls_dh_params_generate2 (dh_params, DH_BITS) < 0)\n\n        return 0;\n\n\n\n#if defined(_VNC_DEBUG) && _VNC_DEBUG >= 2\n\n    gnutls_global_set_log_level(10);\n\n    gnutls_global_set_log_function(vnc_debug_gnutls_log);\n\n#endif\n\n\n\n    tlsinitialized = 1;\n\n\n\n    return 1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "ProcPutImage(ClientPtr client)\n{\n    GC *pGC;\n    DrawablePtr pDraw;\n    long length;                /* length of scanline server padded */\n    long lengthProto;           /* length of scanline protocol padded */\n    char *tmpImage;\n\n    REQUEST(xPutImageReq);\n\n    REQUEST_AT_LEAST_SIZE(xPutImageReq);\n    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);\n    if (stuff->format == XYBitmap) {\n        if ((stuff->depth != 1) ||\n            (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))\n            return BadMatch;\n        length = BitmapBytePad(stuff->width + stuff->leftPad);\n    }\n    else if (stuff->format == XYPixmap) {\n        if ((pDraw->depth != stuff->depth) ||\n            (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))\n            return BadMatch;\n        length = BitmapBytePad(stuff->width + stuff->leftPad);\n        length *= stuff->depth;\n    }\n    else if (stuff->format == ZPixmap) {\n        if ((pDraw->depth != stuff->depth) || (stuff->leftPad != 0))\n            return BadMatch;\n        length = PixmapBytePad(stuff->width, stuff->depth);\n    }\n    else {\n        client->errorValue = stuff->format;\n        return BadValue;\n    }\n\n     tmpImage = (char *) &stuff[1];\n     lengthProto = length;\n \n    if (lengthProto >= (INT32_MAX / stuff->height))\n         return BadLength;\n \n     if ((bytes_to_int32(lengthProto * stuff->height) +\n         bytes_to_int32(sizeof(xPutImageReq))) != client->req_len)\n        return BadLength;\n\n    ReformatImage(tmpImage, lengthProto * stuff->height,\n                  stuff->format == ZPixmap ? BitsPerPixel(stuff->depth) : 1,\n                  ClientOrder(client));\n\n    (*pGC->ops->PutImage) (pDraw, pGC, stuff->depth, stuff->dstX, stuff->dstY,\n                           stuff->width, stuff->height,\n                           stuff->leftPad, stuff->format, tmpImage);\n\n    return Success;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline void atalk_dev_down(struct net_device *dev)\n{\n\tatrtr_device_down(dev);\t/* Remove all routes for the device */\n\taarp_device_down(dev);\t/* Remove AARP entries for the device */\n\tatif_drop_device(dev);\t/* Remove the device */\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\n\t/*\n\t * We have now ensured that nobody can start using ap from now on, but\n\t * we have to wait for all existing users to finish.\n\t */\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\n\t/* We must stop the queue to avoid potentially scribbling\n\t * on the free buffers. The sp->dead completion is not sufficient\n\t * to protect us from sp->xbuff access.\n\t */\n\tnetif_stop_queue(sp->dev);\n\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\n\tunregister_netdev(sp->dev);\n\n\t/* Free all 6pack frame buffers after unreg. */\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\n\tfree_netdev(sp->dev);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void setup_rt_frame(int sig, struct target_sigaction *ka,\n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUState *env)\n\n{\n\n    fprintf(stderr, \"setup_rt_frame: not implemented\\n\");\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "virtual void OnJSONParseSucceeded(const ListValue& wrapper) {\n    CHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n    manifest_parse_complete_ = true;\n    Value* value = NULL;\n    CHECK(wrapper.Get(0, &value));\n    if (value->IsType(Value::TYPE_DICTIONARY)) {\n      parsed_manifest_.reset(\n          static_cast<DictionaryValue*>(value)->DeepCopy());\n    } else {\n      parse_error_ = BeginInstallWithManifestFunction::MANIFEST_ERROR;\n    }\n    ReportResultsIfComplete();\n  }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "LocalFrame* Document::ExecutingFrame() {\n  LocalDOMWindow* window = ExecutingWindow();\n  if (!window)\n    return nullptr;\n  return window->GetFrame();\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int find_snapshot_by_id(BlockDriverState *bs, const char *id_str)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int i;\n\n\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        if (!strcmp(s->snapshots[i].id_str, id_str))\n\n            return i;\n\n    }\n\n    return -1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "SSL_SESSION *SSL_SESSION_new(void)\n\t{\n\tSSL_SESSION *ss;\n\n\tss=(SSL_SESSION *)OPENSSL_malloc(sizeof(SSL_SESSION));\n\tif (ss == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL_SESSION_NEW,ERR_R_MALLOC_FAILURE);\n\t\treturn(0);\n\t\t}\n\tmemset(ss,0,sizeof(SSL_SESSION));\n\n\tss->verify_result = 1; /* avoid 0 (= X509_V_OK) just in case */\n\tss->references=1;\n\tss->timeout=60*5+4; /* 5 minute timeout by default */\n\tss->time=(unsigned long)time(NULL);\n\tss->prev=NULL;\n\tss->next=NULL;\n\tss->compress_meth=0;\n#ifndef OPENSSL_NO_TLSEXT\n\tss->tlsext_hostname = NULL; \n#endif\n\tCRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);\n#ifndef OPENSSL_NO_PSK\n\tss->psk_identity_hint=NULL;\n\tss->psk_identity=NULL;\n#endif\n\treturn(ss);\n\t}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int rtp_asf_fix_header(uint8_t *buf, int len)\n\n{\n\n    uint8_t *p = buf, *end = buf + len;\n\n\n\n    if (len < sizeof(ff_asf_guid) * 2 + 22 ||\n\n        memcmp(p, ff_asf_header, sizeof(ff_asf_guid))) {\n\n        return -1;\n\n    }\n\n    p += sizeof(ff_asf_guid) + 14;\n\n    do {\n\n        uint64_t chunksize = AV_RL64(p + sizeof(ff_asf_guid));\n\n        if (memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {\n\n            if (chunksize > end - p)\n\n                return -1;\n\n            p += chunksize;\n\n            continue;\n\n        }\n\n\n\n        /* skip most of the file header, to min_pktsize */\n\n        p += 6 * 8 + 3 * 4 + sizeof(ff_asf_guid) * 2;\n\n        if (p + 8 <= end && AV_RL32(p) == AV_RL32(p + 4)) {\n\n            /* and set that to zero */\n\n            AV_WL32(p, 0);\n\n            return 0;\n\n        }\n\n        break;\n\n    } while (end - p >= sizeof(ff_asf_guid) + 8);\n\n\n\n    return -1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {\n  DCHECK_EQ(read_type_, kReadAsArrayBuffer);\n  if (array_buffer_result_)\n    return array_buffer_result_;\n\n   if (!raw_data_ || error_code_ != FileErrorCode::kOK)\n     return nullptr;\n \n  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\n  if (finished_loading_) {\n    array_buffer_result_ = result;\n    AdjustReportedMemoryUsageToV8(\n        -1 * static_cast<int64_t>(raw_data_->ByteLength()));\n    raw_data_.reset();\n   }\n  return result;\n }",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int uint64_mul_overflow(uint64_t a, uint64_t b, uint64_t *res)\n{\n    *res = a * b;\n    return (a > UINT64_MAX / b);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ZEND_API zval* ZEND_FASTCALL _zend_hash_index_add_new(HashTable *ht, zend_ulong h, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, h, pData, HASH_ADD | HASH_ADD_NEW ZEND_FILE_LINE_RELAY_CC);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void qemu_mutex_init(QemuMutex *mutex)\n\n{\n\n    int err;\n\n    pthread_mutexattr_t mutexattr;\n\n\n\n    pthread_mutexattr_init(&mutexattr);\n\n    pthread_mutexattr_settype(&mutexattr, PTHREAD_MUTEX_ERRORCHECK);\n\n    err = pthread_mutex_init(&mutex->lock, &mutexattr);\n\n    pthread_mutexattr_destroy(&mutexattr);\n\n    if (err)\n\n        error_exit(err, __func__);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static ssize_t bad_file_sendpage(struct file *file, struct page *page,\n\t\t\tint off, size_t len, loff_t *pos, int more)\n{\n\treturn -EIO;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void MainWindow::showUpgradePrompt()\n{\n    if (Settings.checkUpgradeAutomatic()) {\n        showStatusMessage(\"Checking for upgrade...\");\n        QNetworkRequest request(QUrl(\"https://check.shotcut.org/version.json\"));\n        QSslConfiguration sslConfig = request.sslConfiguration();\n        sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone);\n        request.setSslConfiguration(sslConfig);\n        m_network.get(request);\n    } else {\n        m_network.setStrictTransportSecurityEnabled(false);\n        QAction* action = new QAction(tr(\"Click here to check for a new version of Shotcut.\"), 0);\n        connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered()));\n        showStatusMessage(action, 15 /* seconds */);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int regset_xregset_fpregs_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tstruct fpu *target_fpu = &target->thread.fpu;\n\n\tif (boot_cpu_has(X86_FEATURE_FXSR) && target_fpu->fpstate_active)\n\t\treturn regset->n;\n\telse\n\t\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int bin2bnbits(DRBG_CTX *dctx, BIGNUM *r, const unsigned char *buf)\n\t{\n\tDRBG_EC_CTX *ectx = &dctx->d.ec;\n\tif (!BN_bin2bn(buf, dctx->seedlen, r))\n\t\treturn 0;\n\t/* If we have extra bits right shift off the end of r */\n\tif (ectx->exbits)\n\t\t{\n\t\tif (!BN_rshift(r, r, ectx->exbits))\n\t\t\treturn 0;\n\t\t}\n\treturn 1;\n\t}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_inc(&sbi->nr_pages[count_type]);\n\n\tif (count_type == F2FS_DIRTY_DENTS ||\n\t\t\tcount_type == F2FS_DIRTY_NODES ||\n\t\t\tcount_type == F2FS_DIRTY_META ||\n\t\t\tcount_type == F2FS_DIRTY_QDATA ||\n\t\t\tcount_type == F2FS_DIRTY_IMETA)\n\t\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void config_error(Monitor *mon, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n\n\n    va_start(ap, fmt);\n\n    if (mon) {\n\n        monitor_vprintf(mon, fmt, ap);\n\n    } else {\n\n        fprintf(stderr, \"qemu: \");\n\n        vfprintf(stderr, fmt, ap);\n\n        exit(1);\n\n    }\n\n    va_end(ap);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tif (rdp->decrypt_use_count >= 4096)\n\t{\n\t\tsecurity_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);\n\t\tcrypto_rc4_free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = crypto_rc4_init(rdp->decrypt_key, rdp->rc4_key_len);\n\t\trdp->decrypt_use_count = 0;\n\t}\n\tcrypto_rc4(rdp->rc4_decrypt_key, length, data, data);\n\trdp->decrypt_use_count += 1;\n\trdp->decrypt_checksum_use_count++;\n\treturn TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\n\tassert(game_config::path.empty() == false);\n\n\tstd::string result;\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\n\tbool already_found = false;\n\n\tif (filename[0] == '~')\n\t{\n\t\t// If the filename starts with '~', look in the user data directory.\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\t// If the filename begins with a \"./\", look in the same directory\n\t\t// as the file currently being preprocessed.\n\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\n\treturn result;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void mb_cpu_class_init(ObjectClass *oc, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    CPUClass *cc = CPU_CLASS(oc);\n    MicroBlazeCPUClass *mcc = MICROBLAZE_CPU_CLASS(oc);\n    mcc->parent_realize = dc->realize;\n    dc->realize = mb_cpu_realizefn;\n    mcc->parent_reset = cc->reset;\n    cc->reset = mb_cpu_reset;\n    cc->has_work = mb_cpu_has_work;\n    cc->do_interrupt = mb_cpu_do_interrupt;\n    cc->cpu_exec_interrupt = mb_cpu_exec_interrupt;\n    cc->dump_state = mb_cpu_dump_state;\n    cc->set_pc = mb_cpu_set_pc;\n    cc->gdb_read_register = mb_cpu_gdb_read_register;\n    cc->gdb_write_register = mb_cpu_gdb_write_register;\n#ifdef CONFIG_USER_ONLY\n    cc->handle_mmu_fault = mb_cpu_handle_mmu_fault;\n#else\n    cc->do_unassigned_access = mb_cpu_unassigned_access;\n    cc->get_phys_page_debug = mb_cpu_get_phys_page_debug;\n#endif\n    dc->vmsd = &vmstate_mb_cpu;\n    dc->props = mb_properties;\n    cc->gdb_num_core_regs = 32 + 5;\n    cc->disas_set_info = mb_disas_set_info;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n if (!cmd)\n\t\tprintk(KERN_EMERG \"Restarting system.\\n\");\n else\n\t\tprintk(KERN_EMERG \"Restarting system with command '%s'.\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_RESTART);\n\tmachine_restart(cmd);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Lua::setParamsTable(lua_State* vm, const char* table_name,\n\t\t\t const char* query) const {\n  char outbuf[FILENAME_MAX];\n  char *where;\n  char *tok;\n\n  char *query_string = query ? strdup(query) : NULL;\n\n  lua_newtable(L);\n\n  if (query_string) {\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n\n    tok = strtok_r(query_string, \"&\", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        // ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s = %s\", tok, _equal);\n\n        if((decoded_buf = (char*)malloc(len+1)) != NULL) {\n\n          Utils::urlDecode(_equal, decoded_buf, len+1);\n\n\t  Utils::purifyHTTPparam(tok, true, false);\n\t  Utils::purifyHTTPparam(decoded_buf, false, false);\n\n\t  /* Now make sure that decoded_buf is not a file path */\n\t  FILE *fd;\n\t  if((decoded_buf[0] == '.')\n\t     && ((fd = fopen(decoded_buf, \"r\"))\n\t\t || (fd = fopen(realpath(decoded_buf, outbuf), \"r\")))) {\n\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Discarded '%s'='%s' as argument is a valid file path\",\n\t\t\t\t\t tok, decoded_buf);\n\t    decoded_buf[0] = '\\0';\n\t    fclose(fd);\n\t  }\n\n\t  /* ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, decoded_buf); */\n\n\t  /* put tok and the decoded buffer in to the table */\n\t  lua_push_str_table_entry(vm, tok, decoded_buf);\n\n          free(decoded_buf);\n        } else\n          ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n      }\n\n      tok = strtok_r(NULL, \"&\", &where);\n    } /* while */\n  }\n\n  if(query_string) free(query_string);\n\n  if(table_name)\n    lua_setglobal(L, table_name);\n  else\n    lua_setglobal(L, (char*)\"_GET\"); /* Default */\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void hrtick_start(struct rq *rq, u64 delay)\n{\n\t/*\n\t * Don't schedule slices shorter than 10000ns, that just\n\t * doesn't make sense. Rely on vruntime for fairness.\n\t */\n\tdelay = max_t(u64, delay, 10000LL);\n\thrtimer_start(&rq->hrtick_timer, ns_to_ktime(delay),\n\t\t      HRTIMER_MODE_REL_PINNED);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "}\n    inline int mod(const char x, const char m) {\n#if defined(CHAR_MAX) && CHAR_MAX==255\n      return x%m;\n#else\n      return x>=0?x%m:(x%m?m + x%m:0);\n#endif",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void *grow_array(void *array, int elem_size, int *size, int new_size)\n\n{\n\n    if (new_size >= INT_MAX / elem_size) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Array too big.\\n\");\n\n        exit(1);\n\n    }\n\n    if (*size < new_size) {\n\n        uint8_t *tmp = av_realloc(array, new_size*elem_size);\n\n        if (!tmp) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Could not alloc buffer.\\n\");\n\n            exit(1);\n\n        }\n\n        memset(tmp + *size*elem_size, 0, (new_size-*size) * elem_size);\n\n        *size = new_size;\n\n        return tmp;\n\n    }\n\n    return array;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void monitor_qmp_event(void *opaque, int event)\n\n{\n\n    QObject *data;\n\n    Monitor *mon = opaque;\n\n\n\n    switch (event) {\n\n    case CHR_EVENT_OPENED:\n\n        mon->qmp.in_command_mode = false;\n\n        data = get_qmp_greeting();\n\n        monitor_json_emitter(mon, data);\n\n        qobject_decref(data);\n\n        mon_refcount++;\n\n        break;\n\n    case CHR_EVENT_CLOSED:\n\n        json_message_parser_destroy(&mon->qmp.parser);\n\n        json_message_parser_init(&mon->qmp.parser, handle_qmp_command);\n\n        mon_refcount--;\n\n        monitor_fdsets_cleanup();\n\n        break;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void __init hugetlb_init_hstates(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\tif (minimum_order > huge_page_order(h))\n\t\t\tminimum_order = huge_page_order(h);\n\n\t\t/* oversize hugepages were init'ed in early boot */\n\t\tif (!hstate_is_gigantic(h))\n\t\t\thugetlb_hstate_alloc_pages(h);\n\t}\n\tVM_BUG_ON(minimum_order == UINT_MAX);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ofpacts_format(const struct ofpact *ofpacts, size_t ofpacts_len,\n               struct ds *string)\n{\n    if (!ofpacts_len) {\n        ds_put_format(string, \"%sdrop%s\", colors.drop, colors.end);\n    } else {\n        const struct ofpact *a;\n\n        OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n            if (a != ofpacts) {\n                ds_put_char(string, ',');\n            }\n\n            ofpact_format(a, string);\n        }\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void irda_connect_response(struct irda_sock *self)\n{\n\tstruct sk_buff *skb;\n\n\tIRDA_DEBUG(2, \"%s()\\n\", __func__);\n\n\tskb = alloc_skb(TTP_MAX_HEADER + TTP_SAR_HEADER, GFP_KERNEL);\n\tif (skb == NULL) {\n\t\tIRDA_DEBUG(0, \"%s() Unable to allocate sk_buff!\\n\",\n\t\t\t   __func__);\n\t\treturn;\n\t}\n\n\t/* Reserve space for MUX_CONTROL and LAP header */\n\tskb_reserve(skb, IRDA_MAX_HEADER);\n\n\tirttp_connect_response(self->tsap, self->max_sdu_size_rx, skb);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "TEST_CASE(\"Negated Class test\", \"[general]\")\n{\n    parser parser(R\"(\n        ROOT <- [^a-z_]+\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == true);\n\n    REQUIRE(parser.parse(\"ABC123\"));\n    REQUIRE_FALSE(parser.parse(\"ABcZ\"));\n    REQUIRE_FALSE(parser.parse(\"ABCZ_\"));\n    REQUIRE_FALSE(parser.parse(\"\"));\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer) { /*placeholder */}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void visit_type_int32(Visitor *v, int *value, const char *name, Error **errp)\n\n{\n\n    int64_t val = *value;\n\n    visit_type_int(v, &val, name, errp);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "MONGO_EXPORT void mongo_cursor_set_query( mongo_cursor *cursor, const bson *query ) {\n    cursor->query = query;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void linenoiseHistoryFree(void) {\n    if (history) {\n        for (int j = 0; j < historyLen; ++j)\n            free(history[j]);\n        historyLen = 0;\n        free(history);\n        history = 0;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int opverw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x00;\n\t\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xe8 | op->operands[0].reg;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "QPDFObjectHandle::newReserved(QPDF* qpdf)\n{\n    // Reserve a spot for this object by assigning it an object\n    // number, but then return an unresolved handle to the object.\n    QPDFObjectHandle reserved = qpdf->makeIndirectObject(\n\tQPDFObjectHandle(new QPDF_Reserved()));\n    QPDFObjectHandle result =\n        newIndirect(qpdf, reserved.objid, reserved.generation);\n    result.reserved = true;\n    return result;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void OmniboxViewWin::OnMButtonDown(UINT /*keys*/, const CPoint& /*point*/) {\n  tracking_double_click_ = false;\n\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "cdf_u16tos8(char *buf, size_t len, const uint16_t *p)\n{\n\tsize_t i;\n\tfor (i = 0; i < len && p[i]; i++)\n\t\tbuf[i] = (char)p[i];\n\tbuf[i] = '\\0';\n\treturn buf;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static gboolean udscs_server_accept_cb(GSocketService    *service,\n                                       GSocketConnection *socket_conn,\n                                       GObject           *source_object,\n                                       gpointer           user_data)\n{\n    struct udscs_server *server = user_data;\n    UdscsConnection *new_conn;\n\n    new_conn = g_object_new(UDSCS_TYPE_CONNECTION, NULL);\n    new_conn->debug = server->debug;\n    new_conn->read_callback = server->read_callback;\n    g_object_ref(socket_conn);\n    vdagent_connection_setup(VDAGENT_CONNECTION(new_conn),\n                             G_IO_STREAM(socket_conn),\n                             FALSE,\n                             sizeof(struct udscs_message_header),\n                             server->error_cb);\n\n    server->connections = g_list_prepend(server->connections, new_conn);\n\n    if (server->debug)\n        syslog(LOG_DEBUG, \"new client accepted: %p\", new_conn);\n\n    if (server->connect_callback)\n        server->connect_callback(new_conn);\n\n    return TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int path_lookup_open(int dfd, const char *name, unsigned int lookup_flags,\n\t\tstruct nameidata *nd, int open_flags)\n{\n\treturn __path_lookup_intent_open(dfd, name, lookup_flags, nd,\n\t\t\topen_flags, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "   Get the key size of cipher */\nPHP_FUNCTION(mcrypt_get_key_size)\n{\n\tchar *cipher;\n\tchar *module;\n\tint   cipher_len, module_len; \n\tchar *cipher_dir_string;\n\tchar *module_dir_string;\n\tMCRYPT td;\n\n\tMCRYPT_GET_INI\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\",\n\t\t&cipher, &cipher_len, &module, &module_len) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\ttd = mcrypt_module_open(cipher, cipher_dir_string, module, module_dir_string);\n\tif (td != MCRYPT_FAILED) {\n\t\tRETVAL_LONG(mcrypt_enc_get_key_size(td));\n\t\tmcrypt_module_close(td);\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, MCRYPT_OPEN_MODULE_FAILED);\n\t\tRETURN_FALSE;\n\t}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "native_handle* Parcel::readNativeHandle() const\n{\n int numFds, numInts;\n status_t err;\n    err = readInt32(&numFds);\n if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n if (err != NO_ERROR) return 0;\n\n    native_handle* h = native_handle_create(numFds, numInts);\n if (!h) {\n return 0;\n }\n\n \n     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n         h->data[i] = dup(readFileDescriptor());\n        if (h->data[i] < 0) err = BAD_VALUE;\n     }\n     err = read(h->data + numFds, sizeof(int)*numInts);\n     if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n }\n return h;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "compile_jump_to_end(endlabel_T **el, jumpwhen_T when, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    endlabel_T  *endlabel = ALLOC_CLEAR_ONE(endlabel_T);\n\n    if (endlabel == NULL)\n\treturn FAIL;\n    endlabel->el_next = *el;\n    *el = endlabel;\n    endlabel->el_end_label = instr->ga_len;\n\n    generate_JUMP(cctx, when, 0);\n    return OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void qemu_event_increment(void)\n\n{\n\n    SetEvent(qemu_event_handle);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n{\n\tDoQuickSanityCheck();\n\tModularArithmetic modn(m_n);\n\tInteger r, rInv;\n\tdo {\t// do this in a loop for people using small numbers for testing\n\t\tr.Randomize(rng, Integer::One(), m_n - Integer::One());\n\t\trInv = modn.MultiplicativeInverse(r);\n\t} while (rInv.IsZero());\n\tInteger re = modn.Square(r);\n\tre = modn.Multiply(re, x);\t\t\t// blind\n\n\tInteger cp=re%m_p, cq=re%m_q;\n\tif (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1)\n\t{\n\t\tcp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1;\n\t\tcq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1;\n\t}\n\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t\tcp = ModularSquareRoot(cp, m_p);\n\t\t\t#pragma omp section\n\t\t\t\tcq = ModularSquareRoot(cq, m_q);\n\t\t}\n\n\tInteger y = CRT(cq, m_q, cp, m_p, m_u);\n\ty = modn.Multiply(y, rInv);\t\t\t\t// unblind\n\ty = STDMIN(y, m_n-y);\n\tif (ApplyFunction(y) != x)\t\t\t\t// check\n\t\tthrow Exception(Exception::OTHER_ERROR, \"InvertibleRWFunction: computational error during private key operation\");\n\treturn y;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n \t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n \t\t\t\t    \"disallowed submodule name: %s\",\n \t\t\t\t    name);\n \tfree(name);\n \n \treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static uint64_t ahci_alloc(AHCIQState *ahci, size_t bytes)\n\n{\n\n    return qmalloc(ahci->parent, bytes);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "pg_snprintf(char *str, size_t count, const char *fmt,...)\n{\n\tint\t\t\tlen;\n\tva_list\t\targs;\n\n\tva_start(args, fmt);\n\tlen = pg_vsnprintf(str, count, fmt, args);\n\tva_end(args);\n\treturn len;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "handle_get_config_request(struct ofconn *ofconn, const struct ofp_header *oh)\n{\n    struct ofputil_switch_config config;\n    config.frag = ofconn_get_ofproto(ofconn)->frag_handling;\n    config.invalid_ttl_to_controller\n        = ofconn_get_invalid_ttl_to_controller(ofconn);\n    config.miss_send_len = ofconn_get_miss_send_len(ofconn);\n\n    ofconn_send_reply(ofconn, ofputil_encode_get_config_reply(oh, &config));\n\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void CMSEXPORT cmsFreeProfileSequenceDescription(cmsSEQ* pseq)\n{\n    cmsUInt32Number i;\n\n    for (i=0; i < pseq ->n; i++) {\n        if (pseq ->seq[i].Manufacturer != NULL) cmsMLUfree(pseq ->seq[i].Manufacturer);\n        if (pseq ->seq[i].Model != NULL) cmsMLUfree(pseq ->seq[i].Model);\n        if (pseq ->seq[i].Description != NULL) cmsMLUfree(pseq ->seq[i].Description);\n    }\n\n    if (pseq ->seq != NULL) _cmsFree(pseq ->ContextID, pseq ->seq);\n    _cmsFree(pseq -> ContextID, pseq);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "imapx_uidset_done (struct _uidset_state *ss,\n                   CamelIMAPXCommand *ic)\n{\n\tgint ret = FALSE;\n\n\tif (ss->last != 0) {\n\t\tif (ss->entries > 0)\n\t\t\tcamel_imapx_command_add (ic, \",\");\n\t\tif (ss->last == ss->start)\n\t\t\tcamel_imapx_command_add (ic, \"%u\", ss->last);\n\t\telse\n\t\t\tcamel_imapx_command_add (ic, \"%u:%u\", ss->start, ss->last);\n\t}\n\n\tret = ss->last != 0;\n\n\tss->start = 0;\n\tss->last = 0;\n\tss->uids = 0;\n\tss->entries = 0;\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int sctp_v4_available(union sctp_addr *addr, struct sctp_sock *sp)\n{\n\tstruct net *net = sock_net(&sp->inet.sk);\n\tint ret = inet_addr_type(net, addr->v4.sin_addr.s_addr);\n\n\n\tif (addr->v4.sin_addr.s_addr != htonl(INADDR_ANY) &&\n\t   ret != RTN_LOCAL &&\n\t   !sp->inet.freebind &&\n\t   !net->ipv4.sysctl_ip_nonlocal_bind)\n\t\treturn 0;\n\n\tif (ipv6_only_sock(sctp_opt2sk(sp)))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void split_certinfo(char *string, zval *hash)\n{\n\tchar *org = estrdup(string);\n\tchar *s = org;\n\tchar *split;\n\n\tif(org) {\n\t\tdo {\n\t\t\tchar *key;\n\t\t\tchar *val;\n\t\t\tchar *tmp;\n\n\t\t\tsplit = strstr(s, \"; \");\n\t\t\tif(split)\n\t\t\t\t*split = '\\0';\n\n\t\t\tkey = s;\n\t\t\ttmp = memchr(key, '=', 64);\n\t\t\tif(tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tval = tmp+1;\n\t\t\t\tadd_assoc_string(hash, key, val, 1);\n\t\t\t}\n\t\t\ts = split+2;\n\t\t} while(split);\n\t\tefree(org);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int checkout_conflict_add(\n\tcheckout_data *data,\n\tconst git_index_entry *conflict)\n{\n\tint error = git_index_remove(data->index, conflict->path, 0);\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgit_error_clear();\n\telse if (error < 0)\n\t\treturn error;\n\n\treturn git_index_add(data->index, conflict);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static ExitStatus trans_fop_ded(DisasContext *ctx, uint32_t insn,\n\n                                const DisasInsn *di)\n\n{\n\n    unsigned rt = extract32(insn, 0, 5);\n\n    unsigned ra = extract32(insn, 21, 5);\n\n    return do_fop_ded(ctx, rt, ra, di->f_ded);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "create_face_from_contents (FontLoadJob *job,\n                           gchar **contents,\n                           GError **error)\n{\n  FT_Error ft_error;\n  FT_Face retval;\n\n  ft_error = FT_New_Memory_Face (job->library,\n                                 (const FT_Byte *) job->face_contents,\n                                 (FT_Long) job->face_length,\n                                 job->face_index,\n                                 &retval);\n\n  if (ft_error != 0) {\n    g_autofree gchar *uri = g_file_get_uri (job->file);\n    g_set_error (error, G_IO_ERROR, 0,\n                 \"Unable to read the font face file '%s'\", uri);\n    return NULL;\n  }\n\n  *contents = g_steal_pointer (&job->face_contents);\n  return retval;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static QObject *qmp_output_first(QmpOutputVisitor *qov)\n\n{\n\n    QStackEntry *e = QTAILQ_LAST(&qov->stack, QStack);\n\n\n\n    /* FIXME - find a better way to deal with NULL values */\n\n    if (!e) {\n\n        return NULL;\n\n    }\n\n\n\n    return e->value;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "hufDecode\n    (const Int64 * \thcode,\t// i : encoding table\n     const HufDec * \thdecod,\t// i : decoding table\n     const char* \tin,\t// i : compressed input buffer\n     int\t\tni,\t// i : input size (in bits)\n     int\t\trlc,\t// i : run-length code\n     int\t\tno,\t// i : expected output size (in bytes)\n     unsigned short*\tout)\t//  o: uncompressed output buffer\n{\n    Int64 c = 0;\n    int lc = 0;\n    unsigned short * outb = out;\n    unsigned short * oe = out + no;\n    const char * ie = in + (ni + 7) / 8; // input byte size\n\n    //\n    // Loop on input bytes\n    //\n\n    while (in < ie)\n    {\n\tgetChar (c, lc, in);\n\n\t//\n\t// Access decoding table\n\t//\n\n\twhile (lc >= HUF_DECBITS)\n\t{\n\t    const HufDec pl = hdecod[(c >> (lc-HUF_DECBITS)) & HUF_DECMASK];\n\n\t    if (pl.len)\n\t    {\n\t\t//\n\t\t// Get short code\n\t\t//\n\n\t\tlc -= pl.len;\n\t\tgetCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t    }\n\t    else\n\t    {\n\t\tif (!pl.p)\n\t\t    invalidCode(); // wrong code\n\n\t\t//\n\t\t// Search long code\n\t\t//\n\n\t\tint j;\n\n\t\tfor (j = 0; j < pl.lit; j++)\n\t\t{\n\t\t    int\tl = hufLength (hcode[pl.p[j]]);\n\n\t\t    while (lc < l && in < ie)\t// get more bits\n\t\t\tgetChar (c, lc, in);\n\n\t\t    if (lc >= l)\n\t\t    {\n\t\t\tif (hufCode (hcode[pl.p[j]]) ==\n\t\t\t\t((c >> (lc - l)) & ((Int64(1) << l) - 1)))\n\t\t\t{\n\t\t\t    //\n\t\t\t    // Found : get long code\n\t\t\t    //\n\n\t\t\t    lc -= l;\n\t\t\t    getCode (pl.p[j], rlc, c, lc, in, out, outb, oe);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (j == pl.lit)\n\t\t    invalidCode(); // Not found\n\t    }\n\t}\n    }\n\n    //\n    // Get remaining (short) codes\n    //\n\n    int i = (8 - ni) & 7;\n    c >>= i;\n    lc -= i;\n\n    while (lc > 0)\n    {\n\tconst HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\n\tif (pl.len)\n\t{\n\t    lc -= pl.len;\n\t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t}\n\telse\n\t{\n\t    invalidCode(); // wrong (long) code\n\t}\n    }\n\n    if (out - outb != no)\n\tnotEnoughData ();\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & ((1 << 16) - 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int send_sub_rect_solid(VncState *vs, int x, int y, int w, int h)\n{\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);\n\n    vnc_tight_start(vs);\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n    vnc_tight_stop(vs);\n\n    return send_solid_rect(vs);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\n\tif (bytesread < dword)\n\t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n\n\tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;\n\n\t\tfree (psf->channel_map) ;\n\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\n\treturn 0 ;\n} /* aiff_read_chanmap */",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int FIFOSampleBuffer::isEmpty() const\r\n{\r\n    return (samplesInBuffer == 0) ? 1 : 0;\r\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int ConnectionImpl::StreamImpl::onDataSourceSend(const uint8_t* framehd, size_t length) {\n  // In this callback we are writing out a raw DATA frame without copying. nghttp2 assumes that we\n  // \"just know\" that the frame header is 9 bytes.\n  // https://nghttp2.org/documentation/types.html#c.nghttp2_send_data_callback\n  static const uint64_t FRAME_HEADER_SIZE = 9;\n\n  parent_.outbound_data_frames_++;\n\n  Buffer::OwnedImpl output;\n  if (!parent_.addOutboundFrameFragment(output, framehd, FRAME_HEADER_SIZE)) {\n    ENVOY_CONN_LOG(debug, \"error sending data frame: Too many frames in the outbound queue\",\n                   parent_.connection_);\n    return NGHTTP2_ERR_FLOODED;\n  }\n\n  output.move(pending_send_data_, length);\n  parent_.connection_.write(output, false);\n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void sony_set_leds(struct sony_sc *sc)\n{\n\tif (!(sc->quirks & BUZZ_CONTROLLER))\n\t\tsony_schedule_work(sc, SONY_WORKER_STATE);\n\telse\n\t\tbuzz_set_leds(sc);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "find_index_in_table (MonoDynamicImage *assembly, int table_idx, int col, guint32 token)\n{\n\tint i;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\t\n\ttable = &assembly->tables [table_idx];\n\n\tg_assert (col < table->columns);\n\n\tvalues = table->values + table->columns;\n\tfor (i = 1; i <= table->rows; ++i) {\n\t\tif (values [col] == token)\n\t\t\treturn i;\n\t\tvalues += table->columns;\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "Jsi_Channel Jsi_GetStdChannel(Jsi_Interp *interp, int id) {\n    if (id<0 || id>2)\n        return NULL;\n    return jsiIntData.stdChans+id;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "TfLiteStatus SparseToDenseImpl(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* indices = GetInput(context, node, kIndicesTensor);\n  const TfLiteTensor* output_shape =\n      GetInput(context, node, kOutputShapeTensor);\n  const TfLiteTensor* values = GetInput(context, node, kValueInputTensor);\n  const TfLiteTensor* default_value =\n      GetInput(context, node, kDefaultValueTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputShape(context, output_shape, output));\n  }\n\n  const int num_indices = SizeOfDimension(indices, 0);\n  const bool value_is_scalar = NumDimensions(values) == 0;\n  std::vector<std::vector<TI>> indices_vector;\n  indices_vector.reserve(num_indices);\n  TF_LITE_ENSURE_OK(context, GetIndicesVector<TI>(context, indices, num_indices,\n                                                  &indices_vector));\n  reference_ops::SparseToDense(indices_vector, GetTensorData<T>(values),\n                               *GetTensorData<T>(default_value),\n                               value_is_scalar, GetTensorShape(output),\n                               GetTensorData<T>(output));\n\n  return kTfLiteOk;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int user_update(struct key *key, const void *data, size_t datalen)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tzap = key->payload.data;\n\t\trcu_assign_pointer(key->payload.data, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "png_read_chunk_header(png_structrp png_ptr)\n{\n   png_byte buf[8];\n   png_uint_32 length;\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;\n#endif\n\n   /* Read the length and the chunk name.\n    * This must be performed in a single I/O call.\n    */\n   png_read_data(png_ptr, buf, 8);\n   length = png_get_uint_31(png_ptr, buf);\n\n   /* Put the chunk name into png_ptr->chunk_name. */\n   png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(buf+4);\n\n   png_debug2(0, \"Reading %lx chunk, length = %lu\",\n       (unsigned long)png_ptr->chunk_name, (unsigned long)length);\n\n   /* Reset the crc and run it over the chunk name. */\n   png_reset_crc(png_ptr);\n   png_calculate_crc(png_ptr, buf + 4, 4);\n\n   /* Check to see if chunk name is valid. */\n   png_check_chunk_name(png_ptr, png_ptr->chunk_name);\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;\n#endif\n\n   return length;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "_gnutls_cipher_suite_get_version (const cipher_suite_st * suite)\n{\n  int ret = 0;\n  GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->version);\n  return ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "SProcRenderDispatch (ClientPtr client)\n{\n    REQUEST(xReq);\n    \n    if (stuff->data < RenderNumberRequests)\n\treturn (*SProcRenderVector[stuff->data]) (client);\n    else\n\treturn BadRequest;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void helper_stf_asi(target_ulong addr, int asi, int size, int rd)\n{\n    unsigned int i;\n    target_ulong val = 0;\n    helper_check_align(addr, 3);\n    addr = asi_address_mask(env, asi, addr);\n    switch (asi) {\n    case 0xe0: // UA2007 Block commit store primary (cache flush)\n    case 0xe1: // UA2007 Block commit store secondary (cache flush)\n    case 0xf0: // Block store primary\n    case 0xf1: // Block store secondary\n    case 0xf8: // Block store primary LE\n    case 0xf9: // Block store secondary LE\n            helper_st_asi(addr, val, asi & 0x8f, 4);\n    default:\n        break;\n    switch(size) {\n    default:\n    case 4:\n        val = *((uint32_t *)&env->fpr[rd]);\n        break;\n    case 8:\n        val = *((int64_t *)&DT0);\n        break;\n    case 16:\n        // XXX\n        break;\n    helper_st_asi(addr, val, asi, size);",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int proc_cwd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(d_inode(dentry));\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "u64 sched_clock_cpu(int cpu)\n{\n\tif (unlikely(!sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "passIsNumber ()\n{\n  pass_Codes passCode = passGetScriptToken ();\n  if (passCode != pass_numberFound)\n    {\n      compileError (passNested, \"a number expected\");\n      return 0;\n    }\n  return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int analyze(const uint8_t *buf, int size, int packet_size, int *index)\n\n{\n\n    int stat[TS_MAX_PACKET_SIZE];\n\n    int i;\n\n    int x = 0;\n\n    int best_score = 0;\n\n\n\n    memset(stat, 0, packet_size * sizeof(int));\n\n\n\n    for (x = i = 0; i < size - 3; i++) {\n\n        if (buf[i] == 0x47 && !(buf[i + 1] & 0x80) && (buf[i + 3] & 0x30)) {\n\n            stat[x]++;\n\n            if (stat[x] > best_score) {\n\n                best_score = stat[x];\n\n                if (index)\n\n                    *index = x;\n\n            }\n\n        }\n\n\n\n        x++;\n\n        if (x == packet_size)\n\n            x = 0;\n\n    }\n\n\n\n    return best_score;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void lbs_debug_init(struct lbs_private *priv)\n{\n\tint i;\n\n\tif (!priv->debugfs_dir)\n\t\treturn;\n\n\tfor (i = 0; i < num_of_items; i++)\n\t\titems[i].addr += (size_t) priv;\n\n\tpriv->debugfs_debug = debugfs_create_file(\"debug\", 0644,\n\t\t\t\t\t\t  priv->debugfs_dir, &items[0],\n\t\t\t\t\t\t  &lbs_debug_fops);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n   mrb_bool failed = TRUE;\n \n   mrb_get_args(mrb, \"o\", &orig);\n   fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n   if (fptr_copy != NULL) {\n     fptr_finalize(mrb, fptr_copy, FALSE);\n     mrb_free(mrb, fptr_copy);\n   }\n   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n \n   DATA_TYPE(copy) = &mrb_io_type;\n   DATA_PTR(copy) = fptr_copy;\n\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n\n  return copy;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "HandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)\n{\n\tint n = 0;\n\tchar *reason = NULL;\n\trfbClientToServerTightMsg msg;\n\n\tmemset(&msg, 0, sizeof(rfbClientToServerTightMsg));\n\t\n\tif((n = rfbReadExact(cl, ((char *)&msg)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {\n\t\t\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t\t\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);\n\n\tif(msg.fdc.reasonLen == 0) {\n\t\trfbLog(\"File [%s]: Method [%s]: reason length received is Zero\\n\",\n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\t\n\treason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));\n\tif(reason == NULL) {\n\t\trfbLog(\"File [%s]: Method [%s]: Fatal Error: Memory alloc failed\\n\", \n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\n\tif((n = rfbReadExact(cl, reason, msg.fdc.reasonLen)) <= 0) {\n\t\t\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t\t\n\t    rfbCloseClient(cl);\n\t}\n\n\trfbLog(\"File [%s]: Method [%s]: File Download Cancel Request received:\"\n\t\t\t\t\t\" reason <%s>\\n\", __FILE__, __FUNCTION__, reason);\n\t\n\tpthread_mutex_lock(&fileDownloadMutex);\n\tCloseUndoneFileTransfer(cl, rtcp);\n\tpthread_mutex_unlock(&fileDownloadMutex);\n\t\n\tif(reason != NULL) {\n\t\tfree(reason);\n\t\treason = NULL;\n\t}\n\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "R_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 8 : 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "base::string16 AuthenticatorClientPinEntrySheetModel::GetStepTitle() const {\n  return l10n_util::GetStringUTF16(IDS_WEBAUTHN_PIN_ENTRY_TITLE);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static QEMUFile *open_test_file(bool write)\n\n{\n\n    int fd = dup(temp_fd);\n\n    QIOChannel *ioc;\n\n    lseek(fd, 0, SEEK_SET);\n\n    if (write) {\n\n        g_assert_cmpint(ftruncate(fd, 0), ==, 0);\n\n    }\n\n    ioc = QIO_CHANNEL(qio_channel_file_new_fd(fd));\n\n    if (write) {\n\n        return qemu_fopen_channel_output(ioc);\n\n    } else {\n\n        return qemu_fopen_channel_input(ioc);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "Eina_Bool ewk_view_navigate(Evas_Object* ewkView, int steps)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_navigate(smartData->main_frame, steps);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void rds_inc_path_init(struct rds_incoming *inc, struct rds_conn_path *cp,\n\t\t       struct in6_addr  *saddr)\n{\n\trefcount_set(&inc->i_refcount, 1);\n\tINIT_LIST_HEAD(&inc->i_item);\n\tinc->i_conn = cp->cp_conn;\n\tinc->i_conn_path = cp;\n\tinc->i_saddr = *saddr;\n\tinc->i_rdma_cookie = 0;\n\tinc->i_rx_tstamp = ktime_set(0, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void rds_sock_put(struct rds_sock *rs)\n{\n\tsock_put(rds_rs_to_sk(rs));\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void voice_link(struct VOICE_S *p_voice)\n{\n\tstruct VOICE_S *p_voice2;\n\n\tp_voice2 = first_voice;\n\tfor (;;) {\n\t\tif (p_voice2 == p_voice)\n\t\t\treturn;\n\t\tif (!p_voice2->next)\n\t\t\tbreak;\n\t\tp_voice2 = p_voice2->next;\n\t}\n\tp_voice2->next = p_voice;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int imap_msg_close(struct Context *ctx, struct Message *msg)\n{\n  return mutt_file_fclose(&msg->fp);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "NCR_GetRemoteAddress(NCR_Instance inst) \n{\n  return &inst->remote_addr;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n    }\n  ThrowImageException;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "main_malloc1 (size_t size)\n{\n  void* r = malloc (size);\n  if (r == NULL) { XPR(NT \"malloc: %s\\n\", xd3_mainerror (ENOMEM)); }\n  return r;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int kvm_log_stop(CPUPhysMemoryClient *client,\n\n                        target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n    return kvm_dirty_pages_log_change(phys_addr, size, false);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void f2fs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (to > i_size) {\n\t\tdown_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\t\tdown_write(&F2FS_I(inode)->i_mmap_sem);\n\n\t\ttruncate_pagecache(inode, i_size);\n\t\tif (!IS_NOQUOTA(inode))\n\t\t\tf2fs_truncate_blocks(inode, i_size, true);\n\n\t\tup_write(&F2FS_I(inode)->i_mmap_sem);\n\t\tup_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int dev_get_valid_name(struct net *net,\n\t\t\t      struct net_device *dev,\n\t\t\t      const char *name)\n{\n\tBUG_ON(!net);\n\n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\n\tif (strchr(name, '%'))\n\t\treturn dev_alloc_name_ns(net, dev, name);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (dev->name != name)\n\t\tstrlcpy(dev->name, name, IFNAMSIZ);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int nfs4_xdr_enc_setclientid(struct rpc_rqst *req, __be32 *p, struct nfs4_setclientid *sc)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 1,\n\t};\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\treturn encode_setclientid(&xdr, sc);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline void RENAME(rgb24ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)\n\n{\n\n\tint i;\n\n        assert(src1==src2);\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tint r= src1[6*i + 0] + src1[6*i + 3];\n\n\t\tint g= src1[6*i + 1] + src1[6*i + 4];\n\n\t\tint b= src1[6*i + 2] + src1[6*i + 5];\n\n\n\n\t\tdstU[i]= ((RU*r + GU*g + BU*b)>>(RGB2YUV_SHIFT+1)) + 128;\n\n\t\tdstV[i]= ((RV*r + GV*g + BV*b)>>(RGB2YUV_SHIFT+1)) + 128;\n\n\t}\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "QEMUSizedBuffer *qsb_clone(const QEMUSizedBuffer *qsb)\n\n{\n\n    QEMUSizedBuffer *out = qsb_create(NULL, qsb_get_length(qsb));\n\n    size_t i;\n\n    ssize_t res;\n\n    off_t pos = 0;\n\n\n\n    if (!out) {\n\n        return NULL;\n\n    }\n\n\n\n    for (i = 0; i < qsb->n_iov; i++) {\n\n        res =  qsb_write_at(out, qsb->iov[i].iov_base,\n\n                            pos, qsb->iov[i].iov_len);\n\n        if (res < 0) {\n\n            qsb_free(out);\n\n            return NULL;\n\n        }\n\n        pos += res;\n\n    }\n\n\n\n    return out;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "gfx::NativeViewAccessible GetNativeViewAccessible() {\n    return View::GetNativeViewAccessible();\n  }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool IsAppsShortcutEnabled(Profile* profile) {\n  if (profile->IsLegacySupervised())\n    return false;\n\n#if defined(USE_ASH)\n  return false;\n#else\n  return search::IsInstantExtendedAPIEnabled() && !profile->IsOffTheRecord();\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void timer_start(starttime_t& r)\n{\n#ifdef LIBRAW_WIN32_CALLS\n\tQueryPerformanceCounter(&r.started);\n#else\n\tgettimeofday(&r.started,NULL);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static unsigned long gfn_to_hva_read(struct kvm *kvm, gfn_t gfn)\n{\n\treturn __gfn_to_hva_many(gfn_to_memslot(kvm, gfn), gfn, NULL, false);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void git_delta_index_free(git_delta_index *index)\n{\n\tgit__free(index);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void agp_generic_destroy_pages(struct agp_memory *mem)\n{\n\tint i;\n\tstruct page *page;\n\n\tif (!mem)\n\t\treturn;\n\n#ifdef CONFIG_X86\n\tset_pages_array_wb(mem->pages, mem->page_count);\n#endif\n\n\tfor (i = 0; i < mem->page_count; i++) {\n\t\tpage = mem->pages[i];\n\n#ifndef CONFIG_X86\n\t\tunmap_page_from_agp(page);\n#endif\n\t\tput_page(page);\n\t\t__free_page(page);\n\t\tatomic_dec(&agp_bridge->current_memory_agp);\n\t\tmem->pages[i] = NULL;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static bool is_topic_in_criterias(\n        const char* topic_name,\n        const std::vector<Criteria>& criterias)\n{\n    bool returned_value = false;\n\n    for (auto criteria_it = criterias.begin(); !returned_value &&\n            criteria_it != criterias.end(); ++criteria_it)\n    {\n        for (auto topic : (*criteria_it).topics)\n        {\n            if (StringMatching::matchString(topic.c_str(), topic_name))\n            {\n                returned_value = true;\n                break;\n            }\n        }\n    }\n\n    return returned_value;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline void dnrmg_receive_user_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\n\tif (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)\n\t\treturn;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\tRCV_SKB_FAIL(-EPERM);\n\n\t/* Eventually we might send routing messages too */\n\n\tRCV_SKB_FAIL(-EINVAL);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void MVGAppendPointsCommand(DrawingWand *wand,const char *command,\n  const size_t number_coordinates,const PointInfo *coordinates)\n{\n  const PointInfo\n    *coordinate;\n\n  size_t\n    i;\n\n  (void) MVGPrintf(wand,\"%s\",command);\n  for (i=number_coordinates, coordinate=coordinates; i != 0; i--)\n  {\n    (void) MVGAutoWrapPrintf(wand,\" %.20g %.20g\",coordinate->x,coordinate->y);\n    coordinate++;\n  }\n  (void) MVGPrintf(wand, \"\\n\");\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->uid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->gid : INVALID_GID;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "grub_crypto_gcry_error (gcry_err_code_t in)\n{\n  if (in == GPG_ERR_NO_ERROR)\n    return GRUB_ERR_NONE;\n  return GRUB_ACCESS_DENIED;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "Formattable::setString(const UnicodeString& stringToCopy)\n{\n    dispose();\n    fType = kString;\n    fValue.fString = new UnicodeString(stringToCopy);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void sws_rgb2rgb_init(int flags){\n\n#if (defined(HAVE_MMX2) || defined(HAVE_3DNOW) || defined(HAVE_MMX))  && defined(CONFIG_GPL)\n\n\tif(flags & SWS_CPU_CAPS_MMX2)\n\n\t\trgb2rgb_init_MMX2();\n\n\telse if(flags & SWS_CPU_CAPS_3DNOW)\n\n\t\trgb2rgb_init_3DNOW();\n\n\telse if(flags & SWS_CPU_CAPS_MMX)\n\n\t\trgb2rgb_init_MMX();\n\n\telse\n\n#endif /* defined(HAVE_MMX2) || defined(HAVE_3DNOW) || defined(HAVE_MMX) */\n\n\t\trgb2rgb_init_C();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "HIDDEN void *brotli_init() { return NULL; }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void DateTimeChooserImpl::endChooser()\n{\n    if (!m_popup)\n        return;\n    m_chromeClient->closePagePopup(m_popup);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int BN_bn2binpad(const BIGNUM *a, unsigned char *to, int tolen)\n{\n    if (tolen < 0)\n        return -1;\n    return bn2binpad(a, to, tolen);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void *ok_stdlib_alloc(void *user_data, size_t size) {\n    (void)user_data;\n    return malloc(size);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "FPDF_PAGE PDFiumEngine::Form_GetPage(FPDF_FORMFILLINFO* param,\n                                     FPDF_DOCUMENT document,\n                                     int page_index) {\n  PDFiumEngine* engine = static_cast<PDFiumEngine*>(param);\n  if (page_index < 0 || page_index >= static_cast<int>(engine->pages_.size()))\n    return nullptr;\n  return engine->pages_[page_index]->GetPage();\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void do_notify_resume(struct pt_regs *regs, unsigned long orig_i0,\n\t\t      unsigned long thread_info_flags)\n{\n\tif (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\n\t\tdo_signal(regs, orig_i0);\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "_change_user (GdmSessionWorker  *worker,\n              uid_t              uid,\n              gid_t              gid)\n{\n        gboolean ret;\n\n        ret = FALSE;\n\n#ifdef THE_MAN_PAGE_ISNT_LYING\n        /* pam_setcred wants to be called as the authenticated user\n         * but pam_open_session needs to be called as super-user.\n         *\n         * Set the real uid and gid to the user and give the user a\n         * temporary super-user effective id.\n         */\n        if (setreuid (uid, GDM_SESSION_ROOT_UID) < 0) {\n                return FALSE;\n        }\n#endif\n        worker->priv->uid = uid;\n\n        if (setgid (gid) < 0) {\n                return FALSE;\n        }\n\n        if (initgroups (worker->priv->username, gid) < 0) {\n                return FALSE;\n        }\n\n        return TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n #else\n \tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n \n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n \treturn mobj;\n #endif\n }",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Continue(int lineno, int col_offset, int end_lineno, int end_col_offset,\n         PyArena *arena)\n{\n    stmt_ty p;\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = Continue_kind;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "rgw::auth::s3::STSEngine::get_creds_info(const STS::SessionToken& token) const noexcept\n{\n  using acct_privilege_t = \\\n    rgw::auth::RemoteApplier::AuthInfo::acct_privilege_t;\n\n  return rgw::auth::RemoteApplier::AuthInfo {\n    token.user,\n    token.acct_name,\n    token.perm_mask,\n    (token.is_admin) ? acct_privilege_t::IS_ADMIN_ACCT: acct_privilege_t::IS_PLAIN_ACCT,\n    token.acct_type\n  };\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static bool requiresCompositing(CompositingReasons reasons)\n{\n    return reasons & ~CompositingReasonComboSquashableReasons;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int close_f(int argc, char **argv)\n\n{\n\n    bdrv_close(bs);\n\n    bs = NULL;\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "xmlDictComputeFastQKey(const xmlChar *prefix, int plen,\n                       const xmlChar *name, int len, int seed)\n{\n    unsigned long value = (unsigned long) seed;\n\n    if (plen == 0)\n\tvalue += 30 * (unsigned long) ':';\n    else\n\tvalue += 30 * (*prefix);\n\n    if (len > 10) {\n        value += name[len - (plen + 1 + 1)];\n        len = 10;\n\tif (plen > 10)\n\t    plen = 10;\n    }\n    switch (plen) {\n        case 10: value += prefix[9];\n        case 9: value += prefix[8];\n        case 8: value += prefix[7];\n        case 7: value += prefix[6];\n        case 6: value += prefix[5];\n        case 5: value += prefix[4];\n        case 4: value += prefix[3];\n        case 3: value += prefix[2];\n        case 2: value += prefix[1];\n        case 1: value += prefix[0];\n        default: break;\n    }\n    len -= plen;\n    if (len > 0) {\n        value += (unsigned long) ':';\n\tlen--;\n    }\n    switch (len) {\n        case 10: value += name[9];\n        case 9: value += name[8];\n        case 8: value += name[7];\n        case 7: value += name[6];\n        case 6: value += name[5];\n        case 5: value += name[4];\n        case 4: value += name[3];\n        case 3: value += name[2];\n        case 2: value += name[1];\n        case 1: value += name[0];\n        default: break;\n    }\n    return(value);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "w3m_exit(int i)\n{\n#ifdef USE_MIGEMO\n    init_migemo();\t\t/* close pipe to migemo */\n#endif\n    stopDownload();\n    deleteFiles();\n#ifdef USE_SSL\n    free_ssl_ctx();\n#endif\n    disconnectFTP();\n#ifdef USE_NNTP\n    disconnectNews();\n#endif\n#ifdef __MINGW32_VERSION\n    WSACleanup();\n#endif\n    exit(i);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void ept_set_mmio_spte_mask(void)\n{\n\t/*\n\t * EPT Misconfigurations can be generated if the value of bits 2:0\n\t * of an EPT paging-structure entry is 110b (write/execute).\n\t */\n\tkvm_mmu_set_mmio_spte_mask(VMX_EPT_RWX_MASK,\n\t\t\t\t   VMX_EPT_MISCONFIG_WX_VALUE);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "lseg_distance(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_FLOAT8(lseg_dt(l1, l2));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void SoundTouch::setPitchSemiTones(double newPitch)\r\n{\r\n    setPitchOctaves(newPitch / 12.0);\r\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "SYSCALL_DEFINE3(execve,\n\t\tconst char __user *, filename,\n\t\tconst char __user *const __user *, argv,\n\t\tconst char __user *const __user *, envp)\n{\n\treturn do_execve(getname(filename), argv, envp);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\n\tRETURN_TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ext4_find_extent(struct inode *inode, ext4_lblk_t block,\n\t\t struct ext4_ext_path **orig_path, int flags)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct buffer_head *bh;\n\tstruct ext4_ext_path *path = orig_path ? *orig_path : NULL;\n\tshort int depth, i, ppos = 0;\n\tint ret;\n\n\teh = ext_inode_hdr(inode);\n\tdepth = ext_depth(inode);\n\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tif (depth > path[0].p_maxdepth) {\n\t\t\tkfree(path);\n\t\t\t*orig_path = path = NULL;\n\t\t}\n\t}\n\tif (!path) {\n\t\t/* account possible depth increase */\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 2),\n\t\t\t\tGFP_NOFS);\n\t\tif (unlikely(!path))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath[0].p_maxdepth = depth + 1;\n\t}\n\tpath[0].p_hdr = eh;\n\tpath[0].p_bh = NULL;\n\n\ti = depth;\n\t/* walk through the tree */\n\twhile (i) {\n\t\text_debug(\"depth %d: num %d, max %d\\n\",\n\t\t\t  ppos, le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\n\t\text4_ext_binsearch_idx(inode, path + ppos, block);\n\t\tpath[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);\n\t\tpath[ppos].p_depth = i;\n\t\tpath[ppos].p_ext = NULL;\n\n\t\tbh = read_extent_tree_block(inode, path[ppos].p_block, --i,\n\t\t\t\t\t    flags);\n\t\tif (IS_ERR(bh)) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\teh = ext_block_hdr(bh);\n\t\tppos++;\n\t\tpath[ppos].p_bh = bh;\n\t\tpath[ppos].p_hdr = eh;\n\t}\n\n\tpath[ppos].p_depth = i;\n\tpath[ppos].p_ext = NULL;\n\tpath[ppos].p_idx = NULL;\n\n\t/* find extent */\n\text4_ext_binsearch(inode, path + ppos, block);\n\t/* if not an empty leaf */\n\tif (path[ppos].p_ext)\n\t\tpath[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);\n\n\text4_ext_show_path(inode, path);\n\n\treturn path;\n\nerr:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tif (orig_path)\n\t\t*orig_path = NULL;\n\treturn ERR_PTR(ret);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "Ins_SxyTCA( TT_ExecContext  exc )\n  {\n    FT_Short  AA, BB;\n\n    FT_Byte  opcode = exc->opcode;\n\n\n    AA = (FT_Short)( ( opcode & 1 ) << 14 );\n    BB = (FT_Short)( AA ^ 0x4000 );\n\n    if ( opcode < 4 )\n    {\n      exc->GS.projVector.x = AA;\n      exc->GS.projVector.y = BB;\n\n      exc->GS.dualVector.x = AA;\n      exc->GS.dualVector.y = BB;\n    }\n\n    if ( ( opcode & 2 ) == 0 )\n    {\n      exc->GS.freeVector.x = AA;\n      exc->GS.freeVector.y = BB;\n    }\n\n    Compute_Funcs( exc );\n  }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool checkreturn pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    if (substream->bytes_left) {\n        if (!pb_read(substream, NULL, substream->bytes_left))\n            return false;\n    }\n\n    stream->state = substream->state;\n\n#ifndef PB_NO_ERRMSG\n    stream->errmsg = substream->errmsg;\n#endif\n    return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "eXosip_get_version (void)\n{\n  return EXOSIP_VERSION;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void AuthenticatorSheetModelBase::OnModelDestroyed() {\n  dialog_model_ = nullptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void hns_nic_ring_close(struct net_device *netdev, int idx)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(netdev);\n\tstruct hnae_handle *h = priv->ae_handle;\n\n\th->dev->ops->toggle_ring_irq(priv->ring_data[idx].ring, 1);\n\tdisable_irq(priv->ring_data[idx].ring->irq);\n\n\tnapi_disable(&priv->ring_data[idx].napi);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream->codecpar;\n\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        /*\n         * Packetization Mode:\n         * 0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n         * 1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n         * 2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A),\n         *                      and 29 (FU-B) are allowed.\n         */\n        if (h264_data->packetization_mode > 1)\n            av_log(s, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\\n\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6)\n             parse_profile_level_id(s, h264_data, value);\n     } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n         int ret;\n        if (value[strlen(value) - 1] == ',') {\n             av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");\n             return 0;\n         }\n        par->extradata_size = 0;\n        av_freep(&par->extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,\n                                                 &par->extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)\\n\",\n               par->extradata, par->extradata_size);\n        return ret;\n    }\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "AsyncFor(expr_ty target, expr_ty iter, asdl_seq * body, asdl_seq * orelse, int\n         lineno, int col_offset, int end_lineno, int end_col_offset, PyArena\n         *arena)\n{\n    stmt_ty p;\n    if (!target) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field target is required for AsyncFor\");\n        return NULL;\n    }\n    if (!iter) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field iter is required for AsyncFor\");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = AsyncFor_kind;\n    p->v.AsyncFor.target = target;\n    p->v.AsyncFor.iter = iter;\n    p->v.AsyncFor.body = body;\n    p->v.AsyncFor.orelse = orelse;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static bool can_checksum_protocol(unsigned long features, __be16 protocol)\n{\n\treturn ((features & NETIF_F_GEN_CSUM) ||\n\t\t((features & NETIF_F_V4_CSUM) &&\n\t\t protocol == htons(ETH_P_IP)) ||\n\t\t((features & NETIF_F_V6_CSUM) &&\n\t\t protocol == htons(ETH_P_IPV6)) ||\n\t\t((features & NETIF_F_FCOE_CRC) &&\n\t\t protocol == htons(ETH_P_FCOE)));\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "std::unique_ptr<Backend::Iterator> MemBackendImpl::CreateIterator() {\n  return std::unique_ptr<Backend::Iterator>(\n      new MemIterator(weak_factory_.GetWeakPtr()));\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        /* Copy argument i to top of stack for _encode processing;\n         * the encode function pops it from the stack when complete. */\n        lua_pushvalue(L, i);\n\n        mp_encode_lua_type(L,buf,0);\n\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n\n        /* Reuse the buffer for the next operation by\n         * setting its free count to the total buffer size\n         * and the current position to zero. */\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n\n    /* Concatenate all nargs buffers together */\n    lua_concat(L, nargs);\n    return 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void sub_remove(struct idr *idp, int shift, int id)\n{\n\tstruct idr_layer *p = idp->top;\n\tstruct idr_layer **pa[MAX_IDR_LEVEL];\n\tstruct idr_layer ***paa = &pa[0];\n\tstruct idr_layer *to_free;\n\tint n;\n\n\t*paa = NULL;\n\t*++paa = &idp->top;\n\n\twhile ((shift > 0) && p) {\n\t\tn = (id >> shift) & IDR_MASK;\n\t\t__clear_bit(n, &p->bitmap);\n\t\t*++paa = &p->ary[n];\n\t\tp = p->ary[n];\n\t\tshift -= IDR_BITS;\n\t}\n\tn = id & IDR_MASK;\n\tif (likely(p != NULL && test_bit(n, &p->bitmap))){\n\t\t__clear_bit(n, &p->bitmap);\n\t\trcu_assign_pointer(p->ary[n], NULL);\n\t\tto_free = NULL;\n\t\twhile(*paa && ! --((**paa)->count)){\n\t\t\tif (to_free)\n\t\t\t\tfree_layer(to_free);\n\t\t\tto_free = **paa;\n\t\t\t**paa-- = NULL;\n\t\t}\n\t\tif (!*paa)\n\t\t\tidp->layers = 0;\n\t\tif (to_free)\n\t\t\tfree_layer(to_free);\n\t} else\n\t\tidr_remove_warning(id);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&upperdentry->d_parent->d_inode->i_mutex));\n\tWARN_ON(oe->__upperdentry);\n\tBUG_ON(!upperdentry->d_inode);\n\t/*\n\t * Make sure upperdentry is consistent before making it visible to\n\t * ovl_upperdentry_dereference().\n\t */\n\tsmp_wmb();\n\toe->__upperdentry = upperdentry;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void bit_prop_set(DeviceState *dev, Property *props, bool val)\n\n{\n\n    uint32_t *p = qdev_get_prop_ptr(dev, props);\n\n    uint32_t mask = qdev_get_prop_mask(props);\n\n    if (val)\n\n        *p |= ~mask;\n\n    else\n\n        *p &= ~mask;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "size_t jsvGetFlatStringBlocks(const JsVar *v) {\n  assert(jsvIsFlatString(v));\n  return ((size_t)v->varData.integer+sizeof(JsVar)-1) / sizeof(JsVar);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n \t\terr = do_remount_sb(sb, flags, data, 0);\n \tif (!err) {\n \t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n \t\tmnt->mnt.mnt_flags = mnt_flags;\n \t\ttouch_mnt_namespace(mnt->mnt_ns);\n \t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t       struct sk_buff *skb, u32 mtu)\n{\n\tstruct rt6_info *rt6 = (struct rt6_info *)dst;\n\n\tdst_confirm(dst);\n\tif (mtu < dst_mtu(dst) && rt6->rt6i_dst.plen == 128) {\n\t\tstruct net *net = dev_net(dst->dev);\n\n\t\trt6->rt6i_flags |= RTF_MODIFIED;\n\t\tif (mtu < IPV6_MIN_MTU) {\n\t\t\tu32 features = dst_metric(dst, RTAX_FEATURES);\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\t\tfeatures |= RTAX_FEATURE_ALLFRAG;\n\t\t\tdst_metric_set(dst, RTAX_FEATURES, features);\n\t\t}\n\t\tdst_metric_set(dst, RTAX_MTU, mtu);\n\t\trt6_update_expires(rt6, net->ipv6.sysctl.ip6_rt_mtu_expires);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static u16 b43_fwcapa_read(struct b43_wldev *dev)\n{\n\tB43_WARN_ON(!dev->fw.opensource);\n\treturn b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_FWCAPA);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "n_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n    trigger_modechanged();\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void usb_wakeup_notification(struct usb_device *hdev,\n\t\tunsigned int portnum)\n{\n\tstruct usb_hub *hub;\n\tstruct usb_port *port_dev;\n\n\tif (!hdev)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(hdev);\n\tif (hub) {\n\t\tport_dev = hub->ports[portnum - 1];\n\t\tif (port_dev && port_dev->child)\n\t\t\tpm_wakeup_event(&port_dev->child->dev, 0);\n\n\t\tset_bit(portnum, hub->wakeup_bits);\n\t\tkick_hub_wq(hub);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "process_plane(uint8 * in, int width, int height, uint8 * out, int size)\n{\n\tUNUSED(size);\n\tint indexw;\n\tint indexh;\n\tint code;\n\tint collen;\n\tint replen;\n\tint color;\n\tint x;\n\tint revcode;\n\tuint8 * last_line;\n\tuint8 * this_line;\n\tuint8 * org_in;\n\tuint8 * org_out;\n\n\torg_in = in;\n\torg_out = out;\n\tlast_line = 0;\n\tindexh = 0;\n\twhile (indexh < height)\n\t{\n\t\tout = (org_out + width * height * 4) - ((indexh + 1) * width * 4);\n\t\tcolor = 0;\n\t\tthis_line = out;\n\t\tindexw = 0;\n\t\tif (last_line == 0)\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n \t\t\t\t\treplen = revcode;\n \t\t\t\t\tcollen = 0;\n \t\t\t\t}\n\t\t\t\twhile (collen > 0)\n \t\t\t\t{\n \t\t\t\t\tcolor = CVAL(in);\n \t\t\t\t\t*out = color;\n \t\t\t\t\tout += 4;\n \t\t\t\t\tindexw++;\n \t\t\t\t\tcollen--;\n \t\t\t\t}\n\t\t\t\twhile (replen > 0)\n \t\t\t\t{\n \t\t\t\t\t*out = color;\n \t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n \t\t\t\t\treplen = revcode;\n \t\t\t\t\tcollen = 0;\n \t\t\t\t}\n\t\t\t\twhile (collen > 0)\n \t\t\t\t{\n \t\t\t\t\tx = CVAL(in);\n \t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tx = x + 1;\n\t\t\t\t\t\tcolor = -x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tcolor = x;\n\t\t\t\t\t}\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n \t\t\t\t\tindexw++;\n \t\t\t\t\tcollen--;\n \t\t\t\t}\n\t\t\t\twhile (replen > 0)\n \t\t\t\t{\n \t\t\t\t\tx = last_line[indexw * 4] + color;\n \t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindexh++;\n\t\tlast_line = this_line;\n\t}\n\treturn (int) (in - org_in);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void inv_predict_3(uint8_t *p, const uint8_t *p_l, const uint8_t *p_tl,\n                          const uint8_t *p_t, const uint8_t *p_tr)\n{\n    AV_COPY32(p, p_tr);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "print_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n#ifdef CONFIG_TIMER_STATS\n\tchar tmp[TASK_COMM_LEN + 1];\n#endif\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n#ifdef CONFIG_TIMER_STATS\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->start_site);\n\tmemcpy(tmp, timer->start_comm, TASK_COMM_LEN);\n\ttmp[TASK_COMM_LEN] = 0;\n\tSEQ_printf(m, \", %s/%d\", tmp, timer->start_pid);\n#endif\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "agoo_con_create(agooErr err, int sock, uint64_t id, agooBind b) {\n    agooCon\tc;\n\n    if (NULL == (c = (agooCon)AGOO_CALLOC(1, sizeof(struct _agooCon)))) {\n\tAGOO_ERR_MEM(err, \"Connection\");\n    } else {\n\tc->sock = sock;\n\tc->id = id;\n\tc->timeout = dtime() + CON_TIMEOUT;\n\tc->bind = b;\n\tc->loop = NULL;\n\tpthread_mutex_init(&c->res_lock, 0);\n    }\n    return c;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int32_t cli_bcapi_buffer_pipe_new_fromfile(struct cli_bc_ctx *ctx , uint32_t at)\n{\n    struct bc_buffer *b;\n    unsigned n = ctx->nbuffers + 1;\n\n    if (at >= ctx->file_size)\n\treturn -1;\n\n    b = cli_realloc(ctx->buffers, sizeof(*ctx->buffers)*n);\n    if (!b) {\n\treturn -1;\n    }\n    ctx->buffers = b;\n    ctx->nbuffers = n;\n    b = &b[n-1];\n\n    /* NULL data means read from file at pos read_cursor */\n    b->data = NULL;\n    b->size = 0;\n    b->read_cursor = at;\n    b->write_cursor = 0;\n    return n-1;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int __export rad_packet_add_ipaddr(struct rad_packet_t *pack, const char *vendor_name, const char *name, in_addr_t ipaddr)\n{\n\treturn rad_packet_add_int(pack, vendor_name, name, ipaddr);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "GetSpritePosition(DeviceIntPtr pDev, int *px, int *py)\n{\n    SpritePtr pSprite = pDev->spriteInfo->sprite;\n\n    *px = pSprite->hotPhys.x;\n    *py = pSprite->hotPhys.y;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void add_cx(MCInst *MI)\n{\n\tif (MI->csh->detail) {\n\t\tx86_reg cx;\n\n\t\tif (MI->csh->mode & CS_MODE_16)\n\t\t\tcx = X86_REG_CX;\n\t\telse if (MI->csh->mode & CS_MODE_32)\n\t\t\tcx = X86_REG_ECX;\n\t\telse\t// 64-bit\n\t\t\tcx = X86_REG_RCX;\n\n\t\tMI->flat_insn->detail->regs_read[MI->flat_insn->detail->regs_read_count] = cx;\n\t\tMI->flat_insn->detail->regs_read_count++;\n\n\t\tMI->flat_insn->detail->regs_write[MI->flat_insn->detail->regs_write_count] = cx;\n\t\tMI->flat_insn->detail->regs_write_count++;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\n\tfor (n = 0; n < count; n++, iov++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "cmove(T_ASC_Association *assoc, const char *fname)\n{\n    OFCondition cond = EC_Normal;\n    int n = OFstatic_cast(int, opt_repeatCount);\n    while (cond.good() && n--)\n        cond = moveSCU(assoc, fname);\n    return cond;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static bool io_match_task_safe(struct io_kiocb *head, struct task_struct *task,\n\t\t\t       bool cancel_all)\n{\n\tif (task && head->task != task)\n\t\treturn false;\n\treturn cancel_all;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void sw_perf_event_destroy(struct perf_event *event)\n{\n\tu64 event_id = event->attr.config;\n\n\tWARN_ON(event->parent);\n\n\tstatic_key_slow_dec(&perf_swevent_enabled[event_id]);\n\tswevent_hlist_put();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "compute_consensus_versions_list(smartlist_t *lst, int n_versioning)\n{\n  int min = n_versioning / 2;\n  smartlist_t *good = smartlist_new();\n  char *result;\n  sort_version_list(lst, 0);\n  get_frequent_members(good, lst, min);\n  result = smartlist_join_strings(good, \",\", 0, NULL);\n  smartlist_free(good);\n  return result;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "xmlPrintURI(FILE *stream, xmlURIPtr uri) {\n    xmlChar *out;\n\n    out = xmlSaveUri(uri);\n if (out != NULL) {\n\tfprintf(stream, \"%s\", (char *) out);\n\txmlFree(out);\n }\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static const void *GetVirtualMetacontentFromStream(const Image *image)\n{\n  CacheInfo\n    *cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  return(cache_info->metacontent);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static bool megasas_use_msix(MegasasState *s)\n{\n    return s->flags & MEGASAS_MASK_USE_MSIX;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "evaluate_uid(void)\n{\n  uid_t ruid = getuid();\n  uid_t euid = geteuid();\n\n  /* if we're really root and aren't running setuid */\n  return (uid_t) 0 == ruid && ruid == euid ? 0 : 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * We permit SOCK_DGRAM and RAW is an extension. It is trivial to do\n\t * and gives you the full ELAP frame. Should be handy for CAP 8)\n\t */\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "virDomainGetTime(virDomainPtr dom,\n                 long long *seconds,\n                 unsigned int *nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\",\n                     seconds, nseconds, flags);\n\n     virResetLastError();\n \n     virCheckDomainReturn(dom, -1);\n \n     if (dom->conn->driver->domainGetTime) {\n         int ret = dom->conn->driver->domainGetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void test_checkout_nasty__dot_backslash_dotcapitalgit_path(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dot_backslash_dotcapitalgit_path\", \".GIT/foobar\");\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "clear_reference_bitmap (guint32 offset, guint32 size)\n{\n\tint idx = (offset >> 24) - 1;\n\tuintptr_t *rb;\n\trb = static_reference_bitmaps [idx];\n\toffset &= 0xffffff;\n\toffset /= sizeof (gpointer);\n\tsize /= sizeof (gpointer);\n\tsize += offset;\n\t/* offset is now the bitmap offset */\n\tfor (; offset < size; ++offset)\n\t\trb [offset / (sizeof (uintptr_t) * 8)] &= ~(1L << (offset & (sizeof (uintptr_t) * 8 -1)));\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void ProtocolV2::append_keepalive_ack(utime_t &timestamp) {\n  auto keepalive_ack_frame = KeepAliveFrameAck::Encode(timestamp);\n  connection->outgoing_bl.append(keepalive_ack_frame.get_buffer(session_stream_handlers));\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static unsigned int tun_chr_poll(struct file *file, poll_table * wait)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tstruct sock *sk = tun->sk;\n\tunsigned int mask = 0;\n\n\tif (!tun)\n\t\treturn POLLERR;\n\n\tDBG(KERN_INFO \"%s: tun_chr_poll\\n\", tun->dev->name);\n\n\tpoll_wait(file, &tun->socket.wait, wait);\n\n\tif (!skb_queue_empty(&tun->readq))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\tif (sock_writeable(sk) ||\n\t    (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n\t     sock_writeable(sk)))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\n\tif (tun->dev->reg_state != NETREG_REGISTERED)\n\t\tmask = POLLERR;\n\n\ttun_put(tun);\n\treturn mask;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "add_separator_to_menu(GArray *argv, guint context) {\n    GUI *g = &uzbl.gui;\n    MenuItem *m;\n    gchar *sep_name;\n\n    if(!g->menu_items)\n        g->menu_items = g_ptr_array_new();\n\n    if(!argv_idx(argv, 0))\n        return;\n    else\n        sep_name = argv_idx(argv, 0);\n\n    m = malloc(sizeof(MenuItem));\n    m->name    = g_strdup(sep_name);\n    m->cmd     = NULL;\n    m->context = context;\n    m->issep   = TRUE;\n    g_ptr_array_add(g->menu_items, m);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "inline void Element::updateId(const AtomicString& oldId, const AtomicString& newId)\n{\n    if (!isInTreeScope())\n        return;\n\n    if (oldId == newId)\n        return;\n\n    updateId(treeScope(), oldId, newId);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int f2fs_target_device_index(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tint i;\n\n\tif (!f2fs_is_multi_device(sbi))\n\t\treturn 0;\n\n\tfor (i = 0; i < sbi->s_ndevs; i++)\n\t\tif (FDEV(i).start_blk <= blkaddr && FDEV(i).end_blk >= blkaddr)\n\t\t\treturn i;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void gen_div(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_ov = tcg_temp_new();\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_setcondi_tl(TCG_COND_EQ, sr_ov, srcb, 0);\n\n    /* The result of divide-by-zero is undefined.\n\n       Supress the host-side exception by dividing by 1.  */\n\n    tcg_gen_or_tl(t0, srcb, sr_ov);\n\n    tcg_gen_div_tl(dest, srca, t0);\n\n    tcg_temp_free(t0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_ov, ctz32(SR_OV), 1);\n\n\n\n    gen_ove_ov(dc, sr_ov);\n\n    tcg_temp_free(sr_ov);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int slirp_can_output(void)\n\n{\n\n    return 1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t/* SIDH    | SIDL                 | EIDH   | EIDL\n\t\t * 28 - 21 | 20 19 18 x x x 17 16 | 15 - 8 | 7 - 0\n\t\t */\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\t/* store 28-18 bits */\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\t/* store 17-16 bits */\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\n\t\t/* store 15-0 bits */\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\t/* SIDH   | SIDL\n\t\t * 10 - 3 | 2 1 0 x x x x x\n\t\t */\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\n\tusb_msg.dlc = cf->len;\n\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\n\treturn NETDEV_TX_OK;\n\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int fetch_uidl(char *line, void *data)\n{\n  int i, index;\n  struct Context *ctx = (struct Context *) data;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  char *endp = NULL;\n\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n    return -1;\n  while (*endp == ' ')\n    endp++;\n  memmove(line, endp, strlen(endp) + 1);\n\n  for (i = 0; i < ctx->msgcount; i++)\n    if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)\n      break;\n\n  if (i == ctx->msgcount)\n  {\n    mutt_debug(1, \"new header %d %s\\n\", index, line);\n\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_header_new();\n    ctx->hdrs[i]->data = mutt_str_strdup(line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = true;\n\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n\n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static const char *dd_check(struct dump_dir *dd)\n{\n    unsigned dirname_len = strlen(dd->dd_dirname);\n    char filename_buf[FILENAME_MAX+1];\n    strcpy(filename_buf, dd->dd_dirname);\n    strcpy(filename_buf + dirname_len, \"/\"FILENAME_TIME);\n    dd->dd_time = parse_time_file(filename_buf);\n    if (dd->dd_time < 0)\n    {\n        log_warning(\"Missing file: \"FILENAME_TIME);\n        return FILENAME_TIME;\n    }\n\n    strcpy(filename_buf + dirname_len, \"/\"FILENAME_TYPE);\n    dd->dd_type = load_text_file(filename_buf, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);\n    if (!dd->dd_type || (strlen(dd->dd_type) == 0))\n    {\n        log_warning(\"Missing or empty file: \"FILENAME_TYPE);\n        return FILENAME_TYPE;\n    }\n\n    return NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int parse_fade(struct sbg_parser *p, struct sbg_fade *fr)\n\n{\n\n    struct sbg_fade f;\n\n\n\n    if (lex_char(p, '<'))\n\n        f.in = SBG_FADE_SILENCE;\n\n    else if (lex_char(p, '-'))\n\n        f.in = SBG_FADE_SAME;\n\n    else if (lex_char(p, '='))\n\n        f.in = SBG_FADE_ADAPT;\n\n    else\n\n        return 0;\n\n    if (lex_char(p, '>'))\n\n        f.out = SBG_FADE_SILENCE;\n\n    else if (lex_char(p, '-'))\n\n        f.out = SBG_FADE_SAME;\n\n    else if (lex_char(p, '='))\n\n        f.out = SBG_FADE_ADAPT;\n\n    else\n\n        return AVERROR_INVALIDDATA;\n\n    *fr = f;\n\n    return 1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline int GetCode(GifState * s)\n\n{\n\n    int c, sizbuf;\n\n    uint8_t *ptr;\n\n\n\n    while (s->bbits < s->cursize) {\n\n        ptr = s->pbuf;\n\n        if (ptr >= s->ebuf) {\n\n            if (!s->eob_reached) {\n\n                sizbuf = get_byte(s->f);\n\n                s->ebuf = s->buf + sizbuf;\n\n                s->pbuf = s->buf;\n\n                if (sizbuf > 0) {\n\n                    get_buffer(s->f, s->buf, sizbuf);\n\n                } else {\n\n                    s->eob_reached = 1;\n\n                }\n\n            }\n\n            ptr = s->pbuf;\n\n        }\n\n        s->bbuf |= ptr[0] << s->bbits;\n\n        ptr++;\n\n        s->pbuf = ptr;\n\n        s->bbits += 8;\n\n    }\n\n    c = s->bbuf & s->curmask;\n\n    s->bbuf >>= s->cursize;\n\n    s->bbits -= s->cursize;\n\n    return c;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void HTMLInputElement::setWidth(unsigned width)\n{\n    setUnsignedIntegralAttribute(widthAttr, width);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void OpenConnectionTask::authCredentialsNowAvailable()\n{\n    if (model->accessParser(parser).connState == CONN_STATE_LOGIN && loginCmd.isEmpty()) {\n        if (model->m_hasImapPassword) {\n            loginCmd = parser->login(model->m_imapUser, model->m_imapPassword);\n            model->accessParser(parser).capabilitiesFresh = false;\n        } else {\n            logout(tr(\"No credentials available\"));\n        }\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "GIntBig OGRKMLLayer::GetFeatureCount( int /* bForce */ ) { return 0; }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline bool xfrm6_addr_equal(const xfrm_address_t *a,\n\t\t\t\t    const xfrm_address_t *b)\n{\n\treturn ipv6_addr_equal((const struct in6_addr *)a,\n\t\t\t       (const struct in6_addr *)b);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static handle null() { return 0x7FFFFFFF; }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int old_rsa_priv_decode(EVP_PKEY *pkey,\n                               const unsigned char **pder, int derlen)\n{\n    RSA *rsa;\n    if (!(rsa = d2i_RSAPrivateKey(NULL, pder, derlen))) {\n        RSAerr(RSA_F_OLD_RSA_PRIV_DECODE, ERR_R_RSA_LIB);\n        return 0;\n    }\n    EVP_PKEY_assign_RSA(pkey, rsa);\n    return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "mono_thread_destroy_domain_tls (MonoDomain *domain)\n{\n\twhile (domain->tlsrec_list)\n\t\tmono_thread_destroy_tls (domain->tlsrec_list->tls_offset);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "poly_box(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tBOX\t\t   *box;\n\n\tif (poly->npts < 1)\n\t\tPG_RETURN_NULL();\n\n\tbox = box_copy(&poly->boundbox);\n\n\tPG_RETURN_BOX_P(box);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void ff_set_mpeg4_time(MpegEncContext *s)\n{\n    if (s->pict_type == AV_PICTURE_TYPE_B) {\n        ff_mpeg4_init_direct_mv(s);\n    } else {\n        s->last_time_base = s->time_base;\n        s->time_base      = FFUDIV(s->time, s->avctx->time_base.den);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n\n    /*\n     * which module is this \n     */\n    if ((fp = fopen(tmpstr, \"r\")) == NULL) {\n        snmp_log_perror(tmpstr);\n        return 1;\n    }\n    DEBUGMSGTL((\"parse-mibs\", \"Checking file: %s...\\n\",\n                tmpstr));\n    mibLine = 1;\n    File = tmpstr;\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    fclose(fp);\n\t    return 1;\n    }\n    /*\n     * simple test for this being a MIB \n     */\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        if (ip)\n            fprintf(ip, \"%s %s\\n\", token, d_name);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "test_read_bits(unsigned char const* buf,\n\t       unsigned char const*& p, unsigned int& bit_offset,\n\t       unsigned int& bits_available, int bits_wanted)\n{\n    unsigned long result =\n\tread_bits(p, bit_offset, bits_available, bits_wanted);\n\n    std::cout << \"bits read: \" << bits_wanted << \", result = \" << result\n\t      << std::endl;\n    print_values(p - buf, bit_offset, bits_available);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "scoped_refptr<SSLSocketParams> GetSslParams() {\n    if (GetParam() == HTTP)\n      return scoped_refptr<SSLSocketParams>();\n    return ignored_ssl_socket_params_;\n  }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n \tif (mode->indent_level < MAX_INDENT_LEVEL)\n \t    tbl->indent -= INDENT_INCR;\n     }\n     offset = tbl->indent;\n     if (cmd == HTML_DT) {\n \tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n \t    offset -= INDENT_INCR;\n     }\n     if (tbl->indent > 0) {\n \tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int select_voice(cst_voice **voice, const char *voice_name, void *log_ctx)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(voice_entries); i++) {\n\n        struct voice_entry *entry = &voice_entries[i];\n\n        if (!strcmp(entry->name, voice_name)) {\n\n            *voice = entry->register_fn(NULL);\n\n            if (!*voice) {\n\n                av_log(log_ctx, AV_LOG_ERROR,\n\n                       \"Could not register voice '%s'\\n\", voice_name);\n\n                return AVERROR_UNKNOWN;\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    av_log(log_ctx, AV_LOG_ERROR, \"Could not find voice '%s'\\n\", voice_name);\n\n    av_log(log_ctx, AV_LOG_INFO, \"Choose between the voices: \");\n\n    list_voices(log_ctx, \", \");\n\n\n\n    return AVERROR(EINVAL);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int64_t bdrv_get_block_status_above(BlockDriverState *bs,\n\n                                    BlockDriverState *base,\n\n                                    int64_t sector_num,\n\n                                    int nb_sectors, int *pnum,\n\n                                    BlockDriverState **file)\n\n{\n\n    Coroutine *co;\n\n    BdrvCoGetBlockStatusData data = {\n\n        .bs = bs,\n\n        .base = base,\n\n        .file = file,\n\n        .sector_num = sector_num,\n\n        .nb_sectors = nb_sectors,\n\n        .pnum = pnum,\n\n        .done = false,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_get_block_status_above_co_entry(&data);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_get_block_status_above_co_entry);\n\n        qemu_coroutine_enter(co, &data);\n\n        while (!data.done) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n    return data.ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "xmlStrncatNew(const xmlChar *str1, const xmlChar *str2, int len) {\n    int size;\n    xmlChar *ret;\n\n    if (len < 0)\n        len = xmlStrlen(str2);\n    if ((str2 == NULL) || (len == 0))\n        return(xmlStrdup(str1));\n    if (str1 == NULL)\n        return(xmlStrndup(str2, len));\n\n    size = xmlStrlen(str1);\n    ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));\n    if (ret == NULL) {\n        xmlErrMemory(NULL, NULL);\n        return(xmlStrndup(str1, size));\n    }\n    memcpy(ret, str1, size * sizeof(xmlChar));\n    memcpy(&ret[size], str2, len * sizeof(xmlChar));\n    ret[size + len] = 0;\n    return(ret);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "char *pwcheck(userid, password)\nchar *userid;\nchar *password;\n{\n    char* r;\n    struct passwd *pwd;\n\n    pwd = getpwnam(userid);\n    if (!pwd) {\n\tr = \"Userid not found\";\n    }\n    else if (pwd->pw_passwd[0] == '*') {\n\tr = \"Account disabled\";\n    }\n    else if (strcmp(pwd->pw_passwd, crypt(password, pwd->pw_passwd)) != 0) {\n\tr = \"Incorrect password\";\n    }\n    else {\n\tr = \"OK\";\n    }\n\n    endpwent();\n    \n    return r;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void QEMU_NORETURN do_unassigned_access(target_phys_addr_t addr, int is_write,\n\n                                        int is_exec, int unused, int size)\n\n{\n\n    env->trap_arg0 = addr;\n\n    env->trap_arg1 = is_write;\n\n    dynamic_excp(EXCP_MCHK, 0);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int ntop_interface_is_bridge_interface(lua_State* vm) {\n  int ifid;\n  NetworkInterface *iface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if((lua_type(vm, 1) == LUA_TNUMBER)) {\n    ifid = lua_tointeger(vm, 1);\n\n    if(ifid < 0 || !(iface = ntop->getNetworkInterface(ifid)))\n      return (CONST_LUA_ERROR);\n  }\n\n  lua_pushboolean(vm, iface->is_bridge_interface());\n  return(CONST_LUA_OK);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void copy_bits(PutBitContext *pb,\n\n                      const uint8_t *data, int size,\n\n                      GetBitContext *gb, int nbits)\n\n{\n\n    int rmn_bytes, rmn_bits;\n\n\n\n    rmn_bits = rmn_bytes = get_bits_left(gb);\n\n    if (rmn_bits < nbits)\n\n\n\n\n    rmn_bits &= 7; rmn_bytes >>= 3;\n\n    if ((rmn_bits = FFMIN(rmn_bits, nbits)) > 0)\n\n        put_bits(pb, rmn_bits, get_bits(gb, rmn_bits));\n\n    ff_copy_bits(pb, data + size - rmn_bytes,\n\n                 FFMIN(nbits - rmn_bits, rmn_bytes << 3));\n\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void __blk_rq_prep_clone(struct request *dst, struct request *src)\n{\n\tdst->cpu = src->cpu;\n\tdst->__sector = blk_rq_pos(src);\n\tdst->__data_len = blk_rq_bytes(src);\n\tif (src->rq_flags & RQF_SPECIAL_PAYLOAD) {\n\t\tdst->rq_flags |= RQF_SPECIAL_PAYLOAD;\n\t\tdst->special_vec = src->special_vec;\n\t}\n\tdst->nr_phys_segments = src->nr_phys_segments;\n\tdst->ioprio = src->ioprio;\n\tdst->extra_len = src->extra_len;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline void ide_abort_command(IDEState *s)\n{\n    s->status = READY_STAT | ERR_STAT;\n    s->error = ABRT_ERR;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "double Item_cache_decimal::val_real()\n{\n  DBUG_ASSERT(fixed);\n  double res;\n  if (!has_value())\n    return 0.0;\n  my_decimal2double(E_DEC_FATAL_ERROR, &decimal_value, &res);\n  return res;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void update_gidmap(const char *path, int pid, char *map, size_t map_len)\n{\n\tif (map == NULL || map_len <= 0)\n\t\treturn;\n\n\tif (write_file(map, map_len, \"/proc/%d/gid_map\", pid) < 0) {\n\t\tif (errno != EPERM)\n\t\t\tbail(\"failed to update /proc/%d/gid_map\", pid);\n\t\tif (try_mapping_tool(path, pid, map, map_len))\n\t\t\tbail(\"failed to use newgid map on %d\", pid);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static Jsi_Value *jsi_hashFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_HashEntry* hPtr = (Jsi_HashEntry*)h;\n    void *key = Jsi_HashKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[JSI_MAX_NUMBER_STRING];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void binder_pop_transaction_ilocked(struct binder_thread *target_thread,\n\t\t\t\t\t   struct binder_transaction *t)\n{\n\tBUG_ON(!target_thread);\n\tassert_spin_locked(&target_thread->proc->inner_lock);\n\tBUG_ON(target_thread->transaction_stack != t);\n\tBUG_ON(target_thread->transaction_stack->from != target_thread);\n\ttarget_thread->transaction_stack =\n\t\ttarget_thread->transaction_stack->from_parent;\n\tt->from = NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "remove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\thash->count--;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void sixpack_receive_buf(struct tty_struct *tty,\n\tconst unsigned char *cp, const char *fp, int count)\n{\n\tstruct sixpack *sp;\n\tint count1;\n\n\tif (!count)\n\t\treturn;\n\n\tsp = sp_get(tty);\n\tif (!sp)\n\t\treturn;\n\n\t/* Read the characters out of the buffer */\n\tcount1 = count;\n\twhile (count) {\n\t\tcount--;\n\t\tif (fp && *fp++) {\n\t\t\tif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))\n\t\t\t\tsp->dev->stats.rx_errors++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tsixpack_decode(sp, cp, count1);\n\n\tsp_put(sp);\n\ttty_unthrottle(tty);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\n\tif (!ax)\n\t\treturn;\n\n\t/*\n\t * We have now ensured that nobody can start using ap from now on, but\n\t * we have to wait for all existing users to finish.\n\t */\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\t/*\n\t * Halt the transmit queue so that a new transmit cannot scribble\n\t * on our buffers\n\t */\n\tnetif_stop_queue(ax->dev);\n\n\t/* Free all AX25 frame buffers. */\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\n\tax->tty = NULL;\n\n\tunregister_netdev(ax->dev);\n\tfree_netdev(ax->dev);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static uint64_t arm_ldq_ptw(CPUState *cs, hwaddr addr, bool is_secure,\n\n                            ARMMMUIdx mmu_idx, ARMMMUFaultInfo *fi)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    MemTxAttrs attrs = {};\n\n    AddressSpace *as;\n\n\n\n    attrs.secure = is_secure;\n\n    as = arm_addressspace(cs, attrs);\n\n    addr = S1_ptw_translate(env, mmu_idx, addr, attrs, fi);\n\n    if (fi->s1ptw) {\n\n        return 0;\n\n    }\n\n    if (regime_translation_big_endian(env, mmu_idx)) {\n\n        return address_space_ldq_be(as, addr, attrs, NULL);\n\n    } else {\n\n        return address_space_ldq_le(as, addr, attrs, NULL);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "PassOwnPtr<LayerTilerChromium> LayerTilerChromium::create(LayerRendererChromium* layerRenderer, const IntSize& tileSize)\n{\n    if (!layerRenderer || tileSize.isEmpty())\n        return 0;\n\n    return adoptPtr(new LayerTilerChromium(layerRenderer, tileSize));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void kvm_arm_reset_vcpu(ARMCPU *cpu)\n\n{\n\n    /* Re-init VCPU so that all registers are set to\n\n     * their respective reset values.\n\n     */\n\n    kvm_arm_vcpu_init(CPU(cpu));\n\n    write_kvmstate_to_list(cpu);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "//! Load image from a JPEG file \\overloading.\n    CImg<T>& load_jpeg(std::FILE *const file) {\n      return _load_jpeg(file,0);",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  // find the size of the final UCS-2 string\n  size_t i;\n  for (_Length=0, i=0; i<UTF8string.length(); _Length++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80)\n      i++;\n    else if ((lead >> 5) == 0x6)\n      i += 2;\n    else if ((lead >> 4) == 0xe)\n      i += 3;\n    else if ((lead >> 3) == 0x1e)\n      i += 4;\n    else\n      // Invalid size?\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<UTF8string.length(); j++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80) {\n      _Data[j] = lead;\n      i++;\n    } else if ((lead >> 5) == 0x6) {\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n      i += 2;\n    } else if ((lead >> 4) == 0xe) {\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n      i += 3;\n    } else if ((lead >> 3) == 0x1e) {\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n      i += 4;\n    } else\n      // Invalid char?\n      break;\n  }\n  _Data[j] = 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "on_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler ? handler->opaque : NULL;\n\n\tif (!handler) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n\t\t\t\t      \"unknown subtype\"));\n\t\treturn TRUE;\n\t}\n\tdbus_unexport_handler(handler);\n\ttcmur_unregister_handler(handler);\n\tg_bus_unwatch_name(info->watcher_id);\n\tg_free(info);\n\tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n\treturn TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "writeDataError(instanceData *pData, cJSON **pReplyRoot, uchar *reqmsg)\n{\n\tchar *rendered = NULL;\n\tcJSON *errRoot;\n\tcJSON *req;\n\tcJSON *replyRoot = *pReplyRoot;\n\tsize_t toWrite;\n\tssize_t wrRet;\n\tchar errStr[1024];\n\tDEFiRet;\n\n\tif(pData->errorFile == NULL) {\n\t\tDBGPRINTF(\"omelasticsearch: no local error logger defined - \"\n\t\t          \"ignoring ES error information\\n\");\n\t\tFINALIZE;\n\t}\n\n\tif(pData->fdErrFile == -1) {\n\t\tpData->fdErrFile = open((char*)pData->errorFile,\n\t\t\t\t\tO_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,\n\t\t\t\t\tS_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);\n\t\tif(pData->fdErrFile == -1) {\n\t\t\trs_strerror_r(errno, errStr, sizeof(errStr));\n\t\t\tDBGPRINTF(\"omelasticsearch: error opening error file: %s\\n\", errStr);\n\t\t\tABORT_FINALIZE(RS_RET_ERR);\n\t\t}\n\t}\n\tif((req=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);\n\tcJSON_AddItemToObject(req, \"url\", cJSON_CreateString((char*)pData->restURL));\n\tcJSON_AddItemToObject(req, \"postdata\", cJSON_CreateString((char*)reqmsg));\n\n\tif((errRoot=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);\n\tcJSON_AddItemToObject(errRoot, \"request\", req);\n\tcJSON_AddItemToObject(errRoot, \"reply\", replyRoot);\n\trendered = cJSON_Print(errRoot);\n\t/* we do not do real error-handling on the err file, as this finally complicates\n\t * things way to much.\n\t */\n\tDBGPRINTF(\"omelasticsearch: error record: '%s'\\n\", rendered);\n\ttoWrite = strlen(rendered);\n\twrRet = write(pData->fdErrFile, rendered, toWrite);\n\tif(wrRet != (ssize_t) toWrite) {\n\t\tDBGPRINTF(\"omelasticsearch: error %d writing error file, write returns %lld\\n\",\n\t\t\t  errno, (long long) wrRet);\n\t}\n\tfree(rendered);\n\tcJSON_Delete(errRoot);\n\t*pReplyRoot = NULL; /* tell caller not to delete once again! */\n\nfinalize_it:\n\tif(rendered != NULL)\n\t\tfree(rendered);\n\tRETiRet;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void ovs_lock(void)\n{\n\tmutex_lock(&ovs_mutex);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\n\t/* User must provide at least the assoc id */\n \tif (len < sizeof(sctp_assoc_t))\n \t\treturn -EINVAL;\n \n \tif (copy_from_user(&sas, optval, len))\n \t\treturn -EFAULT;\n \n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\n\t/* New high max rto observed, will return 0 if not a single\n\t * RTO update took place. obs_rto_ipaddr will be bogus\n\t * in such a case\n\t */\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\n \t/* Mark beginning of a new observation period */\n \tasoc->stats.max_obs_rto = asoc->rto_min;\n \n\t/* Allow the struct to grow and fill in as much as possible */\n\tlen = min_t(size_t, len, sizeof(sas));\n \tif (put_user(len, optlen))\n \t\treturn -EFAULT;\n \n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "_asn1_extract_der_octet (asn1_node node, const unsigned char *der,\n\t\t\t int der_len, unsigned flags)\n{\n  int len2, len3;\n  int counter, counter_end;\n  int result;\n\n  len2 = asn1_get_length_der (der, der_len, &len3);\n  if (len2 < -1)\n    return ASN1_DER_ERROR;\n\n  counter = len3 + 1;\n\n  if (len2 == -1)\n    counter_end = der_len - 2;\n  else\n    counter_end = der_len;\n\n  while (counter < counter_end)\n    {\n      len2 = asn1_get_length_der (der + counter, der_len, &len3);\n\n      if (IS_ERR(len2, flags))\n\t{\n\t  warn();\n\t  return ASN1_DER_ERROR;\n\t}\n\n      if (len2 >= 0)\n\t{\n\t  DECR_LEN(der_len, len2+len3);\n\t  _asn1_append_value (node, der + counter + len3, len2);\n\t}\n      else\n\t{\t\t\t/* indefinite */\n\t  DECR_LEN(der_len, len3);\n\t  result =\n\t    _asn1_extract_der_octet (node, der + counter + len3,\n\t\t\t\t     der_len, flags);\n\t  if (result != ASN1_SUCCESS)\n\t    return result;\n\t  len2 = 0;\n\t}\n\n      DECR_LEN(der_len, 1);\n      counter += len2 + len3 + 1;\n    }\n\n  return ASN1_SUCCESS;\n\ncleanup:\n  return result;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int isShadowTableName(sqlite3 *db, char *zName){\n  char *zTail;                  /* Pointer to the last \"_\" in zName */\n  Table *pTab;                  /* Table that zName is a shadow of */\n  Module *pMod;                 /* Module for the virtual table */\n\n  zTail = strrchr(zName, '_');\n  if( zTail==0 ) return 0;\n  *zTail = 0;\n  pTab = sqlite3FindTable(db, zName, 0);\n  *zTail = '_';\n  if( pTab==0 ) return 0;\n  if( !IsVirtual(pTab) ) return 0;\n  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->azModuleArg[0]);\n  if( pMod==0 ) return 0;\n  if( pMod->pModule->iVersion<3 ) return 0;\n  if( pMod->pModule->xShadowName==0 ) return 0;\n  return pMod->pModule->xShadowName(zTail+1);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void pin_remove(struct fs_pin *pin)\n{\n\tspin_lock(&pin_lock);\n\thlist_del(&pin->m_list);\n\thlist_del(&pin->s_list);\n\tspin_unlock(&pin_lock);\n\tspin_lock_irq(&pin->wait.lock);\n\tpin->done = 1;\n\twake_up_locked(&pin->wait);\n\tspin_unlock_irq(&pin->wait.lock);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void ADDCALL sass_file_context_set_options (struct Sass_File_Context* ctx, struct Sass_Options* opt) { copy_options(ctx, opt); }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void sctp_v4_inaddr_any(union sctp_addr *addr, __be16 port)\n{\n\taddr->v4.sin_family = AF_INET;\n\taddr->v4.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr->v4.sin_port = port;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void _php_pgsql_notice_ptr_dtor(void **ptr) \n{\n\tphp_pgsql_notice *notice = (php_pgsql_notice *)*ptr;\n\tif (notice) {\n\t\tefree(notice->message);\n\t\tefree(notice);\n\t\tnotice = NULL;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "**/\n    CImg<T>& operator-=(const char *const expression) {\n      return *this-=(+*this)._fill(expression,true,1,0,0,\"operator-=\",this);",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int cmm_pages_handler(struct ctl_table *ctl, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tlong nr = cmm_get_pages();\n\tstruct ctl_table ctl_entry = {\n\t\t.procname\t= ctl->procname,\n\t\t.data\t\t= &nr,\n\t\t.maxlen\t\t= sizeof(long),\n\t};\n\tint rc;\n\n\trc = proc_doulongvec_minmax(&ctl_entry, write, buffer, lenp, ppos);\n\tif (rc < 0 || !write)\n\t\treturn rc;\n\n\tcmm_set_pages(nr);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int wc_RsaPSS_VerifyInline(byte* in, word32 inLen, byte** out,\n                           enum wc_HashType hash, int mgf, RsaKey* key)\n{\n#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER\n    return wc_RsaPSS_VerifyInline_ex(in, inLen, out, hash, mgf,\n                                                 RSA_PSS_SALT_LEN_DEFAULT, key);\n#else\n    return wc_RsaPSS_VerifyInline_ex(in, inLen, out, hash, mgf,\n                                                RSA_PSS_SALT_LEN_DISCOVER, key);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void long2str(unsigned char *dst, s32 n)\n{\n\tdst[0] = (n    )&0xff;\n\tdst[1] = (n>> 8)&0xff;\n\tdst[2] = (n>>16)&0xff;\n\tdst[3] = (n>>24)&0xff;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bjc_put_page_margins(gp_file *file, int length, int lm, int rm, int top)\n{\n    byte parms[4];\n\n    parms[0] = length, parms[1] = lm, parms[2] = rm, parms[3] = top;\n/*    count = 4;       */ /* could be 1..3 */\n    bjc_put_command(file, 'g', 4);\n    bjc_put_bytes(file, parms, 4);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static ssize_t set_cmci_disabled(struct device *s,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t size)\n{\n\tu64 new;\n\n\tif (kstrtou64(buf, 0, &new) < 0)\n\t\treturn -EINVAL;\n\n\tif (mca_cfg.cmci_disabled ^ !!new) {\n\t\tif (new) {\n\t\t\t/* disable cmci */\n\t\t\ton_each_cpu(mce_disable_cmci, NULL, 1);\n\t\t\tmca_cfg.cmci_disabled = true;\n\t\t} else {\n\t\t\t/* enable cmci */\n\t\t\tmca_cfg.cmci_disabled = false;\n\t\t\ton_each_cpu(mce_enable_ce, NULL, 1);\n\t\t}\n\t}\n\treturn size;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void caps_to_network(RDMACapabilities *cap)\n\n{\n\n    cap->version = htonl(cap->version);\n\n    cap->flags = htonl(cap->flags);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int mb86a20s_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tint val;\n\n\t*status = 0;\n\n\tval = mb86a20s_readreg(state, 0x0a) & 0xf;\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val >= 2)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (val >= 4)\n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (val >= 5)\n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (val >= 7)\n\t\t*status |= FE_HAS_SYNC;\n\n\tif (val >= 8)\t\t\t\t/* Maybe 9? */\n\t\t*status |= FE_HAS_LOCK;\n\n\tdev_dbg(&state->i2c->dev, \"%s: Status = 0x%02x (state = %d)\\n\",\n\t\t __func__, *status, val);\n\n\treturn val;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "sshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "kvm_eventfd_init(struct kvm *kvm)\n{\n#ifdef CONFIG_HAVE_KVM_IRQFD\n\tspin_lock_init(&kvm->irqfds.lock);\n\tINIT_LIST_HEAD(&kvm->irqfds.items);\n\tINIT_LIST_HEAD(&kvm->irqfds.resampler_list);\n\tmutex_init(&kvm->irqfds.resampler_lock);\n#endif\n\tINIT_LIST_HEAD(&kvm->ioeventfds);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "XMLRPC_VALUE XMLRPC_VectorRewind(XMLRPC_VALUE value) {\n   XMLRPC_VALUE xReturn = NULL;\n   if(value && value->type == xmlrpc_vector && value->v) {\n      xReturn = (XMLRPC_VALUE)Q_Head(value->v->q);\n   }\n   return xReturn;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void jas_matrix_setall(jas_matrix_t *matrix, jas_seqent_t val)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = val;\n\t\t\t}\n\t\t}\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int _pgsql_commit_txn(void *conn, const sasl_utils_t *utils)\n{\n    return _pgsql_exec(conn, \"COMMIT;\", NULL, 0, NULL, utils);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\n\t*minor_status = 0;\n\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\n\t/*\n\t * If this is still an SPNEGO mech, release it locally.\n\t */\n\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n\t\t(void) gss_delete_sec_context(minor_status,\n\t\t\t\t    &(*ctx)->ctx_handle,\n\t\t\t\t    output_token);\n\t\t(void) release_spnego_ctx(ctx);\n\t} else {\n\t\tret = gss_delete_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    output_token);\n\t}\n\n\treturn (ret);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void sungem_send_packet(SunGEMState *s, const uint8_t *buf,\n                               int size)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n    if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) {\n        nc->info->receive(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int esil_avr_hook_reg_write(RAnalEsil *esil, const char *name, ut64 *val) {\n\tCPU_MODEL *cpu;\n\n\tif (!esil || !esil->anal) {\n\t\treturn 0;\n\t}\n\n\tcpu = get_cpu_model (esil->anal->cpu);\n\n\tif (!strcmp (name, \"pc\")) {\n\t\t*val &= CPU_PC_MASK (cpu);\n\t} else if (!strcmp (name, \"pcl\")) {\n\t\tif (cpu->pc < 8) {\n\t\t\t*val &= MASK (8);\n\t\t}\n\t} else if (!strcmp (name, \"pch\")) {\n\t\t*val = cpu->pc > 8\n\t\t\t? *val & MASK (cpu->pc - 8)\n\t\t\t: 0;\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void ColorChooserWin::OnColorChosen(SkColor color) {\n   if (web_contents_)\n     web_contents_->DidChooseColorInColorChooser(color);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "build_edi(krb5_context context,\n\t  hx509_context hx509ctx,\n\t  hx509_certs certs,\n\t  ExternalPrincipalIdentifiers *ids)\n{\n    return hx509_certs_iter_f(hx509ctx, certs, cert2epi, ids);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void cpu_interrupt(CPUArchState *env, int mask)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n\n\n    env->interrupt_request |= mask;\n\n    cpu_unlink_tb(cpu);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static netdev_features_t tun_net_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\treturn (features & tun->set_features) | (features & ~TUN_USER_FEATURES);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void CLASS parse_qt(int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp) + 7 < end)\n  {\n    save = ftell(ifp);\n    if ((size = get4()) < 8)\n      return;\n    fread(tag, 4, 1, ifp);\n    if (!memcmp(tag, \"moov\", 4) || !memcmp(tag, \"udta\", 4) || !memcmp(tag, \"CNTH\", 4))\n      parse_qt(save + size);\n    if (!memcmp(tag, \"CNDA\", 4))\n      parse_jpeg(ftell(ifp));\n    fseek(ifp, save + size, SEEK_SET);\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void sctp_hash_established(struct sctp_association *asoc)\n{\n\tif (asoc->temp)\n\t\treturn;\n\n\tsctp_local_bh_disable();\n\t__sctp_hash_established(asoc);\n\tsctp_local_bh_enable();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void AudioNode::Dispose() {\n  DCHECK(IsMainThread());\n#if DEBUG_AUDIONODE_REFERENCES\n  fprintf(stderr, \"[%16p]: %16p: %2d: AudioNode::dispose %16p\\n\", context(),\n          this, Handler().GetNodeType(), handler_.get());\n #endif\n   BaseAudioContext::GraphAutoLocker locker(context());\n   Handler().Dispose();\n  if (context()->HasRealtimeConstraint()) {\n     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n         std::move(handler_));\n  } else {\n    if (context()->ContextState() == BaseAudioContext::kRunning) {\n      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n          std::move(handler_));\n    }\n   }\n }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)\n{\n  YYUSE (yyvaluep);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YYUSE (yytype);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)\n{\n    detachParser();\n\n    removeChildren();\n    ASSERT(!m_focusedElement);\n\n    setCompatibilityMode(NoQuirksMode);\n\n    if (!threadedParsingEnabledForTesting())\n        parserSyncPolicy = ForceSynchronousParsing;\n\n    m_parserSyncPolicy = parserSyncPolicy;\n    m_parser = createParser();\n    setParsingState(Parsing);\n    setReadyState(Loading);\n\n    return m_parser;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int pam_sm_open_session (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    task_id=(short int) magic();\n    return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);\n}    /* pam_sm_open_session */",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "xsltFreeNsAliasList(xsltNsAliasPtr item)\n{\n    xsltNsAliasPtr tmp;\n    \n    while (item) {\n\ttmp = item;\n\titem = item->next;\n\txmlFree(tmp);\n    } \n    return;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bool FontData::Bound(int32_t offset, int32_t length) {\n  if (offset + length > Size() || offset < 0 || length < 0)\n    return false;\n\n  bound_offset_ += offset;\n  bound_length_ = length;\n  return true;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "jbig2_image_compose_opt_OR(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_OR);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_OR);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "onigenc_set_default_encoding(OnigEncoding enc)\n{\n  OnigEncDefaultCharEncoding = enc;\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int selinux_netlbl_inode_permission(struct inode *inode, int mask)\n{\n\tint rc;\n\tstruct sock *sk;\n\tstruct socket *sock;\n\tstruct sk_security_struct *sksec;\n\n\tif (!S_ISSOCK(inode->i_mode) ||\n\t    ((mask & (MAY_WRITE | MAY_APPEND)) == 0))\n\t\treturn 0;\n\n\tsock = SOCKET_I(inode);\n\tsk = sock->sk;\n\tsksec = sk->sk_security;\n\tif (sksec->nlbl_state != NLBL_REQUIRE)\n\t\treturn 0;\n\n\tlocal_bh_disable();\n\tbh_lock_sock_nested(sk);\n\tif (likely(sksec->nlbl_state == NLBL_REQUIRE))\n\t\trc = selinux_netlbl_sock_setsid(sk);\n\telse\n\t\trc = 0;\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "http_client_check_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)\n{\n  GError *error;\n  CheckData *data = user_data;\n  gboolean op_res;\n\n  error = NULL;\n  op_res = FALSE;\n\n  if (msg->status_code == SOUP_STATUS_CANCELLED)\n    goto out;\n  else if (msg->status_code != SOUP_STATUS_OK)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Code: %u - Unexpected response from server\"),\n                   msg->status_code);\n      goto out;\n    }\n\n  op_res = TRUE;\n\n out:\n  g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n  if (error != NULL)\n    g_simple_async_result_take_error (data->res, error);\n\n  g_simple_async_result_complete_in_idle (data->res);\n  g_idle_add (http_client_check_data_free, data);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "link_heap_page(mrb_gc *gc, mrb_heap_page *page)\n{\n  page->next = gc->heaps;\n  if (gc->heaps)\n    gc->heaps->prev = page;\n  gc->heaps = page;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static bool check_mem_area(uc_engine *uc, uint64_t address, size_t size)\n{\n    size_t count = 0, len;\n\n    while (count < size) {\n        MemoryRegion *mr = memory_mapping(uc, address);\n        if (mr) {\n            len = (size_t)MIN(size - count, mr->end - address);\n            count += len;\n            address += len;\n        } else { // this address is not mapped in yet\n            break;\n        }\n    }\n\n    return (count == size);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "parse_numeric_servname(const char *servname)\n{\n\tint n;\n\tchar *endptr=NULL;\n\tn = (int) strtol(servname, &endptr, 10);\n\tif (n>=0 && n <= 65535 && servname[0] && endptr && !endptr[0])\n\t\treturn n;\n\telse\n\t\treturn -1;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t len;\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        len = r->sector_count * 512;\n        if (len > SCSI_DMA_BUF_SIZE) {\n            len = SCSI_DMA_BUF_SIZE;\n        }\n        r->iov.iov_len = len;\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n        scsi_req_data(&r->req, len);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static double mp_list_set_ioff(_cimg_math_parser& mp) {\n        const unsigned int ind = (unsigned int)cimg::mod((int)_mp_arg(2),mp.listin.width());\n        CImg<T> &img = mp.listout[ind];\n        const longT\n          off = (longT)_mp_arg(3),\n          whds = (longT)img.size();\n        const double val = _mp_arg(1);\n        if (off>=0 && off<whds) img[off] = (T)val;\n        return val;",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void Sleep(int millisecs)\n{\n    const struct timespec rqtp = { 0 , millisecs*1000000 } ;\n    struct timespec   rmtp ;\n    nanosleep(&rqtp,&rmtp);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "count_chunks(struct regional* r)\n{\n\tsize_t c = 1;\n\tchar* p = r->next;\n\twhile(p) {\n\t\tc++;\n\t\tp = *(char**)p;\n\t}\n\treturn c;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/*\n\t * ->lru in the tail pages is occupied by compound_head.\n\t * Let's use ->mapping + ->index in the second tail page as list_head.\n\t */\n\treturn (struct list_head *)&page[2].mapping;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n\n            if (op == self) {\n                continue;\n            }\n\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                break;\n            }\n        }\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit, rightLimit;\n \tint i;\n \tint restoreAlphaBleding;\n \n\tif (border < 0) {\n \t\t/* Refuse to fill to a non-solid border */\n \t\treturn;\n \t}\n \n \tleftLimit = (-1);\n \n \trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\t\n\tfor (i = x; (i >= 0); i--) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == (-1)) {\n\t\tim->alphaBlendingFlag = restoreAlphaBleding;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); (i < im->sx); i++) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c;\n\t\t\tc = gdImageGetPixel (im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c = gdImageGetPixel (im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBleding;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void Magick::Image::colorize(const unsigned int alpha_,const Color &penColor_)\n{\n  colorize(alpha_,alpha_,alpha_,penColor_);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "BdrvDirtyBitmap *bdrv_create_dirty_bitmap(BlockDriverState *bs, int granularity,\n\n                                          Error **errp)\n\n{\n\n    int64_t bitmap_size;\n\n    BdrvDirtyBitmap *bitmap;\n\n\n\n    assert((granularity & (granularity - 1)) == 0);\n\n\n\n    granularity >>= BDRV_SECTOR_BITS;\n\n    assert(granularity);\n\n    bitmap_size = bdrv_nb_sectors(bs);\n\n    if (bitmap_size < 0) {\n\n        error_setg_errno(errp, -bitmap_size, \"could not get length of device\");\n\n        errno = -bitmap_size;\n\n        return NULL;\n\n    }\n\n    bitmap = g_malloc0(sizeof(BdrvDirtyBitmap));\n\n    bitmap->bitmap = hbitmap_alloc(bitmap_size, ffs(granularity) - 1);\n\n    QLIST_INSERT_HEAD(&bs->dirty_bitmaps, bitmap, list);\n\n    return bitmap;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void dtls1_clear_record_buffer(SSL *s)\n{\n    pitem *item;\n\n    for (item = pqueue_pop(s->d1->sent_messages);\n         item != NULL; item = pqueue_pop(s->d1->sent_messages)) {\n        dtls1_hm_fragment_free((hm_fragment *)item->data);\n        pitem_free(item);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void dd_save_text(struct dump_dir *dd, const char *name, const char *data)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int encode_locku(struct xdr_stream *xdr, const struct nfs_locku_args *args)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(12+NFS4_STATEID_SIZE+16);\n\tWRITE32(OP_LOCKU);\n\tWRITE32(nfs4_lock_type(args->fl, 0));\n\tWRITE32(args->seqid->sequence->counter);\n\tWRITEMEM(args->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE64(args->fl->fl_start);\n\tWRITE64(nfs4_lock_length(args->fl));\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void ndpi_set_log_level(struct ndpi_detection_module_struct *ndpi_str, u_int l){\n  ndpi_str->ndpi_log_level = l;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int dmar_check_one_atsr(struct acpi_dmar_header *hdr, void *arg)\n{\n\tint i;\n\tstruct device *dev;\n\tstruct acpi_dmar_atsr *atsr;\n\tstruct dmar_atsr_unit *atsru;\n\n\tatsr = container_of(hdr, struct acpi_dmar_atsr, header);\n\tatsru = dmar_find_atsr(atsr);\n\tif (!atsru)\n\t\treturn 0;\n\n\tif (!atsru->include_all && atsru->devices && atsru->devices_cnt) {\n\t\tfor_each_active_dev_scope(atsru->devices, atsru->devices_cnt,\n\t\t\t\t\t  i, dev)\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static Variant setVariable(const Object& obj, const char* varName, const Variant& varValue) {\n  return obj->o_set(varName, varValue, s_ZipArchive);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_check_callbacks(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers(p);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "Buffer(T *ptr = FMT_NULL, std::size_t capacity = 0)\n    : ptr_(ptr), size_(0), capacity_(capacity) {}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static struct sk_buff *skb_reorder_vlan_header(struct sk_buff *skb)\n{\n\tif (skb_cow(skb, skb_headroom(skb)) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tmemmove(skb->data - ETH_HLEN, skb->data - skb->mac_len - VLAN_HLEN,\n\t\t2 * ETH_ALEN);\n\tskb->mac_header += VLAN_HLEN;\n\treturn skb;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "QmpInputVisitor *qmp_input_visitor_new(QObject *obj, bool strict)\n\n{\n\n    QmpInputVisitor *v;\n\n\n\n    v = g_malloc0(sizeof(*v));\n\n\n\n    v->visitor.type = VISITOR_INPUT;\n\n    v->visitor.start_struct = qmp_input_start_struct;\n\n    v->visitor.end_struct = qmp_input_end_struct;\n\n    v->visitor.start_list = qmp_input_start_list;\n\n    v->visitor.next_list = qmp_input_next_list;\n\n    v->visitor.end_list = qmp_input_end_list;\n\n    v->visitor.start_alternate = qmp_input_start_alternate;\n\n    v->visitor.type_int64 = qmp_input_type_int64;\n\n    v->visitor.type_uint64 = qmp_input_type_uint64;\n\n    v->visitor.type_bool = qmp_input_type_bool;\n\n    v->visitor.type_str = qmp_input_type_str;\n\n    v->visitor.type_number = qmp_input_type_number;\n\n    v->visitor.type_any = qmp_input_type_any;\n\n    v->visitor.type_null = qmp_input_type_null;\n\n    v->visitor.optional = qmp_input_optional;\n\n    v->strict = strict;\n\n\n\n    v->root = obj;\n\n    qobject_incref(obj);\n\n\n\n    return v;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n \t\tgoto err;\n \t}\n \n\tlen = file ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "hotplug_hrtick(struct notifier_block *nfb, unsigned long action, void *hcpu)\n{\n\tint cpu = (int)(long)hcpu;\n\n\tswitch (action) {\n\tcase CPU_UP_CANCELED:\n\tcase CPU_UP_CANCELED_FROZEN:\n\tcase CPU_DOWN_PREPARE:\n\tcase CPU_DOWN_PREPARE_FROZEN:\n\tcase CPU_DEAD:\n\tcase CPU_DEAD_FROZEN:\n\t\thrtick_clear(cpu_rq(cpu));\n\t\treturn NOTIFY_OK;\n\t}\n\n\treturn NOTIFY_DONE;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int fib6_nh_drop_pcpu_from(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_pcpu_arg *arg = _arg;\n\n\t__fib6_drop_pcpu_from(nh, arg->from, arg->table);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t       struct skb_shared_hwtstamps *hwtstamps)\n{\n\tstruct sock *sk = skb->sk;\n\n\tif (!skb_may_tx_timestamp(sk, false))\n\t\treturn;\n\n\t/* Take a reference to prevent skb_orphan() from freeing the socket,\n\t * but only if the socket refcount is not zero.\n\t */\n\tif (likely(atomic_inc_not_zero(&sk->sk_refcnt))) {\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\t\t__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND);\n\t\tsock_put(sk);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void atusb_disconnect(struct usb_interface *interface)\n{\n\tstruct atusb *atusb = usb_get_intfdata(interface);\n\n\tdev_dbg(&atusb->usb_dev->dev, \"%s\\n\", __func__);\n\n\tatusb->shutdown = 1;\n\tcancel_delayed_work_sync(&atusb->work);\n\n\tusb_kill_anchored_urbs(&atusb->rx_urbs);\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\n\tieee802154_unregister_hw(atusb->hw);\n\n\tieee802154_free_hw(atusb->hw);\n\n\tusb_set_intfdata(interface, NULL);\n\tusb_put_dev(atusb->usb_dev);\n\n\tpr_debug(\"%s done\\n\", __func__);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static long ioctl_file_clone_range(struct file *file, void __user *argp)\n{\n\tstruct file_clone_range args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn ioctl_file_clone(file, args.src_fd, args.src_offset,\n\t\t\t\targs.src_length, args.dest_offset);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void FoFiTrueType::convertToType1(char *psName, const char **newEncoding,\n\t\t\t\t  GBool ascii, FoFiOutputFunc outputFunc,\n\t\t\t\t  void *outputStream) {\n  char *start;\n  int length;\n  FoFiType1C *ff;\n\n  if (!getCFFBlock(&start, &length)) {\n    return;\n  }\n  if (!(ff = FoFiType1C::make(start, length))) {\n    return;\n  }\n  ff->convertToType1(psName, newEncoding, ascii, outputFunc, outputStream);\n  delete ff;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "uint_t aubio_tempo_set_threshold(aubio_tempo_t * o, smpl_t threshold) {\n  o->threshold = threshold;\n  aubio_peakpicker_set_threshold(o->pp, o->threshold);\n  return AUBIO_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static js_Ast *logor(js_State *J, int notin)\n{\n\tjs_Ast *a = logand(J, notin);\n\tif (jsP_accept(J, TK_OR))\n\t\ta = EXP2(LOGOR, a, logor(J, notin));\n\treturn a;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "unsigned int munlock_vma_page(struct page *page)\n{\n\tunsigned int nr_pages;\n\tstruct zone *zone = page_zone(page);\n\n\tBUG_ON(!PageLocked(page));\n\n\t/*\n\t * Serialize with any parallel __split_huge_page_refcount() which\n\t * might otherwise copy PageMlocked to part of the tail pages before\n\t * we clear it in the head page. It also stabilizes hpage_nr_pages().\n\t */\n\tspin_lock_irq(&zone->lru_lock);\n\n\tnr_pages = hpage_nr_pages(page);\n\tif (!TestClearPageMlocked(page))\n\t\tgoto unlock_out;\n\n\t__mod_zone_page_state(zone, NR_MLOCK, -nr_pages);\n\n\tif (__munlock_isolate_lru_page(page, true)) {\n\t\tspin_unlock_irq(&zone->lru_lock);\n\t\t__munlock_isolated_page(page);\n\t\tgoto out;\n\t}\n\t__munlock_isolation_failed(page);\n\nunlock_out:\n\tspin_unlock_irq(&zone->lru_lock);\n\nout:\n\treturn nr_pages - 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "create_bits (pixman_format_code_t format,\n             int                  width,\n             int                  height,\n             int *\t\t  rowstride_bytes,\n\t     pixman_bool_t\t  clear)\n{\n    int stride;\n    size_t buf_size;\n    int bpp;\n\n    /* what follows is a long-winded way, avoiding any possibility of integer\n     * overflows, of saying:\n     * stride = ((width * bpp + 0x1f) >> 5) * sizeof (uint32_t);\n     */\n\n    bpp = PIXMAN_FORMAT_BPP (format);\n    if (_pixman_multiply_overflows_int (width, bpp))\n\treturn NULL;\n\n    stride = width * bpp;\n    if (_pixman_addition_overflows_int (stride, 0x1f))\n\treturn NULL;\n\n    stride += 0x1f;\n    stride >>= 5;\n\n    stride *= sizeof (uint32_t);\n\n     if (_pixman_multiply_overflows_size (height, stride))\n \treturn NULL;\n \n    buf_size = height * stride;\n \n     if (rowstride_bytes)\n \t*rowstride_bytes = stride;\n\n    if (clear)\n\treturn calloc (buf_size, 1);\n    else\n\treturn malloc (buf_size);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static unsigned int stack_maxrandom_size(void)\n {\n\tunsigned int max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \n \treturn max;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "test_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "MagickPrivate void XDelay(Display *display,const size_t milliseconds)\n{\n  assert(display != (Display *) NULL);\n  (void) XFlush(display);\n  MagickDelay(milliseconds);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tstruct sockaddr_ipx *sipx = (struct sockaddr_ipx *)msg->msg_name;\n\tstruct ipxhdr *ipx = NULL;\n\tstruct sk_buff *skb;\n\tint copied, rc;\n\n\tlock_sock(sk);\n\t/* put the autobinding in */\n\tif (!ipxs->port) {\n\t\tstruct sockaddr_ipx uaddr;\n\n\t\tuaddr.sipx_port\t\t= 0;\n\t\tuaddr.sipx_network \t= 0;\n\n#ifdef CONFIG_IPX_INTERN\n\t\trc = -ENETDOWN;\n\t\tif (!ipxs->intrfc)\n\t\t\tgoto out; /* Someone zonked the iface */\n\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node, IPX_NODE_LEN);\n#endif\t/* CONFIG_IPX_INTERN */\n\n\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t      sizeof(struct sockaddr_ipx));\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb)\n\t\tgoto out;\n\n\tipx \t= ipx_hdr(skb);\n\tcopied \t= ntohs(ipx->ipx_pktsize) - sizeof(struct ipxhdr);\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\trc = skb_copy_datagram_iovec(skb, sizeof(struct ipxhdr), msg->msg_iov,\n\t\t\t\t     copied);\n\tif (rc)\n\t\tgoto out_free;\n \tif (skb->tstamp.tv64)\n \t\tsk->sk_stamp = skb->tstamp;\n \n\tmsg->msg_namelen = sizeof(*sipx);\n \tif (sipx) {\n \t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n \t\tmemcpy(sipx->sipx_node, ipx->ipx_source.node, IPX_NODE_LEN);\n \t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n \t\tsipx->sipx_type \t= ipx->ipx_type;\n \t\tsipx->sipx_zero\t\t= 0;\n \t}\n \trc = copied;\n \nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "SPL_METHOD(SplFileObject, fflush)\n{\n\tspl_filesystem_object *intern = Z_SPLFILESYSTEM_P(getThis());\n\n\tif(!intern->u.file.stream) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0, \"Object not initialized\");\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(!php_stream_flush(intern->u.file.stream));\n} /* }}} */",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n {\n\tu16 offset = sizeof(struct ipv6hdr);\n \tunsigned int packet_len = skb_tail_pointer(skb) -\n \t\tskb_network_header(skb);\n \tint found_rhdr = 0;\n \t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n \n \twhile (offset <= packet_len) {\n \t\tstruct ipv6_opt_hdr *exthdr;\n \n \t\tswitch (**nexthdr) {\n \n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n \n \t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n \t\t\t\t\t\t offset);\n\t\toffset += ipv6_optlen(exthdr);\n \t\t*nexthdr = &exthdr->nexthdr;\n \t}\n \n\treturn -EINVAL;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void warn_dirty_buffer(struct buffer_head *bh)\n{\n\tprintk(KERN_WARNING\n\t       \"JBD2: Spotted dirty metadata buffer (dev = %pg, blocknr = %llu). \"\n\t       \"There's a risk of filesystem corruption in case of system \"\n\t       \"crash.\\n\",\n\t       bh->b_bdev, (unsigned long long)bh->b_blocknr);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static const char **get_handler_errmsgs(int nr)\n{\n  return handler_errmsgs;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void msix_write_config(PCIDevice *dev, uint32_t addr,\n\n                       uint32_t val, int len)\n\n{\n\n    unsigned enable_pos = dev->msix_cap + MSIX_CONTROL_OFFSET;\n\n    int vector;\n\n    bool was_masked;\n\n\n\n    if (!range_covers_byte(addr, len, enable_pos)) {\n\n        return;\n\n    }\n\n\n\n    was_masked = dev->msix_function_masked;\n\n    msix_update_function_masked(dev);\n\n\n\n    if (!msix_enabled(dev)) {\n\n        return;\n\n    }\n\n\n\n    pci_device_deassert_intx(dev);\n\n\n\n    if (dev->msix_function_masked == was_masked) {\n\n        return;\n\n    }\n\n\n\n    for (vector = 0; vector < dev->msix_entries_nr; ++vector) {\n\n        msix_handle_mask_update(dev, vector);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "xfs_attr_shortform_verify(\n\tstruct xfs_inode\t\t*ip)\n{\n\tstruct xfs_attr_shortform\t*sfp;\n\tstruct xfs_attr_sf_entry\t*sfep;\n\tstruct xfs_attr_sf_entry\t*next_sfep;\n\tchar\t\t\t\t*endp;\n\tstruct xfs_ifork\t\t*ifp;\n\tint\t\t\t\ti;\n\tint64_t\t\t\t\tsize;\n\n\tASSERT(ip->i_afp->if_format == XFS_DINODE_FMT_LOCAL);\n\tifp = XFS_IFORK_PTR(ip, XFS_ATTR_FORK);\n\tsfp = (struct xfs_attr_shortform *)ifp->if_u1.if_data;\n\tsize = ifp->if_bytes;\n\n\t/*\n\t * Give up if the attribute is way too short.\n\t */\n\tif (size < sizeof(struct xfs_attr_sf_hdr))\n\t\treturn __this_address;\n\n\tendp = (char *)sfp + size;\n\n\t/* Check all reported entries */\n\tsfep = &sfp->list[0];\n\tfor (i = 0; i < sfp->hdr.count; i++) {\n\t\t/*\n\t\t * struct xfs_attr_sf_entry has a variable length.\n\t\t * Check the fixed-offset parts of the structure are\n\t\t * within the data buffer.\n\t\t */\n\t\tif (((char *)sfep + sizeof(*sfep)) >= endp)\n\t\t\treturn __this_address;\n\n\t\t/* Don't allow names with known bad length. */\n\t\tif (sfep->namelen == 0)\n\t\t\treturn __this_address;\n\n\t\t/*\n\t\t * Check that the variable-length part of the structure is\n\t\t * within the data buffer.  The next entry starts after the\n\t\t * name component, so nextentry is an acceptable test.\n\t\t */\n\t\tnext_sfep = XFS_ATTR_SF_NEXTENTRY(sfep);\n\t\tif ((char *)next_sfep > endp)\n\t\t\treturn __this_address;\n\n\t\t/*\n\t\t * Check for unknown flags.  Short form doesn't support\n\t\t * the incomplete or local bits, so we can use the namespace\n\t\t * mask here.\n\t\t */\n\t\tif (sfep->flags & ~XFS_ATTR_NSP_ONDISK_MASK)\n\t\t\treturn __this_address;\n\n\t\t/*\n\t\t * Check for invalid namespace combinations.  We only allow\n\t\t * one namespace flag per xattr, so we can just count the\n\t\t * bits (i.e. hweight) here.\n\t\t */\n\t\tif (hweight8(sfep->flags & XFS_ATTR_NSP_ONDISK_MASK) > 1)\n\t\t\treturn __this_address;\n\n\t\tsfep = next_sfep;\n\t}\n\tif ((void *)sfep != (void *)endp)\n\t\treturn __this_address;\n\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "pa2bit(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    /* FIXME: precalculate greyscale palette? */\n    for (x = 0; x < xsize; x++, in += 4) {\n        *out++ = (L(&palette[in[0] * 4]) >= 128000) ? 255 : 0;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "CURLcode Curl_http_done(struct connectdata *conn,\n                        CURLcode status, bool premature)\n{\n  struct SessionHandle *data = conn->data;\n  struct HTTP *http =data->req.protop;\n\n  Curl_unencode_cleanup(conn);\n\n#ifdef USE_SPNEGO\n  if(data->state.proxyneg.state == GSS_AUTHSENT ||\n      data->state.negotiate.state == GSS_AUTHSENT)\n    Curl_cleanup_negotiate(data);\n#endif\n\n  /* set the proper values (possibly modified on POST) */\n  conn->fread_func = data->set.fread_func; /* restore */\n  conn->fread_in = data->set.in; /* restore */\n  conn->seek_func = data->set.seek_func; /* restore */\n  conn->seek_client = data->set.seek_client; /* restore */\n\n  if(http == NULL)\n    return CURLE_OK;\n\n  if(http->send_buffer) {\n    Curl_send_buffer *buff = http->send_buffer;\n\n    free(buff->buffer);\n    free(buff);\n    http->send_buffer = NULL; /* clear the pointer */\n  }\n\n  if(HTTPREQ_POST_FORM == data->set.httpreq) {\n    data->req.bytecount = http->readbytecount + http->writebytecount;\n\n    Curl_formclean(&http->sendit); /* Now free that whole lot */\n    if(http->form.fp) {\n      /* a file being uploaded was left opened, close it! */\n      fclose(http->form.fp);\n      http->form.fp = NULL;\n    }\n  }\n  else if(HTTPREQ_PUT == data->set.httpreq)\n    data->req.bytecount = http->readbytecount + http->writebytecount;\n\n  if(status)\n    return status;\n\n  if(!premature && /* this check is pointless when DONE is called before the\n                      entire operation is complete */\n     !conn->bits.retry &&\n     !data->set.connect_only &&\n     ((http->readbytecount +\n       data->req.headerbytecount -\n       data->req.deductheadercount)) <= 0) {\n    /* If this connection isn't simply closed to be retried, AND nothing was\n       read from the HTTP server (that counts), this can't be right so we\n       return an error here */\n    failf(data, \"Empty reply from server\");\n    return CURLE_GOT_NOTHING;\n  }\n\n  return CURLE_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "NO_INLINE void jsWarn(const char *fmt, ...) {\n  jsiConsoleRemoveInputLine();\n  jsiConsolePrint(\"WARNING: \");\n  va_list argp;\n  va_start(argp, fmt);\n  vcbprintf((vcbprintf_callback)jsiConsolePrintString,0, fmt, argp);\n  va_end(argp);\n  jsiConsolePrint(\"\\n\");\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int disk_events_set_dfl_poll_msecs(const char *val,\n\t\t\t\t\t  const struct kernel_param *kp)\n{\n\tstruct disk_events *ev;\n\tint ret;\n\n\tret = param_set_ulong(val, kp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&disk_events_mutex);\n\n\tlist_for_each_entry(ev, &disk_events, node)\n\t\tdisk_flush_events(ev->disk, 0);\n\n\tmutex_unlock(&disk_events_mutex);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void CoreNetwork::putCmd(const QString &cmd, const QList<QByteArray> &params, const QByteArray &prefix)\n{\n    QByteArray msg;\n\n    if (!prefix.isEmpty())\n        msg += \":\" + prefix + \" \";\n    msg += cmd.toUpper().toLatin1();\n\n    for (int i = 0; i < params.size(); i++) {\n        msg += \" \";\n\n        if (i == params.size() - 1 && (params[i].contains(' ') || (!params[i].isEmpty() && params[i][0] == ':')))\n            msg += \":\";\n\n        msg += params[i];\n    }\n\n    putRawLine(msg);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void HeaderMapImpl::remove(const LowerCaseString& key) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.get());\n  if (cb) {\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    removeInline(ref_lookup_response.entry_);\n  } else {\n    for (auto i = headers_.begin(); i != headers_.end();) {\n      if (i->key() == key.get().c_str()) {\n        i = headers_.erase(i);\n      } else {\n        ++i;\n      }\n    }\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int debugcon_parse(const char *devname)\n\n{   \n\n    QemuOpts *opts;\n\n\n\n    if (!qemu_chr_new(\"debugcon\", devname, NULL)) {\n\n        exit(1);\n\n    }\n\n    opts = qemu_opts_create(qemu_find_opts(\"device\"), \"debugcon\", 1);\n\n    if (!opts) {\n\n        fprintf(stderr, \"qemu: already have a debugcon device\\n\");\n\n        exit(1);\n\n    }\n\n    qemu_opt_set(opts, \"driver\", \"isa-debugcon\");\n\n    qemu_opt_set(opts, \"chardev\", \"debugcon\");\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void acm_tty_throttle(struct tty_struct *tty)\n{\n\tstruct acm *acm = tty->driver_data;\n\n\tspin_lock_irq(&acm->read_lock);\n\tacm->throttle_req = 1;\n\tspin_unlock_irq(&acm->read_lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int search_ssh_again(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {\n  ndpi_search_ssh_tcp(ndpi_struct, flow);\n\n  if((flow->protos.ssh.hassh_client[0] != '\\0')\n     && (flow->protos.ssh.hassh_server[0] != '\\0')) {\n    /* stop extra processing */\n    flow->extra_packets_func = NULL; /* We're good now */\n    return(0);\n  }\n\n  /* Possibly more processing */\n  return(1);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,\n    const char *name, size_t namelen)\n {\n \tchar *copy;\n \n \t/*\n \t * Refuse names with embedded NUL bytes.\n \t * XXX: Do we need to push an error onto the error stack?\n\t */\n\tif (name && memchr(name, '\\0', namelen))\n\t\treturn 0;\n\n\tif (mode == SET_HOST && id->hosts) {\n\t\tstring_stack_free(id->hosts);\n\t\tid->hosts = NULL;\n\t}\n\tif (name == NULL || namelen == 0)\n\t\treturn 1;\n\tcopy = strndup(name, namelen);\n\tif (copy == NULL)\n\t\treturn 0;\n\n\tif (id->hosts == NULL &&\n\t    (id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {\n\t\tfree(copy);\n\t\treturn 0;\n\t}\n\n\tif (!sk_OPENSSL_STRING_push(id->hosts, copy)) {\n\t\tfree(copy);\n\t\tif (sk_OPENSSL_STRING_num(id->hosts) == 0) {\n\t\t\tsk_OPENSSL_STRING_free(id->hosts);\n\t\t\tid->hosts = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool PDFiumEngine::MouseDownState::Matches(\n    const PDFiumPage::Area& area,\n    const PDFiumPage::LinkTarget& target) const {\n  if (area_ != area)\n    return false;\n\n  if (area == PDFiumPage::WEBLINK_AREA)\n    return target_.url == target.url;\n\n  if (area == PDFiumPage::DOCLINK_AREA)\n    return target_.page == target.page;\n\n  return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "filter_close (struct backend *b, struct connection *conn)\n{\n  struct backend_filter *f = container_of (b, struct backend_filter, backend);\n  void *handle = connection_get_handle (conn, b->i);\n\n  debug (\"%s: close\", b->name);\n\n  if (handle && f->filter.close)\n    f->filter.close (handle);\n  backend_set_handle (b, conn, NULL);\n  b->next->close (b->next, conn);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "double Item_singlerow_subselect::val_real()\n{\n  DBUG_ASSERT(fixed == 1);\n  if (forced_const)\n    return value->val_real();\n  if (!exec() && !value->null_value)\n  {\n    null_value= FALSE;\n    return value->val_real();\n  }\n  else\n  {\n    reset();\n    return 0;\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int failover_set_primary(DeviceState *dev, void *opaque)\n{\n    FailoverDevice *fdev = opaque;\n    PCIDevice *pci_dev = (PCIDevice *)\n        object_dynamic_cast(OBJECT(dev), TYPE_PCI_DEVICE);\n\n    if (!pci_dev) {\n        return 0;\n    }\n\n    if (!g_strcmp0(pci_dev->failover_pair_id, fdev->n->netclient_name)) {\n        fdev->dev = dev;\n        return 1;\n    }\n\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static\nsize_t php_mysqlnd_sha256_pk_request_write(MYSQLND_CONN_DATA * conn, void * _packet)\n{\n\tMYSQLND_ERROR_INFO * error_info = conn->error_info;\n\tMYSQLND_PFC * pfc = conn->protocol_frame_codec;\n\tMYSQLND_VIO * vio = conn->vio;\n\tMYSQLND_STATS * stats = conn->stats;\n\tzend_uchar buffer[MYSQLND_HEADER_SIZE + 1];\n\tsize_t sent;\n\n\tDBG_ENTER(\"php_mysqlnd_sha256_pk_request_write\");\n\n\tint1store(buffer + MYSQLND_HEADER_SIZE, '\\1');\n\tsent = pfc->data->m.send(pfc, vio, buffer, 1, stats, error_info);\n\n\tDBG_RETURN(sent);",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void sha1_final(unsigned char *md, SHACTX c)\n{\n    unsigned int mdlen = 0;\n\n    EVP_DigestFinal(c, md, &mdlen);\n    EVP_MD_CTX_destroy(c);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "passIsComma(CharsString *passLine, int *passLinepos, int *passPrevLinepos,\n\t\tCharsString *passHoldString, FileInfo *passNested,\n\t\tTranslationTableHeader *table) {\n\twidechar passHoldNumber;\n\tpass_Codes passCode = passGetScriptToken(passLine, passLinepos, passPrevLinepos,\n\t\t\tpassHoldString, &passHoldNumber, passNested, table);\n\tif (passCode != pass_comma) {\n\t\tcompileError(passNested, \"',' expected\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void LineBitmapRequester::Next8Lines(UBYTE c)\n{\n  int cnt = 8;\n  do {\n    struct Line *row = *m_pppImage[c];\n    if (!row)\n      break;\n    m_pppImage[c] = &(row->m_pNext);\n  } while(--cnt && *m_pppImage[c]);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void hrtick_start(struct rq *rq, u64 delay)\n{\n\tstruct hrtimer *timer = &rq->hrtick_timer;\n\tktime_t time = ktime_add_ns(timer->base->get_time(), delay);\n\n\thrtimer_set_expires(timer, time);\n\n\tif (rq == this_rq()) {\n\t\t__hrtick_restart(rq);\n\t} else if (!rq->hrtick_csd_pending) {\n\t\t__smp_call_function_single(cpu_of(rq), &rq->hrtick_csd, 0);\n\t\trq->hrtick_csd_pending = 1;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "DeviceState *qdev_try_create(BusState *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n\n\n\n\n\n    dev = DEVICE(object_new(name));\n\n    if (!dev) {\n\n\n\n\n\n    if (!bus) {\n\n        bus = sysbus_get_default();\n\n\n\n\n    qdev_set_parent_bus(dev, bus);\n\n    qdev_prop_set_globals(dev);\n\n\n\n    return dev;\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "SpawnPreparationInfo prepareSpawn(const Options &options) {\n\t\tTRACE_POINT();\n\t\tSpawnPreparationInfo info;\n\t\tprepareChroot(info, options);\n\t\tinfo.userSwitching = prepareUserSwitching(options);\n\t\tprepareSwitchingWorkingDirectory(info, options);\n\t\tinferApplicationInfo(info);\n\t\treturn info;\n\t}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\n\t/* cleanup if umh_setup() was successful but exec failed */\n\tif (info->retval) {\n\t\tfput(umd_info->pipe_to_umh);\n\t\tfput(umd_info->pipe_from_umh);\n\t\tput_pid(umd_info->tgid);\n\t\tumd_info->tgid = NULL;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\n\t\t\t\t  u32 __user *optval, int __user *optlen)\n{\n\tconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_info tfrc;\n\tconst void *val;\n\n\tswitch (optname) {\n \tcase DCCP_SOCKOPT_CCID_TX_INFO:\n \t\tif (len < sizeof(tfrc))\n \t\t\treturn -EINVAL;\n \t\ttfrc.tfrctx_x\t   = hc->tx_x;\n \t\ttfrc.tfrctx_x_recv = hc->tx_x_recv;\n \t\ttfrc.tfrctx_x_calc = hc->tx_x_calc;\n\t\ttfrc.tfrctx_rtt\t   = hc->tx_rtt;\n\t\ttfrc.tfrctx_p\t   = hc->tx_p;\n\t\ttfrc.tfrctx_rto\t   = hc->tx_t_rto;\n\t\ttfrc.tfrctx_ipi\t   = hc->tx_t_ipi;\n\t\tlen = sizeof(tfrc);\n\t\tval = &tfrc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void RenderViewImpl::willSendSubmitEvent(WebKit::WebFrame* frame,\n    const WebKit::WebFormElement& form) {\n  DocumentState* document_state =\n      DocumentState::FromDataSource(frame->dataSource());\n  document_state->set_password_form_data(CreatePasswordForm(form));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void smp_send_keypress_notification(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  p_cb->local_keypress_notification = *(uint8_t*)p_data;\n  smp_send_cmd(SMP_OPCODE_PAIR_KEYPR_NOTIF, p_cb);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void scsi_write_do_fua(SCSIDiskReq *r)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    assert(r->req.aiocb == NULL);\n    assert(!r->req.io_canceled);\n\n    if (r->need_fua_emulation) {\n        block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,\n                         BLOCK_ACCT_FLUSH);\n        r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);\n        return;\n    }\n\n    scsi_req_complete(&r->req, GOOD);\n    scsi_req_unref(&r->req);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n \t\treturn;\n \t}\n \tif (status) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n \t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n \t\t/* These are unsolicited reports from the firmware, hence no\n \t\t   waiting command to wakeup */\n \t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n \t\tmemcpy(command_info->result_buffer, &data[1],\n \t\t\t\t\t\turb->actual_length - 1);\n \t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\n\t/* Continue trying to always read */\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "free_footnote_ref(struct footnote_ref *ref)\n{\n\tbufrelease(ref->contents);\n\tfree(ref);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static CharDriverState *qemu_chr_open_pp(QemuOpts *opts)\n\n{\n\n    const char *filename = qemu_opt_get(opts, \"path\");\n\n    CharDriverState *chr;\n\n    int fd;\n\n\n\n    fd = open(filename, O_RDWR);\n\n    if (fd < 0)\n\n        return NULL;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    chr->opaque = (void *)(intptr_t)fd;\n\n    chr->chr_write = null_chr_write;\n\n    chr->chr_ioctl = pp_ioctl;\n\n    return chr;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ia32_setup_arg_pages (struct linux_binprm *bprm, int executable_stack)\n{\n\tint ret;\n\n\tret = setup_arg_pages(bprm, IA32_STACK_TOP, executable_stack);\n\tif (!ret) {\n\t\t/*\n\t\t * Can't do it in ia64_elf32_init(). Needs to be done before\n\t\t * calls to elf32_map()\n\t\t */\n\t\tcurrent->thread.ppl = ia32_init_pp_list();\n\t}\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void Jsi_InterpDelete(Jsi_Interp* interp)\n{\n    if (interp->deleting || interp->level > 0 || !interp->onDeleteTbl)\n        return;\n    interp->deleting = 1;\n    Jsi_HashDelete(interp->onDeleteTbl);\n    interp->onDeleteTbl = NULL;\n    Jsi_EventuallyFree(interp, interp, jsiInterpDelete);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void Image::setByteOrder(ByteOrder byteOrder)\n    {\n        byteOrder_ = byteOrder;\n    }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "//! Convert pixel values from sRGB to RGB color spaces \\newinstance.\n    CImg<Tfloat> get_sRGBtoRGB() const {\n      return CImg<Tfloat>(*this,false).sRGBtoRGB();",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "SplashBitmap::SplashBitmap(int widthA, int heightA, int rowPad,\n\t\t\t   SplashColorMode modeA, GBool alphaA,\n\t\t\t   GBool topDown) {\n  width = widthA;\n  height = heightA;\n  mode = modeA;\n  switch (mode) {\n  case splashModeMono1:\n    rowSize = (width + 7) >> 3;\n    break;\n  case splashModeMono8:\n    rowSize = width;\n    break;\n  case splashModeRGB8:\n  case splashModeBGR8:\n    rowSize = width * 3;\n    break;\n  case splashModeXBGR8:\n    rowSize = width * 4;\n    break;\n#if SPLASH_CMYK\n  case splashModeCMYK8:\n    rowSize = width * 4;\n    break;\n#endif\n  }\n  rowSize += rowPad - 1;\n  rowSize -= rowSize % rowPad;\n  data = (SplashColorPtr)gmalloc(rowSize * height);\n  if (!topDown) {\n    data += (height - 1) * rowSize;\n    rowSize = -rowSize;\n  }\n  if (alphaA) {\n    alpha = (Guchar *)gmalloc(width * height);\n  } else {\n    alpha = NULL;\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static bool imap_parser_is_next_text(struct imap_parser *parser)\n{\n\tconst struct imap_arg *arg;\n\tsize_t len;\n\n\tif (parser->cur_list != &parser->root_list)\n\t\treturn FALSE;\n\n\targ = array_back(&parser->root_list);\n\tif (arg->type != IMAP_ARG_ATOM)\n\t\treturn FALSE;\n\n\tlen = strlen(arg->_data.str);\n\treturn len > 0 && arg->_data.str[len-1] == ']';\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void ccid_cleanup_builtins(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ccids); i++)\n\t\tccid_deactivate(ccids[i]);\n\ttfrc_lib_exit();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void unit_add_to_gc_queue(Unit *u) {\n        assert(u);\n\n        if (u->in_gc_queue || u->in_cleanup_queue)\n                return;\n\n        if (!unit_may_gc(u))\n                return;\n\n        LIST_PREPEND(gc_queue, u->manager->gc_unit_queue, u);\n        u->in_gc_queue = true;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *ev_pair) {\n\tut64 sz = 0;\n\tif (ev_pair == NULL) {\n\t\treturn sz;\n\t}\n\t// ev_pair->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);\n\tsz += 2;\n\t// ev_pair->value = r_bin_java_element_value_new (bin, offset+2);\n\tif (ev_pair->value) {\n\t\tsz += r_bin_java_element_value_calc_size (ev_pair->value);\n\t}\n\treturn sz;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void test_checkout_nasty__gitmodules_symlink(void)\n{\n\tcl_repo_set_bool(repo, \"core.protectHFS\", true);\n\ttest_checkout_fails(\"refs/heads/gitmodules-symlink\", \".gitmodules\");\n\tcl_repo_set_bool(repo, \"core.protectHFS\", false);\n\n\tcl_repo_set_bool(repo, \"core.protectNTFS\", true);\n\ttest_checkout_fails(\"refs/heads/gitmodules-symlink\", \".gitmodules\");\n\tcl_repo_set_bool(repo, \"core.protectNTFS\", false);\n\n\ttest_checkout_fails(\"refs/heads/gitmodules-symlink\", \".gitmodules\");\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "struct sc_card_driver * sc_get_coolkey_driver(void)\n{\n\treturn sc_get_driver();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": " */\nstatic xmlNodePtr\nxmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                              xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL) {\n        cur = ctxt->context->node;\n        if (cur == NULL)\n            return (NULL);\n\tif (cur->type == XML_NAMESPACE_DECL)\n\t    cur = (xmlNodePtr)((xmlNsPtr)cur)->next;\n        ctxt->ancestor = cur->parent;\n    }\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    while (cur->prev == NULL) {\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n        if (cur != ctxt->ancestor)\n            return (cur);\n        ctxt->ancestor = cur->parent;\n    }\n    cur = cur->prev;\n    while (cur->last != NULL)\n        cur = cur->last;",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int hfs_cat_find_brec(struct super_block *sb, u32 cnid,\n\t\t      struct hfs_find_data *fd)\n{\n\thfs_cat_rec rec;\n\tint res, len, type;\n\n\thfs_cat_build_key(sb, fd->search_key, cnid, NULL);\n\tres = hfs_brec_read(fd, &rec, sizeof(rec));\n\tif (res)\n\t\treturn res;\n\n\ttype = rec.type;\n\tif (type != HFS_CDR_THD && type != HFS_CDR_FTH) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfd->search_key->cat.ParID = rec.thread.ParID;\n\tlen = fd->search_key->cat.CName.len = rec.thread.CName.len;\n\tmemcpy(fd->search_key->cat.CName.name, rec.thread.CName.name, len);\n\treturn hfs_brec_find(fd);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void DelegatedFrameHost::OnCompositingEnded(\n    ui::Compositor* compositor) {\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void config__init(struct mosquitto_db *db, struct mosquitto__config *config)\n{\n\tmemset(config, 0, sizeof(struct mosquitto__config));\n\tconfig__init_reload(db, config);\n\n\tconfig->daemon = false;\n\tmemset(&config->default_listener, 0, sizeof(struct mosquitto__listener));\n\tconfig->default_listener.max_connections = -1;\n\tconfig->default_listener.protocol = mp_mqtt;\n\tconfig->default_listener.security_options.allow_anonymous = -1;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static jboolean android_net_wifi_set_Country_Code_Hal(JNIEnv *env,jclass cls, jint iface,\n        jstring country_code) {\n\n JNIHelper helper(env);\n    wifi_interface_handle handle = getIfaceHandle(helper, cls, iface);\n\n ScopedUtfChars chars(env, country_code);\n const char *country = chars.c_str();\n\n    ALOGD(\"set country code: %s\", country);\n    wifi_error res = hal_fn.wifi_set_country_code(handle, country);\n return res == WIFI_SUCCESS;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int inet_nonblocking_connect(const char *str, bool *in_progress,\n\n                             Error **errp)\n\n{\n\n    QemuOpts *opts;\n\n    int sock = -1;\n\n\n\n    opts = qemu_opts_create(&dummy_opts, NULL, 0, NULL);\n\n    if (inet_parse(opts, str) == 0) {\n\n        sock = inet_connect_opts(opts, false, in_progress, errp);\n\n    } else {\n\n        error_set(errp, QERR_SOCKET_CREATE_FAILED);\n\n    }\n\n    qemu_opts_del(opts);\n\n    return sock;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "send_fprtime_if_not_null (ctrl_t ctrl, const char *keyword,\n                          int number, const unsigned char *stamp)\n{\n  char numbuf1[50], numbuf2[50];\n  unsigned long value;\n\n  value = (stamp[0] << 24) | (stamp[1]<<16) | (stamp[2]<<8) | stamp[3];\n  if (!value)\n    return;\n  sprintf (numbuf1, \"%d\", number);\n  sprintf (numbuf2, \"%lu\", value);\n  send_status_info (ctrl, keyword,\n                    numbuf1, (size_t)strlen(numbuf1),\n                    numbuf2, (size_t)strlen(numbuf2), NULL, 0);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int iscsi_host_get_param(struct Scsi_Host *shost, enum iscsi_host_param param,\n\t\t\t char *buf)\n{\n\tstruct iscsi_host *ihost = shost_priv(shost);\n\tint len;\n\n\tswitch (param) {\n\tcase ISCSI_HOST_PARAM_NETDEV_NAME:\n\t\tlen = sprintf(buf, \"%s\\n\", ihost->netdev);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tlen = sprintf(buf, \"%s\\n\", ihost->hwaddress);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_INITIATOR_NAME:\n\t\tlen = sprintf(buf, \"%s\\n\", ihost->initiatorname);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn len;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int ath6kl_wmi_set_tx_pwr_cmd(struct wmi *wmi, u8 if_idx, u8 dbM)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_tx_pwr_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(struct wmi_set_tx_pwr_cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_tx_pwr_cmd *) skb->data;\n\tcmd->dbM = dbM;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_TX_PWR_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "TfLiteStatus EvalSimple(TfLiteContext* context, TfLiteNode* node,\n                        const TfLiteTensor* lookup, const TfLiteTensor* value,\n                        TfLiteTensor* output) {\n  const int row_size = SizeOfDimension(value, 0);\n  const int row_bytes = value->bytes / row_size;\n\n  char* output_raw = GetTensorData<char>(output);\n  const char* value_raw = GetTensorData<char>(value);\n  const int32_t* lookup_data = GetTensorData<int32_t>(lookup);\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = lookup_data[i];\n    if (idx >= row_size || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, row_size - 1);\n      return kTfLiteError;\n    } else {\n      std::memcpy(output_raw + i * row_bytes, value_raw + idx * row_bytes,\n                  row_bytes);\n    }\n  }\n\n  return kTfLiteOk;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int lg2ff_init(struct hid_device *hid)\n{\n\tstruct lg2ff_device *lg2ff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\n\t/* Check that the report looks ok */\n\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);\n\tif (!report)\n\t\treturn -ENODEV;\n\n\tlg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);\n\tif (!lg2ff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, lg2ff, play_effect);\n\tif (error) {\n\t\tkfree(lg2ff);\n\t\treturn error;\n\t}\n\n\tlg2ff->report = report;\n\treport->field[0]->value[0] = 0xf3;\n\treport->field[0]->value[1] = 0x00;\n\treport->field[0]->value[2] = 0x00;\n\treport->field[0]->value[3] = 0x00;\n\treport->field[0]->value[4] = 0x00;\n\treport->field[0]->value[5] = 0x00;\n\treport->field[0]->value[6] = 0x00;\n\n\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"Force feedback for Logitech variant 2 rumble devices by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "PyImaging_SunRleDecoderNew(PyObject* self, PyObject* args)\n{\n    ImagingDecoderObject* decoder;\n\n    char* mode;\n    char* rawmode;\n    if (!PyArg_ParseTuple(args, \"ss\", &mode, &rawmode))\n        return NULL;\n\n    decoder = PyImaging_DecoderNew(0);\n    if (decoder == NULL)\n        return NULL;\n\n    if (get_unpacker(decoder, mode, rawmode) < 0)\n        return NULL;\n\n    decoder->decode = ImagingSunRleDecode;\n\n    return (PyObject*) decoder;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void ip6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,\n\t\t\t   int how)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tstruct inet6_dev *idev = rt->rt6i_idev;\n\tstruct net_device *loopback_dev =\n\t\tdev_net(dev)->loopback_dev;\n\n\tif (dev != loopback_dev) {\n\t\tif (idev && idev->dev == dev) {\n\t\t\tstruct inet6_dev *loopback_idev =\n\t\t\t\tin6_dev_get(loopback_dev);\n\t\t\tif (loopback_idev) {\n\t\t\t\trt->rt6i_idev = loopback_idev;\n\t\t\t\tin6_dev_put(idev);\n\t\t\t}\n\t\t}\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "SYSCALL_DEFINE3(osf_sysinfo, int, command, char __user *, buf, long, count)\n{\n\tconst char *sysinfo_table[] = {\n\t\tutsname()->sysname,\n\t\tutsname()->nodename,\n\t\tutsname()->release,\n\t\tutsname()->version,\n\t\tutsname()->machine,\n\t\t\"alpha\",\t/* instruction set architecture */\n\t\t\"dummy\",\t/* hardware serial number */\n\t\t\"dummy\",\t/* hardware manufacturer */\n\t\t\"dummy\",\t/* secure RPC domain */\n\t};\n\tunsigned long offset;\n\tconst char *res;\n\tlong len, err = -EINVAL;\n\n\toffset = command-1;\n\tif (offset >= ARRAY_SIZE(sysinfo_table)) {\n\t\t/* Digital UNIX has a few unpublished interfaces here */\n\t\tprintk(\"sysinfo(%d)\", command);\n\t\tgoto out;\n\t}\n\n\tdown_read(&uts_sem);\n\tres = sysinfo_table[offset];\n\tlen = strlen(res)+1;\n\tif (len > count)\n\t\tlen = count;\n\tif (copy_to_user(buf, res, len))\n\t\terr = -EFAULT;\n\telse\n\t\terr = 0;\n\tup_read(&uts_sem);\n out:\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static unsigned char fli_read_char(FILE *f)\n{\n\tunsigned char b;\n\tfread(&b,1,1,f);\n\treturn b;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ModuleExport size_t RegisterMVGImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"MVG\");\n  entry->decoder=(DecodeImageHandler *) ReadMVGImage;\n  entry->encoder=(EncodeImageHandler *) WriteMVGImage;\n  entry->magick=(IsImageFormatHandler *) IsMVG;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Magick Vector Graphics\");\n  entry->module=ConstantString(\"MVG\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline void ConvertRGBToCMYK(PixelInfo *pixel)\n{\n  MagickRealType\n    black,\n    blue,\n    cyan,\n    green,\n    magenta,\n    red,\n    yellow;\n\n  if (pixel->colorspace != sRGBColorspace)\n    {\n      red=QuantumScale*pixel->red;\n      green=QuantumScale*pixel->green;\n      blue=QuantumScale*pixel->blue;\n    }\n  else\n    {\n      red=QuantumScale*DecodePixelGamma(pixel->red);\n      green=QuantumScale*DecodePixelGamma(pixel->green);\n      blue=QuantumScale*DecodePixelGamma(pixel->blue);\n    }\n  if ((fabs((double) red) < MagickEpsilon) &&\n      (fabs((double) green) < MagickEpsilon) &&\n      (fabs((double) blue) < MagickEpsilon))\n    {\n      pixel->black=(MagickRealType) QuantumRange;\n      return;\n    }\n  cyan=(MagickRealType) (1.0-red);\n  magenta=(MagickRealType) (1.0-green);\n  yellow=(MagickRealType) (1.0-blue);\n  black=cyan;\n  if (magenta < black)\n    black=magenta;\n  if (yellow < black)\n    black=yellow;\n  cyan=(MagickRealType) ((cyan-black)/(1.0-black));\n  magenta=(MagickRealType) ((magenta-black)/(1.0-black));\n  yellow=(MagickRealType) ((yellow-black)/(1.0-black));\n  pixel->colorspace=CMYKColorspace;\n  pixel->red=QuantumRange*cyan;\n  pixel->green=QuantumRange*magenta;\n  pixel->blue=QuantumRange*yellow;\n  pixel->black=QuantumRange*black;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "uint32_t readDouble(double& dub) {\n    T_VIRTUAL_CALL();\n    return readDouble_virt(dub);\n  }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "uint32_t read_callback(void *user_data, void *buffer, uint32_t length)\n{\n    return fread(buffer, 1, length, (FILE*)user_data);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);\n\n    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);\n\n    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);\n\n\n\n    if (!dev->conf.bs) {\n\n        fprintf(stderr, \"%s: no drive specified\\n\", qdev->info->name);\n\n        goto err;\n\n    }\n\n    if (dev->unit == -1) {\n\n        dev->unit = bus->master ? 1 : 0;\n\n    }\n\n    switch (dev->unit) {\n\n    case 0:\n\n        if (bus->master) {\n\n            fprintf(stderr, \"ide: tried to assign master twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->master = dev;\n\n        break;\n\n    case 1:\n\n        if (bus->slave) {\n\n            fprintf(stderr, \"ide: tried to assign slave twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->slave = dev;\n\n        break;\n\n    default:\n\n        goto err;\n\n    }\n\n    return info->init(dev);\n\n\n\nerr:\n\n    return -1;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "GF_Err smhd_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"SoundMediaHeaderBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"SoundMediaHeaderBox\", a, trace);\n\treturn GF_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void SoundTouch::setTempoChange(double newTempo)\r\n{\r\n    virtualTempo = 1.0 + 0.01 * newTempo;\r\n    calcEffectiveRateAndTempo();\r\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl)\n{\n  const size_t so_ext_len= sizeof(SO_EXT) - 1;\n  if (my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,\n                    SO_EXT))\n  {\n    char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1);\n    memcpy(s, dl->str, dl->length);\n    strcpy(s + dl->length, SO_EXT);\n    dl->str= s;\n    dl->length+= so_ext_len;\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int avcodec_close(AVCodecContext *avctx)\n\n{\n\n    entangled_thread_counter++;\n\n    if(entangled_thread_counter != 1){\n\n        av_log(avctx, AV_LOG_ERROR, \"insufficient thread locking around avcodec_open/close()\\n\");\n\n        entangled_thread_counter--;\n\n        return -1;\n\n    }\n\n\n\n    if (ENABLE_THREADS && avctx->thread_opaque)\n\n        avcodec_thread_free(avctx);\n\n    if (avctx->codec->close)\n\n        avctx->codec->close(avctx);\n\n    avcodec_default_free_buffers(avctx);\n\n    av_freep(&avctx->priv_data);\n\n\n    avctx->codec = NULL;\n\n    entangled_thread_counter--;\n\n    return 0;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "ofputil_bucket_check_duplicate_id(const struct ovs_list *buckets)\n{\n    struct ofputil_bucket *i, *j;\n\n    LIST_FOR_EACH (i, list_node, buckets) {\n        LIST_FOR_EACH_REVERSE (j, list_node, buckets) {\n            if (i == j) {\n                break;\n            }\n            if (i->bucket_id == j->bucket_id) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n{\n\tstruct rlimit new_rlim, *old_rlim;\n\tunsigned long it_prof_secs;\n\tint retval;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n\t\treturn -EINVAL;\n\told_rlim = current->signal->rlim + resource;\n\tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n\t    !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n\t\treturn -EPERM;\n\n\tretval = security_task_setrlimit(resource, &new_rlim);\n\tif (retval)\n\t\treturn retval;\n\n\ttask_lock(current->group_leader);\n\t*old_rlim = new_rlim;\n\ttask_unlock(current->group_leader);\n\n\tif (resource != RLIMIT_CPU)\n\t\tgoto out;\n\n\t/*\n\t * RLIMIT_CPU handling.   Note that the kernel fails to return an error\n\t * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a\n\t * very long-standing error, and fixing it now risks breakage of\n\t * applications, so we live with it\n\t */\n\tif (new_rlim.rlim_cur == RLIM_INFINITY)\n\t\tgoto out;\n\n\tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n\tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n\t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n\t\tcputime_t cputime;\n\n\t\tif (rlim_cur == 0) {\n\t\t\t/*\n\t\t\t * The caller is asking for an immediate RLIMIT_CPU\n\t\t\t * expiry.  But we use the zero value to mean \"it was\n\t\t\t * never set\".  So let's cheat and make it one second\n\t\t\t * instead\n\t\t\t */\n\t\t\trlim_cur = 1;\n\t\t}\n\t\tcputime = secs_to_cputime(rlim_cur);\n\t\tread_lock(&tasklist_lock);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tread_unlock(&tasklist_lock);\n\t}\nout:\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "_iup_worker_shift( IUP_Worker  worker,\n                     FT_UInt     p1,\n                     FT_UInt     p2,\n                     FT_UInt     p )\n  {\n    FT_UInt     i;\n    FT_F26Dot6  dx;\n\n\n    dx = SUB_LONG( worker->curs[p].x, worker->orgs[p].x );\n    if ( dx != 0 )\n    {\n      for ( i = p1; i < p; i++ )\n        worker->curs[i].x = ADD_LONG( worker->curs[i].x, dx );\n\n      for ( i = p + 1; i <= p2; i++ )\n        worker->curs[i].x = ADD_LONG( worker->curs[i].x, dx );\n    }\n  }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void vnc_init_basic_info_from_server_addr(QIOChannelSocket *ioc,\n                                                 VncBasicInfo *info,\n                                                 Error **errp)\n{\n    SocketAddress *addr = NULL;\n    addr = qio_channel_socket_get_local_address(ioc, errp);\n    if (!addr) {\n    vnc_init_basic_info(addr, info, errp);\n    qapi_free_SocketAddress(addr);",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ossl_cipher_set_key(VALUE self, VALUE key)\n{\n    EVP_CIPHER_CTX *ctx;\n    int key_len;\n\n    StringValue(key);\n    GetCipher(self, ctx);\n\n    key_len = EVP_CIPHER_CTX_key_length(ctx);\n    if (RSTRING_LEN(key) != key_len)\n\tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return key;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static enum AVPixelFormat get_chroma_format(SchroChromaFormat schro_pix_fmt)\n\n{\n\n    int num_formats = sizeof(schro_pixel_format_map) /\n\n                      sizeof(schro_pixel_format_map[0]);\n\n    int idx;\n\n\n\n    for (idx = 0; idx < num_formats; ++idx)\n\n        if (schro_pixel_format_map[idx].schro_pix_fmt == schro_pix_fmt)\n\n            return schro_pixel_format_map[idx].ff_pix_fmt;\n\n    return AV_PIX_FMT_NONE;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline __u64 ptr_to_id(void *ptr)\n{\n return (__u64) (uintptr_t) ptr;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int qeth_cm_enable_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"cmenblcb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.cm_filter_r,\n\t       QETH_CM_ENABLE_RESP_FILTER_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "std::string utf16ToUtf8(const StringPiece16& utf16) {\n ssize_t utf8Length = utf16_to_utf8_length(utf16.data(), utf16.length());\n if (utf8Length <= 0) {\n return {};\n\n     }\n \n     std::string utf8;\n     utf8.resize(utf8Length);\n    utf16_to_utf8(utf16.data(), utf16.length(), &*utf8.begin());\n     return utf8;\n }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "psutil_pids(PyObject *self, PyObject *args) {\n    kinfo_proc *proclist = NULL;\n    kinfo_proc *orig_address = NULL;\n    size_t num_processes;\n    size_t idx;\n    PyObject *py_pid = NULL;\n    PyObject *py_retlist = PyList_New(0);\n\n    if (py_retlist == NULL)\n        return NULL;\n\n    if (psutil_get_proc_list(&proclist, &num_processes) != 0)\n        goto error;\n\n    // save the address of proclist so we can free it later\n    orig_address = proclist;\n    for (idx = 0; idx < num_processes; idx++) {\n        py_pid = Py_BuildValue(\"i\", proclist->kp_proc.p_pid);\n        if (! py_pid)\n            goto error;\n        if (PyList_Append(py_retlist, py_pid))\n            goto error;\n        Py_DECREF(py_pid);\n        proclist++;\n    }\n    free(orig_address);\n\n    return py_retlist;\n\nerror:\n    Py_XDECREF(py_pid);\n    Py_DECREF(py_retlist);\n    if (orig_address != NULL)\n        free(orig_address);\n    return NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline void ConvertLuvToXYZ(const double L,const double u,const double v,\n  double *X,double *Y,double *Z)\n{\n  assert(X != (double *) NULL);\n  assert(Y != (double *) NULL);\n  assert(Z != (double *) NULL);\n  if (L > (CIEK*CIEEpsilon))\n    *Y=(double) pow((L+16.0)/116.0,3.0);\n  else\n    *Y=L/CIEK;\n  *X=((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+\n    5.0*(*Y))/((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/\n    3.0)-(-1.0/3.0));\n  *Z=(*X*(((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-\n    5.0*(*Y);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void megasas_queue_write(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    return;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void parse_type_int64(Visitor *v, const char *name, int64_t *obj,\n\n                             Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n\n\n    if (!siv->string) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"integer\");\n\n        return;\n\n    }\n\n\n\n    parse_str(siv, errp);\n\n\n\n    if (!siv->ranges) {\n\n        goto error;\n\n    }\n\n\n\n    if (!siv->cur_range) {\n\n        Range *r;\n\n\n\n        siv->cur_range = g_list_first(siv->ranges);\n\n        if (!siv->cur_range) {\n\n            goto error;\n\n        }\n\n\n\n        r = siv->cur_range->data;\n\n        if (!r) {\n\n            goto error;\n\n        }\n\n\n\n        siv->cur = r->begin;\n\n    }\n\n\n\n    *obj = siv->cur;\n\n    siv->cur++;\n\n    return;\n\n\n\nerror:\n\n    error_setg(errp, QERR_INVALID_PARAMETER_VALUE, name ? name : \"null\",\n\n               \"an int64 value or range\");\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "status_icon_popup_menu_selection_done_cb (GtkMenuShell *menu_shell, gpointer data)\n{\n        GsdXrandrManager *manager = GSD_XRANDR_MANAGER (data);\n        struct GsdXrandrManagerPrivate *priv = manager->priv;\n\n        gtk_widget_destroy (priv->popup_menu);\n        priv->popup_menu = NULL;\n\n        gnome_rr_labeler_hide (priv->labeler);\n        g_object_unref (priv->labeler);\n        priv->labeler = NULL;\n\n        gnome_rr_config_free (priv->configuration);\n        priv->configuration = NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void blkreplay_bh_cb(void *opaque)\n\n{\n\n    Request *req = opaque;\n\n    qemu_coroutine_enter(req->co, NULL);\n\n    qemu_bh_delete(req->bh);\n\n    g_free(req);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "DeviceState *ssi_create_slave(SSIBus *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n    dev = qdev_create(&bus->qbus, name);\n\n    qdev_init(dev);\n\n    return dev;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "TPML_TAGGED_TPM_PROPERTY_Unmarshal(TPML_TAGGED_TPM_PROPERTY  *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    UINT32 i;\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT32_Unmarshal(&target->count, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->count > MAX_TPM_PROPERTIES) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {\n\trc = TPMS_TAGGED_PROPERTY_Unmarshal(&target->tpmProperty[i], buffer, size);\n    }\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int call_fib6_entry_notifier(struct notifier_block *nb, struct net *net,\n\t\t\t\t    enum fib_event_type event_type,\n\t\t\t\t    struct fib6_info *rt)\n{\n\tstruct fib6_entry_notifier_info info = {\n\t\t.rt = rt,\n\t};\n\n\treturn call_fib6_notifier(nb, net, event_type, &info.info);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "BSONObj expectedResult() {\n        // When the result cannot be represented in a NumberLong, a NumberDouble is returned.\n        const auto im = numeric_limits<int>::max();\n        const auto llm = numeric_limits<long long>::max();\n        double result = static_cast<double>(im) + static_cast<double>(llm);\n        return BSON(\"\" << result);\n    }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int e820_add_entry(uint64_t address, uint64_t length, uint32_t type)\n\n{\n\n    int index = le32_to_cpu(e820_reserve.count);\n\n    struct e820_entry *entry;\n\n\n\n    if (type != E820_RAM) {\n\n        /* old FW_CFG_E820_TABLE entry -- reservations only */\n\n        if (index >= E820_NR_ENTRIES) {\n\n            return -EBUSY;\n\n        }\n\n        entry = &e820_reserve.entry[index++];\n\n\n\n        entry->address = cpu_to_le64(address);\n\n        entry->length = cpu_to_le64(length);\n\n        entry->type = cpu_to_le32(type);\n\n\n\n        e820_reserve.count = cpu_to_le32(index);\n\n    }\n\n\n\n    /* new \"etc/e820\" file -- include ram too */\n\n    e820_table = g_realloc(e820_table,\n\n                           sizeof(struct e820_entry) * (e820_entries+1));\n\n    e820_table[e820_entries].address = cpu_to_le64(address);\n\n    e820_table[e820_entries].length = cpu_to_le64(length);\n\n    e820_table[e820_entries].type = cpu_to_le32(type);\n\n    e820_entries++;\n\n\n\n    return e820_entries;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int qemu_pixman_get_type(int rshift, int gshift, int bshift)\n\n{\n\n    int type = PIXMAN_TYPE_OTHER;\n\n\n\n    if (rshift > gshift && gshift > bshift) {\n\n        if (bshift == 0) {\n\n            type = PIXMAN_TYPE_ARGB;\n\n        } else {\n\n\n            type = PIXMAN_TYPE_RGBA;\n\n\n        }\n\n    } else if (rshift < gshift && gshift < bshift) {\n\n        if (rshift == 0) {\n\n            type = PIXMAN_TYPE_ABGR;\n\n        } else {\n\n\n            type = PIXMAN_TYPE_BGRA;\n\n\n        }\n\n    }\n\n    return type;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline int page_zone_id(struct page *page)\n{\n\treturn (page->flags >> ZONEID_PGSHIFT) & ZONEID_MASK;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "nvmet_fc_getassociationid(u64 connectionid)\n{\n\treturn connectionid & ~NVMET_FC_QUEUEID_MASK;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\t/* release callback will free clt in last put */\n\tdevice_unregister(&clt->dev);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline void paravirt_arch_dup_mmap(struct mm_struct *oldmm,\n\t\t\t\t\t  struct mm_struct *mm)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\nvoid f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount)\n {\n \t__issue_discard_cmd(sbi, false);\n \t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, !umount);\n }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "ves_icall_System_Reflection_MethodBase_GetMethodBodyInternal (MonoMethod *method)\n{\n\treturn mono_method_body_get_object (mono_domain_get (), method);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void ims_pcu_report_events(struct ims_pcu *pcu)\n{\n\tu32 data = get_unaligned_be32(&pcu->read_buf[3]);\n\n\tims_pcu_buttons_report(pcu, data & ~IMS_PCU_GAMEPAD_MASK);\n\tif (pcu->gamepad)\n\t\tims_pcu_gamepad_report(pcu, data);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "QPDFObjectHandle::replaceStreamData(PointerHolder<Buffer> data,\n\t\t\t\t    QPDFObjectHandle const& filter,\n\t\t\t\t    QPDFObjectHandle const& decode_parms)\n{\n    assertStream();\n    dynamic_cast<QPDF_Stream*>(obj.getPointer())->replaceStreamData(\n\tdata, filter, decode_parms);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "spell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t/* TRUE for the prefix tree */\n    int\t\tprefixcnt)\t/* when \"prefixtree\" is TRUE: prefix count */\n{\n    int\t\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    /* The tree size was computed when writing the file, so that we can\n     * allocate it as one long block. <nodecount> */\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len > 0)\n    {\n\t/* Allocate the byte array. */\n\tbp = lalloc((long_u)len, TRUE);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\n\t/* Allocate the index array. */\n\tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t/* Recursively read the tree and store it in the array. */\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void bgr_to_rgb(fz_context *ctx, const fz_colorspace *cs, const float *bgr, float *rgb)\n{\n\trgb[0] = bgr[2];\n\trgb[1] = bgr[1];\n\trgb[2] = bgr[0];\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version, flags;\n    CHECK(avifROStreamRead(&s, &version, 1)); // unsigned int(8) version = 0;\n    if (version != 0) {\n        return AVIF_FALSE;\n    }\n    CHECK(avifROStreamRead(&s, &flags, 1));         // unsigned int(8) flags;\n    CHECK(avifROStreamRead(&s, &grid->rows, 1));    // unsigned int(8) rows_minus_one;\n    CHECK(avifROStreamRead(&s, &grid->columns, 1)); // unsigned int(8) columns_minus_one;\n    ++grid->rows;\n    ++grid->columns;\n\n    uint32_t fieldLength = ((flags & 1) + 1) * 16;\n    if (fieldLength == 16) {\n        uint16_t outputWidth16, outputHeight16;\n        CHECK(avifROStreamReadU16(&s, &outputWidth16));  // unsigned int(FieldLength) output_width;\n        CHECK(avifROStreamReadU16(&s, &outputHeight16)); // unsigned int(FieldLength) output_height;\n        grid->outputWidth = outputWidth16;\n        grid->outputHeight = outputHeight16;\n    } else {\n        if (fieldLength != 32) {\n            // This should be impossible\n            return AVIF_FALSE;\n        }\n        CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  // unsigned int(FieldLength) output_width;\n        CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); // unsigned int(FieldLength) output_height;\n    }\n    return AVIF_TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static __inline__ void icmpv6_xmit_unlock(struct sock *sk)\n{\n\tspin_unlock_bh(&sk->sk_lock.slock);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "PHP_LIBXML_API void php_libxml_structured_error_handler(void *userData, xmlErrorPtr error)\n{\n\t_php_list_set_error_structure(error, NULL);\n\n\treturn;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static ssize_t set_ignore_ce(struct device *s,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t size)\n{\n\tu64 new;\n\n\tif (kstrtou64(buf, 0, &new) < 0)\n\t\treturn -EINVAL;\n\n\tif (mca_cfg.ignore_ce ^ !!new) {\n\t\tif (new) {\n\t\t\t/* disable ce features */\n\t\t\tmce_timer_delete_all();\n\t\t\ton_each_cpu(mce_disable_cmci, NULL, 1);\n\t\t\tmca_cfg.ignore_ce = true;\n\t\t} else {\n\t\t\t/* enable ce features */\n\t\t\tmca_cfg.ignore_ce = false;\n\t\t\ton_each_cpu(mce_enable_ce, (void *)1, 1);\n\t\t}\n\t}\n\treturn size;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void do_flatten_cache(const char *cache_dir)\n{\n\tgf_enum_directory(cache_dir, GF_FALSE, revert_cache_file, NULL, \"*.txt\");\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n{\n\tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n\tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; /* XXX xp->share */\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n       /* this is two hexadecimal digits following a '%' */\n       char hexstr[3];\n       char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n\n      hex = strtoul(hexstr, &ptr, 16);\n\n      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n\n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        /* Curl_convert_from_network calls failf if unsuccessful */\n        free(ns);\n        return res;\n      }\n\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n\n  if(olen)\n    /* store output size */\n    *olen = strindex;\n\n  if(ostring)\n    /* store output string */\n    *ostring = ns;\n\n  return CURLE_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\n{\n    int result = -1;\n\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n    case GEN_X400:\n    case GEN_EDIPARTY:\n        result = ASN1_TYPE_cmp(a->d.other, b->d.other);\n        break;\n\n    case GEN_OTHERNAME:\n        result = OTHERNAME_cmp(a->d.otherName, b->d.otherName);\n        break;\n\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        result = ASN1_STRING_cmp(a->d.ia5, b->d.ia5);\n        break;\n\n    case GEN_DIRNAME:\n        result = X509_NAME_cmp(a->d.dirn, b->d.dirn);\n        break;\n\n    case GEN_IPADD:\n        result = ASN1_OCTET_STRING_cmp(a->d.ip, b->d.ip);\n        break;\n\n    case GEN_RID:\n        result = OBJ_cmp(a->d.rid, b->d.rid);\n        break;\n    }\n    return result;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "unsigned int qemu_get_be32(QEMUFile *f)\n\n{\n\n    unsigned int v;\n\n    v = qemu_get_byte(f) << 24;\n\n    v |= qemu_get_byte(f) << 16;\n\n    v |= qemu_get_byte(f) << 8;\n\n    v |= qemu_get_byte(f);\n\n    return v;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "iscsi_aio_writev(BlockDriverState *bs, int64_t sector_num,\n                 QEMUIOVector *qiov, int nb_sectors,\n                 BlockDriverCompletionFunc *cb,\n                 void *opaque)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    IscsiAIOCB *acb;\n    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n    trace_iscsi_aio_writev(iscsilun->iscsi, sector_num, nb_sectors, opaque, acb);\n    acb->iscsilun    = iscsilun;\n    acb->qiov        = qiov;\n    acb->nb_sectors  = nb_sectors;\n    acb->sector_num  = sector_num;\n    acb->retries     = ISCSI_CMD_RETRIES;\n    if (iscsi_aio_writev_acb(acb) != 0) {\n        qemu_aio_release(acb);\n    iscsi_set_events(iscsilun);\n    return &acb->common;",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "mail_config_ews_autodiscover_run_cb (GObject *source_object,\n                                     GAsyncResult *result,\n                                     gpointer user_data)\n{\n\tAsyncContext *async_context = user_data;\n\tEMailConfigEwsAutodiscover *autodiscover;\n\tEAlertSink *alert_sink;\n\tGError *error = NULL;\n\tEMailConfigServiceBackend *backend;\n\tCamelSettings *settings;\n\n\tautodiscover = async_context->autodiscover;\n\talert_sink = e_activity_get_alert_sink (async_context->activity);\n\n\tmail_config_ews_autodiscover_finish (E_MAIL_CONFIG_EWS_AUTODISCOVER (source_object), result, &error);\n\n\tbackend = e_mail_config_ews_autodiscover_get_backend (autodiscover);\n\tsettings = e_mail_config_service_backend_get_settings (backend);\n\t/*\n\t * And unstop since we are back to the main thread.\n\t */\n\tg_object_thaw_notify (G_OBJECT (settings));\n\n\tif (e_activity_handle_cancellation (async_context->activity, error)) {\n\t\tg_error_free (error);\n\n\t} else if (error != NULL) {\n\t\te_alert_submit (\n\t\t\talert_sink,\n\t\t\t\"ews:autodiscovery-error\",\n\t\t\terror->message, NULL);\n\t\tg_error_free (error);\n\t}\n\n\tgtk_widget_set_sensitive (GTK_WIDGET (autodiscover), TRUE);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void intel_hda_class_init_ich9(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->device_id = 0x293e;\n    k->revision = 3;\n    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);\n    dc->desc = \"Intel HD Audio Controller (ich9)\";",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static unsigned char asn1_header_decode(struct asn1_ctx *ctx,\n\t\t\t\t\tunsigned char **eoc,\n\t\t\t\t\tunsigned int *cls,\n\t\t\t\t\tunsigned int *con,\n\t\t\t\t\tunsigned int *tag)\n{\n\tunsigned int def, len;\n\n\tif (!asn1_id_decode(ctx, cls, con, tag))\n\t\treturn 0;\n\n\tdef = len = 0;\n\tif (!asn1_length_decode(ctx, &def, &len))\n\t\treturn 0;\n\n\tif (def)\n\t\t*eoc = ctx->pointer + len;\n\telse\n\t\t*eoc = NULL;\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "zip_dealloc(zipobject *lz)\n{\n    PyObject_GC_UnTrack(lz);\n    Py_XDECREF(lz->ittuple);\n    Py_XDECREF(lz->result);\n    Py_TYPE(lz)->tp_free(lz);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "decrypt(MPI output, MPI a, MPI b, ELG_secret_key *skey )\n{\n    MPI t1 = mpi_alloc_secure( mpi_get_nlimbs( skey->p ) );\n\n    mpi_normalize (a);\n    mpi_normalize (b);\n\n    /* output = b/(a^x) mod p */\n    mpi_powm( t1, a, skey->x, skey->p );\n    mpi_invm( t1, t1, skey->p );\n    mpi_mulm( output, b, t1, skey->p );\n#if 0\n    if( DBG_CIPHER ) {\n\tlog_mpidump(\"elg decrypted x= \", skey->x);\n\tlog_mpidump(\"elg decrypted p= \", skey->p);\n\tlog_mpidump(\"elg decrypted a= \", a);\n\tlog_mpidump(\"elg decrypted b= \", b);\n\tlog_mpidump(\"elg decrypted M= \", output);\n    }\n#endif\n    mpi_free(t1);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void set_frame_distances(MpegEncContext * s){\n\n    assert(s->current_picture_ptr->f.pts != AV_NOPTS_VALUE);\n\n    s->time = s->current_picture_ptr->f.pts * s->avctx->time_base.num;\n\n\n\n    if(s->pict_type==AV_PICTURE_TYPE_B){\n\n        s->pb_time= s->pp_time - (s->last_non_b_time - s->time);\n\n        assert(s->pb_time > 0 && s->pb_time < s->pp_time);\n\n    }else{\n\n        s->pp_time= s->time - s->last_non_b_time;\n\n        s->last_non_b_time= s->time;\n\n        assert(s->picture_number==0 || s->pp_time > 0);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static char* jsi_FSRealPathProc(Jsi_Interp *interp, Jsi_Value *src, char *newPath) {\n    return Jsi_FileRealpath(interp, src, newPath);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)\n{\n    return TIFFReadDirEntryLong8ArrayWithLimit(tif, direntry, value, ~((uint64)0));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void php_x509_free(zend_resource *rsrc)\n{\n\tX509 *x509 = (X509 *)rsrc->ptr;\n\tX509_free(x509);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "mm_user_key_allowed(struct passwd *pw, Key *key)\n{\n\treturn (mm_key_allowed(MM_USERKEY, NULL, NULL, key));\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head,\n\t\t\t\t    const struct kvm_memory_slot *slot)\n{\n\treturn rmap_write_protect(rmap_head, false);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int CMS_data(CMS_ContentInfo *cms, BIO *out, unsigned int flags)\n{\n    BIO *cont;\n    int r;\n    if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_data) {\n        CMSerr(CMS_F_CMS_DATA, CMS_R_TYPE_NOT_DATA);\n        return 0;\n    }\n    cont = CMS_dataInit(cms, NULL);\n    if (!cont)\n        return 0;\n    r = cms_copy_content(out, cont, flags);\n    BIO_free_all(cont);\n    return r;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static const char *req_hostname_field(request_rec *r)\n{\n    return r->hostname;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n#if __UNIX__\n\t//int msecs = (1000 * secs) + (usecs / 1000);\n\tint msecs = (usecs / 1000);\n\tstruct pollfd fds[1];\n\tfds[0].fd = s->fd;\n\tfds[0].events = POLLIN | POLLPRI;\n\tfds[0].revents = POLLNVAL | POLLHUP | POLLERR;\n\treturn poll ((struct pollfd *)&fds, 1, msecs);\n#elif __WINDOWS__\n\tfd_set rfds;\n\tstruct timeval tv;\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\tFD_ZERO (&rfds);\n\tFD_SET (s->fd, &rfds);\n\ttv.tv_sec = secs;\n\ttv.tv_usec = usecs;\n\treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n#else\n\treturn true; /* always ready if unknown */\n#endif\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "validate_cursor(void)\n{\n    check_cursor_moved(curwin);\n    if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))\n\tcurs_columns(TRUE);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "Formattable::~Formattable()\n{\n    dispose();\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int __init chainiv_module_init(void)\n{\n\treturn crypto_register_template(&chainiv_tmpl);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void Jsi_ListClear(Jsi_List *list) {\n    Jsi_ListEntry *l;\n    while (list->head) {\n        l = list->head;\n        list->head = list->head->next;\n        l->next = l->prev = NULL;\n        if (list->opts.freeListProc && l->value)\n            (list->opts.freeListProc)(list->opts.interp, l, l->value);\n        Jsi_ListEntryDelete(l);\n    }\n    list->numEntries = 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota)\n{\n\tint ret;\n\tstruct cfs_schedulable_data data = {\n\t\t.tg = tg,\n\t\t.period = period,\n\t\t.quota = quota,\n\t};\n\n\tif (quota != RUNTIME_INF) {\n\t\tdo_div(data.period, NSEC_PER_USEC);\n\t\tdo_div(data.quota, NSEC_PER_USEC);\n\t}\n\n\trcu_read_lock();\n\tret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "smb_fdata(netdissect_options *ndo,\n          const u_char *buf, const char *fmt, const u_char *maxbuf,\n          int unicodestr)\n{\n    static int depth = 0;\n    char s[128];\n    char *p;\n\n    while (*fmt) {\n\tswitch (*fmt) {\n\tcase '*':\n\t    fmt++;\n \t    while (buf < maxbuf) {\n \t\tconst u_char *buf2;\n \t\tdepth++;\n\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);\n \t\tdepth--;\n \t\tif (buf2 == NULL)\n \t\t    return(NULL);\n\t\tif (buf2 == buf)\n\t\t    return(buf);\n\t\tbuf = buf2;\n\t    }\n\t    return(buf);\n\n\tcase '|':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    break;\n\n\tcase '%':\n\t    fmt++;\n\t    buf = maxbuf;\n\t    break;\n\n\tcase '#':\n\t    fmt++;\n\t    return(buf);\n\t    break;\n\n\tcase '[':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    memset(s, 0, sizeof(s));\n\t    p = strchr(fmt, ']');\n\t    if ((size_t)(p - fmt + 1) > sizeof(s)) {\n\t\t/* overrun */\n\t\treturn(buf);\n\t    }\n\t    strncpy(s, fmt, p - fmt);\n\t    s[p - fmt] = '\\0';\n\t    fmt = p + 1;\n\t    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);\n\t    if (buf == NULL)\n\t\treturn(NULL);\n\t    break;\n\n\tdefault:\n\t    ND_PRINT((ndo, \"%c\", *fmt));\n\t    fmt++;\n\t    break;\n\t}\n    }\n    if (!depth && buf < maxbuf) {\n\tsize_t len = PTR_DIFF(maxbuf, buf);\n\tND_PRINT((ndo, \"Data: (%lu bytes)\\n\", (unsigned long)len));\n\tsmb_print_data(ndo, buf, len);\n\treturn(buf + len);\n    }\n    return(buf);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static bool hidpp_validate_device(struct hid_device *hdev)\n{\n\treturn hidpp_validate_report(hdev, REPORT_ID_HIDPP_SHORT,\n\t\t\t\t     HIDPP_REPORT_SHORT_LENGTH, false) &&\n\t       hidpp_validate_report(hdev, REPORT_ID_HIDPP_LONG,\n\t\t\t\t     HIDPP_REPORT_LONG_LENGTH, true);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "group_type group_classify(struct sched_group *group,\n\t\t\t  struct sg_lb_stats *sgs)\n{\n\tif (sgs->group_no_capacity)\n\t\treturn group_overloaded;\n\n\tif (sg_imbalanced(group))\n\t\treturn group_imbalanced;\n\n\tif (sgs->group_misfit_task_load)\n\t\treturn group_misfit_task;\n\n\treturn group_other;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "http_isfiltered(const struct http *fm, unsigned u, unsigned how)\n{\n\tconst char *e;\n\tconst struct http_hdrflg *f;\n\n\tif (fm->hdf[u] & HDF_FILTER)\n\t\treturn (1);\n\te = strchr(fm->hd[u].b, ':');\n\tif (e == NULL)\n\t\treturn (0);\n\tf = http_hdr_flags(fm->hd[u].b, e);\n\treturn (f != NULL && f->flag & how);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "NTSTATUS server_service_dns_init(void)\n{\n\treturn register_server_service(\"dns\", dns_task_init);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "pvscsi_device_find(PVSCSIState *s, int channel, int target,\n                   uint8_t *requested_lun, uint8_t *target_lun)\n{\n    if (requested_lun[0] || requested_lun[2] || requested_lun[3] ||\n        requested_lun[4] || requested_lun[5] || requested_lun[6] ||\n        requested_lun[7] || (target > PVSCSI_MAX_DEVS)) {\n        return NULL;\n    } else {\n        *target_lun = requested_lun[1];\n        return scsi_device_find(&s->bus, channel, target, *target_lun);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "libxlLoggerFree(libxlLogger *logger)\n{\n    xentoollog_logger *xtl_logger = (xentoollog_logger*)logger;\n    if (logger->defaultLogFile)\n        VIR_FORCE_FCLOSE(logger->defaultLogFile);\n    g_clear_pointer(&logger->files, g_hash_table_unref);\n    xtl_logger_destroy(xtl_logger);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "JBIG2HuffmanDecoder::JBIG2HuffmanDecoder()\n{\n    str = nullptr;\n    byteCounter = 0;\n    reset();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static ssize_t mon_text_read_t(struct file *file, char __user *buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct mon_reader_text *rp = file->private_data;\n\tstruct mon_event_text *ep;\n\tstruct mon_text_ptr ptr;\n\n\tep = mon_text_read_wait(rp, file);\n\tif (IS_ERR(ep))\n\t\treturn PTR_ERR(ep);\n\tmutex_lock(&rp->printf_lock);\n\tptr.cnt = 0;\n\tptr.pbuf = rp->printf_buf;\n\tptr.limit = rp->printf_size;\n\n\tmon_text_read_head_t(rp, &ptr, ep);\n\tmon_text_read_statset(rp, &ptr, ep);\n\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\n\t    \" %d\", ep->length);\n\tmon_text_read_data(rp, &ptr, ep);\n\n\tif (copy_to_user(buf, rp->printf_buf, ptr.cnt))\n\t\tptr.cnt = -EFAULT;\n\tmutex_unlock(&rp->printf_lock);\n\tkmem_cache_free(rp->e_slab, ep);\n\treturn ptr.cnt;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void ChromotingInstance::ReleaseAllKeys() {\n  if (IsConnected())\n    input_tracker_.ReleaseAll();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int main() {\n\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static boolean jpeg_empty_output_buffer(j_compress_ptr cinfo)\n{\n    VncState *vs = cinfo->client_data;\n    Buffer *buffer = &vs->tight.jpeg;\n\n    buffer->offset = buffer->capacity;\n    buffer_reserve(buffer, 2048);\n    jpeg_init_destination(cinfo);\n    return TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n {\n \tunsigned char *buf;\n \n\tassert(bufsize >= 0);\n \n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n \tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n \t  bufsize) {\n \t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "soup_filter_input_stream_new (GInputStream *base_stream)\n{\n\treturn g_object_new (SOUP_TYPE_FILTER_INPUT_STREAM,\n\t\t\t     \"base-stream\", base_stream,\n\t\t\t     \"close-base-stream\", FALSE,\n\t\t\t     NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "string OuterNodeName(const NodeDef* node, bool is_div) const {\n    auto scope_and_name = ParseNodeScopeAndName(node->name());\n    return is_div ? OptimizedNodeName(scope_and_name, \"Div\")\n                  : OptimizedNodeName(scope_and_name, \"Mul\");\n  }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline int f2fs_build_stats(struct f2fs_sb_info *sbi) { return 0; }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int read_rle_sgi(uint8_t *out_buf, SgiState *s)\n\n{\n\n    uint8_t *dest_row;\n\n    unsigned int len = s->height * s->depth * 4;\n\n    GetByteContext g_table = s->g;\n\n    unsigned int y, z;\n\n    unsigned int start_offset;\n\n\n\n    /* size of  RLE offset and length tables */\n\n    if (len * 2  > bytestream2_get_bytes_left(&s->g)) {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    for (z = 0; z < s->depth; z++) {\n\n        dest_row = out_buf;\n\n        for (y = 0; y < s->height; y++) {\n\n            dest_row -= s->linesize;\n\n            start_offset = bytestream2_get_be32(&g_table);\n\n            bytestream2_seek(&s->g, start_offset, SEEK_SET);\n\n            if (expand_rle_row(s, dest_row + z, dest_row + FFABS(s->linesize),\n\n                               s->depth) != s->width) {\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "set_agg_lats_to_bottom (class ipcp_param_lattices *plats)\n{\n  bool ret = !plats->aggs_bottom;\n  plats->aggs_bottom = true;\n  return ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "authdir_policy_badexit_address(uint32_t addr, uint16_t port)\n{\n  return ! addr_policy_permits_address(addr, port, authdir_badexit_policy);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void bdrv_throttle_write_timer_cb(void *opaque)\n{\n    BlockDriverState *bs = opaque;\n    qemu_co_enter_next(&bs->throttled_reqs[1]);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "e1000e_init_msix(E1000EState *s)\n\n{\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n    int res = msix_init(PCI_DEVICE(s), E1000E_MSIX_VEC_NUM,\n\n                        &s->msix,\n\n                        E1000E_MSIX_IDX, E1000E_MSIX_TABLE,\n\n                        &s->msix,\n\n                        E1000E_MSIX_IDX, E1000E_MSIX_PBA,\n\n                        0xA0);\n\n\n\n    if (res < 0) {\n\n        trace_e1000e_msix_init_fail(res);\n\n    } else {\n\n        if (!e1000e_use_msix_vectors(s, E1000E_MSIX_VEC_NUM)) {\n\n            msix_uninit(d, &s->msix, &s->msix);\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int smacker_decode_tree(BitstreamContext *bc, HuffContext *hc,\n                                uint32_t prefix, int length)\n {\n     if (!bitstream_read_bit(bc)) { // Leaf\n         if(hc->current >= 256){\n             av_log(NULL, AV_LOG_ERROR, \"Tree size exceeded!\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if(length){\n            hc->bits[hc->current] = prefix;\n            hc->lengths[hc->current] = length;\n        } else {\n            hc->bits[hc->current] = 0;\n            hc->lengths[hc->current] = 0;\n        }\n        hc->values[hc->current] = bitstream_read(bc, 8);\n        hc->current++;\n        if(hc->maxlength < length)\n            hc->maxlength = length;\n        return 0;\n    } else { //Node\n        int r;\n        length++;\n        r = smacker_decode_tree(bc, hc, prefix, length);\n        if(r)\n            return r;\n        return smacker_decode_tree(bc, hc, prefix | (1 << (length - 1)), length);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "nsPluginInstance::setupCookies(const std::string& pageurl)\n{\n    std::string::size_type pos;\n    pos = pageurl.find(\"/\", pageurl.find(\"//\", 0) + 2) + 1;\n    std::string url = pageurl.substr(0, pos);\n\n    std::string ncookie;\n \n    char *cookie = 0;\n    uint32_t length = 0;\n\n    NPError rv = NPERR_GENERIC_ERROR;\n#if NPAPI_VERSION != 190\n    if (NPNFuncs.getvalueforurl) {\n        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),\n                                &cookie, &length);\n    } else {\n        LOG_ONCE( gnash::log_debug(\"Browser doesn't support getvalueforurl\") );\n    }\n#endif\n\n    if (rv == NPERR_GENERIC_ERROR) {\n        log_debug(\"Trying window.document.cookie for cookies\");\n        ncookie = getDocumentProp(\"cookie\");\n    }\n\n    if (cookie) {\n        ncookie.assign(cookie, length);\n        NPN_MemFree(cookie);\n    }\n\n    if (ncookie.empty()) {\n        gnash::log_debug(\"No stored Cookie for %s\", url);\n        return;\n    }\n\n    gnash::log_debug(\"The Cookie for %s is %s\", url, ncookie);\n    std::ofstream cookiefile;\n    std::stringstream ss;\n     ss << \"/tmp/gnash-cookies.\" << getpid();\n \n     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);\n \n  \n    typedef boost::char_separator<char> char_sep;\n    typedef boost::tokenizer<char_sep> tokenizer;\n    tokenizer tok(ncookie, char_sep(\";\"));\n\n    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {\n        cookiefile << \"Set-Cookie: \" << *it << std::endl;\n    }\n \n    cookiefile.close();\n  \n    if (setenv(\"GNASH_COOKIES_IN\", ss.str().c_str(), 1) < 0) {\n        gnash::log_error(\n            \"Couldn't set environment variable GNASH_COOKIES_IN to %s\",\n            ncookie);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void PPB_URLLoader_Impl::InstanceWasDeleted() {\n  loader_.reset();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void showregs (RList *list) {\n\tif (!r_list_empty (list)) {\n\t\tchar *reg;\n\t\tRListIter *iter;\n\t\tr_list_foreach (list, iter, reg) {\n\t\t\tr_cons_print (reg);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\" \");\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_newline();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int snd_compr_update_tstamp(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_tstamp *tstamp)\n{\n\tif (!stream->ops->pointer)\n\t\treturn -ENOTSUPP;\n\tstream->ops->pointer(stream, tstamp);\n\tpr_debug(\"dsp consumed till %d total %d bytes\\n\",\n\t\ttstamp->byte_offset, tstamp->copied_total);\n\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\tstream->runtime->total_bytes_transferred = tstamp->copied_total;\n\telse\n\t\tstream->runtime->total_bytes_available = tstamp->copied_total;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int EVP_MD_CTX_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in)\n\t{\n\tEVP_MD_CTX_init(out);\n\treturn EVP_MD_CTX_copy_ex(out, in);\n\t}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void GfxICCBasedColorSpace::getDefaultColor(GfxColor *color) const\n{\n    int i;\n\n    for (i = 0; i < nComps; ++i) {\n        if (rangeMin[i] > 0) {\n            color->c[i] = dblToCol(rangeMin[i]);\n        } else if (rangeMax[i] < 0) {\n            color->c[i] = dblToCol(rangeMax[i]);\n        } else {\n            color->c[i] = 0;\n        }\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "BOOL ber_read_contextual_tag(wStream* s, BYTE tag, int* length, BOOL pc)\n{\n\tBYTE byte;\n\n\tif(Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte != ((BER_CLASS_CTXT | BER_PC(pc)) | (BER_TAG_MASK & tag)))\n\t{\n\t\tStream_Rewind(s, 1);\n\t\treturn FALSE;\n\t}\n\n\treturn ber_read_length(s, length);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "zfs_fuid_create_cred(zfsvfs_t *zfsvfs, zfs_fuid_type_t type,\n    cred_t *cr, zfs_fuid_info_t **fuidp)\n{\n\tuid_t\t\tid;\n\n\tVERIFY(type == ZFS_OWNER || type == ZFS_GROUP);\n\n\tid = (type == ZFS_OWNER) ? crgetuid(cr) : crgetgid(cr);\n\n\tif (IS_EPHEMERAL(id))\n\t\treturn ((type == ZFS_OWNER) ? UID_NOBODY : GID_NOBODY);\n\n\treturn ((uint64_t)id);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "target_read_memory (bfd_vma memaddr,\n\n                    bfd_byte *myaddr,\n\n                    int length,\n\n                    struct disassemble_info *info)\n\n{\n\n    int i;\n\n    for(i = 0; i < length; i++) {\n\n        myaddr[i] = ldub_code(memaddr + i);\n\n    }\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static enum hrtimer_restart pit_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_kpit_state *ps = container_of(data, struct kvm_kpit_state, timer);\n\tstruct kvm_pit *pt = ps->kvm->arch.vpit;\n\n\tif (ps->reinject || !atomic_read(&ps->pending)) {\n\t\tatomic_inc(&ps->pending);\n\t\tqueue_kthread_work(&pt->worker, &pt->expired);\n\t}\n\n\tif (ps->is_periodic) {\n\t\thrtimer_add_expires_ns(&ps->timer, ps->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void vmci_transport_set_buffer_size(struct vsock_sock *vsk, u64 val)\n{\n\tif (val < vmci_trans(vsk)->queue_pair_min_size)\n\t\tvmci_trans(vsk)->queue_pair_min_size = val;\n\tif (val > vmci_trans(vsk)->queue_pair_max_size)\n\t\tvmci_trans(vsk)->queue_pair_max_size = val;\n\tvmci_trans(vsk)->queue_pair_size = val;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int ecb_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t       struct scatterlist *src, unsigned int nbytes)\n{\n\treturn glue_ecb_crypt_128bit(&serpent_dec, desc, dst, src, nbytes);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void hidp_process_report(struct hidp_session *session,\n\t\t\t\tint type, const u8 *data, int len, int intr)\n{\n\tif (len > HID_MAX_BUFFER_SIZE)\n\t\tlen = HID_MAX_BUFFER_SIZE;\n\n\tmemcpy(session->input_buf, data, len);\n\thid_input_report(session->hid, type, session->input_buf, len, intr);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "virtual void parse(const UnicodeString& ,\n                    Formattable& ,\n                    ParsePosition& ) const {}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void ipc_rcu_putref(void *ptr)\n {\n\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n \t\treturn;\n \n \tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ssh_packet_connection_af(struct ssh *ssh)\n{\n\tstruct sockaddr_storage to;\n\tsocklen_t tolen = sizeof(to);\n\n\tmemset(&to, 0, sizeof(to));\n\tif (getsockname(ssh->state->connection_out, (struct sockaddr *)&to,\n\t    &tolen) < 0)\n\t\treturn 0;\n#ifdef IPV4_IN_IPV6\n\tif (to.ss_family == AF_INET6 &&\n\t    IN6_IS_ADDR_V4MAPPED(&((struct sockaddr_in6 *)&to)->sin6_addr))\n\t\treturn AF_INET;\n#endif\n\treturn to.ss_family;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "seamless_process(STREAM s)\n {\n \tunsigned int pkglen;\n \tchar *buf;\n \n \tpkglen = s->end - s->p;\n \t/* str_handle_lines requires null terminated strings */\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);\n\n\txfree(buf);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "GF_Err moof_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\n\tif (ptr->mfhd) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->mfhd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mfhd->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->TrackList);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)\n\n{\n\n    AVStream *st = s->streams[stream_index];\n\n    avio_seek(s->pb, FFMAX(timestamp, 0) * st->codec->width * st->codec->height * 4, SEEK_SET);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static ui64 get_pid_start_time(pid_t pid){\n  glibtop_proc_time buf={0};\n  glibtop_get_proc_time(&buf,pid);\n  return buf.start_time;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void SitePerProcessBrowserTest::SetUpOnMainThread() {\n  host_resolver()->AddRule(\"*\", \"127.0.0.1\");\n  SetupCrossSiteRedirector(embedded_test_server());\n  ASSERT_TRUE(embedded_test_server()->Start());\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !inode_capable(inode, CAP_FOWNER);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\n\tkfree(clt);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int cbcmac_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_cipher *cipher;\n\tstruct crypto_instance *inst = (void *)tfm->__crt_alg;\n\tstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\n\tstruct cbcmac_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tcipher = crypto_spawn_cipher(spawn);\n\tif (IS_ERR(cipher))\n\t\treturn PTR_ERR(cipher);\n\n\tctx->child = cipher;\n\n\treturn 0;\n};",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void clap_del(GF_Box *s)\n{\n\tGF_CleanAppertureBox *ptr = (GF_CleanAppertureBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void Compute(OpKernelContext* context) override {\n    // Get the input Tensors.\n    OpInputList params_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"params_nested_splits\",\n                                                &params_nested_splits_in));\n    const Tensor& params_dense_values_in =\n        context->input(params_nested_splits_in.size());\n    const Tensor& indices_in =\n        context->input(params_nested_splits_in.size() + 1);\n\n    DCHECK_GT(params_nested_splits_in.size(), 0);  // Enforced by REGISTER_OP.\n    SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;\n    OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));\n\n    OP_REQUIRES(context, params_dense_values_in.dims() > 0,\n                errors::InvalidArgument(\"params.rank must be nonzero\"));\n    SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);\n\n    // Calculate the `splits`, and store the value slices that we need to\n    // copy in `value_slices`.\n    std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;\n    SPLITS_TYPE num_values = 0;\n    std::vector<std::vector<SPLITS_TYPE>> out_splits;\n    OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,\n                                       num_params_dense_values, &out_splits,\n                                       &value_slices, &num_values));\n\n    // Write the output tensors.\n    OP_REQUIRES_OK(context, WriteSplits(out_splits, context));\n    OP_REQUIRES_OK(context,\n                   WriteValues(params_dense_values_in, value_slices,\n                               out_splits.size(), num_values, context));\n  }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[0], regs[1]);\n    regs += 2;\n  }\n  return hash;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ZEND_API int add_get_assoc_stringl_ex(zval *arg, const char *key, uint key_len, const char *str, uint length, void **dest, int duplicate) /* {{{ */\n{\n\tzval *tmp;\n\n\tif (UNEXPECTED(length > INT_MAX)) {\n\t\tzend_error_noreturn(E_ERROR, \"String overflow, max size is %d\", INT_MAX);\n\t}\n\n\tMAKE_STD_ZVAL(tmp);\n\tZVAL_STRINGL(tmp, str, length, duplicate);\n\n\treturn zend_symtable_update(Z_ARRVAL_P(arg), key, key_len, (void *) &tmp, sizeof(zval *), dest);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "  void DocumentChecker::process(const char * str, int size)\n  {\n    proc_str_.clear();\n    conv_->decode(str, size, proc_str_);\n    proc_str_.append(0);\n    FilterChar * begin = proc_str_.pbegin();\n    FilterChar * end   = proc_str_.pend() - 1;\n    if (filter_)\n      filter_->process(begin, end);\n    tokenizer_->reset(begin, end);\n  }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void RemoteFrame::DidFreeze() {\n  DCHECK(RuntimeEnabledFeatures::PageLifecycleEnabled());\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "release_chunk (GMarkupParseContext *context, GString *str)\n{\n  GSList *node;\n  if (!str)\n    return;\n  if (str->allocated_len > 256)\n    { /* large strings are unusual and worth freeing */\n      g_string_free (str, TRUE);\n      return;\n    }\n  string_blank (str);\n  node = get_list_node (context, str);\n  context->spare_chunks = g_slist_concat (node, context->spare_chunks);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static st8 iflag(char *input) {\n\tst8 res = 0;\n\tut8 i;\n\tr_str_case (input, false);\n\t\n\tfor (i = 0; i < strlen(input); i++) {\n\t\tswitch (input[i]) {\n\t\tcase 'a':\n\t\t\tres |= 0x4;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tres |= 0x2;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tres |= 0x1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn res;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void kvm_register_target_sys_reg_table(unsigned int target,\n\t\t\t\t       struct kvm_sys_reg_target_table *table)\n{\n\ttarget_tables[target] = table;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int get_uint64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n    qemu_get_be64s(f, v);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int set_wcr(struct kvm_vcpu *vcpu, const struct sys_reg_desc *rd,\n\t\tconst struct kvm_one_reg *reg, void __user *uaddr)\n{\n\t__u64 *r = &vcpu->arch.vcpu_debug_state.dbg_wcr[rd->reg];\n\n\tif (copy_from_user(r, uaddr, KVM_REG_SIZE(reg->id)) != 0)\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static INLINE int vpx_read(vpx_reader *r, int prob) {\n  unsigned int bit = 0;\n  BD_VALUE value;\n  BD_VALUE bigsplit;\n  int count;\n  unsigned int range;\n  unsigned int split = (r->range * prob + (256 - prob)) >> CHAR_BIT;\n\n  if (r->count < 0) vpx_reader_fill(r);\n\n  value = r->value;\n  count = r->count;\n\n  bigsplit = (BD_VALUE)split << (BD_VALUE_SIZE - CHAR_BIT);\n\n  range = split;\n\n  if (value >= bigsplit) {\n    range = r->range - split;\n    value = value - bigsplit;\n    bit = 1;\n  }\n\n  {\n    const int shift = vpx_norm[range];\n    range <<= shift;\n    value <<= shift;\n    count -= shift;\n  }\n  r->value = value;\n  r->count = count;\n  r->range = range;\n\n  return bit;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void terminate_thread (gpointer key, gpointer value, gpointer user)\n{\n\tMonoInternalThread *thread=(MonoInternalThread *)value;\n\t\n\tif(thread->tid != (gsize)user) {\n\t\t/*TerminateThread (thread->handle, -1);*/\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  /* variable length */\n  }\n  if (update) return -1;\n  return len;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "QString PamBackend::userName() {\n        return QString::fromLocal8Bit((const char*) m_pam->getItem(PAM_USER));\n    }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int qdev_add_one_global(QemuOpts *opts, void *opaque)\n\n{\n\n    GlobalProperty *g;\n\n    ObjectClass *oc;\n\n\n\n    g = g_malloc0(sizeof(*g));\n\n    g->driver   = qemu_opt_get(opts, \"driver\");\n\n    g->property = qemu_opt_get(opts, \"property\");\n\n    g->value    = qemu_opt_get(opts, \"value\");\n\n    oc = object_class_by_name(g->driver);\n\n    if (oc) {\n\n        DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n        if (dc->hotpluggable) {\n\n            /* If hotpluggable then skip not_used checking. */\n\n            g->not_used = false;\n\n        } else {\n\n            /* Maybe a typo. */\n\n            g->not_used = true;\n\n        }\n\n    } else {\n\n        /* Maybe a typo. */\n\n        g->not_used = true;\n\n    }\n\n    qdev_prop_register_global(g);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "  HeadersWrapper(const T* value) : value_(value) {}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\t/* Now we can treat all alike */\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n \t}\n \n \tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(sax));\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n\t}\n\n\tmsg->msg_namelen = sizeof(*sax);\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\treturn copied;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int qemu_savevm_state_iterate(QEMUFile *f)\n\n{\n\n    SaveStateEntry *se;\n\n    int ret = 1;\n\n\n\n    trace_savevm_state_iterate();\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n        if (!se->ops || !se->ops->save_live_iterate) {\n\n            continue;\n\n        }\n\n        if (se->ops && se->ops->is_active) {\n\n            if (!se->ops->is_active(se->opaque)) {\n\n                continue;\n\n            }\n\n        }\n\n        if (qemu_file_rate_limit(f)) {\n\n            return 0;\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_PART);\n\n\n\n        ret = se->ops->save_live_iterate(f, se->opaque);\n\n        trace_savevm_section_end(se->idstr, se->section_id, ret);\n\n\n\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n        }\n\n        if (ret <= 0) {\n\n            /* Do not proceed to the next vmstate before this one reported\n\n               completion of the current stage. This serializes the migration\n\n               and reduces the probability that a faster changing state is\n\n               synchronized over and over again. */\n\n            break;\n\n        }\n\n    }\n\n    return ret;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void ppc_store_msr_32 (CPUPPCState *env, uint32_t value)\n\n{\n\n    do_store_msr(env,\n\n                 (do_load_msr(env) & ~0xFFFFFFFFULL) | (value & 0xFFFFFFFF));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void queue_autoload_drivers(void)\n{\n\tschedule_work(&autoload_work);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n\n    //do padding ourselves\n    if (direction)\n    {\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    else\n    {\n        temp = b64ToByte(temp);\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n\n    if (!cipher.ok())\n        return cipherText;\n\n    if (direction)\n        temp2 = byteToB64(temp2);\n\n    return temp2;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int auth_sasl_check_ssf(RedSASL *sasl, int *runSSF)\n{\n    const void *val;\n    int err, ssf;\n\n    *runSSF = 0;\n    if (!sasl->wantSSF) {\n        return 1;\n    }\n\n    err = sasl_getprop(sasl->conn, SASL_SSF, &val);\n    if (err != SASL_OK) {\n        return 0;\n    }\n\n    ssf = *(const int *)val;\n    spice_debug(\"negotiated an SSF of %d\", ssf);\n    if (ssf < 56) {\n        return 0; /* 56 is good for Kerberos */\n    }\n\n    *runSSF = 1;\n\n    /* We have a SSF that's good enough */\n    return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline void skcipher_map_src(struct skcipher_walk *walk)\n{\n\twalk->src.virt.addr = skcipher_map(&walk->in);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void gen_dstst(DisasContext *ctx)\n\n{\n\n    if (rA(ctx->opcode) == 0) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n    } else {\n\n        /* interpreted as no-op */\n\n    }\n\n\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void AudioOutputController::DoReportError(int code) {\n  DCHECK_EQ(message_loop_, MessageLoop::current());\n  if (state_ != kClosed)\n    handler_->OnError(this, code);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void ZrtpQueue::handleTimeout(const std::string &c) {\n    if (zrtpEngine != NULL) {\n        zrtpEngine->processTimeout();\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void fw_cfg_io_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = fw_cfg_io_realize;\n\n    dc->props = fw_cfg_io_properties;\n\n\n\n\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "append_command(char_u *cmd)\n{\n    char_u *s = cmd;\n    char_u *d;\n\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff + 5 < IOSIZE)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)\n\t    break;\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int decode_syncpoint(NUTContext *nut, int64_t *ts, int64_t *back_ptr)\n\n{\n\n    AVFormatContext *s = nut->avf;\n\n    AVIOContext *bc    = s->pb;\n\n    int64_t end;\n\n    uint64_t tmp;\n\n\n\n    nut->last_syncpoint_pos = avio_tell(bc) - 8;\n\n\n\n    end  = get_packetheader(nut, bc, 1, SYNCPOINT_STARTCODE);\n\n    end += avio_tell(bc);\n\n\n\n    tmp       = ffio_read_varlen(bc);\n\n    *back_ptr = nut->last_syncpoint_pos - 16 * ffio_read_varlen(bc);\n\n    if (*back_ptr < 0)\n\n        return -1;\n\n\n\n    ff_nut_reset_ts(nut, nut->time_base[tmp % nut->time_base_count],\n\n                    tmp / nut->time_base_count);\n\n\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n\n        av_log(s, AV_LOG_ERROR, \"sync point checksum mismatch\\n\");\n\n        return -1;\n\n    }\n\n\n\n    *ts = tmp / s->nb_streams *\n\n          av_q2d(nut->time_base[tmp % s->nb_streams]) * AV_TIME_BASE;\n\n    ff_nut_add_sp(nut, nut->last_syncpoint_pos, *back_ptr, *ts);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void virtio_setup(uint64_t dev_info)\n\n{\n\n    struct schib schib;\n\n    int ssid;\n\n    bool found = false;\n\n    uint16_t dev_no;\n\n\n\n    /*\n\n     * We unconditionally enable mss support. In every sane configuration,\n\n     * this will succeed; and even if it doesn't, stsch_err() can deal\n\n     * with the consequences.\n\n     */\n\n    enable_mss_facility();\n\n\n\n    if (dev_info != -1) {\n\n        dev_no = dev_info & 0xffff;\n\n        debug_print_int(\"device no. \", dev_no);\n\n        blk_schid.ssid = (dev_info >> 16) & 0x3;\n\n        debug_print_int(\"ssid \", blk_schid.ssid);\n\n        found = find_dev(&schib, dev_no);\n\n    } else {\n\n        for (ssid = 0; ssid < 0x3; ssid++) {\n\n            blk_schid.ssid = ssid;\n\n            found = find_dev(&schib, -1);\n\n            if (found) {\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!found) {\n\n        virtio_panic(\"No virtio-blk device found!\\n\");\n\n    }\n\n\n\n    virtio_setup_block(blk_schid);\n\n\n\n    if (!virtio_ipl_disk_is_valid()) {\n\n        virtio_panic(\"No valid hard disk detected.\\n\");\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void qemu_cond_init(QemuCond *cond)\n\n{\n\n    memset(cond, 0, sizeof(*cond));\n\n\n\n    cond->sema = CreateSemaphore(NULL, 0, LONG_MAX, NULL);\n\n    if (!cond->sema) {\n\n        error_exit(GetLastError(), __func__);\n\n    }\n\n    cond->continue_event = CreateEvent(NULL,    /* security */\n\n                                       FALSE,   /* auto-reset */\n\n                                       FALSE,   /* not signaled */\n\n                                       NULL);   /* name */\n\n    if (!cond->continue_event) {\n\n        error_exit(GetLastError(), __func__);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "//! Return base-2 logarithm of a value.\n    inline double log2(const double x) {\n      const double base = std::log(2.0);\n      return std::log(x)/base;",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void pdf_run_d0(fz_context *ctx, pdf_processor *proc, float wx, float wy)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tif (pr->nested_depth > 1)\n\t\treturn;\n\tpr->dev->flags |= FZ_DEVFLAG_COLOR;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int ct_release_key(struct media_player *mp, void *user_data)\n{\n\tstruct avrcp_player *player = user_data;\n\n\treturn ct_release(player);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void svhandler_flash_erase_sector(void) {\n  uint32_t sector = _param_1;\n\n  // Do not allow firmware to erase bootstrap or bootloader sectors.\n  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n      (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) {\n    return;\n  }\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Erase the sector.\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n\n  // Return flash status.\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  // Wait for any write operation to complete.\n  flash_wait_for_last_operation();\n\n  // Disable writes to flash.\n  FLASH_CR &= ~FLASH_CR_PG;\n\n  // lock flash register\n  FLASH_CR |= FLASH_CR_LOCK;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void kvmclock_realize(DeviceState *dev, Error **errp)\n{\n    KVMClockState *s = KVM_CLOCK(dev);\n    kvm_update_clock(s);\n    qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void __exit sha256_s390_fini(void)\n{\n\tcrypto_unregister_shash(&sha224_alg);\n\tcrypto_unregister_shash(&sha256_alg);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void ipip_dev_free(struct net_device *dev)\n{\n\tfree_percpu(dev->tstats);\n\tfree_netdev(dev);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void construct_server(void *obj)\n{\n\tPgSocket *server = obj;\n\n\tmemset(server, 0, sizeof(PgSocket));\n\tlist_init(&server->head);\n\tsbuf_init(&server->sbuf, server_proto);\n\tserver->state = SV_FREE;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "rpki_rtr_print(netdissect_options *ndo, register const u_char *pptr, register u_int len)\n{\n    u_int tlen, pdu_type, pdu_len;\n    const u_char *tptr;\n    const rpki_rtr_pdu *pdu_header;\n\n    tptr = pptr;\n    tlen = len;\n\n    if (!ndo->ndo_vflag) {\n\tND_PRINT((ndo, \", RPKI-RTR\"));\n\treturn;\n    }\n\n    while (tlen >= sizeof(rpki_rtr_pdu)) {\n\n        ND_TCHECK2(*tptr, sizeof(rpki_rtr_pdu));\n\n\tpdu_header = (const rpki_rtr_pdu *)tptr;\n        pdu_type = pdu_header->pdu_type;\n        pdu_len = EXTRACT_32BITS(pdu_header->length);\n        ND_TCHECK2(*tptr, pdu_len);\n\n        /* infinite loop check */\n        if (!pdu_type || !pdu_len) {\n            break;\n        }\n\n        if (tlen < pdu_len) {\n            goto trunc;\n        }\n\n\t/*\n\t * Print the PDU.\n\t */\n\tif (rpki_rtr_pdu_print(ndo, tptr, 8))\n\t\tgoto trunc;\n\n        tlen -= pdu_len;\n        tptr += pdu_len;\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t%s\", tstr));\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int dgram_disconnect(struct sock *sk, int flags)\n{\n\tstruct dgram_sock *ro = dgram_sk(sk);\n\n\tlock_sock(sk);\n\tro->connected = 0;\n\trelease_sock(sk);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void __exit usbip_host_exit(void)\n{\n\tdriver_remove_file(&stub_driver.drvwrap.driver,\n\t\t\t   &driver_attr_match_busid);\n\n\tdriver_remove_file(&stub_driver.drvwrap.driver,\n\t\t\t   &driver_attr_rebind);\n\n\t/*\n\t * deregister() calls stub_disconnect() for all devices. Device\n\t * specific data is cleared in stub_disconnect().\n\t */\n\tusb_deregister_device_driver(&stub_driver);\n\n\t/* initiate scan to attach devices */\n\tstub_device_rebind();\n\n\tkmem_cache_destroy(stub_priv_cache);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "bool Scanner::fill(size_t need)\n{\n    if (eof) return false;\n\n    pop_finished_files();\n\n    DASSERT(bot <= tok && tok <= lim);\n    size_t free = static_cast<size_t>(tok - bot);\n    size_t copy = static_cast<size_t>(lim - tok);\n\n    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n\n        free = BSIZE - copy;\n    }\n\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n\n    return true;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline void ipmi_si_set_not_busy(struct timespec64 *ts)\n{\n\tts->tv_nsec = -1;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int legacy_fs_context_dup(struct fs_context *fc, struct fs_context *src_fc)\n{\n\tstruct legacy_fs_context *ctx;\n\tstruct legacy_fs_context *src_ctx = src_fc->fs_private;\n\n\tctx = kmemdup(src_ctx, sizeof(*src_ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (ctx->param_type == LEGACY_FS_INDIVIDUAL_PARAMS) {\n\t\tctx->legacy_data = kmemdup(src_ctx->legacy_data,\n\t\t\t\t\t   src_ctx->data_size, GFP_KERNEL);\n\t\tif (!ctx->legacy_data) {\n\t\t\tkfree(ctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfc->fs_private = ctx;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void aio_co_schedule(AioContext *ctx, Coroutine *co)\n{\n    trace_aio_co_schedule(ctx, co);\n    QSLIST_INSERT_HEAD_ATOMIC(&ctx->scheduled_coroutines,\n                              co, co_scheduled_next);\n    qemu_bh_schedule(ctx->co_schedule_bh);",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void qpci_memwrite(QPCIDevice *dev, void *data, const void *buf, size_t len)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    g_assert(addr >= QPCI_PIO_LIMIT);\n\n    dev->bus->memwrite(dev->bus, addr, buf, len);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int nfsaclsvc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_accessargs *argp)\n{\n\tp = nfs2svc_decode_fh(p, &argp->fh);\n\tif (!p)\n\t\treturn 0;\n\targp->access = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "\nstatic int php_date_timezone_initialize_from_hash(zval **return_value, php_timezone_obj **tzobj, HashTable *myht TSRMLS_DC)\n{\n\tzval            **z_timezone = NULL;\n\tzval            **z_timezone_type = NULL;\n\n\tif (zend_hash_find(myht, \"timezone_type\", 14, (void**) &z_timezone_type) == SUCCESS) {\n\t\tif (zend_hash_find(myht, \"timezone\", 9, (void**) &z_timezone) == SUCCESS) {\n\t\t\tconvert_to_long(*z_timezone_type);\n\t\t\tif (SUCCESS == timezone_initialize(*tzobj, Z_STRVAL_PP(z_timezone) TSRMLS_CC)) {\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\treturn FAILURE;",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int load_image_targphys(const char *filename,\n\n\t\t\ttarget_phys_addr_t addr, int max_sz)\n\n{\n\n    int size;\n\n\n\n    size = get_image_size(filename);\n\n    if (size > 0)\n\n        rom_add_file_fixed(filename, addr, -1);\n\n    return size;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n \t\treturn -EOPNOTSUPP;\n \n \taddr &= KVM_PIT_CHANNEL_MASK;\n \ts = &pit_state->channels[addr];\n \n \tmutex_lock(&pit_state->lock);\n\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "int main( int /*argc*/, char ** argv)\n{\n\n  InitializeMagick(*argv);\n\n  int failures=0;\n\n  try {\n\n    string srcdir(\"\");\n    if(getenv(\"SRCDIR\") != 0)\n      srcdir = getenv(\"SRCDIR\");\n\n\n    list<Image> imageList;\n    readImages( &imageList, srcdir + \"test_image_anim.miff\" );\n\n    Image appended;\n\n    appendImages( &appended, imageList.begin(), imageList.end() );\n    if (( appended.signature() != \"3a90bb0bb8f69f6788ab99e9e25598a0d6c5cdbbb797f77ad68011e0a8b1689d\" ) &&\n        ( appended.signature() != \"c15fcd1e739b73638dc4e36837bdb53f7087359544664caf7b1763928129f3c7\" ) &&\n        ( appended.signature() != \"229ff72f812e5f536245dc3b4502a0bc2ab2363f67c545863a85ab91ebfbfb83\" ) &&\n        ( appended.signature() != \"b98c42c55fc4e661cb3684154256809c03c0c6b53da2738b6ce8066e1b6ddef0\" ))\n      {\n\t++failures;\n\tcout << \"Line: \" << __LINE__\n\t     << \"  Horizontal append failed, signature = \"\n\t     << appended.signature() << endl;\n\tappended.write(\"appendImages_horizontal_out.miff\");\n      }\n\n     appendImages( &appended, imageList.begin(), imageList.end(), true );\n     if (( appended.signature() != \"d73d25ccd6011936d08b6d0d89183b7a61790544c2195269aff4db2f782ffc08\" ) &&\n        ( appended.signature() != \"0909f7ffa7c6ea410fb2ebfdbcb19d61b19c4bd271851ce3bd51662519dc2b58\" ) &&\n         ( appended.signature() != \"11b97ba6ac1664aa1c2faed4c86195472ae9cce2ed75402d975bb4ffcf1de751\" ) &&\n         ( appended.signature() != \"cae4815eeb3cb689e73b94d897a9957d3414d1d4f513e8b5e52579b05d164bfe\" ))\n       {\n\t++failures;\n\tcout << \"Line: \" << __LINE__\n\t     << \"  Vertical append failed, signature = \"\n\t     << appended.signature() << endl;\n\tappended.write(\"appendImages_vertical_out.miff\");\n      }\n    \n  }\n\n  catch( Exception &error_ )\n    {\n      cout << \"Caught exception: \" << error_.what() << endl;\n      return 1;\n    }\n  catch( exception &error_ )\n    {\n      cout << \"Caught exception: \" << error_.what() << endl;\n      return 1;\n    }\n\n  if ( failures )\n    {\n      cout << failures << \" failures\" << endl;\n      return 1;\n    }\n  \n  return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int tipc_send_packet(struct socket *sock, struct msghdr *m, size_t dsz)\n{\n\tif (dsz > TIPC_MAX_USER_MSG_SIZE)\n\t\treturn -EMSGSIZE;\n\n\treturn tipc_send_stream(sock, m, dsz);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int cursorIsOpen(Vdbe *v, int iCur, int k){\n  while( k>=0 ){\n    VdbeOp *pOp = sqlite3VdbeGetOp(v,k--);\n    if( pOp->p1!=iCur ) continue;\n    if( pOp->opcode==OP_Close ) return 0;\n    if( pOp->opcode==OP_OpenRead ) return 1;\n    if( pOp->opcode==OP_OpenWrite ) return 1;\n    if( pOp->opcode==OP_OpenDup ) return 1;\n    if( pOp->opcode==OP_OpenAutoindex ) return 1;\n    if( pOp->opcode==OP_OpenEphemeral ) return 1;\n  }\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int ia5casecmp(const char *s1, const char *s2)\n{\n    return ia5ncasecmp(s1, s2, SIZE_MAX);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int sisusb_setidxregor(struct sisusb_usb_data *sisusb, int port,\n\t\tu8 index, u8 myor)\n{\n\treturn sisusb_setidxregandor(sisusb, port, index, 0xff, myor);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void close_tmpinbuf(rzip_control *control)\n{\n\tcontrol->flags &= ~FLAG_TMP_INBUF;\n\tdealloc(control->tmp_inbuf);\n\tif (!BITS32)\n\t\tcontrol->usable_ram = control->maxram += control->ramsize / 18;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int shmem_init_inodecache(void)\n{\n\tshmem_inode_cachep = kmem_cache_create(\"shmem_inode_cache\",\n\t\t\t\tsizeof(struct shmem_inode_info),\n\t\t\t\t0, SLAB_PANIC, shmem_init_inode);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "std::wstring GetElevationServiceName() {\n  std::wstring name = GetElevationServiceDisplayName();\n  name.erase(std::remove_if(name.begin(), name.end(), isspace), name.end());\n  return name;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "remove_socket_from_array(GIOChannel *chan) {\n    gboolean ret = 0;\n\n    /* TODO: Do wee need to manually free the IO channel or is this\n     *       happening implicitly on unref?\n     */\n    ret = g_ptr_array_remove_fast(uzbl.comm.connect_chan, chan);\n    if(!ret)\n        ret = g_ptr_array_remove_fast(uzbl.comm.client_chan, chan);\n\n    return ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int ext4_check_blockref(const char *function, unsigned int line,\n\t\t\tstruct inode *inode, __le32 *p, unsigned int max)\n{\n\t__le32 *bref = p;\n\tunsigned int blk;\n\n\tif (ext4_has_feature_journal(inode->i_sb) &&\n\t    (inode->i_ino ==\n\t     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))\n\t\treturn 0;\n\n\twhile (bref < p+max) {\n\t\tblk = le32_to_cpu(*bref++);\n\t\tif (blk &&\n\t\t    unlikely(!ext4_data_block_valid(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t    blk, 1))) {\n\t\t\text4_error_inode(inode, function, line, blk,\n\t\t\t\t\t \"invalid block\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "std::string Magick::Image::comment(void) const\n{\n  const char\n    *value;\n\n  GetPPException;\n  value=GetImageProperty(constImage(),\"Comment\",exceptionInfo);\n  ThrowImageException;\n\n  if (value)\n    return(std::string(value));\n\n  return(std::string()); // Intentionally no exception\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int generic_timeout_nlattr_to_obj(struct nlattr *tb[],\n\t\t\t\t\t struct net *net, void *data)\n{\n\tunsigned int *timeout = data;\n\tstruct nf_generic_net *gn = generic_pernet(net);\n\n\tif (tb[CTA_TIMEOUT_GENERIC_TIMEOUT])\n\t\t*timeout =\n\t\t    ntohl(nla_get_be32(tb[CTA_TIMEOUT_GENERIC_TIMEOUT])) * HZ;\n\telse {\n\t\t/* Set default generic timeout. */\n\t\t*timeout = gn->timeout;\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void audio_pp_nb_voices (const char *typ, int nb)\n\n{\n\n    switch (nb) {\n\n    case 0:\n\n        printf (\"Does not support %s\\n\", typ);\n\n        break;\n\n    case 1:\n\n        printf (\"One %s voice\\n\", typ);\n\n        break;\n\n    case INT_MAX:\n\n        printf (\"Theoretically supports many %s voices\\n\", typ);\n\n        break;\n\n    default:\n\n        printf (\"Theoretically supports upto %d %s voices\\n\", nb, typ);\n\n        break;\n\n    }\n\n\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "BSONObj spec() {\n        return BSON(\"$or\" << BSON_ARRAY(1));\n    }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void __exit exit_f2fs_fs(void)\n{\n\tf2fs_destroy_root_stats();\n\tunregister_filesystem(&f2fs_fs_type);\n\tunregister_shrinker(&f2fs_shrinker_info);\n\tf2fs_exit_sysfs();\n\tdestroy_extent_cache();\n\tdestroy_checkpoint_caches();\n\tdestroy_segment_manager_caches();\n\tdestroy_node_manager_caches();\n\tdestroy_inodecache();\n\tf2fs_destroy_trace_ios();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int nfs4_xdr_enc_open_downgrade(struct rpc_rqst *req, __be32 *p, struct nfs_closeargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_open_downgrade(&xdr, args);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int snd_seq_ioctl_get_queue_client(struct snd_seq_client *client,\n\t\t\t\t\t  void __user *arg)\n{\n\tstruct snd_seq_queue_client info;\n\tint used;\n\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tused = snd_seq_queue_is_used(info.queue, client->number);\n\tif (used < 0)\n\t\treturn -EINVAL;\n\tinfo.used = used;\n\tinfo.client = client->number;\n\n\tif (copy_to_user(arg, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "NTSTATUS TCCompleteDiskIrp (PIRP irp, NTSTATUS status, ULONG_PTR information)\n{\n\tirp->IoStatus.Status = status;\n\tirp->IoStatus.Information = information;\n\tIoCompleteRequest (irp, NT_SUCCESS (status) ? IO_DISK_INCREMENT : IO_NO_INCREMENT);\n\treturn status;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void cpu_common_reset(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int i;\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", cpu->cpu_index);\n\n        log_cpu_state(cpu, cc->reset_dump_flags);\n\n    }\n\n\n\n    cpu->interrupt_request = 0;\n\n    cpu->halted = 0;\n\n    cpu->mem_io_pc = 0;\n\n    cpu->mem_io_vaddr = 0;\n\n    cpu->icount_extra = 0;\n\n    cpu->icount_decr.u32 = 0;\n\n    cpu->can_do_io = 1;\n\n    cpu->exception_index = -1;\n\n    cpu->crash_occurred = false;\n\n\n\n    if (tcg_enabled()) {\n\n        for (i = 0; i < TB_JMP_CACHE_SIZE; ++i) {\n\n            atomic_set(&cpu->tb_jmp_cache[i], NULL);\n\n        }\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n        tlb_flush(cpu, 0);\n\n#endif\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "//! Fill all pixel values with specified value \\newinstance.\n    CImg<T> get_fill(const T& val) const {\n      return CImg<T>(_width,_height,_depth,_spectrum).fill(val);",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "xcf_load_old_paths (XcfInfo   *info,\n                    GimpImage *image)\n{\n  guint32      num_paths;\n  guint32      last_selected_row;\n  GimpVectors *active_vectors;\n\n  xcf_read_int32 (info, &last_selected_row, 1);\n  xcf_read_int32 (info, &num_paths,         1);\n\n  while (num_paths-- > 0)\n    xcf_load_old_path (info, image);\n\n  active_vectors =\n    GIMP_VECTORS (gimp_container_get_child_by_index (gimp_image_get_vectors (image),\n                                                     last_selected_row));\n\n  if (active_vectors)\n    gimp_image_set_active_vectors (image, active_vectors);\n\n  return TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int url_is_local_not_ssh(const char *url)\n{\n\tconst char *colon = strchr(url, ':');\n\tconst char *slash = strchr(url, '/');\n\treturn !colon || (slash && slash < colon) ||\n\t\thas_dos_drive_prefix(url);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int xenstore_scan(const char *type, int dom, struct XenDevOps *ops)\n\n{\n\n    struct XenDevice *xendev;\n\n    char path[XEN_BUFSIZE], token[XEN_BUFSIZE];\n\n    char **dev = NULL, *dom0;\n\n    unsigned int cdev, j;\n\n\n\n    /* setup watch */\n\n    dom0 = xs_get_domain_path(xenstore, 0);\n\n    snprintf(token, sizeof(token), \"be:%p:%d:%p\", type, dom, ops);\n\n    snprintf(path, sizeof(path), \"%s/backend/%s/%d\", dom0, type, dom);\n\n    free(dom0);\n\n    if (!xs_watch(xenstore, path, token)) {\n\n        xen_be_printf(NULL, 0, \"xen be: watching backend path (%s) failed\\n\", path);\n\n        return -1;\n\n    }\n\n\n\n    /* look for backends */\n\n    dev = xs_directory(xenstore, 0, path, &cdev);\n\n    if (!dev) {\n\n        return 0;\n\n    }\n\n    for (j = 0; j < cdev; j++) {\n\n        xendev = xen_be_get_xendev(type, dom, atoi(dev[j]), ops);\n\n        if (xendev == NULL) {\n\n            continue;\n\n        }\n\n        xen_be_check_state(xendev);\n\n    }\n\n    free(dev);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\t/* release all previous allocated pages in the table */\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "shift(stack *s, int type, char *str, int newstate, int lineno, int col_offset,\n      int end_lineno, int end_col_offset)\n{\n    int err;\n    assert(!s_empty(s));\n    err = PyNode_AddChild(s->s_top->s_parent, type, str, lineno, col_offset,\n                          end_lineno, end_col_offset);\n    if (err)\n        return err;\n    s->s_top->s_state = newstate;\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "wc_is_ucs_wide(wc_uint32 ucs)\n{\n    if (ucs <= WC_C_UCS2_END)\n\treturn (wc_map_range_search((wc_uint16)ucs,\n\t\tucs_wide_map, N_ucs_wide_map) != NULL);\n    else\n\treturn ((ucs & ~0xFFFF) == WC_C_UCS4_PLANE2 ||\n\t\t(ucs & ~0xFFFF) == WC_C_UCS4_PLANE3);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void strextract(const char *str, char delim, char *extr, int size)\n/* extract a substinr \"extr\" from \"str\" until \"delim\" is found */\n{\n   int i;\n\n   for (i = 0; str[i] != delim && i < size - 1; i++)\n      extr[i] = str[i];\n   extr[i] = 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct fxregs_state *fxsave;\n\n\tvcpu_load(vcpu);\n\n\tfxsave = &vcpu->arch.guest_fpu.state.fxsave;\n\tmemcpy(fpu->fpr, fxsave->st_space, 128);\n\tfpu->fcw = fxsave->cwd;\n\tfpu->fsw = fxsave->swd;\n\tfpu->ftwx = fxsave->twd;\n\tfpu->last_opcode = fxsave->fop;\n\tfpu->last_ip = fxsave->rip;\n\tfpu->last_dp = fxsave->rdp;\n\tmemcpy(fpu->xmm, fxsave->xmm_space, sizeof(fxsave->xmm_space));\n\n\tvcpu_put(vcpu);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "inline int ComputeOutSize(TfLitePadding padding, int image_size,\n                          int filter_size, int stride, int dilation_rate = 1) {\n  int effective_filter_size = (filter_size - 1) * dilation_rate + 1;\n  switch (padding) {\n    case kTfLitePaddingSame:\n      return (image_size + stride - 1) / stride;\n    case kTfLitePaddingValid:\n      return (image_size + stride - effective_filter_size) / stride;\n    default:\n      return 0;\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "uint8 CSoundFile::GetBestMidiChannel(CHANNELINDEX nChn) const\n{\n\tif(nChn >= MAX_CHANNELS)\n\t{\n\t\treturn 0;\n\t}\n\n\tconst ModInstrument *ins = m_PlayState.Chn[nChn].pModInstrument;\n\tif(ins != nullptr)\n\t{\n\t\tif(ins->nMidiChannel == MidiMappedChannel)\n\t\t{\n\t\t\treturn (m_PlayState.Chn[nChn].nMasterChn ? (m_PlayState.Chn[nChn].nMasterChn - 1) : nChn) % 16;\n\t\t} else if(ins->HasValidMIDIChannel())\n\t\t{\n\t\t\treturn (ins->nMidiChannel - 1) & 0x0F;\n\t\t}\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void rv40_h_strong_loop_filter(uint8_t *src, const int stride,\n\n                                      const int alpha, const int lims,\n\n                                      const int dmode, const int chroma)\n\n{\n\n    rv40_strong_loop_filter(src, stride, 1, alpha, lims, dmode, chroma);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n\n        /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n\n        g_return_val_if_fail (client != NULL, TRUE);\n\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline void context_set_present(struct context_entry *context)\n{\n\tcontext->lo |= 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void pdf_run_gs_CA(fz_context *ctx, pdf_processor *proc, float alpha)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_gstate *gstate = pdf_flush_text(ctx, pr);\n\tgstate->stroke.alpha = fz_clamp(alpha, 0, 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)\r\n{\r\n    auto* zei = entries.getUnchecked (index);\r\n\r\n   #if JUCE_WINDOWS\r\n    auto entryPath = zei->entry.filename;\r\n   #else\r\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\r\n   #endif\r\n\r\n    if (entryPath.isEmpty())\r\n        return Result::ok();\r\n\r\n    auto targetFile = targetDirectory.getChildFile (entryPath);\r\n\r\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\r\n        return targetFile.createDirectory(); // (entry is a directory, not a file)\r\n\r\n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\r\n\r\n    if (in == nullptr)\r\n        return Result::fail (\"Failed to open the zip file for reading\");\r\n\r\n    if (targetFile.exists())\r\n    {\r\n        if (! shouldOverwriteFiles)\r\n            return Result::ok();\r\n\r\n        if (! targetFile.deleteFile())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n    }\r\n\r\n    if (! targetFile.getParentDirectory().createDirectory())\r\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\n\r\n    if (zei->entry.isSymbolicLink)\r\n    {\r\n        String originalFilePath (in->readEntireStreamAsString()\r\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\r\n\r\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\r\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\r\n    }\r\n    else\r\n    {\r\n        FileOutputStream out (targetFile);\r\n\r\n        if (out.failedToOpen())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n\r\n        out << *in;\r\n    }\r\n\r\n    targetFile.setCreationTime (zei->entry.fileTime);\r\n    targetFile.setLastModificationTime (zei->entry.fileTime);\r\n    targetFile.setLastAccessTime (zei->entry.fileTime);\r\n\r\n    return Result::ok();\r\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n {\n \tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n \tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n \n \t/* Synchronize */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\n\t\t\t\t\t hashbin_lock_depth++);\n\t}\n \n \t/*\n \t *  Free the entries in the hashbin, TODO: use hashbin_clear when\n \t *  it has been shown to work\n \t */\n \tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\t\twhile (queue ) {\n\t\t\tif (free_func)\n\t\t\t\t(*free_func)(queue);\n\t\t\tqueue = dequeue_first(\n\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);\n \t\t}\n \t}\n \n\t/* Cleanup local data */\n\thashbin->hb_current = NULL;\n \thashbin->magic = ~HB_MAGIC;\n \n \t/* Release lock */\n\tif ( hashbin->hb_type & HB_LOCK) {\n \t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n#ifdef CONFIG_LOCKDEP\n\t\thashbin_lock_depth--;\n#endif\n\t}\n \n \t/*\n \t *  Free the hashbin structure\n\t */\n\tkfree(hashbin);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int hva_to_pfn_remapped(struct vm_area_struct *vma,\n\t\t\t       unsigned long addr, bool *async,\n\t\t\t       bool write_fault, bool *writable,\n\t\t\t       kvm_pfn_t *p_pfn)\n{\n\tkvm_pfn_t pfn;\n\tpte_t *ptep;\n\tspinlock_t *ptl;\n\tint r;\n\n\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n\tif (r) {\n\t\t/*\n\t\t * get_user_pages fails for VM_IO and VM_PFNMAP vmas and does\n\t\t * not call the fault handler, so do it here.\n\t\t */\n\t\tbool unlocked = false;\n\t\tr = fixup_user_fault(current->mm, addr,\n\t\t\t\t     (write_fault ? FAULT_FLAG_WRITE : 0),\n\t\t\t\t     &unlocked);\n\t\tif (unlocked)\n\t\t\treturn -EAGAIN;\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (write_fault && !pte_write(*ptep)) {\n\t\tpfn = KVM_PFN_ERR_RO_FAULT;\n\t\tgoto out;\n\t}\n\n\tif (writable)\n\t\t*writable = pte_write(*ptep);\n\tpfn = pte_pfn(*ptep);\n\n\t/*\n\t * Get a reference here because callers of *hva_to_pfn* and\n\t * *gfn_to_pfn* ultimately call kvm_release_pfn_clean on the\n\t * returned pfn.  This is only needed if the VMA has VM_MIXEDMAP\n\t * set, but the kvm_get_pfn/kvm_release_pfn_clean pair will\n\t * simply do nothing for reserved pfns.\n\t *\n\t * Whoever called remap_pfn_range is also going to call e.g.\n\t * unmap_mapping_range before the underlying pages are freed,\n\t * causing a call to our MMU notifier.\n\t */ \n\tkvm_get_pfn(pfn);\n\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\t*p_pfn = pfn;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int libquvi_close(AVFormatContext *s)\n\n{\n\n    LibQuviContext *qc = s->priv_data;\n\n    if (qc->fmtctx)\n\n        avformat_close_input(&qc->fmtctx);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int rtnl_group_changelink(struct net *net, int group,\n\t\tstruct ifinfomsg *ifm,\n\t\tstruct nlattr **tb)\n{\n\tstruct net_device *dev;\n\tint err;\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->group == group) {\n\t\t\terr = do_setlink(dev, ifm, tb, NULL, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "OFBool DcmSCP::getHostLookupEnabled() const\n{\n  return m_cfg->getHostLookupEnabled();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void irc_core_deinit(void)\n{\n\tsignal_emit(\"chat protocol deinit\", 1, chat_protocol_find(\"IRC\"));\n\n\tcap_deinit();\n\tirc_expandos_deinit();\n\tnetsplit_deinit();\n\tlag_deinit();\n\tirc_commands_deinit();\n\tctcp_deinit();\n\n\tirc_queries_deinit();\n\tirc_channels_deinit();\n\tirc_irc_deinit();\n\tirc_servers_deinit();\n\tirc_chatnets_deinit();\n        irc_session_deinit();\n\n\tchat_protocol_unregister(\"IRC\");\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void RemoveActionCallback(const ActionCallback& callback) {\n  DCHECK(g_task_runner.Get());\n   DCHECK(g_task_runner.Get()->BelongsToCurrentThread());\n   std::vector<ActionCallback>* callbacks = g_callbacks.Pointer();\n   for (size_t i = 0; i < callbacks->size(); ++i) {\n    if ((*callbacks)[i] == callback) {\n       callbacks->erase(callbacks->begin() + i);\n       return;\n     }\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void imap_free_header_data(struct ImapHeaderData **data)\n{\n  if (!data || !*data)\n    return;\n\n  /* this should be safe even if the list wasn't used */\n  FREE(&((*data)->flags_system));\n  FREE(&((*data)->flags_remote));\n  FREE(data);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void EditorClientBlackBerry::textDidChangeInTextArea(Element*)\n{\n    notImplemented();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "write_packet(int fd, gss_buffer_t buf)\n{\n\tuint32_t\tlen;\n\tOM_uint32\tmin_stat;\n\tint\t\tret = 0;\n\n\tlen = htonl(buf->length);\n\tif ((writen(fd, &len, 4) != 4) ||\n\t    (writen(fd, buf->value, buf->length) != buf->length))\n\t\tret = -1;\n\n\tgss_release_buffer (&min_stat, buf);\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ByteVector::ByteVector(const char *data)\n{\n  d = new ByteVectorPrivate;\n  setData(data);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void Magick::Image::transpose(void)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=TransposeImage(constImage(),exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int dsOpen(void) {\n    struct stat sb;\n    int retval;\n    char *path = server.diskstore_path;\n\n    if ((retval = stat(path,&sb) == -1) && errno != ENOENT) {\n        redisLog(REDIS_WARNING, \"Error opening disk store at %s: %s\",\n                path, strerror(errno));\n        return REDIS_ERR;\n    }\n\n    /* Directory already in place. Assume everything is ok. */\n    if (retval == 0 && S_ISDIR(sb.st_mode)) return REDIS_OK;\n\n    /* File exists but it's not a directory */\n    if (retval == 0 && !S_ISDIR(sb.st_mode)) {\n        redisLog(REDIS_WARNING,\"Disk store at %s is not a directory\", path);\n        return REDIS_ERR;\n    }\n\n    /* New disk store, create the directory structure now, as creating\n     * them in a lazy way is not a good idea, after very few insertions\n     * we'll need most of the 65536 directories anyway. */\n    if (mkdir(path) == -1) {\n        redisLog(REDIS_WARNING,\"Disk store init failed creating dir %s: %s\",\n            path, strerror(errno));\n        return REDIS_ERR;\n    }\n    return REDIS_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "EnableFileTransfer(rfbBool enable)\n{\n\tfileTransferEnabled = enable;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int aac_parse_packet(AVFormatContext *ctx, PayloadContext *data,\n\n                            AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                            const uint8_t *buf, int len, uint16_t seq,\n\n                            int flags)\n\n{\n\n    int ret;\n\n    if (rtp_parse_mp4_au(data, buf))\n\n        return -1;\n\n\n\n    buf += data->au_headers_length_bytes + 2;\n\n    len -= data->au_headers_length_bytes + 2;\n\n\n\n    /* XXX: Fixme we only handle the case where rtp_parse_mp4_au define\n\n                    one au_header */\n\n    if ((ret = av_new_packet(pkt, data->au_headers[0].size)) < 0)\n\n        return ret;\n\n    memcpy(pkt->data, buf, data->au_headers[0].size);\n\n\n\n    pkt->stream_index = st->index;\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline void __skb_frag_set_page(skb_frag_t *frag, struct page *page)\n{\n\tfrag->page.p = page;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "compile_string_node(Node* node, regex_t* reg)\n{\n  int r, len, prev_len, slen, ambig;\n  OnigEncoding enc = reg->enc;\n  UChar *p, *prev, *end;\n  StrNode* sn;\n\n  sn = NSTR(node);\n  if (sn->end <= sn->s)\n    return 0;\n\n  end = sn->end;\n  ambig = NSTRING_IS_AMBIG(node);\n\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n\n  for (; p < end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string(prev, prev_len, slen, reg, ambig);\n      if (r) return r;\n\n      prev  = p;\n      slen  = 1;\n      prev_len = len;\n    }\n\n    p += len;\n  }\n  return add_compile_string(prev, prev_len, slen, reg, ambig);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "uint64_t helper_mulqv(CPUAlphaState *env, uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tl, th;\n\n\n\n    muls64(&tl, &th, op1, op2);\n\n    /* If th != 0 && th != -1, then we had an overflow */\n\n    if (unlikely((th + 1) > 1)) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return tl;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline void skb_entail(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_skb_cb *tcb = TCP_SKB_CB(skb);\n\n\tskb->csum    = 0;\n\ttcb->seq     = tcb->end_seq = tp->write_seq;\n\ttcb->flags   = TCPCB_FLAG_ACK;\n\ttcb->sacked  = 0;\n\tskb_header_release(skb);\n\ttcp_add_write_queue_tail(sk, skb);\n\tsk->sk_wmem_queued += skb->truesize;\n\tsk_mem_charge(sk, skb->truesize);\n\tif (tp->nonagle & TCP_NAGLE_PUSH)\n\t\ttp->nonagle &= ~TCP_NAGLE_PUSH;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "size_t tls12_get_psigalgs(SSL *s, const unsigned char **psigs)\n\t{\n\t/* If Suite B mode use Suite B sigalgs only, ignore any other\n\t * preferences.\n\t */\n#ifndef OPENSSL_NO_EC\n\tswitch (tls1_suiteb(s))\n\t\t{\n\tcase SSL_CERT_FLAG_SUITEB_128_LOS:\n\t\t*psigs = suiteb_sigalgs;\n\t\treturn sizeof(suiteb_sigalgs);\n\n\tcase SSL_CERT_FLAG_SUITEB_128_LOS_ONLY:\n\t\t*psigs = suiteb_sigalgs;\n\t\treturn 2;\n\n\tcase SSL_CERT_FLAG_SUITEB_192_LOS:\n\t\t*psigs = suiteb_sigalgs + 2;\n\t\treturn 2;\n\t\t}\n#endif\n\t/* If server use client authentication sigalgs if not NULL */\n\tif (s->server && s->cert->client_sigalgs)\n\t\t{\n\t\t*psigs = s->cert->client_sigalgs;\n\t\treturn s->cert->client_sigalgslen;\n\t\t}\n\telse if (s->cert->conf_sigalgs)\n\t\t{\n\t\t*psigs = s->cert->conf_sigalgs;\n\t\treturn s->cert->conf_sigalgslen;\n\t\t}\n\telse\n\t\t{\n\t\t*psigs = tls12_sigalgs;\n#ifdef OPENSSL_FIPS\n\t\t/* If FIPS mode don't include MD5 which is last */\n\t\tif (FIPS_mode())\n\t\t\treturn sizeof(tls12_sigalgs) - 2;\n\t\telse\n#endif\n\t\t\treturn sizeof(tls12_sigalgs);\n\t\t}\n\t}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void EmptyRelease( update_t *p_update )\n{\n    p_update->release.i_major = 0;\n    p_update->release.i_minor = 0;\n    p_update->release.i_revision = 0;\n\n    FREENULL( p_update->release.psz_url );\n    FREENULL( p_update->release.psz_desc );\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int stbi__bmp_test_raw(stbi__context *s)\n{\n   int r;\n   int sz;\n   if (stbi__get8(s) != 'B') return 0;\n   if (stbi__get8(s) != 'M') return 0;\n   stbi__get32le(s); // discard filesize\n   stbi__get16le(s); // discard reserved\n   stbi__get16le(s); // discard reserved\n   stbi__get32le(s); // discard data offset\n   sz = stbi__get32le(s);\n   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);\n   return r;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int vp9_alloc_frame(AVCodecContext *ctx, VP9Frame *f)\n\n{\n\n    VP9Context *s = ctx->priv_data;\n\n    int ret, sz;\n\n\n\n    if ((ret = ff_thread_get_buffer(ctx, &f->tf, AV_GET_BUFFER_FLAG_REF)) < 0)\n\n        return ret;\n\n    sz = 64 * s->sb_cols * s->sb_rows;\n\n    if (!(f->extradata = av_buffer_allocz(sz * (1 + sizeof(struct VP9mvrefPair))))) {\n\n        ff_thread_release_buffer(ctx, &f->tf);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    f->segmentation_map = f->extradata->data;\n\n    f->mv = (struct VP9mvrefPair *) (f->extradata->data + sz);\n\n\n\n    // retain segmentation map if it doesn't update\n\n    if (s->segmentation.enabled && !s->segmentation.update_map &&\n\n        !s->keyframe && !s->intraonly) {\n\n        memcpy(f->segmentation_map, s->frames[LAST_FRAME].segmentation_map, sz);\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void __skb_get_hash(struct sk_buff *skb)\n{\n\tstruct flow_keys keys;\n\tu32 hash;\n\n\t__flow_hash_secret_init();\n\n\thash = ___skb_get_hash(skb, &keys, hashrnd);\n\n\t__skb_set_sw_hash(skb, hash, flow_keys_have_l4(&keys));\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "htp_status_t htp_tx_destroy(htp_tx_t *tx) {\n    if (tx == NULL) return HTP_ERROR;\n\n    if (!htp_tx_is_complete(tx)) return HTP_ERROR;\n\n    htp_tx_destroy_incomplete(tx);\n\n    return HTP_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void kvm_set_page_dirty(struct page *page)\n{\n\tkvm_set_pfn_dirty(page_to_pfn(page));\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void stripnewline(char *x)\n{\n\tsize_t l = strlen(x);\n\tif (l && x[l-1] == '\\n')\n\t\tx[l-1] = '\\0';\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem )\n{\n\tint i = 0;\n\tcJSON *c = object->child;\n\twhile ( c && cJSON_strcasecmp( c->string, string ) ) {\n\t\t++i;\n\t\tc = c->next;\n\t}\n\tif ( c ) {\n\t\tnewitem->string = cJSON_strdup( string );\n\t\tcJSON_ReplaceItemInArray( object, i, newitem );\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int is_ud_qp(struct bnxt_re_qp *qp)\n{\n\treturn (qp->qplib_qp.type == CMDQ_CREATE_QP_TYPE_UD ||\n\t\tqp->qplib_qp.type == CMDQ_CREATE_QP_TYPE_GSI);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "XML_SetStartElementHandler(XML_Parser parser,\n                           XML_StartElementHandler start) {\n  startElementHandler = start;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int __init ecryptfs_init_crypto(void)\n{\n\tmutex_init(&key_tfm_list_mutex);\n\tINIT_LIST_HEAD(&key_tfm_list);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int xan_huffman_decode(uint8_t *dest, int dest_len,\n\n                              const uint8_t *src, int src_len)\n\n{\n\n    uint8_t byte = *src++;\n\n    uint8_t ival = byte + 0x16;\n\n    const uint8_t * ptr = src + byte*2;\n\n    int ptr_len = src_len - 1 - byte*2;\n\n    uint8_t val = ival;\n\n    uint8_t *dest_end = dest + dest_len;\n\n    uint8_t *dest_start = dest;\n\n    int ret;\n\n    GetBitContext gb;\n\n\n\n    if ((ret = init_get_bits8(&gb, ptr, ptr_len)) < 0)\n\n        return ret;\n\n\n\n    while (val != 0x16) {\n\n        unsigned idx = val - 0x17 + get_bits1(&gb) * byte;\n\n        if (idx >= 2 * byte)\n\n            return AVERROR_INVALIDDATA;\n\n        val = src[idx];\n\n\n\n        if (val < 0x16) {\n\n            if (dest >= dest_end)\n\n                return dest_len;\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n    }\n\n\n\n    return dest - dest_start;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "gst_asf_demux_get_buffer (GstBuffer ** p_buf, guint num_bytes_to_read,\n    guint8 ** p_data, guint64 * p_size)\n{\n  *p_buf = NULL;\n\n  if (*p_size < num_bytes_to_read)\n    return FALSE;\n\n  *p_buf = gst_buffer_new_and_alloc (num_bytes_to_read);\n  gst_buffer_fill (*p_buf, 0, *p_data, num_bytes_to_read);\n\n  *p_data += num_bytes_to_read;\n  *p_size -= num_bytes_to_read;\n\n  return TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "copy_thread(unsigned long clone_flags, unsigned long stack_start,\n\t    unsigned long stk_sz, struct task_struct *p)\n{\n\tstruct thread_info *thread = task_thread_info(p);\n\tstruct pt_regs *childregs = task_pt_regs(p);\n\n\tmemset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));\n\n\tif (likely(!(p->flags & PF_KTHREAD))) {\n\t\t*childregs = *current_pt_regs();\n\t\tchildregs->ARM_r0 = 0;\n\t\tif (stack_start)\n\t\t\tchildregs->ARM_sp = stack_start;\n\t} else {\n\t\tmemset(childregs, 0, sizeof(struct pt_regs));\n\t\tthread->cpu_context.r4 = stk_sz;\n\t\tthread->cpu_context.r5 = stack_start;\n\t\tchildregs->ARM_cpsr = SVC_MODE;\n\t}\n\tthread->cpu_context.pc = (unsigned long)ret_from_fork;\n\tthread->cpu_context.sp = (unsigned long)childregs;\n\n\tclear_ptrace_hw_breakpoint(p);\n\n\tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value = childregs->ARM_r3;\n\n\tthread_notify(THREAD_NOTIFY_COPY, thread);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "nm_utils_machine_id_bin(void)\n{\n    return &_machine_id_get(TRUE)->bin;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "MagickExport void *ResizeQuantumMemory(void *memory,const size_t count,\n  const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    {\n      memory=RelinquishMagickMemory(memory);\n      return((void *) NULL);\n    }\n  extent=count*quantum;\n  return(ResizeMagickMemory(memory,extent));\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline unsigned short ScaleQuantumToShort(const Quantum quantum)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((unsigned short) ((quantum+MagickULLConstant(32768))/\n    MagickULLConstant(65537)));\n#else\n  if (quantum <= 0.0)\n    return(0);\n  if ((quantum/65537.0) >= 65535.0)\n    return(65535);\n  return((unsigned short) (quantum/65537.0+0.5));\n#endif\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static struct pneigh_entry *pneigh_get_next(struct seq_file *seq,\n\t\t\t\t\t    struct pneigh_entry *pn,\n\t\t\t\t\t    loff_t *pos)\n{\n\tstruct neigh_seq_state *state = seq->private;\n\tstruct neigh_table *tbl = state->tbl;\n\n\tpn = pn->next;\n\twhile (!pn) {\n\t\tif (++state->bucket > PNEIGH_HASHMASK)\n\t\t\tbreak;\n\t\tpn = tbl->phash_buckets[state->bucket];\n\t\tif (pn)\n\t\t\tbreak;\n\t}\n\n\tif (pn && pos)\n\t\t--(*pos);\n\n\treturn pn;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "vg_resource_destroy(VuGpu *g,\n                    struct virtio_gpu_simple_resource *res)\n{\n    int i;\n\n    if (res->scanout_bitmask) {\n        for (i = 0; i < VIRTIO_GPU_MAX_SCANOUTS; i++) {\n            if (res->scanout_bitmask & (1 << i)) {\n                vg_disable_scanout(g, i);\n            }\n        }\n    }\n\n    vugbm_buffer_destroy(&res->buffer);\n    pixman_image_unref(res->image);\n    QTAILQ_REMOVE(&g->reslist, res, next);\n    g_free(res);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int idr_alloc(struct idr *idr, void *ptr, int start, int end, gfp_t gfp_mask)\n{\n\tint max = end > 0 ? end - 1 : INT_MAX;\t/* inclusive upper limit */\n\tstruct idr_layer *pa[MAX_IDR_LEVEL];\n\tint id;\n\n\tmight_sleep_if(gfp_mask & __GFP_WAIT);\n\n\t/* sanity checks */\n\tif (WARN_ON_ONCE(start < 0))\n\t\treturn -EINVAL;\n\tif (unlikely(max < start))\n\t\treturn -ENOSPC;\n\n\t/* allocate id */\n\tid = idr_get_empty_slot(idr, start, pa, gfp_mask, NULL);\n\tif (unlikely(id < 0))\n\t\treturn id;\n\tif (unlikely(id > max))\n\t\treturn -ENOSPC;\n\n\tidr_fill_slot(ptr, id, pa);\n\treturn id;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "unsigned long sock_i_ino(struct sock *sk)\n{\n\tunsigned long ino;\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tino = sk->sk_socket ? SOCK_INODE(sk->sk_socket)->i_ino : 0;\n\tread_unlock_bh(&sk->sk_callback_lock);\n\treturn ino;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.time_page)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline unsigned php_unicode_tofold_full(\n\t\tunsigned code, enum mbfl_no_encoding enc, unsigned *out) {\n\tcode = php_unicode_tofold_raw(code, enc);\n\tif (UNEXPECTED(code > 0xffffff)) {\n\t\tunsigned len = code >> 24;\n\t\tconst unsigned *p = &_uccase_extra_table[code & 0xffffff];\n\t\tmemcpy(out, p + 1, len * sizeof(unsigned));\n\t\treturn len;\n\t}\n\t*out = code;\n\treturn 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "set_num_723(unsigned char *p, uint16_t value)\n{\n\tarchive_le16enc(p, value);\n\tarchive_be16enc(p+2, value);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "pdf14_open(gx_device *dev)\n{\n    pdf14_device *pdev = (pdf14_device *)dev;\n    gs_int_rect rect;\n\n    if_debug2m('v', dev->memory, \"[v]pdf14_open: width = %d, height = %d\\n\",\n               dev->width, dev->height);\n    rect.p.x = 0;\n    rect.p.y = 0;\n    rect.q.x = dev->width;\n    rect.q.y = dev->height;\n    pdev->ctx = pdf14_ctx_new(&rect, dev->color_info.num_components,\n        pdev->color_info.polarity != GX_CINFO_POLARITY_SUBTRACTIVE, dev);\n    if (pdev->ctx == NULL)\n        return_error(gs_error_VMerror);\n    pdev->free_devicen = true;\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "SPICE_GNUC_VISIBLE SpiceServer *spice_server_new(void)\n{\n    /* we can't handle multiple instances (yet) */\n    spice_assert(reds == NULL);\n\n    reds = spice_new0(RedsState, 1);\n    return reds;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int common_perm_dir_dentry(int op, const struct path *dir,\n\t\t\t\t  struct dentry *dentry, u32 mask,\n\t\t\t\t  struct path_cond *cond)\n{\n\tstruct path path = { dir->mnt, dentry };\n\n\treturn common_perm(op, &path, mask, cond);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int X509_REQ_extension_nid(int req_nid)\n{\n    int i, nid;\n    for (i = 0;; i++) {\n        nid = ext_nids[i];\n        if (nid == NID_undef)\n            return 0;\n        else if (req_nid == nid)\n            return 1;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void use_normal_update_speed(WmallDecodeCtx *s, int ich)\n\n{\n\n    int ilms, recent, icoef;\n\n    s->update_speed[ich] = 8;\n\n    for (ilms = s->cdlms_ttl[ich]; ilms >= 0; ilms--) {\n\n        recent = s->cdlms[ich][ilms].recent;\n\n        if (s->bV3RTM) {\n\n            for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n\n                s->cdlms[ich][ilms].lms_updates[icoef + recent] /= 2;\n\n        } else {\n\n            for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n\n                s->cdlms[ich][ilms].lms_updates[icoef] /= 2;\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void do_srad (void)\n\n{\n\n    int64_t ret;\n\n\n\n    if (likely(!(T1 & 0x40UL))) {\n\n        if (likely((uint64_t)T1 != 0)) {\n\n            ret = (int64_t)T0 >> (T1 & 0x3FUL);\n\n            if (likely(ret >= 0 || ((int64_t)T0 & ((1 << T1) - 1)) == 0)) {\n\n                xer_ca = 0;\n\n            } else {\n\n                xer_ca = 1;\n\n            }\n\n        } else {\n\n            ret = T0;\n\n            xer_ca = 0;\n\n        }\n\n    } else {\n\n        ret = (-1) * ((uint64_t)T0 >> 63);\n\n        if (likely(ret >= 0 || ((uint64_t)T0 & ~0x8000000000000000ULL) == 0)) {\n\n            xer_ca = 0;\n\n        } else {\n\n            xer_ca = 1;\n\n        }\n\n    }\n\n    T0 = ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "TiffIfdMakernote* TiffIfdMakernote::doClone() const\n    {\n        assert(false); // Not implemented\n        return 0;\n    }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int url_open(URLContext **puc, const char *filename, int flags)\n\n{\n\n    URLProtocol *up;\n\n    const char *p;\n\n    char proto_str[128], *q;\n\n\n\n    p = filename;\n\n    q = proto_str;\n\n    while (*p != '\\0' && *p != ':') {\n\n        /* protocols can only contain alphabetic chars */\n\n        if (!isalpha(*p))\n\n            goto file_proto;\n\n        if ((q - proto_str) < sizeof(proto_str) - 1)\n\n            *q++ = *p;\n\n        p++;\n\n    }\n\n    /* if the protocol has length 1, we consider it is a dos drive */\n\n    if (*p == '\\0' || (q - proto_str) <= 1) {\n\n    file_proto:\n\n        strcpy(proto_str, \"file\");\n\n    } else {\n\n        *q = '\\0';\n\n    }\n\n\n\n    up = first_protocol;\n\n    while (up != NULL) {\n\n        if (!strcmp(proto_str, up->name))\n\n            return url_open_protocol (puc, up, filename, flags);\n\n        up = up->next;\n\n    }\n\n    *puc = NULL;\n\n    return AVERROR(ENOENT);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline void xfrm_state_put_sync(struct xfrm_state *x)\n{\n\tif (refcount_dec_and_test(&x->refcnt))\n\t\t__xfrm_state_destroy(x, true);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\tstruct skcipher_tfm *tfm;\n\tstruct crypto_skcipher *skcipher;\n\n\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n\tif (!tfm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskcipher = crypto_alloc_skcipher(name, type, mask);\n\tif (IS_ERR(skcipher)) {\n\t\tkfree(tfm);\n\t\treturn ERR_CAST(skcipher);\n\t}\n\n\ttfm->skcipher = skcipher;\n\n\treturn tfm;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int tsk_set_importance(struct tipc_sock *tsk, int imp)\n{\n\tif (imp > TIPC_CRITICAL_IMPORTANCE)\n\t\treturn -EINVAL;\n\tmsg_set_importance(&tsk->phdr, (u32)imp);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline TCGOp *tcg_emit_op(TCGOpcode opc)\n\n{\n\n    TCGContext *ctx = tcg_ctx;\n\n    int oi = ctx->gen_next_op_idx;\n\n    int ni = oi + 1;\n\n    int pi = oi - 1;\n\n    TCGOp *op = &ctx->gen_op_buf[oi];\n\n\n\n    tcg_debug_assert(oi < OPC_BUF_SIZE);\n\n    ctx->gen_op_buf[0].prev = oi;\n\n    ctx->gen_next_op_idx = ni;\n\n\n\n    memset(op, 0, offsetof(TCGOp, args));\n\n    op->opc = opc;\n\n    op->prev = pi;\n\n    op->next = ni;\n\n\n\n    return op;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "Eina_Bool ewk_view_setting_resizable_textareas_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    return priv->settings.resizableTextareas;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool utf8ToUcs2le(std::string& str)\n    {\n        return mb2wc(CP_UTF8, str);\n    }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void hmp_pcie_aer_inject_error(Monitor *mon, const QDict *qdict)\n\n{\n\n    QObject *data;\n\n    int devfn;\n\n\n\n    if (do_pcie_aer_inject_error(mon, qdict, &data) < 0) {\n\n        return;\n\n    }\n\n\n\n    qdict = qobject_to_qdict(data);\n\n    assert(qdict);\n\n\n\n    devfn = (int)qdict_get_int(qdict, \"devfn\");\n\n    monitor_printf(mon, \"OK id: %s root bus: %s, bus: %x devfn: %x.%x\\n\",\n\n                   qdict_get_str(qdict, \"id\"),\n\n                   qdict_get_str(qdict, \"root_bus\"),\n\n                   (int) qdict_get_int(qdict, \"bus\"),\n\n                   PCI_SLOT(devfn), PCI_FUNC(devfn));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static struct inet_frag_queue *inet_frag_alloc(struct netns_frags *nf,\n\t\tstruct inet_frags *f, void *arg)\n{\n\tstruct inet_frag_queue *q;\n\n\tq = kzalloc(f->qsize, GFP_ATOMIC);\n\tif (q == NULL)\n\t\treturn NULL;\n\n\tq->net = nf;\n\tf->constructor(q, arg);\n\tadd_frag_mem_limit(q, f->qsize);\n\n\tsetup_timer(&q->timer, f->frag_expire, (unsigned long)q);\n\tspin_lock_init(&q->lock);\n\tatomic_set(&q->refcnt, 1);\n\tINIT_LIST_HEAD(&q->lru_list);\n\n\treturn q;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void clear_work_data(struct work_struct *work)\n{\n\tsmp_wmb();\t/* see set_work_pool_and_clear_pending() */\n\tset_work_data(work, WORK_STRUCT_NO_POOL, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bool ResourceDispatcherHostImpl::AcceptAuthRequest(\n    ResourceLoader* loader,\n    net::AuthChallengeInfo* auth_info) {\n  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))\n    return false;\n\n  if (!auth_info->is_proxy) {\n    HttpAuthResourceType resource_type =\n        HttpAuthResourceTypeOf(loader->request());\n    UMA_HISTOGRAM_ENUMERATION(\"Net.HttpAuthResource\",\n                               resource_type,\n                               HTTP_AUTH_RESOURCE_LAST);\n \n    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)\n      return false;\n   }\n \n   return true;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "struct bio *bio_split(struct bio *bio, int sectors,\n\t\t      gfp_t gfp, struct bio_set *bs)\n{\n\tstruct bio *split = NULL;\n\n\tBUG_ON(sectors <= 0);\n\tBUG_ON(sectors >= bio_sectors(bio));\n\n\tsplit = bio_clone_fast(bio, gfp, bs);\n\tif (!split)\n\t\treturn NULL;\n\n\tsplit->bi_iter.bi_size = sectors << 9;\n\n\tif (bio_integrity(split))\n\t\tbio_integrity_trim(split);\n\n\tbio_advance(bio, split->bi_iter.bi_size);\n\n\tif (bio_flagged(bio, BIO_TRACE_COMPLETION))\n\t\tbio_set_flag(bio, BIO_TRACE_COMPLETION);\n\n\treturn split;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void OPPROTO op_fdivr_STN_ST0(void)\n\n{\n\n    CPU86_LDouble *p;\n\n    p = &ST(PARAM1);\n\n    *p = ST0 / *p;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void RECORD_LAYER_release(RECORD_LAYER *rl)\n{\n    if (SSL3_BUFFER_is_initialised(&rl->rbuf))\n        ssl3_release_read_buffer(rl->s);\n    if (rl->numwpipes > 0)\n        ssl3_release_write_buffer(rl->s);\n    SSL3_RECORD_release(rl->rrec, SSL_MAX_PIPELINES);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "GenericList *visit_next_list(Visitor *v, GenericList **list, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        return v->next_list(v, list, errp);\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline int decode_bytes(const uint8_t *inbuffer, uint8_t *out, int bytes)\n\n{\n\n    static const uint32_t tab[4] = {\n\n        AV_BE2NE32C(0x37c511f2), AV_BE2NE32C(0xf237c511),\n\n        AV_BE2NE32C(0x11f237c5), AV_BE2NE32C(0xc511f237),\n\n    };\n\n    int i, off;\n\n    uint32_t c;\n\n    const uint32_t *buf;\n\n    uint32_t *obuf = (uint32_t *) out;\n\n    /* FIXME: 64 bit platforms would be able to do 64 bits at a time.\n\n     * I'm too lazy though, should be something like\n\n     * for (i = 0; i < bitamount / 64; i++)\n\n     *     (int64_t) out[i] = 0x37c511f237c511f2 ^ av_be2ne64(int64_t) in[i]);\n\n     * Buffer alignment needs to be checked. */\n\n\n\n    off = (intptr_t) inbuffer & 3;\n\n    buf = (const uint32_t *) (inbuffer - off);\n\n    c = tab[off];\n\n    bytes += 3 + off;\n\n    for (i = 0; i < bytes / 4; i++)\n\n        obuf[i] = c ^ buf[i];\n\n\n\n    return off;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ServerItem::ServerItem(const QString &name, ItemType itype, const QString &continent, const QString &country) {\n\tsiParent = NULL;\n\tbParent = true;\n\tqsName = name;\n\titType = itype;\n\tif (itType == PublicType) {\n\t\tqsCountryCode = country;\n\t\tqsContinentCode = continent;\n\t}\n\tsetFlags(flags() & ~Qt::ItemIsDragEnabled);\n\tbCA = false;\n\n\tinit();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "MagickExport void *DetachBlob(BlobInfo *blob_info)\n{\n  void\n    *data;\n\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (blob_info->mapped != MagickFalse)\n    {\n      (void) UnmapBlob(blob_info->data,blob_info->length);\n      RelinquishMagickResource(MapResource,blob_info->length);\n    }\n  blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  blob_info->custom_stream=(CustomStreamInfo *) NULL;\n  return(data);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void NuPlayer::GenericSource::notifyBufferingUpdate(int percentage) {\n    sp<AMessage> msg = dupNotify();\n    msg->setInt32(\"what\", kWhatBufferingUpdate);\n    msg->setInt32(\"percentage\", percentage);\n    msg->post();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "uint64_t Image::byteSwap(uint64_t value,bool bSwap) const\n    {\n        uint64_t result = 0;\n        byte* source_value = reinterpret_cast<byte *>(&value);\n        byte* destination_value = reinterpret_cast<byte *>(&result);\n\n        for (int i = 0; i < 8; i++)\n            destination_value[i] = source_value[8 - i - 1];\n\n        return bSwap ? result : value;\n    }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "smpl_t aubio_tempo_get_delay_s(aubio_tempo_t * o) {\n  return o->delay / (smpl_t)(o->samplerate);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "gerbv_gdk_draw_amacro(GdkPixmap *pixmap, GdkGC *gc, \n\t\t      gerbv_simplified_amacro_t *s, double scale, \n\t\t      gint x, gint y)\n{\n\tdprintf(\"%s(): drawing simplified aperture macros:\\n\", __func__);\n\n\twhile (s != NULL) {\n\t\tif (s->type >= GERBV_APTYPE_MACRO_CIRCLE\n\t\t && s->type <= GERBV_APTYPE_MACRO_LINE22) {\n\t\t\tdgk_draw_amacro_funcs[s->type](pixmap, gc,\n\t\t\t\t\ts->parameter, scale, x, y);\n\t\t\tdprintf(\"  %s\\n\", gerbv_aperture_type_name(s->type));\n\t\t} else {\n\t\t\tGERB_FATAL_ERROR(\n\t\t\t\t_(\"Unknown simplified aperture macro type %d\"),\n\t\t\t\ts->type);\n\t\t}\n\n\t\ts = s->next;\n\t}\n} /* gerbv_gdk_draw_amacro */",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void virtio_gpu_ttm_bo_destroy(struct ttm_buffer_object *tbo)\n{\n\tstruct virtio_gpu_object *bo;\n\tstruct virtio_gpu_device *vgdev;\n\n\tbo = container_of(tbo, struct virtio_gpu_object, tbo);\n\tvgdev = (struct virtio_gpu_device *)bo->gem_base.dev->dev_private;\n\n\tif (bo->hw_res_handle)\n\t\tvirtio_gpu_cmd_unref_resource(vgdev, bo->hw_res_handle);\n\tif (bo->pages)\n\t\tvirtio_gpu_object_free_sg_table(bo);\n\tdrm_gem_object_release(&bo->gem_base);\n\tkfree(bo);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "RenderWidgetHostImpl::GetParentNativeViewAccessible() {\n  return delegate_ ? delegate_->GetParentNativeViewAccessible() : NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(&context->guest_rsvd_check,\n\t\t\t\tvcpu->arch.reserved_gpa_bits,\n\t\t\t\tcontext->root_level, is_efer_nx(context),\n\t\t\t\tguest_can_use_gbpages(vcpu),\n\t\t\t\tis_cr4_pse(context),\n\t\t\t\tguest_cpuid_is_amd_or_hygon(vcpu));\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "template<> struct type<cimg_int64> {",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void HttpStreamParser::GetSSLInfo(SSLInfo* ssl_info) {\n  if (request_->url.SchemeIs(\"https\") && connection_->socket()) {\n    SSLClientSocket* ssl_socket =\n        static_cast<SSLClientSocket*>(connection_->socket());\n    ssl_socket->GetSSLInfo(ssl_info);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static ssize_t wakeup_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", device_can_wakeup(dev)\n\t\t? (device_may_wakeup(dev) ? _enabled : _disabled)\n\t\t: \"\");\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype)\n{\n    if (v == NULL || v->vt != JSI_VT_OBJECT)\n        return 0;\n    if (otype != JSI_OT_ARRAY)\n        return (v->d.obj->ot == otype);\n    if (v->d.obj->ot != JSI_OT_OBJECT || !v->d.obj->isarrlist)\n        return 0;\n    return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline sector_t logical_to_blk(struct inode *inode, loff_t offset)\n{\n\treturn (offset >> inode->i_blkbits);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "smtp_port_for_connect(host_item * host, int port)\n{\nif (host->port != PORT_NONE)\n  {\n  HDEBUG(D_transport|D_acl|D_v)\n    debug_printf_indent(\"Transport port=%d replaced by host-specific port=%d\\n\", port,\n      host->port);\n  port = host->port;\n  }\nelse host->port = port;    /* Set the port actually used */\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "mrb_irep_remove_lv(mrb_state *mrb, mrb_irep *irep)\n{\n  int i;\n\n  if (irep->flags & MRB_IREP_NO_FREE) return;\n  if (irep->lv) {\n    mrb_free(mrb, (void*)irep->lv);\n    irep->lv = NULL;\n  }\n  if (!irep->reps) return;\n  for (i = 0; i < irep->rlen; ++i) {\n    mrb_irep_remove_lv(mrb, (mrb_irep*)irep->reps[i]);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n\n        if (rom->romsize > rom->datasize) {\n            /* If datasize is less than romsize, it means that we didn't\n             * allocate all the ROM because the trailing data are only zeros.\n             */\n\n            d += l;\n            l = rom->romsize - rom->datasize;\n\n            if ((d + l) > (dest + size)) {\n                /* Rom size doesn't fit in the destination area. Adjust to avoid\n                 * overflow.\n                 */\n                l = dest - d;\n            }\n\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n\n    return (d + l) - dest;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int ZEXPORT deflatePrime (strm, bits, value)\n    z_streamp strm;\n    int bits;\n    int value;\n{\n    deflate_state *s;\n    int put;\n\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))\n        return Z_BUF_ERROR;\n    do {\n        put = Buf_size - s->bi_valid;\n        if (put > bits)\n            put = bits;\n        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);\n        s->bi_valid += put;\n        _tr_flush_bits(s);\n        value >>= put;\n        bits -= put;\n    } while (bits);\n    return Z_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n \tstruct scsi_device *SDev;\n \tstruct scsi_sense_hdr sshdr;\n \tint result, err = 0, retries = 0;\n \n \tSDev = cd->device;\n \n       retry:\n \tif (!scsi_block_when_processing_errors(SDev)) {\n \t\terr = -ENODEV;\n \t\tgoto out;\n \t}\n \n \tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n\t\t\t      cgc->buffer, cgc->buflen,\n\t\t\t      (unsigned char *)cgc->sense, &sshdr,\n \t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n \n \t/* Minimal error checking.  Ignore cases we know about, and report the rest. */\n \tif (driver_byte(result) != 0) {\n \t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t/* This happens if there is no disc in drive */\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\t/* sense: Logical unit is in process of becoming ready */\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\t/* sleep 2 sec and try again */\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\t/* 20 secs are enough? */\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\t/* sense: Invalid command operation code */\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\n\t/* Wake up a process waiting for device */\n      out:\n\tcgc->stat = err;\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n {\n     const char *perm = \"add\";\n     return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline int __set_dabr(unsigned long dabr, unsigned long dabrx)\n{\n\tmtspr(SPRN_DAC1, dabr);\n#ifdef CONFIG_PPC_47x\n\tisync();\n#endif\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static bool IsOnlySiblingWithTagName(Element* element) {\n  DCHECK(element);\n  return (1U == NthIndexCache::NthOfTypeIndex(*element)) &&\n         (1U == NthIndexCache::NthLastOfTypeIndex(*element));\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n \t\thwc->event_base\t= 0;\n \t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n \t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n \t} else {\n \t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n \t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "struct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint32_t str_j = 0;\n    uint32_t index1;\n\n    plist_data_t data = plist_new_plist_data();\n\n    data->type = PLIST_ARRAY;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_j = j * bplist->ref_size;\n        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index1);\n        if (!val) {\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, val);\n    }\n\n    return node;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void term_init(void)\n\n{\n\n#if HAVE_TERMIOS_H\n\n    if(!run_as_daemon){\n\n    struct termios tty;\n\n\n\n    tcgetattr (0, &tty);\n\n    oldtty = tty;\n\n    atexit(term_exit);\n\n\n\n    tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP\n\n                          |INLCR|IGNCR|ICRNL|IXON);\n\n    tty.c_oflag |= OPOST;\n\n    tty.c_lflag &= ~(ECHO|ECHONL|ICANON|IEXTEN);\n\n    tty.c_cflag &= ~(CSIZE|PARENB);\n\n    tty.c_cflag |= CS8;\n\n    tty.c_cc[VMIN] = 1;\n\n    tty.c_cc[VTIME] = 0;\n\n\n\n    tcsetattr (0, TCSANOW, &tty);\n\n    signal(SIGQUIT, sigterm_handler); /* Quit (POSIX).  */\n\n    }\n\n#endif\n\n    avformat_network_deinit();\n\n\n\n    signal(SIGINT , sigterm_handler); /* Interrupt (ANSI).    */\n\n    signal(SIGTERM, sigterm_handler); /* Termination (ANSI).  */\n\n#ifdef SIGXCPU\n\n    signal(SIGXCPU, sigterm_handler);\n\n#endif\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset) {\n\tbloc = *offset;\n\twhile (node && node->symbol == INTERNAL_NODE) {\n\t\tif (get_bit(fin)) {\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tnode = node->left;\n\t\t}\n\t}\n\tif (!node) {\n\t\t*ch = 0;\n\t\treturn;\n//\t\tCom_Error(ERR_DROP, \"Illegal tree!\");\n\t}\n\t*ch = node->symbol;\n\t*offset = bloc;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "datetime_s_rfc3339(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg;\n\n    rb_scan_args(argc, argv, \"02\", &str, &sg);\n\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"-4712-01-01T00:00:00+00:00\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n\n    {\n\tVALUE hash = date_s__rfc3339(klass, str);\n\treturn dt_new_by_frags(klass, hash, sg);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "target_count_increase(struct iter_qstate* iq, int num)\n{\n\ttarget_count_create(iq);\n\tif(iq->target_count)\n\t\tiq->target_count[1] += num;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline void skb_frag_list_init(struct sk_buff *skb)\n{\n\tskb_shinfo(skb)->frag_list = NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline bool cpu_has_vmx_eptp_uncacheable(void)\n{\n\treturn vmx_capability.ept & VMX_EPTP_UC_BIT;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void add_send_options(GDHCPClient *dhcp_client,\n\t\t\t\tstruct dhcp_packet *packet)\n{\n\tg_hash_table_foreach(dhcp_client->send_value_hash,\n\t\t\t\tadd_binary_option, packet);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "//! Return a reference to the maximum pixel value \\const.\n    const T& max() const {\n      if (is_empty())\n        throw CImgInstanceException(_cimg_instance\n                                    \"max(): Empty instance.\",\n                                    cimg_instance);\n      const T *ptr_max = _data;\n      T max_value = *ptr_max;\n      cimg_for(*this,ptrs,T) if (*ptrs>max_value) max_value = *(ptr_max=ptrs);\n      return *ptr_max;",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static QemuOpts *opts_parse(QemuOptsList *list, const char *params,\n                            int permit_abbrev, bool defaults)\n{\n    const char *firstname;\n    char value[1024], *id = NULL;\n    const char *p;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    assert(!permit_abbrev || list->implied_opt_name);\n    firstname = permit_abbrev ? list->implied_opt_name : NULL;\n    if (strncmp(params, \"id=\", 3) == 0) {\n        get_opt_value(value, sizeof(value), params+3);\n        id = value;\n    } else if ((p = strstr(params, \",id=\")) != NULL) {\n        get_opt_value(value, sizeof(value), p+4);\n        id = value;\n    }\n    opts = qemu_opts_create(list, id, !defaults, &local_err);\n    if (opts == NULL) {\n        if (error_is_set(&local_err)) {\n            qerror_report_err(local_err);\n            error_free(local_err);\n        }\n        return NULL;\n    }\n    if (opts_do_parse(opts, params, firstname, defaults) != 0) {\n        qemu_opts_del(opts);\n        return NULL;\n    }\n    return opts;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "bgp_nlri_parse_vpnv4 (struct peer *peer, struct attr *attr, \n\t\t      struct bgp_nlri *packet)\n{\n  u_char *pnt;\n  u_char *lim;\n  struct prefix p;\n  int psize;\n  int prefixlen;\n  u_int16_t type;\n  struct rd_as rd_as;\n  struct rd_ip rd_ip;\n  struct prefix_rd prd;\n  u_char *tagpnt;\n\n  /* Check peer status. */\n  if (peer->status != Established)\n    return 0;\n  \n  /* Make prefix_rd */\n  prd.family = AF_UNSPEC;\n  prd.prefixlen = 64;\n\n   pnt = packet->nlri;\n   lim = pnt + packet->length;\n \n   for (; pnt < lim; pnt += psize)\n     {\n       /* Clear prefix structure. */\n\n \n       /* Fetch prefix length. */\n       prefixlen = *pnt++;\n      p.family = AF_INET;\n       psize = PSIZE (prefixlen);\n      if (prefixlen < 88)\n\t{\n\t  zlog_err (\"prefix length is less than 88: %d\", prefixlen);\n\t  return -1;\n\t}\n       /* Copyr label to prefix. */\n      tagpnt = pnt;;\n \n       /* Copy routing distinguisher to rd. */\n       memcpy (&prd.val, pnt + 3, 8);\n      else if (type == RD_TYPE_IP)\n\tzlog_info (\"prefix %ld:%s:%ld:%s/%d\", label, inet_ntoa (rd_ip.ip),\n\t\t   rd_ip.val, inet_ntoa (p.u.prefix4), p.prefixlen);\n#endif /* 0 */\n\n      if (pnt + psize > lim)\n\treturn -1;\n\n      if (attr)\n\tbgp_update (peer, &p, attr, AFI_IP, SAFI_MPLS_VPN,\n\t\t    ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd, tagpnt, 0);\n      else\n \t  return -1;\n \t}\n \n      p.prefixlen = prefixlen - 88;\n      memcpy (&p.u.prefix, pnt + 11, psize - 11);\n \n #if 0\n       if (type == RD_TYPE_AS)\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void remove_entry(HashEntry* entry)\n{\n    HashEntry* prev = entry->prev;\n    HashEntry* next = entry->next;\n\n    if (prev != NULL) entry->prev->next = next;\n    if (next != NULL) entry->next->prev = prev;\n\n    if (prev == NULL) {\n        // we are the head of the list. set the head to be next\n        gHashTable.slots[entry->slot] = entry->next;\n    }\n\n    // we just removed and entry, decrease the size of the hashtable\n    gHashTable.count--;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "lt_dlhandle_fetch (lt_dlinterface_id iface, const char *module_name)\n{\n  lt_dlhandle handle = 0;\n\n  assert (iface); /* iface is a required argument */\n\n  while ((handle = lt_dlhandle_iterate (iface, handle)))\n    {\n      lt_dlhandle cur = handle;\n      if (cur && cur->info.name && streq (cur->info.name, module_name))\n\tbreak;\n    }\n\n  return handle;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_alg *alg;\n\tstruct shash_alg *salg;\n\tint err;\n\tint ds;\n\tint ss;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\n\tif (err)\n\t\treturn err;\n\n \tsalg = shash_attr_alg(tb[1], 0, 0);\n \tif (IS_ERR(salg))\n \t\treturn PTR_ERR(salg);\n \n \terr = -EINVAL;\n \tds = salg->digestsize;\n \tss = salg->statesize;\n\talg = &salg->base;\n \tif (ds > alg->cra_blocksize ||\n \t    ss < alg->cra_blocksize)\n \t\tgoto out_put_alg;\n\n\tinst = shash_alloc_instance(\"hmac\", alg);\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\n\terr = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,\n\t\t\t\t      shash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = alg->cra_blocksize;\n\tinst->alg.base.cra_alignmask = alg->cra_alignmask;\n\n\tss = ALIGN(ss, alg->cra_alignmask + 1);\n\tinst->alg.digestsize = ds;\n\tinst->alg.statesize = ss;\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +\n\t\t\t\t     ALIGN(ss * 2, crypto_tfm_ctx_alignment());\n\n\tinst->alg.base.cra_init = hmac_init_tfm;\n\tinst->alg.base.cra_exit = hmac_exit_tfm;\n\n\tinst->alg.init = hmac_init;\n\tinst->alg.update = hmac_update;\n\tinst->alg.final = hmac_final;\n\tinst->alg.finup = hmac_finup;\n\tinst->alg.export = hmac_export;\n\tinst->alg.import = hmac_import;\n\tinst->alg.setkey = hmac_setkey;\n\n\terr = shash_register_instance(tmpl, inst);\n\tif (err) {\nout_free_inst:\n\t\tshash_free_instance(shash_crypto_instance(inst));\n\t}\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "SCTP_STATIC void sctp_destroy_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp;\n\n\tSCTP_DEBUG_PRINTK(\"sctp_destroy_sock(sk: %p)\\n\", sk);\n\n\t/* Release our hold on the endpoint. */\n\tsp = sctp_sk(sk);\n\tif (sp->do_auto_asconf) {\n\t\tsp->do_auto_asconf = 0;\n\t\tlist_del(&sp->auto_asconf_list);\n\t}\n\tsctp_endpoint_free(sp->ep);\n\tlocal_bh_disable();\n\tpercpu_counter_dec(&sctp_sockets_allocated);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,\n        const u_char **pktdata, const char *funcname,\n        const int line, const char *file)\n{\n    int res = pcap_next_ex(pcap, pkthdr, pktdata);\n\n    if (*pktdata && *pkthdr) {\n        if ((*pkthdr)->len > MAXPACKET) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\\n\",\n                    file, funcname, line, (*pkthdr)->len, MAXPACKET);\n            exit(-1);\n        }\n\n        if ((*pkthdr)->len < (*pkthdr)->caplen) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\\n\",\n                    file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);\n            exit(-1);\n        }\n    }\n\n    return res;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "smtp_proceed_wiz(struct smtp_session *s, const char *args)\n{\n\tsmtp_reply(s, \"500 %s %s: this feature is not supported yet ;-)\",\n\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t    esc_description(ESC_INVALID_COMMAND));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "MONGO_EXPORT const char* mongo_get_host(mongo* conn, int i) {\n    mongo_replica_set* r = conn->replica_set;\n    mongo_host_port* hp;\n    int count = 0;\n    if (!r) return 0;\n    for (hp = r->hosts; hp; hp = hp->next) {\n        if (count == i)\n            return _get_host_port(hp);\n        ++count;\n    }\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int mb_var_thread(AVCodecContext *c, void *arg){\n\n    MpegEncContext *s= *(void**)arg;\n\n    int mb_x, mb_y;\n\n\n\n    for(mb_y=s->start_mb_y; mb_y < s->end_mb_y; mb_y++) {\n\n        for(mb_x=0; mb_x < s->mb_width; mb_x++) {\n\n            int xx = mb_x * 16;\n\n            int yy = mb_y * 16;\n\n            uint8_t *pix = s->new_picture.f.data[0] + (yy * s->linesize) + xx;\n\n            int varc;\n\n            int sum = s->dsp.pix_sum(pix, s->linesize);\n\n\n\n            varc = (s->dsp.pix_norm1(pix, s->linesize) - (((unsigned)sum*sum)>>8) + 500 + 128)>>8;\n\n\n\n            s->current_picture.mb_var [s->mb_stride * mb_y + mb_x] = varc;\n\n            s->current_picture.mb_mean[s->mb_stride * mb_y + mb_x] = (sum+128)>>8;\n\n            s->me.mb_var_sum_temp    += varc;\n\n        }\n\n    }\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "bool OnCurtainPolicyUpdate(bool curtain_required) {\n    DCHECK(context_->network_task_runner()->BelongsToCurrentThread());\n\n#if defined(OS_MACOSX)\n    if (curtain_required) {\n      if (getuid() == 0) {\n        Shutdown(kLoginScreenNotSupportedExitCode);\n        return false;\n      }\n    }\n#endif\n    if (curtain_->required() != curtain_required) {\n      LOG(INFO) << \"Updated curtain policy.\";\n      curtain_->set_required(curtain_required);\n      return true;\n    }\n    return false;\n  }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "  void PostMessage(v8::Isolate* isolate,\n                   gin_helper::ErrorThrower thrower,\n                   const std::string& channel,\n                   v8::Local<v8::Value> message_value,\n                   absl::optional<v8::Local<v8::Value>> transfer) {\n    if (!electron_browser_remote_) {\n      thrower.ThrowError(kIPCMethodCalledAfterContextReleasedError);\n      return;\n    }\n    blink::TransferableMessage transferable_message;\n    if (!electron::SerializeV8Value(isolate, message_value,\n                                    &transferable_message)) {\n      // SerializeV8Value sets an exception.\n      return;\n    }\n\n    std::vector<v8::Local<v8::Object>> transferables;\n    if (transfer && !transfer.value()->IsUndefined()) {\n      if (!gin::ConvertFromV8(isolate, *transfer, &transferables)) {\n        thrower.ThrowTypeError(\"Invalid value for transfer\");\n        return;\n      }\n    }\n\n    std::vector<blink::MessagePortChannel> ports;\n    for (auto& transferable : transferables) {\n      absl::optional<blink::MessagePortChannel> port =\n          blink::WebMessagePortConverter::\n              DisentangleAndExtractMessagePortChannel(isolate, transferable);\n      if (!port.has_value()) {\n        thrower.ThrowTypeError(\"Invalid value for transfer\");\n        return;\n      }\n      ports.emplace_back(port.value());\n    }\n\n    transferable_message.ports = std::move(ports);\n    electron_browser_remote_->ReceivePostMessage(\n        channel, std::move(transferable_message));\n  }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "inline void Context::trace_leave(const char *name, const char *a_s, size_t n,\n                                 SemanticValues &sv, any &dt,\n                                 size_t len) const {\n  tracer_leave(name, a_s, n, sv, *this, dt, len);\n  trace_ids.pop_back();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "CharSet conv_get_charset_from_str(const gchar *charset)\n{\n\tGHashTable *table;\n\n\tif (!charset) return C_AUTO;\n\n\ttable = conv_get_charset_from_str_table();\n\treturn GPOINTER_TO_UINT(g_hash_table_lookup(table, charset));\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void gdImageHLine(gdImagePtr im, int y, int x1, int x2, int col)\n{\n\tif (im->thick > 1) {\n\t\tint thickhalf = im->thick >> 1;\n\t\t_gdImageFilledHRectangle(im, x1, y - thickhalf, x2, y + im->thick - thickhalf - 1, col);\n\t} else {\n\t\tif (x2 < x1) {\n\t\t\tint t = x2;\n\t\t\tx2 = x1;\n\t\t\tx1 = t;\n\t\t}\n\n\t\tfor (;x1 <= x2; x1++) {\n\t\t\tgdImageSetPixel(im, x1, y, col);\n\t\t}\n\t}\n\treturn;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline int ieee802154_match_sock(u8 *hw_addr, u16 pan_id,\n\t\tu16 short_addr, struct dgram_sock *ro)\n{\n\tif (!ro->bound)\n\t\treturn 1;\n\n\tif (ro->src_addr.addr_type == IEEE802154_ADDR_LONG &&\n\t    !memcmp(ro->src_addr.hwaddr, hw_addr, IEEE802154_ADDR_LEN))\n\t\treturn 1;\n\n\tif (ro->src_addr.addr_type == IEEE802154_ADDR_SHORT &&\n\t\t     pan_id == ro->src_addr.pan_id &&\n\t\t     short_addr == ro->src_addr.short_addr)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void mm_rearm_timer(struct qemu_alarm_timer *t, int64_t delta)\n\n{\n\n    int nearest_delta_ms = (delta + 999999) / 1000000;\n\n    if (nearest_delta_ms < 1) {\n\n        nearest_delta_ms = 1;\n\n    }\n\n\n\n    timeKillEvent(mm_timer);\n\n    mm_timer = timeSetEvent(nearest_delta_ms,\n\n                            mm_period,\n\n                            mm_alarm_handler,\n\n                            (DWORD_PTR)t,\n\n                            TIME_ONESHOT | TIME_CALLBACK_FUNCTION);\n\n\n\n    if (!mm_timer) {\n\n        fprintf(stderr, \"Failed to re-arm win32 alarm timer %ld\\n\",\n\n                GetLastError());\n\n\n\n        timeEndPeriod(mm_period);\n\n        exit(1);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline void addrconf_sysctl_register(struct inet6_dev *idev)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "char *mksnpath(char *buf, size_t n, const char *fmt, ...)\n{\n\tva_list args;\n\tunsigned len;\n\n\tva_start(args, fmt);\n\tlen = vsnprintf(buf, n, fmt, args);\n\tva_end(args);\n\tif (len >= n) {\n\t\tstrlcpy(buf, bad_path, n);\n\t\treturn buf;\n\t}\n\treturn (char *)cleanup_path(buf);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void xmlGROW (xmlParserCtxtPtr ctxt) {\n    unsigned long curEnd = ctxt->input->end - ctxt->input->cur;\n    unsigned long curBase = ctxt->input->cur - ctxt->input->base;\n\n    if (((curEnd > (unsigned long) XML_MAX_LOOKUP_LIMIT) ||\n         (curBase > (unsigned long) XML_MAX_LOOKUP_LIMIT)) &&\n         ((ctxt->input->buf) && (ctxt->input->buf->readcallback != (xmlInputReadCallback) xmlNop)) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"Huge input lookup\");\n        ctxt->instate = XML_PARSER_EOF;\n    }\n    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n    if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0) &&\n        (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))\n\t    xmlPopInput(ctxt);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void virtio_blk_free_request(VirtIOBlockReq *req)\n\n{\n\n    if (req) {\n\n        g_slice_free(VirtQueueElement, req->elem);\n\n        g_slice_free(VirtIOBlockReq, req);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "std::string get_save_index_file()\n{\n\treturn get_user_data_dir() + \"/save_index.gz\";\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "bool ContainerNode::checkParserAcceptChild(const Node& newChild) const\n{\n    if (!isDocumentNode())\n        return true;\n    return toDocument(*this).canAcceptChild(newChild, nullptr, IGNORE_EXCEPTION);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void __generic_push(RAnalOp *op, int sz) {\n\tESIL_A (\"sp,_ram,+,\");\t\t\t// calc pointer SRAM(sp)\n\tif (sz > 1) {\n\t\tESIL_A (\"-%d,+,\", sz - 1);\t// dec SP by 'sz'\n\t}\n\tESIL_A (\"=[%d],\", sz);\t\t\t// store value in stack\n\tESIL_A (\"-%d,sp,+=,\", sz);\t\t// decrement stack pointer\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void png_write_data(png_structp png_ptr, png_bytep data,\n                           png_size_t length)\n{\n    VncState *vs = png_get_io_ptr(png_ptr);\n\n    buffer_reserve(&vs->tight.png, vs->tight.png.offset + length);\n    memcpy(vs->tight.png.buffer + vs->tight.png.offset, data, length);\n\n    vs->tight.png.offset += length;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "//! Access to pixel value with Dirichlet boundary conditions for the 2 coordinates (\\c pos,\\c x) \\const.\n    T atNX(const int pos, const int x, const int y, const int z, const int c, const T& out_value) const {\n      return (pos<0 || pos>=(int)_width)?out_value:_data[pos].atX(x,y,z,c,out_value);",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "start_stuff(void)\n{\n    if (readbuf1.bh_first.b_next != NULL)\n    {\n\treadbuf1.bh_curr = &(readbuf1.bh_first);\n\treadbuf1.bh_space = 0;\n    }\n    if (readbuf2.bh_first.b_next != NULL)\n    {\n\treadbuf2.bh_curr = &(readbuf2.bh_first);\n\treadbuf2.bh_space = 0;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static gboolean gd_key_event(GtkWidget *widget, GdkEventKey *key, void *opaque)\n{\n    VirtualConsole *vc = opaque;\n    GtkDisplayState *s = vc->s;\n    int gdk_keycode = key->hardware_keycode;\n    int qemu_keycode;\n    int i;\n    if (key->keyval == GDK_KEY_Pause) {\n        qemu_input_event_send_key_qcode(vc->gfx.dcl.con, Q_KEY_CODE_PAUSE,\n                                        key->type == GDK_KEY_PRESS);\n    qemu_keycode = gd_map_keycode(s, gtk_widget_get_display(widget),\n                                  gdk_keycode);\n    trace_gd_key_event(vc->label, gdk_keycode, qemu_keycode,\n                       (key->type == GDK_KEY_PRESS) ? \"down\" : \"up\");\n    for (i = 0; i < ARRAY_SIZE(modifier_keycode); i++) {\n        if (qemu_keycode == modifier_keycode[i]) {\n            s->modifier_pressed[i] = (key->type == GDK_KEY_PRESS);\n    qemu_input_event_send_key_number(vc->gfx.dcl.con, qemu_keycode,\n                                     key->type == GDK_KEY_PRESS);",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "xfs_attr_args_init(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tmemset(args, 0, sizeof(*args));\n\targs->geo = dp->i_mount->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->dp = dp;\n\targs->flags = flags;\n\targs->name = name;\n\targs->namelen = strlen((const char *)name);\n\tif (args->namelen >= MAXNAMELEN)\n\t\treturn -EFAULT;\t\t/* match IRIX behaviour */\n\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void coroutine_fn verify_entered_step_2(void *opaque)\n\n{\n\n    Coroutine *caller = (Coroutine *)opaque;\n\n\n\n    g_assert(qemu_coroutine_entered(caller));\n\n    g_assert(qemu_coroutine_entered(qemu_coroutine_self()));\n\n    qemu_coroutine_yield();\n\n\n\n    /* Once more to check it still works after yielding */\n\n    g_assert(qemu_coroutine_entered(caller));\n\n    g_assert(qemu_coroutine_entered(qemu_coroutine_self()));\n\n    qemu_coroutine_yield();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "template<typename t>\n    void eval(CImg<t> &output, const char *const expression,\n              const double x=0, const double y=0, const double z=0, const double c=0,\n              const CImgList<T> *const list_inputs=0, CImgList<T> *const list_outputs=0) {\n      _eval(output,this,expression,x,y,z,c,list_inputs,list_outputs);",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "std::string indent() { return generator_->indent(); }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "struct domain_device *sas_ex_to_ata(struct domain_device *ex_dev, int phy_id)\n{\n\tstruct ex_phy *ex_phy = &ex_dev->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *dev;\n\tstruct sas_rphy *rphy;\n\n\tif (!ex_phy->port)\n\t\treturn NULL;\n\n\trphy = ex_phy->port->rphy;\n\tif (!rphy)\n\t\treturn NULL;\n\n\tdev = sas_find_dev_by_rphy(rphy);\n\n\tif (dev && dev_is_sata(dev))\n\t\treturn dev;\n\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static abi_long do_sendto(int fd, abi_ulong msg, size_t len, int flags,\n\n                          abi_ulong target_addr, socklen_t addrlen)\n\n{\n\n    void *addr;\n\n    void *host_msg;\n\n    abi_long ret;\n\n\n\n    if ((int)addrlen < 0) {\n\n        return -TARGET_EINVAL;\n\n    }\n\n\n\n    host_msg = lock_user(VERIFY_READ, msg, len, 1);\n\n    if (!host_msg)\n\n        return -TARGET_EFAULT;\n\n    if (fd_trans_target_to_host_data(fd)) {\n\n        ret = fd_trans_target_to_host_data(fd)(host_msg, len);\n\n        if (ret < 0) {\n\n            unlock_user(host_msg, msg, 0);\n\n            return ret;\n\n        }\n\n    }\n\n    if (target_addr) {\n\n        addr = alloca(addrlen+1);\n\n        ret = target_to_host_sockaddr(fd, addr, target_addr, addrlen);\n\n        if (ret) {\n\n            unlock_user(host_msg, msg, 0);\n\n            return ret;\n\n        }\n\n        ret = get_errno(safe_sendto(fd, host_msg, len, flags, addr, addrlen));\n\n    } else {\n\n        ret = get_errno(safe_sendto(fd, host_msg, len, flags, NULL, 0));\n\n    }\n\n    unlock_user(host_msg, msg, 0);\n\n    return ret;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static struct slave *bond_xmit_activebackup_slave_get(struct bonding *bond,\n\t\t\t\t\t\t      struct sk_buff *skb)\n{\n\treturn rcu_dereference(bond->curr_active_slave);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline void eventpoll_init_file(struct file *file)\n{\n\tINIT_LIST_HEAD(&file->f_ep_links);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "SYNTH_FILTER_FUNC(sse2)\n\nSYNTH_FILTER_FUNC(avx)\n\n\n\n\nav_cold void ff_synth_filter_init_x86(SynthFilterContext *s)\n\n{\n\n#if HAVE_YASM\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if ARCH_X86_32\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        s->synth_filter_float = synth_filter_sse;\n\n    }\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        s->synth_filter_float = synth_filter_sse2;\n\n    }\n\n    if (EXTERNAL_AVX(cpu_flags)) {\n\n        s->synth_filter_float = synth_filter_avx;\n\n    }\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\n\tcharsetDetector = ucsdet_open(&errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "Ins_SRP2( INS_ARG )\n  {\n    DO_SRP2\n  }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void RenderWidgetHostImpl::DidOverscroll(\n    const ui::DidOverscrollParams& params) {\n  if (view_)\n    view_->DidOverscroll(params);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void reload_tss(void)\n{\n\t/*\n\t * VT restores TR but not its size.  Useless.\n\t */\n\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\tstruct desc_struct *descs;\n\n\tdescs = (void *)gdt->address;\n\tdescs[GDT_ENTRY_TSS].type = 9; /* available TSS */\n\tload_TR_desc();\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "const char *ssh_scp_request_get_filename(ssh_scp scp)\n{\n    if (scp == NULL) {\n        return NULL;\n    }\n\n    return scp->request_name;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static MockFetchContext* create()\n    {\n        return new MockFetchContext;\n    }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;\n\t\tattr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->size = offset;\n\t}\n\t// IFDBG r_bin_java_print_constant_value_attr_summary(attr);\n\treturn attr;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int send_rect_simple(VncState *vs, int x, int y, int w, int h,\n                            bool split)\n{\n    int max_size, max_width;\n    int max_sub_width, max_sub_height;\n    int dx, dy;\n    int rw, rh;\n    int n = 0;\n\n    max_size = tight_conf[vs->tight.compression].max_rect_size;\n    max_width = tight_conf[vs->tight.compression].max_rect_width;\n\n    if (split && (w > max_width || w * h > max_size)) {\n        max_sub_width = (w > max_width) ? max_width : w;\n        max_sub_height = max_size / max_sub_width;\n\n        for (dy = 0; dy < h; dy += max_sub_height) {\n            for (dx = 0; dx < w; dx += max_width) {\n                rw = MIN(max_sub_width, w - dx);\n                rh = MIN(max_sub_height, h - dy);\n                n += send_sub_rect(vs, x+dx, y+dy, rw, rh);\n            }\n        }\n    } else {\n        n += send_sub_rect(vs, x, y, w, h);\n    }\n\n    return n;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int avpriv_unlock_avformat(void)\n\n{\n\n    if (lockmgr_cb) {\n\n        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_RELEASE))\n\n            return -1;\n\n    }\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void scsi_remove_request(SCSIDiskReq *r)\n\n{\n\n    qemu_free(r->iov.iov_base);\n\n    scsi_req_free(&r->req);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void vnc_client_error(VncState *vs)\n\n{\n\n    vnc_client_io_error(vs, -1, EINVAL);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "RootWindow::~RootWindow() {\n  if (compositor_lock_) {\n    draw_on_compositor_unlock_ = false;\n    compositor_lock_->CancelLock();\n    DCHECK(!compositor_lock_);\n  }\n  compositor_->RemoveObserver(this);\n  compositor_.reset();\n\n  host_.reset(NULL);\n\n  layer()->GetAnimator()->RemoveObserver(this);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void imap_allow_reopen(struct Context *ctx)\n{\n  struct ImapData *idata = NULL;\n  if (!ctx || !ctx->data || ctx->magic != MUTT_IMAP)\n    return;\n\n  idata = ctx->data;\n  if (idata->ctx == ctx)\n    idata->reopen |= IMAP_REOPEN_ALLOW;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static jas_iccattrtab_t *jas_iccattrtab_create()\n{\n\tjas_iccattrtab_t *tab;\n\ttab = 0;\n\tif (!(tab = jas_malloc(sizeof(jas_iccattrtab_t))))\n\t\tgoto error;\n\ttab->maxattrs = 0;\n\ttab->numattrs = 0;\n\ttab->attrs = 0;\n\tif (jas_iccattrtab_resize(tab, 32))\n\t\tgoto error;\n\treturn tab;\nerror:\n\tif (tab)\n\t\tjas_iccattrtab_destroy(tab);\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void DownloadItemImpl::MarkAsComplete() {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  DCHECK(AllDataSaved());\n  destination_info_.end_time = base::Time::Now();\n  TransitionTo(COMPLETE_INTERNAL);\n  UpdateObservers();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void send_ext_key_event_ack(VncState *vs)\n\n{\n\n    vnc_lock_output(vs);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n\n    vnc_write_u8(vs, 0);\n\n    vnc_write_u16(vs, 1);\n\n    vnc_framebuffer_update(vs, 0, 0,\n\n                           surface_width(vs->vd->ds),\n\n                           surface_height(vs->vd->ds),\n\n                           VNC_ENCODING_EXT_KEY_EVENT);\n\n    vnc_unlock_output(vs);\n\n    vnc_flush(vs);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int diff_check(const char *diff_name)\n{\n  FILE *res_file;\n  char buf[128];\n  int have_diff= 0;\n\n  my_snprintf(buf, sizeof(buf), \"%s -v\", diff_name);\n\n  if (!(res_file= popen(buf, \"r\")))\n    die(\"popen(\\\"%s\\\", \\\"r\\\") failed\", buf);\n\n  /*\n    if diff is not present, nothing will be in stdout to increment\n    have_diff\n  */\n  if (fgets(buf, sizeof(buf), res_file))\n    have_diff= 1;\n\n  pclose(res_file);\n\n  return have_diff;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "managesieve_parser_read_string(struct managesieve_parser *parser,\n\t\t\t\t   const unsigned char *data, size_t data_size)\n{\n\tsize_t i;\n\n\t/* QUOTED-CHAR        = SAFE-UTF8-CHAR / \"\\\" QUOTED-SPECIALS\n\t * quoted             = <\"> *QUOTED-CHAR <\">\n\t *                    ;; limited to 1024 octets between the <\">s\n\t */\n\n\t/* read until we've found non-escaped \", CR or LF */\n\tfor (i = parser->cur_pos; i < data_size; i++) {\n\t\tif (data[i] == '\"') {\n\n\t\t\tif ( !uni_utf8_data_is_valid(data+1, i-1) ) {\n\t\t\t\tparser->error = \"Invalid UTF-8 character in quoted-string.\";\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tmanagesieve_parser_save_arg(parser, data, i);\n\t\t\ti++; /* skip the trailing '\"' too */\n\t\t\tbreak;\n\t\t}\n\n\t\tif (data[i] == '\\\\') {\n\t\t\tif (i+1 == data_size) {\n\t\t\t\t/* known data ends with '\\' - leave it to\n\t\t\t\t   next time as well if it happens to be \\\" */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* save the first escaped char */\n\t\t\tif (parser->str_first_escape < 0)\n\t\t\t\tparser->str_first_escape = i;\n\n\t\t\t/* skip the escaped char */\n\t\t\ti++;\n\n\t\t\tif ( !IS_QUOTED_SPECIAL(data[i]) ) {\n\t\t\t\tparser->error =\n\t\t\t\t\t\"Escaped quoted-string character is not a QUOTED-SPECIAL.\";\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( (data[i] & 0x80) == 0 && !IS_SAFE_CHAR(data[i]) ) {\n\t\t\tparser->error = \"String contains invalid character.\";\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tparser->cur_pos = i;\n\treturn ( parser->cur_type == ARG_PARSE_NONE );\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "dns_zone_setxfrsource4dscp(dns_zone_t *zone, isc_dscp_t dscp) {\n\tREQUIRE(DNS_ZONE_VALID(zone));\n\n\tLOCK_ZONE(zone);\n\tzone->xfrsource4dscp = dscp;\n\tUNLOCK_ZONE(zone);\n\n\treturn (ISC_R_SUCCESS);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "uint32_t pci_default_read_config(PCIDevice *d, \n\n                                 uint32_t address, int len)\n\n{\n\n    uint32_t val;\n\n    switch(len) {\n\n    case 1:\n\n        val = d->config[address];\n\n        break;\n\n    case 2:\n\n        val = le16_to_cpu(*(uint16_t *)(d->config + address));\n\n        break;\n\n    default:\n\n    case 4:\n\n        val = le32_to_cpu(*(uint32_t *)(d->config + address));\n\n        break;\n\n    }\n\n    return val;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "wl_map_insert_new(struct wl_map *map, uint32_t flags, void *data)\n{\n\tunion map_entry *start, *entry;\n\tstruct wl_array *entries;\n\tuint32_t base;\n\n\tif (map->side == WL_MAP_CLIENT_SIDE) {\n\t\tentries = &map->client_entries;\n\t\tbase = 0;\n\t} else {\n\t\tentries = &map->server_entries;\n\t\tbase = WL_SERVER_ID_START;\n\t}\n\n\tif (map->free_list) {\n\t\tstart = entries->data;\n\t\tentry = &start[map->free_list >> 1];\n\t\tmap->free_list = entry->next;\n\t} else {\n\t\tentry = wl_array_add(entries, sizeof *entry);\n\t\tif (!entry)\n\t\t\treturn 0;\n\t\tstart = entries->data;\n\t}\n\n\tentry->data = data;\n\tentry->next |= (flags & 0x1) << 1;\n\n\treturn (entry - start) + base;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void ath_send_bar(struct ath_atx_tid *tid, u16 seqno)\n{\n\tif (!tid->an->sta)\n\t\treturn;\n\n\tieee80211_send_bar(tid->an->vif, tid->an->sta->addr, tid->tidno,\n\t\t\t   seqno << IEEE80211_SEQ_SEQ_SHIFT);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void gprinter_free(struct usb_function *f)\n{\n\tstruct printer_dev *dev = func_to_printer(f);\n\tstruct f_printer_opts *opts;\n\n\topts = container_of(f->fi, struct f_printer_opts, func_inst);\n\tkfree(dev);\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "kick_jobs(tube t, unsigned int n)\n{\n    if (buried_job_p(t)) return kick_buried_jobs(t, n);\n    return kick_delayed_jobs(t, n);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void ff_thread_await_progress(ThreadFrame *f, int progress, int field)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline bool netdev_adjacent_is_neigh_list(struct net_device *dev,\n\t\t\t\t\t\t struct net_device *adj_dev,\n\t\t\t\t\t\t struct list_head *dev_list)\n{\n\treturn (dev_list == &dev->adj_list.upper ||\n\t\tdev_list == &dev->adj_list.lower) &&\n\t\tnet_eq(dev_net(dev), dev_net(adj_dev));",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline void remove_entity_load_avg(struct sched_entity *se) {}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "constexpr uint32_t OlympusMnHeader::sizeOfSignature()\n    {\n        return sizeof(signature_);\n    }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int xbzrle_decode_buffer(uint8_t *src, int slen, uint8_t *dst, int dlen)\n\n{\n\n    int i = 0, d = 0;\n\n    int ret;\n\n    uint32_t count = 0;\n\n\n\n    while (i < slen) {\n\n\n\n        /* zrun */\n\n        if ((slen - i) < 2) {\n\n            return -1;\n\n        }\n\n\n\n        ret = uleb128_decode_small(src + i, &count);\n\n        if (ret < 0 || (i && !count)) {\n\n            return -1;\n\n        }\n\n        i += ret;\n\n        d += count;\n\n\n\n        /* overflow */\n\n        if (d > dlen) {\n\n            return -1;\n\n        }\n\n\n\n        /* nzrun */\n\n        if ((slen - i) < 2) {\n\n            return -1;\n\n        }\n\n\n\n        ret = uleb128_decode_small(src + i, &count);\n\n        if (ret < 0 || !count) {\n\n            return -1;\n\n        }\n\n        i += ret;\n\n\n\n        /* overflow */\n\n        if (d + count > dlen || i + count > slen) {\n\n            return -1;\n\n        }\n\n\n\n        memcpy(dst + d, src + i, count);\n\n        d += count;\n\n        i += count;\n\n    }\n\n\n\n    return d;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "com_print(String *buffer,char *line __attribute__((unused)))\n{\n  tee_puts(\"--------------\", stdout);\n  (void) tee_fputs(buffer->c_ptr(), stdout);\n  if (!buffer->length() || (*buffer)[buffer->length()-1] != '\\n')\n    tee_putc('\\n', stdout);\n  tee_puts(\"--------------\\n\", stdout);\n  return 0;\t\t\t\t\t/* If empty buffer */\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "compute_O_rc4_key(std::string const& user_password,\n\t\t  std::string const& owner_password,\n\t\t  QPDF::EncryptionData const& data,\n\t\t  unsigned char key[OU_key_bytes_V4])\n{\n    if (data.getV() >= 5)\n    {\n\tthrow std::logic_error(\n\t    \"compute_O_rc4_key called for file with V >= 5\");\n    }\n    std::string password = owner_password;\n    if (password.empty())\n    {\n\tpassword = user_password;\n    }\n    MD5 md5;\n    md5.encodeDataIncrementally(\n\tpad_or_truncate_password_V4(password).c_str(), key_bytes);\n    MD5::Digest digest;\n    int key_len = std::min(static_cast<int>(sizeof(digest)),\n                           data.getLengthBytes());\n    iterate_md5_digest(md5, digest, ((data.getR() >= 3) ? 50 : 0), key_len);\n    memcpy(key, digest, OU_key_bytes_V4);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int attribute_align_arg avcodec_encode_video(AVCodecContext *avctx, uint8_t *buf, int buf_size,\n\n                                             const AVFrame *pict)\n\n{\n\n    AVPacket pkt;\n\n    int ret, got_packet = 0;\n\n\n\n    if (buf_size < FF_MIN_BUFFER_SIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"buffer smaller than minimum size\\n\");\n\n        return -1;\n\n    }\n\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = buf;\n\n    pkt.size = buf_size;\n\n\n\n    ret = avcodec_encode_video2(avctx, &pkt, pict, &got_packet);\n\n\n\n    if (!ret && got_packet && avctx->coded_frame) {\n\n        avctx->coded_frame->pts       = pkt.pts;\n\n        avctx->coded_frame->key_frame = !!(pkt.flags & AV_PKT_FLAG_KEY);\n\n    }\n\n\n\n\n\n    /* free any side data since we cannot return it */\n\n    if (pkt.side_data_elems > 0) {\n\n        int i;\n\n        for (i = 0; i < pkt.side_data_elems; i++)\n\n            av_free(pkt.side_data[i].data);\n\n        av_freep(&pkt.side_data);\n\n        pkt.side_data_elems = 0;\n\n    }\n\n\n\n    return ret ? ret : pkt.size;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int unit_get_unit_file_preset(Unit *u) {\n        assert(u);\n\n        if (u->unit_file_preset < 0 && u->fragment_path)\n                u->unit_file_preset = unit_file_query_preset(\n                                u->manager->unit_file_scope,\n                                NULL,\n                                basename(u->fragment_path));\n\n        return u->unit_file_preset;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void* CLUTElemDup(cmsStage* mpe)\n{\n    _cmsStageCLutData* Data = (_cmsStageCLutData*) mpe ->Data;\n    _cmsStageCLutData* NewElem;\n\n\n    NewElem = (_cmsStageCLutData*) _cmsMallocZero(mpe ->ContextID, sizeof(_cmsStageCLutData));\n    if (NewElem == NULL) return NULL;\n\n    NewElem ->nEntries       = Data ->nEntries;\n    NewElem ->HasFloatValues = Data ->HasFloatValues;\n\n    if (Data ->Tab.T) {\n\n        if (Data ->HasFloatValues)\n            NewElem ->Tab.TFloat = (cmsFloat32Number*) _cmsDupMem(mpe ->ContextID, Data ->Tab.TFloat, Data ->nEntries * sizeof (cmsFloat32Number));\n        else\n            NewElem ->Tab.T = (cmsUInt16Number*) _cmsDupMem(mpe ->ContextID, Data ->Tab.T, Data ->nEntries * sizeof (cmsUInt16Number));\n    }\n\n    NewElem ->Params   = _cmsComputeInterpParamsEx(mpe ->ContextID,\n                                                   Data ->Params ->nSamples,\n                                                   Data ->Params ->nInputs,\n                                                   Data ->Params ->nOutputs,\n                                                   NewElem ->Tab.T,\n                                                   Data ->Params ->dwFlags);\n\n    return (void*) NewElem;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int kiocb_cancel(struct kiocb *kiocb)\n{\n\tkiocb_cancel_fn *old, *cancel;\n\n\t/*\n\t * Don't want to set kiocb->ki_cancel = KIOCB_CANCELLED unless it\n\t * actually has a cancel function, hence the cmpxchg()\n\t */\n\n\tcancel = ACCESS_ONCE(kiocb->ki_cancel);\n\tdo {\n\t\tif (!cancel || cancel == KIOCB_CANCELLED)\n\t\t\treturn -EINVAL;\n\n\t\told = cancel;\n\t\tcancel = cmpxchg(&kiocb->ki_cancel, old, KIOCB_CANCELLED);\n\t} while (cancel != old);\n\n\treturn cancel(kiocb);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "MagickExport void RegisterStaticModules(void)\n{\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    if (MagickModules[i].registered == MagickFalse)\n      {\n        (void) (MagickModules[i].register_module)();\n        MagickModules[i].registered=MagickTrue;\n      }\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void session_set_recv_data_progressive_notify\n\t\t\t\t\t(Session *session,\n\t\t\t\t\t RecvDataProgressiveNotify notify_func,\n\t\t\t\t\t gpointer data)\n{\n\tsession->recv_data_progressive_notify = notify_func,\n\tsession->recv_data_progressive_notify_data = data;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "notify_timeout_cb (GObject *gobject, GParamSpec *pspec, GObject *self)\n{\n\tg_object_notify (self, \"timeout\");\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool ChromeDownloadManagerDelegate::ShouldOpenFileBasedOnExtension(\n    const FilePath& path) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  FilePath::StringType extension = path.Extension();\n  if (extension.empty())\n    return false;\n  if (extensions::Extension::IsExtension(path))\n    return false;\n  DCHECK(extension[0] == FilePath::kExtensionSeparator);\n  extension.erase(0, 1);\n  return download_prefs_->IsAutoOpenEnabledForExtension(extension);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "f_test_getvalue(typval_T *argvars, typval_T *rettv)\n{\n    char_u *name;\n\n    if (check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    name = tv_get_string(&argvars[0]);\n\n    if (STRCMP(name, (char_u *)\"need_fileinfo\") == 0)\n\trettv->vval.v_number = need_fileinfo;\n    else\n\tsemsg(_(e_invalid_argument_str), name);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void ImageDataPlatformBackend::Unmap() {\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "archive_write_get_bytes_in_last_block(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_get_bytes_in_last_block\");\n\treturn (a->bytes_in_last_block);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void __ip_vs_unlink_dest(struct ip_vs_service *svc,\n\t\t\t\tstruct ip_vs_dest *dest,\n\t\t\t\tint svcupd)\n{\n\tdest->flags &= ~IP_VS_DEST_F_AVAILABLE;\n\n\t/*\n\t *  Remove it from the d-linked destination list.\n\t */\n\tlist_del(&dest->n_list);\n\tsvc->num_dests--;\n\n\t/*\n\t *  Call the update_service function of its scheduler\n\t */\n\tif (svcupd && svc->scheduler->update_service)\n\t\t\tsvc->scheduler->update_service(svc);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "sfxHandle_t S_AL_RegisterSound( const char *sample, qboolean compressed )\n{\n\tsfxHandle_t sfx = S_AL_BufferFind(sample);\n\n\tif((!knownSfx[sfx].inMemory) && (!knownSfx[sfx].isDefault))\n\t\tS_AL_BufferLoad(sfx, s_alPrecache->integer);\n\tknownSfx[sfx].lastUsedTime = Com_Milliseconds();\n\n\tif (knownSfx[sfx].isDefault) {\n\t\treturn 0;\n\t}\n\n\treturn sfx;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void v9fs_readlink(void *opaque)\n\n{\n\n    V9fsPDU *pdu = opaque;\n\n    size_t offset = 7;\n\n    V9fsString target;\n\n    int32_t fid;\n\n    int err = 0;\n\n    V9fsFidState *fidp;\n\n\n\n    pdu_unmarshal(pdu, offset, \"d\", &fid);\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    v9fs_string_init(&target);\n\n    err = v9fs_co_readlink(pdu, &fidp->path, &target);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    offset += pdu_marshal(pdu, offset, \"s\", &target);\n\n    err = offset;\n\n    v9fs_string_free(&target);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    trace_v9fs_readlink_return(pdu->tag, pdu->id, target.data);\n\n    complete_pdu(pdu->s, pdu, err);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "    bool canCreate() override { return current_ < max(); }",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "perf_output_sample_regs(struct perf_output_handle *handle,\n\t\t\tstruct pt_regs *regs, u64 mask)\n{\n\tint bit;\n\n\tfor_each_set_bit(bit, (const unsigned long *) &mask,\n\t\t\t sizeof(mask) * BITS_PER_BYTE) {\n\t\tu64 val;\n\n\t\tval = perf_reg_value(regs, bit);\n\t\tperf_output_put(handle, val);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "char *get_56_lenc_string(char **buffer,\n                         size_t *max_bytes_available,\n                         size_t *string_length)\n{\n  static char empty_string[1]= { '\\0' };\n  char *begin= *buffer;\n\n  if (*max_bytes_available == 0)\n    return NULL;\n\n  /*\n    If the length encoded string has the length 0\n    the total size of the string is only one byte long (the size byte)\n  */\n  if (*begin == 0)\n  {\n    *string_length= 0;\n    --*max_bytes_available;\n    ++*buffer;\n    /*\n      Return a pointer to the \\0 character so the return value will be\n      an empty string.\n    */\n    return empty_string;\n  }\n\n  *string_length= (size_t)net_field_length_ll((uchar **)buffer);\n\n  DBUG_EXECUTE_IF(\"sha256_password_scramble_too_long\",\n                  *string_length= SIZE_T_MAX;\n  );\n\n  size_t len_len= (size_t)(*buffer - begin);\n  \n  if (*string_length > *max_bytes_available - len_len)\n    return NULL;\n\n  *max_bytes_available -= *string_length;\n  *max_bytes_available -= len_len;\n  *buffer += *string_length;\n  return (char *)(begin + len_len);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "size_t jsvGetString(const JsVar *v, char *str, size_t len) {\n  assert(len>0);\n  const char *s = jsvGetConstString(v);\n  if (s) {\n    /* don't use strncpy here because we don't\n      * want to pad the entire buffer with zeros */\n     len--;\n     int l = 0;\n    while (*s && l<len) {\n       str[l] = s[l];\n       l++;\n     }\n    str[l] = 0;\n    return l;\n  } else if (jsvIsInt(v)) {\n    itostr(v->varData.integer, str, 10);\n    return strlen(str);\n  } else if (jsvIsFloat(v)) {\n    ftoa_bounded(v->varData.floating, str, len);\n    return strlen(str);\n  } else if (jsvHasCharacterData(v)) {\n    assert(!jsvIsStringExt(v));\n    size_t l = len;\n    JsvStringIterator it;\n    jsvStringIteratorNewConst(&it, v, 0);\n    while (jsvStringIteratorHasChar(&it)) {\n      if (l--<=1) {\n        *str = 0;\n        jsvStringIteratorFree(&it);\n        return len;\n      }\n      *(str++) = jsvStringIteratorGetChar(&it);\n      jsvStringIteratorNext(&it);\n    }\n    jsvStringIteratorFree(&it);\n    *str = 0;\n    return len-l;\n  } else {\n    JsVar *stringVar = jsvAsString((JsVar*)v, false); // we know we're casting to non-const here\n    if (stringVar) {\n      size_t l = jsvGetString(stringVar, str, len); // call again - but this time with converted var\n      jsvUnLock(stringVar);\n      return l;\n    } else {\n      str[0] = 0;\n      jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n      return 0;\n    }\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void InlineFlowBox::extractLine()\n{\n    if (!m_extracted)\n        extractLineBoxFromRenderObject();\n    for (InlineBox* child = firstChild(); child; child = child->nextOnLine())\n        child->extractLine();\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "uint64_t HELPER(neon_abdl_u32)(uint32_t a, uint32_t b)\n\n{\n\n    uint64_t tmp;\n\n    uint64_t result;\n\n    DO_ABD(result, a, b, uint16_t);\n\n    DO_ABD(tmp, a >> 16, b >> 16, uint16_t);\n\n    return result | (tmp << 32);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static const SSL_METHOD *ssl23_get_server_method(int ver)\n\t{\n#ifndef OPENSSL_NO_SSL2\n\tif (ver == SSL2_VERSION)\n\t\treturn(SSLv2_server_method());\n#endif\n\tif (ver == SSL3_VERSION)\n\t\treturn(SSLv3_server_method());\n\telse if (ver == TLS1_VERSION)\n\t\treturn(TLSv1_server_method());\n\telse if (ver == TLS1_1_VERSION)\n\t\treturn(TLSv1_1_server_method());\n\telse if (ver == TLS1_2_VERSION)\n\t\treturn(TLSv1_2_server_method());\n\telse\n\t\treturn(NULL);\n\t}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "Document getSpec() {\n        return DOC(\"input\" << DOC_ARRAY(DOC_ARRAY(1 << 2) << Value(BSONNULL)) << \"expected\"\n                           << DOC(\"$setIntersection\" << BSONNULL << \"$setUnion\" << BSONNULL\n                                                     << \"$setDifference\"\n                                                     << BSONNULL)\n                           << \"error\"\n                           << DOC_ARRAY(\"$setEquals\"_sd\n                                        << \"$setIsSubset\"_sd));\n    }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static NTSTATUS read_packet_remainder(int fd, char *buffer,\n\t\t\t\t      unsigned int timeout, ssize_t len)\n{\n\tif (len <= 0) {\n\t\treturn NT_STATUS_OK;\n\t}\n\n\treturn read_fd_with_timeout(fd, buffer, len, len, timeout, NULL);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void load_psw(CPUS390XState *env, uint64_t mask, uint64_t addr)\n\n{\n\n    uint64_t old_mask = env->psw.mask;\n\n\n\n    env->psw.addr = addr;\n\n    env->psw.mask = mask;\n\n    if (tcg_enabled()) {\n\n        env->cc_op = (mask >> 44) & 3;\n\n    }\n\n\n\n    if ((old_mask ^ mask) & PSW_MASK_PER) {\n\n        s390_cpu_recompute_watchpoints(CPU(s390_env_get_cpu(env)));\n\n    }\n\n\n\n    if (mask & PSW_MASK_WAIT) {\n\n        S390CPU *cpu = s390_env_get_cpu(env);\n\n        if (s390_cpu_halt(cpu) == 0) {\n\n#ifndef CONFIG_USER_ONLY\n\n            qemu_system_shutdown_request(SHUTDOWN_CAUSE_GUEST_SHUTDOWN);\n\n#endif\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int64_t coroutine_fn vvfat_co_get_block_status(BlockDriverState *bs,\n\n\tint64_t sector_num, int nb_sectors, int *n, BlockDriverState **file)\n\n{\n\n    BDRVVVFATState* s = bs->opaque;\n\n    *n = s->sector_count - sector_num;\n\n    if (*n > nb_sectors) {\n\n        *n = nb_sectors;\n\n    } else if (*n < 0) {\n\n        return 0;\n\n    }\n\n    return BDRV_BLOCK_DATA;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "unsigned int lcdGetPixelIndex_ArrayBuffer(JsGraphics *gfx, int x, int y, int pixelCount) {\n  if (gfx->data.flags & JSGRAPHICSFLAGS_ARRAYBUFFER_ZIGZAG) {\n    if (y&1) x = gfx->data.width - (x+pixelCount);\n  }\n  if (gfx->data.flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE)\n    return (unsigned int)(((x + (y>>3)*gfx->data.width)<<3) | (y&7));\n  else\n    return (unsigned int)((x + y*gfx->data.width)*gfx->data.bpp);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int req_alert(lua_State *L)\n{\n    return req_log_at(L, APLOG_ALERT);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void ContainerNode::appendChildCommon(Node& child)\n{\n    child.setParentOrShadowHostNode(this);\n\n    if (m_lastChild) {\n        child.setPreviousSibling(m_lastChild);\n        m_lastChild->setNextSibling(&child);\n    } else {\n        setFirstChild(&child);\n    }\n\n    setLastChild(&child);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void WebContentsImpl::SystemDragEnded() {\n  if (GetRenderViewHost())\n    GetRenderViewHostImpl()->DragSourceSystemDragEnded();\n  if (delegate_)\n    delegate_->DragEnded();\n  if (browser_plugin_embedder_.get())\n    browser_plugin_embedder_->SystemDragEnded();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "handle_cmdallow(CMD_Request *rx_message, CMD_Reply *tx_message)\n{\n  IPAddr ip;\n  int subnet_bits;\n  UTI_IPNetworkToHost(&rx_message->data.allow_deny.ip, &ip);\n  subnet_bits = ntohl(rx_message->data.allow_deny.subnet_bits);\n  if (CAM_AddAccessRestriction(&ip, subnet_bits, 1, 0)) {\n    tx_message->status = htons(STT_SUCCESS);\n  } else {\n    tx_message->status = htons(STT_BADSUBNET);\n  }              \n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool is_tty_option(char *name)\n{\n  return (name[0] == 't' && name[1] == '_') || !strcmp((char *)name, \"term\");\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int mxf_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n\n{\n\n    AVStream *st = s->streams[stream_index];\n\n    int64_t seconds;\n\n\n\n    if (!s->bit_rate)\n\n        return AVERROR_INVALIDDATA;\n\n    if (sample_time < 0)\n\n        sample_time = 0;\n\n    seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);\n\n    avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET);\n\n    ff_update_cur_dts(s, st, sample_time);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "WandExport void DrawSetStrokeMiterLimit(DrawingWand *wand,\n  const size_t miterlimit)\n{\n  assert(wand != (DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  if (CurrentContext->miterlimit != miterlimit)\n    {\n      CurrentContext->miterlimit=miterlimit;\n      (void) MVGPrintf(wand,\"stroke-miterlimit %.20g\\n\",(double) miterlimit);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void RemoteFsDevice::Details::save() const\n{\n    Configuration cfg(constCfgPrefix+name);\n\n    cfg.set(\"url\", url.toString());\n    cfg.set(\"extraOptions\", extraOptions);\n    cfg.set(\"configured\", configured);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 rowsperstrip;\n\tuint32 stripsperplane;\n\tuint32 stripinplane;\n\tuint16 plane;\n\tuint32 rows;\n\ttmsize_t stripsize;\n\tif (!TIFFCheckRead(tif,0))\n\t\treturn((tmsize_t)(-1));\n\tif (strip>=td->td_nstrips)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"%lu: Strip out of range, max %lu\",(unsigned long)strip,\n\t\t    (unsigned long)td->td_nstrips);\n\t\treturn((tmsize_t)(-1));\n\t}\n\t/*\n\t * Calculate the strip size according to the number of\n\t * rows in the strip (check for truncated last strip on any\n\t * of the separations).\n\t */\n \trowsperstrip=td->td_rowsperstrip;\n \tif (rowsperstrip>td->td_imagelength)\n \t\trowsperstrip=td->td_imagelength;\n\tstripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip);\n \tstripinplane=(strip%stripsperplane);\n \tplane=(uint16)(strip/stripsperplane);\n \trows=td->td_imagelength-stripinplane*rowsperstrip;\n\tif (rows>rowsperstrip)\n\t\trows=rowsperstrip;\n\tstripsize=TIFFVStripSize(tif,rows);\n\tif (stripsize==0)\n\t\treturn((tmsize_t)(-1));\n\n    /* shortcut to avoid an extra memcpy() */\n    if( td->td_compression == COMPRESSION_NONE &&\n        size!=(tmsize_t)(-1) && size >= stripsize &&\n        !isMapped(tif) &&\n        ((tif->tif_flags&TIFF_NOREADRAW)==0) )\n    {\n        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)\n            return ((tmsize_t)(-1));\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf,stripsize);\n\n        (*tif->tif_postdecode)(tif,buf,stripsize);\n        return (stripsize);\n    }\n\n\tif ((size!=(tmsize_t)(-1))&&(size<stripsize))\n\t\tstripsize=size;\n\tif (!TIFFFillStrip(tif,strip))\n\t\treturn((tmsize_t)(-1));\n\tif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\n\t\treturn((tmsize_t)(-1));\n\t(*tif->tif_postdecode)(tif,buf,stripsize);\n\treturn(stripsize);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "compile_string_node(Node* node, regex_t* reg)\n{\n  int r, len, prev_len, slen, ambig;\n  OnigEncoding enc = reg->enc;\n  UChar *p, *prev, *end;\n  StrNode* sn;\n\n  sn = NSTR(node);\n  if (sn->end <= sn->s)\n    return 0;\n\n  end = sn->end;\n  ambig = NSTRING_IS_AMBIG(node);\n\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n\n  for (; p < end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string(prev, prev_len, slen, reg, ambig);\n      if (r) return r;\n\n      prev  = p;\n      slen  = 1;\n      prev_len = len;\n    }\n\n    p += len;\n  }\n  return add_compile_string(prev, prev_len, slen, reg, ambig);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int tight_send_framebuffer_update(VncState *vs, int x, int y,\n                                         int w, int h)\n{\n    int max_rows;\n\n    if (vs->clientds.pf.bytes_per_pixel == 4 && vs->clientds.pf.rmax == 0xFF &&\n        vs->clientds.pf.bmax == 0xFF && vs->clientds.pf.gmax == 0xFF) {\n        vs->tight.pixel24 = true;\n    } else {\n        vs->tight.pixel24 = false;\n    }\n\n#ifdef CONFIG_VNC_JPEG\n    if (vs->tight.quality != (uint8_t)-1) {\n        double freq = vnc_update_freq(vs, x, y, w, h);\n\n        if (freq > tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\n            return send_rect_simple(vs, x, y, w, h, false);\n        }\n    }\n#endif\n\n    if (w * h < VNC_TIGHT_MIN_SPLIT_RECT_SIZE) {\n        return send_rect_simple(vs, x, y, w, h, true);\n    }\n\n    /* Calculate maximum number of rows in one non-solid rectangle. */\n\n    max_rows = tight_conf[vs->tight.compression].max_rect_size;\n    max_rows /= MIN(tight_conf[vs->tight.compression].max_rect_width, w);\n\n    return find_large_solid_color_rect(vs, x, y, w, h, max_rows);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int kvaser_usb_leaf_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_SET_CTRL_MODE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_ctrl_mode);\n\tcmd->u.ctrl_mode.tid = 0xff;\n\tcmd->u.ctrl_mode.channel = priv->channel;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\n\telse\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "Break(int lineno, int col_offset, int end_lineno, int end_col_offset, PyArena\n      *arena)\n{\n    stmt_ty p;\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = Break_kind;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "utf16be_mbc_to_code(const UChar* p, const UChar* end ARG_UNUSED)\n{\n  OnigCodePoint code;\n\n  if (UTF16_IS_SURROGATE_FIRST(*p)) {\n    code = ((((p[0] - 0xd8) << 2) + ((p[1] & 0xc0) >> 6) + 1) << 16)\n         + ((((p[1] & 0x3f) << 2) + (p[2] - 0xdc)) << 8)\n         + p[3];\n  }\n  else {\n    code = p[0] * 256 + p[1];\n  }\n  return code;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "R_API RBinJavaCPTypeMetas *U(r_bin_java_get_cp_meta_from_tag)(ut8 tag) {\n\tut16 i = 0;\n\t// set default to unknown.\n\tRBinJavaCPTypeMetas *res = &R_BIN_JAVA_CP_METAS[2];\n\tfor (i = 0; i < R_BIN_JAVA_CP_METAS_SZ; i++) {\n\t\tif (tag == R_BIN_JAVA_CP_METAS[i].tag) {\n\t\t\tres = &R_BIN_JAVA_CP_METAS[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "**/\n    const CImg<T>& save_raw(const char *const filename, const bool is_multiplexed=false) const {\n      return _save_raw(0,filename,is_multiplexed);",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "SProcGetProperty(ClientPtr client)\n{\n    REQUEST(xGetPropertyReq);\n    swaps(&stuff->length);\n    REQUEST_SIZE_MATCH(xGetPropertyReq);\n    swapl(&stuff->window);\n    swapl(&stuff->property);\n    swapl(&stuff->type);\n    swapl(&stuff->longOffset);\n    swapl(&stuff->longLength);\n    return ((*ProcVector[X_GetProperty]) (client));\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "onig_region_init(OnigRegion* region)\n{\n  region->num_regs     = 0;\n  region->allocated    = 0;\n  region->beg          = (int* )0;\n  region->end          = (int* )0;\n  region->history_root = (OnigCaptureTreeNode* )0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline struct page *f2fs_pagecache_get_page(\n\t\t\t\tstruct address_space *mapping, pgoff_t index,\n\t\t\t\tint fgp_flags, gfp_t gfp_mask)\n{\n\tif (time_to_inject(F2FS_M_SB(mapping), FAULT_PAGE_GET)) {\n\t\tf2fs_show_injection_info(FAULT_PAGE_GET);\n\t\treturn NULL;\n\t}\n\n\treturn pagecache_get_page(mapping, index, fgp_flags, gfp_mask);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,\n                BIO *dcont, BIO *out, unsigned int flags)\n{\n    int r;\n    BIO *cont;\n    if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {\n        CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);\n        return 0;\n    }\n    if (!dcont && !check_content(cms))\n        return 0;\n    if (flags & CMS_DEBUG_DECRYPT)\n        cms->d.envelopedData->encryptedContentInfo->debug = 1;\n    else\n        cms->d.envelopedData->encryptedContentInfo->debug = 0;\n    if (!pk && !cert && !dcont && !out)\n        return 1;\n    if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))\n        return 0;\n    cont = CMS_dataInit(cms, dcont);\n    if (!cont)\n        return 0;\n    r = cms_copy_content(out, cont, flags);\n    do_free_upto(cont, dcont);\n    return r;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void Magick::Image::spread(const double amount_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=SpreadImage(constImage(),image()->interpolate,amount_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "GF_Err bloc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (const char *) ptr->baseLocation, 256);\n\tgf_bs_write_data(bs, (const char *) ptr->basePurlLocation, 256);\n\tfor (i=0; i < 64; i++ ) {\n\t\tgf_bs_write_u64(bs, 0);\n\t}\n\treturn GF_OK;",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void set_own_dir(const char *argv0) {\n\tsize_t l = strlen(argv0);\n\twhile(l && argv0[l - 1] != '/')\n\t\tl--;\n\tif(l == 0)\n#ifdef SUPER_SECURE\n\t\tmemcpy(own_dir, \"/dev/null/\", 2);\n#else\n\t\tmemcpy(own_dir, \".\", 2);\n#endif\n\telse {\n\t\tmemcpy(own_dir, argv0, l - 1);\n\t\town_dir[l] = 0;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t/* UDA v1.0 */\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t/* UDA v1.1 or later */\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n \t\tl = 0;\n \t}\n \tobj->buffersize = 1024;\n\tobj->buffer = malloc(obj->buffersize);\n\tif(!obj->buffer) {\n\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\tif(xml) {\n\t\t\tfree(xml);\n \t\t}\n\t\tobj->state = EError;\n\t\treturn;\n \t}\n\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t                       obj->sub->uuid, obj->sub->seq,\n\t                       l, xml);\n \tif(xml) {\n \t\tfree(xml);\n \t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int vnc_display_password(DisplayState *ds, const char *password)\n\n{\n\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n\n\n\n    if (!vs) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!password) {\n\n        /* This is not the intention of this interface but err on the side\n\n           of being safe */\n\n        return vnc_display_disable_login(ds);\n\n    }\n\n\n\n    if (vs->password) {\n\n        g_free(vs->password);\n\n        vs->password = NULL;\n\n    }\n\n    vs->password = g_strdup(password);\n\n    if (vs->auth == VNC_AUTH_NONE) {\n\n        vs->auth = VNC_AUTH_VNC;\n\n    }\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "BufferManager::BufferInfo* buffer() const {\n      return buffer_;\n    }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static inline void do_rfi(CPUPPCState *env, target_ulong nip, target_ulong msr,\n                          target_ulong msrm, int keep_msrh)\n{\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n#if defined(TARGET_PPC64)\n    if (msr_is_64bit(env, msr)) {\n        nip = (uint64_t)nip;\n        msr &= (uint64_t)msrm;\n    } else {\n        nip = (uint32_t)nip;\n        msr = (uint32_t)(msr & msrm);\n        if (keep_msrh) {\n            msr |= env->msr & ~((uint64_t)0xFFFFFFFF);\n        }\n    }\n#else\n    nip = (uint32_t)nip;\n    msr &= (uint32_t)msrm;\n#endif\n    /* XXX: beware: this is false if VLE is supported */\n    env->nip = nip & ~((target_ulong)0x00000003);\n    hreg_store_msr(env, msr, 1);\n#if defined(DEBUG_OP)\n    cpu_dump_rfi(env->nip, env->msr);\n#endif\n    /* No need to raise an exception here,\n     * as rfi is always the last insn of a TB\n     */\n    cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "zzip_dir_fdopen(int fd, zzip_error_t * errcode_p)\n{\n    return zzip_dir_fdopen_ext_io(fd, errcode_p, 0, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int adx_decode(ADXContext *c, int16_t *out, int offset,\n\n                      const uint8_t *in, int ch)\n\n{\n\n    ADXChannelState *prev = &c->prev[ch];\n\n    GetBitContext gb;\n\n    int scale = AV_RB16(in);\n\n    int i;\n\n    int s0, s1, s2, d;\n\n\n\n    /* check if this is an EOF packet */\n\n    if (scale & 0x8000)\n\n        return -1;\n\n\n\n    init_get_bits(&gb, in + 2, (BLOCK_SIZE - 2) * 8);\n\n    out += offset;\n\n    s1 = prev->s1;\n\n    s2 = prev->s2;\n\n    for (i = 0; i < BLOCK_SAMPLES; i++) {\n\n        d  = get_sbits(&gb, 4);\n\n        s0 = ((d << COEFF_BITS) * scale + c->coeff[0] * s1 + c->coeff[1] * s2) >> COEFF_BITS;\n\n        s2 = s1;\n\n        s1 = av_clip_int16(s0);\n\n        *out++ = s1;\n\n    }\n\n    prev->s1 = s1;\n\n    prev->s2 = s2;\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int inet6_fill_ifinfo(struct sk_buff *skb, struct inet6_dev *idev, \n\t\t\t     u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tstruct net_device\t*dev = idev->dev;\n\t__s32\t\t\t*array = NULL;\n\tstruct ifinfomsg\t*r;\n\tstruct nlmsghdr \t*nlh;\n\tunsigned char\t\t*b = skb->tail;\n\tstruct rtattr\t\t*subattr;\n\t__u32\t\t\tmtu = dev->mtu;\n\tstruct ifla_cacheinfo\tci;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*r), flags);\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_INET6;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev_get_flags(dev);\n\tr->ifi_change = 0;\n\n\tRTA_PUT(skb, IFLA_IFNAME, strlen(dev->name)+1, dev->name);\n\n\tif (dev->addr_len)\n\t\tRTA_PUT(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr);\n\n\tRTA_PUT(skb, IFLA_MTU, sizeof(mtu), &mtu);\n\tif (dev->ifindex != dev->iflink)\n\t\tRTA_PUT(skb, IFLA_LINK, sizeof(int), &dev->iflink);\n\t\t\t\n\tsubattr = (struct rtattr*)skb->tail;\n\n\tRTA_PUT(skb, IFLA_PROTINFO, 0, NULL);\n\n\t/* return the device flags */\n\tRTA_PUT(skb, IFLA_INET6_FLAGS, sizeof(__u32), &idev->if_flags);\n\n\t/* return interface cacheinfo */\n\tci.max_reasm_len = IPV6_MAXPLEN;\n\tci.tstamp = (__u32)(TIME_DELTA(idev->tstamp, INITIAL_JIFFIES) / HZ * 100\n\t\t    + TIME_DELTA(idev->tstamp, INITIAL_JIFFIES) % HZ * 100 / HZ);\n\tci.reachable_time = idev->nd_parms->reachable_time;\n\tci.retrans_time = idev->nd_parms->retrans_time;\n\tRTA_PUT(skb, IFLA_INET6_CACHEINFO, sizeof(ci), &ci);\n\t\n\t/* return the device sysctl params */\n\tif ((array = kmalloc(DEVCONF_MAX * sizeof(*array), GFP_ATOMIC)) == NULL)\n\t\tgoto rtattr_failure;\n\tipv6_store_devconf(&idev->cnf, array, DEVCONF_MAX * sizeof(*array));\n\tRTA_PUT(skb, IFLA_INET6_CONF, DEVCONF_MAX * sizeof(*array), array);\n\n\t/* XXX - Statistics/MC not implemented */\n\tsubattr->rta_len = skb->tail - (u8*)subattr;\n\n\tnlh->nlmsg_len = skb->tail - b;\n\tkfree(array);\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tif (array)\n\t\tkfree(array);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void ttwu_queue(struct task_struct *p, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n#if defined(CONFIG_SMP)\n\tif (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {\n\t\tsched_clock_cpu(cpu); /* sync clocks x-cpu */\n\t\tttwu_queue_remote(p, cpu);\n\t\treturn;\n\t}\n#endif\n\n\traw_spin_lock(&rq->lock);\n\tttwu_do_activate(rq, p, 0);\n\traw_spin_unlock(&rq->lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "views::View* OmniboxViewWin::parent_view() const {\n  return parent_view_;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "smp_fetch_hdr_val(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                  const struct arg *args, struct sample *smp)\n{\n\tint ret = smp_fetch_hdr(px, l4, l7, opt, args, smp);\n\n\tif (ret > 0) {\n\t\tsmp->type = SMP_T_UINT;\n\t\tsmp->data.uint = strl2ic(smp->data.str.str, smp->data.str.len);\n\t}\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int dccp_hdlr_ack_ratio(struct sock *sk, u64 ratio, bool rx)\n{\n\tif (rx)\n\t\tdccp_sk(sk)->dccps_r_ack_ratio = ratio;\n\telse\n\t\tdccp_sk(sk)->dccps_l_ack_ratio = ratio;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "auth_delkeys(void)\n{\n\tsymkey *\tsk;\n\n\tITER_DLIST_BEGIN(key_listhead, sk, llink, symkey)\n\t\tif (sk->keyid > NTP_MAXKEY) {\t/* autokey */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Don't lose info as to which keys are trusted.\n\t\t */\n\t\tif (KEY_TRUSTED & sk->flags) {\n\t\t\tif (sk->secret != NULL) {\n\t\t\t\tmemset(sk->secret, '\\0', sk->secretsize);\n\t\t\t\tfree(sk->secret);\n\t\t\t\tsk->secret = NULL; /* TALOS-CAN-0054 */\n\t\t\t}\n\t\t\tsk->secretsize = 0;\n\t\t\tsk->lifetime = 0;\n\t\t} else {\n\t\t\tfreesymkey(sk, &key_hash[KEYHASH(sk->keyid)]);\n\t\t}\n\tITER_DLIST_END()\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int floppy_request_regions(int fdc)\n{\n\tconst struct io_region *p;\n\n\tfor (p = io_regions; p < ARRAY_END(io_regions); p++) {\n\t\tif (!request_region(FDCS->address + p->offset,\n\t\t\t\t    p->size, \"floppy\")) {\n\t\t\tDPRINT(\"Floppy io-port 0x%04lx in use\\n\",\n\t\t\t       FDCS->address + p->offset);\n\t\t\tfloppy_release_allocated_regions(fdc, p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void skip_input(DBEContext *s, int nb_words)\n\n{\n\n    s->input      += nb_words * s->word_bytes;\n\n    s->input_size -= nb_words;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "print(WebKitWebView *page, GArray *argv, GString *result) {\n    (void) page; (void) result;\n    gchar* buf;\n\n    buf = expand(argv_idx(argv, 0), 0);\n    g_string_assign(result, buf);\n    g_free(buf);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "JVM_RawAllocateInCategory(size_t size, const char * callsite, jint category)\n{\n\treturn j9portLibrary.omrPortLibrary.mem_allocate_memory(&j9portLibrary.omrPortLibrary, (UDATA) size, (char *) ((callsite == NULL) ? J9_GET_CALLSITE() : callsite), category);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "R_API int r_sys_cmd_str_full(const char *cmd, const char *input, char **output, int *len, char **sterr) {\n\teprintf (\"r_sys_cmd_str: not yet implemented for this platform\\n\");\n\treturn false;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void bonito_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = bonito_initfn;\n\n    k->vendor_id = 0xdf53;\n\n    k->device_id = 0x00d5;\n\n    k->revision = 0x01;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"Host bridge\";\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_bonito;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void WebContentsImpl::HandleGestureEnd() {\n  if (delegate_)\n    delegate_->HandleGestureEnd();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void nfs_commit_release(void *calldata)\n{\n\tstruct nfs_commit_data *data = calldata;\n\n\tdata->completion_ops->completion(data);\n\tnfs_commitdata_release(calldata);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void add_machine_test_cases(void)\n\n{\n\n    const char *arch = qtest_get_arch();\n\n    QDict *response, *minfo;\n\n    QList *list;\n\n    const QListEntry *p;\n\n    QObject *qobj;\n\n    QString *qstr;\n\n    const char *mname, *path;\n\n\n\n    qtest_start(\"-machine none\");\n\n    response = qmp(\"{ 'execute': 'query-machines' }\");\n\n    g_assert(response);\n\n    list = qdict_get_qlist(response, \"return\");\n\n    g_assert(list);\n\n\n\n    for (p = qlist_first(list); p; p = qlist_next(p)) {\n\n        minfo = qobject_to_qdict(qlist_entry_obj(p));\n\n        g_assert(minfo);\n\n        qobj = qdict_get(minfo, \"name\");\n\n        g_assert(qobj);\n\n        qstr = qobject_to_qstring(qobj);\n\n        g_assert(qstr);\n\n        mname = qstring_get_str(qstr);\n\n        if (!is_blacklisted(arch, mname)) {\n\n            path = g_strdup_printf(\"qom/%s\", mname);\n\n            qtest_add_data_func(path, g_strdup(mname), test_machine);\n\n        }\n\n    }\n\n\n\n    qtest_end();\n\n    QDECREF(response);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "adv_error adv_png_read(\n\tunsigned* pix_width, unsigned* pix_height, unsigned* pix_pixel,\n\tunsigned char** dat_ptr, unsigned* dat_size,\n\tunsigned char** pix_ptr, unsigned* pix_scanline,\n\tunsigned char** pal_ptr, unsigned* pal_size,\n\tadv_fz* f)\n{\n\tadv_error r;\n\tunsigned char* rns_ptr;\n\tunsigned rns_size;\n\n\tr = adv_png_read_rns(pix_width, pix_height, pix_pixel, dat_ptr, dat_size, pix_ptr, pix_scanline, pal_ptr, pal_size, &rns_ptr, &rns_size, f);\n\n\tif (r == 0)\n\t\tfree(rns_ptr);\n\n\treturn r;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "parse_wcc_attr(netdissect_options *ndo,\n               const uint32_t *dp)\n{\n\tND_PRINT((ndo, \" sz %\" PRIu64, EXTRACT_64BITS(&dp[0])));\n\tND_PRINT((ndo, \" mtime %u.%06u ctime %u.%06u\",\n\t       EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[3]),\n\t       EXTRACT_32BITS(&dp[4]), EXTRACT_32BITS(&dp[5])));\n\treturn (dp + 6);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static size_t compat_readv(struct file *file,\n\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t   unsigned long vlen, loff_t *pos)\n{\n\tssize_t ret = -EBADF;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\tgoto out;\n\n\tret = compat_do_readv_writev(READ, file, vec, vlen, pos);\n\nout:\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void *seq_buf_alloc(unsigned long size)\n{\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int parse_hex32(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint32_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n\n\n    if (sscanf(str, \"%\" PRIx32, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void vhost_net_enable_vq(struct vhost_net *n,\n\t\t\t\tstruct vhost_virtqueue *vq)\n{\n\tstruct socket *sock;\n\n\tsock = rcu_dereference_protected(vq->private_data,\n\t\t\t\t\t lockdep_is_held(&vq->mutex));\n\tif (!sock)\n\t\treturn;\n\tif (vq == n->vqs + VHOST_NET_VQ_TX) {\n\t\tn->tx_poll_state = VHOST_NET_POLL_STOPPED;\n\t\ttx_poll_start(n, sock);\n\t} else\n\t\tvhost_poll_start(n->poll + VHOST_NET_VQ_RX, sock->file);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "RenderViewHostImpl* WebContentsImpl::GetRenderViewHostImpl() {\n  return static_cast<RenderViewHostImpl*>(GetRenderViewHost());\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "gs_window_destroy (GSWindow *window)\n{\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        gtk_widget_destroy (GTK_WIDGET (window));\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void BnDrm::readVector(const Parcel &data, Vector<uint8_t> &vector) const {\n uint32_t size = data.readInt32();\n vector.insertAt((size_t)0, size);\n    data.read(vector.editArray(), size);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void allocate_buffers(ALACContext *alac)\n\n{\n\n    int chan;\n\n    for (chan = 0; chan < alac->numchannels; chan++) {\n\n        alac->predicterror_buffer[chan] =\n\n            av_malloc(alac->setinfo_max_samples_per_frame * 4);\n\n\n\n        alac->outputsamples_buffer[chan] =\n\n            av_malloc(alac->setinfo_max_samples_per_frame * 4);\n\n\n\n        alac->wasted_bits_buffer[chan] = av_malloc(alac->setinfo_max_samples_per_frame * 4);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "int qemu_acl_insert(qemu_acl *acl,\n\n                    int deny,\n\n                    const char *match,\n\n                    int index)\n\n{\n\n    qemu_acl_entry *entry;\n\n    qemu_acl_entry *tmp;\n\n    int i = 0;\n\n\n\n    if (index <= 0)\n\n        return -1;\n\n    if (index > acl->nentries) {\n\n        return qemu_acl_append(acl, deny, match);\n\n    }\n\n\n\n    entry = g_malloc(sizeof(*entry));\n\n    entry->match = g_strdup(match);\n\n    entry->deny = deny;\n\n\n\n    QTAILQ_FOREACH(tmp, &acl->entries, next) {\n\n        i++;\n\n        if (i == index) {\n\n            QTAILQ_INSERT_BEFORE(tmp, entry, next);\n\n            acl->nentries++;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return i;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "explicit FakeUsbMidiDevice(Logger* logger) : logger_(logger) {}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "Type* SafeArrayAlloc(unsigned long long num_elements,\n                     unsigned long long element_size) {\n  if (num_elements == 0 || element_size == 0)\n    return NULL;\n\n  const size_t kMaxAllocSize = 0x80000000;  // 2GiB\n  const unsigned long long num_bytes = num_elements * element_size;\n  if (element_size > (kMaxAllocSize / num_elements))\n    return NULL;\n  if (num_bytes != static_cast<size_t>(num_bytes))\n    return NULL;\n\n  return new (std::nothrow) Type[static_cast<size_t>(num_bytes)];\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "main(int argc, char *argv[])\n{\n  int cnt,rc,cc;\n  char cmnd[1024];\n\n  strcpy(cmnd, CMD);\n\n  if (argc > 1)\n  {\n    for (cnt = 1; cnt < argc; cnt++)\n    {\n      strcat(cmnd, \" \");\n      strcat(cmnd, argv[cnt]);\n    }\n  }\n  else\n  {\n    fprintf(stderr, \"__ %s:  failed %d  %d\\n\", argv[0], rc, cc);\n    return 255;\n  }\n\n  cc = setuid(UID);\n  rc = system(cmnd);\n\n  if ((rc != 0) || (cc != 0))\n  {\n    fprintf(stderr, \"__ %s:  failed %d  %d\\n\", argv[0], rc, cc);\n    return 1;\n  }\n\n  return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len _U_,\n\t\t const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\t uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int prepare_timeout(const struct timespec __user *u_abs_timeout,\n\t\t\t   struct timespec *ts)\n{\n\tif (copy_from_user(ts, u_abs_timeout, sizeof(struct timespec)))\n\t\treturn -EFAULT;\n\tif (!timespec_valid(ts))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "evbuffer_ptr_subtract(struct evbuffer *buf, struct evbuffer_ptr *pos,\n    size_t howfar)\n{\n\tif (howfar > (size_t)pos->pos)\n\t\treturn -1;\n\tif (pos->internal_.chain && howfar <= pos->internal_.pos_in_chain) {\n\t\tpos->internal_.pos_in_chain -= howfar;\n\t\tpos->pos -= howfar;\n\t\treturn 0;\n\t} else {\n\t\tconst size_t newpos = pos->pos - howfar;\n\t\t/* Here's the inefficient part: it walks over the\n\t\t * chains until we hit newpos. */\n\t\treturn evbuffer_ptr_set(buf, pos, newpos, EVBUFFER_PTR_SET);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void mmf_recalc_uprobes(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (!valid_vma(vma, false))\n\t\t\tcontinue;\n\t\t/*\n\t\t * This is not strictly accurate, we can race with\n\t\t * uprobe_unregister() and see the already removed\n\t\t * uprobe if delete_uprobe() was not yet called.\n\t\t * Or this uprobe can be filtered out.\n\t\t */\n\t\tif (vma_has_uprobes(vma, vma->vm_start, vma->vm_end))\n\t\t\treturn;\n\t}\n\n\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void h264bsdResetStorage(storage_t *pStorage)\n{\n\n/* Variables */\n\n    u32 i;\n\n/* Code */\n\n    ASSERT(pStorage);\n\n    pStorage->slice->numDecodedMbs = 0;\n    pStorage->slice->sliceId = 0;\n\n for (i = 0; i < pStorage->picSizeInMbs; i++)\n {\n        pStorage->mb[i].sliceId = 0;\n        pStorage->mb[i].decoded = 0;\n }\n\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void kvm_apic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    APICCommonState *s = APIC_COMMON(dev);\n\n\n\n    memory_region_init_io(&s->io_memory, NULL, &kvm_apic_io_ops, s, \"kvm-apic-msi\",\n\n                          APIC_SPACE_SIZE);\n\n\n\n    if (kvm_has_gsi_routing()) {\n\n        msi_nonbroken = true;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void xvid_idct_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n\n{\n\n    ff_xvid_idct(block);\n\n    ff_put_pixels_clamped(block, dest, line_size);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "PPC_OP(subfeo)\n\n{\n\n    do_subfeo();\n\n    RETURN();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int mp_get_vlc(MotionPixelsContext *mp, GetBitContext *gb)\n\n{\n\n    int i;\n\n\n\n    i = (mp->codes_count == 1) ? 0 : get_vlc2(gb, mp->vlc.table, mp->max_codes_bits, 1);\n\n\n    return mp->codes[i].delta;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static ut64 num_callback(RNum *user, const char *name, int *ok) {\n\tRFlag *f = (RFlag*)user;\n\tRFlagItem *item;\n\tif (ok) {\n\t\t*ok = 0;\n\t}\n\titem = ht_find (f->ht_name, name, NULL);\n\tif (item) {\n\t\tif (item->alias) {\n\t\t\treturn 0LL;\n\t\t}\n\t\tif (ok) {\n\t\t\t*ok = 1;\n\t\t}\n\t\treturn item->offset;\n\t}\n\treturn 0LL;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void sctp_transport_reset(struct sctp_transport *t)\n{\n\tstruct sctp_association *asoc = t->asoc;\n\n\t/* RFC 2960 (bis), Section 5.2.4\n\t * All the congestion control parameters (e.g., cwnd, ssthresh)\n\t * related to this peer MUST be reset to their initial values\n\t * (see Section 6.2.1)\n\t */\n\tt->cwnd = min(4*asoc->pathmtu, max_t(__u32, 2*asoc->pathmtu, 4380));\n\tt->burst_limited = 0;\n\tt->ssthresh = asoc->peer.i.a_rwnd;\n\tt->rto = asoc->rto_initial;\n\tt->rtt = 0;\n\tt->srtt = 0;\n\tt->rttvar = 0;\n\n\t/* Reset these additional varibles so that we have a clean\n\t * slate.\n\t */\n\tt->partial_bytes_acked = 0;\n\tt->flight_size = 0;\n\tt->error_count = 0;\n\tt->rto_pending = 0;\n\tt->hb_sent = 0;\n\n\t/* Initialize the state information for SFR-CACC */\n\tt->cacc.changeover_active = 0;\n\tt->cacc.cycling_changeover = 0;\n\tt->cacc.next_tsn_at_change = 0;\n\tt->cacc.cacc_saw_newack = 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void uprobe_clear_state(struct mm_struct *mm)\n{\n\tstruct xol_area *area = mm->uprobes_state.xol_area;\n\n\tif (!area)\n\t\treturn;\n\n\tput_page(area->pages[0]);\n\tkfree(area->bitmap);\n\tkfree(area);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap_atomic(kaddr);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tup_write(&iinfo->i_data_sem);\n\terr = filemap_fdatawrite(inode->i_mapping);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(iinfo->i_data + iinfo->i_lenEAttr, kaddr, inode->i_size);\n\t\tkunmap_atomic(kaddr);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tput_page(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "SPL_METHOD(FilesystemIterator, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_FILE_DIR_KEY(intern, SPL_FILE_DIR_KEY_AS_FILENAME)) {\n\t\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n\t} else {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void shadow_page_table_clear_flood(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 spte;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, addr, iterator, spte)\n\t\tclear_sp_write_flooding_count(iterator.sptep);\n\twalk_shadow_page_lockless_end(vcpu);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "force_sig_info(int sig, struct siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\tif (action->sa.sa_handler == SIG_DFL)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = specific_send_sig_info(sig, info, t);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int con_init(struct XenDevice *xendev)\n\n{\n\n    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);\n\n    char *type, *dom;\n\n\n\n    /* setup */\n\n    dom = xs_get_domain_path(xenstore, con->xendev.dom);\n\n    snprintf(con->console, sizeof(con->console), \"%s/console\", dom);\n\n    free(dom);\n\n\n\n    type = xenstore_read_str(con->console, \"type\");\n\n    if (!type || strcmp(type, \"ioemu\") != 0) {\n\n\txen_be_printf(xendev, 1, \"not for me (type=%s)\\n\", type);\n\n\treturn -1;\n\n    }\n\n\n\n    if (!serial_hds[con->xendev.dev])\n\n\txen_be_printf(xendev, 1, \"WARNING: serial line %d not configured\\n\",\n\n                      con->xendev.dev);\n\n    else\n\n        con->chr = serial_hds[con->xendev.dev];\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int __init sha256_generic_mod_init(void)\n{\n\treturn crypto_register_shashes(sha256_algs, ARRAY_SIZE(sha256_algs));\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "S3BootScriptSaveIoWrite (\r\n  IN  S3_BOOT_SCRIPT_LIB_WIDTH          Width,\r\n  IN  UINT64                            Address,\r\n  IN  UINTN                             Count,\r\n  IN  VOID                              *Buffer\r\n  )\r\n\r\n{\r\n  UINT8                     Length;\r\n  UINT8                    *Script;\r\n  UINT8                     WidthInByte;\r\n  EFI_BOOT_SCRIPT_IO_WRITE  ScriptIoWrite;\r\n\r\n  WidthInByte = (UINT8) (0x01 << (Width & 0x03));\r\n  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_IO_WRITE) + (WidthInByte * Count));\r\n\r\n  Script = S3BootScriptGetEntryAddAddress (Length);\r\n  if (Script == NULL) {\r\n    return RETURN_OUT_OF_RESOURCES;\r\n  }\r\n  //\r\n  // save script data\r\n  //\r\n  ScriptIoWrite.OpCode  = EFI_BOOT_SCRIPT_IO_WRITE_OPCODE;\r\n  ScriptIoWrite.Length  = Length;\r\n  ScriptIoWrite.Width   = Width;\r\n  ScriptIoWrite.Address = Address;\r\n  ScriptIoWrite.Count   = (UINT32) Count;\r\n  CopyMem ((VOID*)Script, (VOID*)&ScriptIoWrite, sizeof(EFI_BOOT_SCRIPT_IO_WRITE));\r\n  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_IO_WRITE)), Buffer, WidthInByte * Count);\r\n\r\n  SyncBootScript (Script);\r\n\r\n  return RETURN_SUCCESS;\r\n}\r",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int ffurl_read_complete(URLContext *h, unsigned char *buf, int size)\n\n{\n\n    if (h->flags & AVIO_FLAG_WRITE)\n\n        return AVERROR(EIO);\n\n    return retry_transfer_wrapper(h, buf, size, size, h->prot->url_read);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static SCSIDiskReq *scsi_find_request(SCSIDiskState *s, uint32_t tag)\n\n{\n\n    return DO_UPCAST(SCSIDiskReq, req, scsi_req_find(&s->qdev, tag));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "MagickExport void ResetStringInfo(StringInfo *string_info)\n{\n  assert(string_info != (StringInfo *) NULL);\n  assert(string_info->signature == MagickCoreSignature);\n  (void) memset(string_info->datum,0,string_info->length);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "_nc_fmt_funcptr(char *target, const char *source, size_t size)\n{\n    size_t n;\n    char *dst = target;\n    bool leading = TRUE;\n\n    union {\n\tint value;\n\tchar bytes[sizeof(int)];\n    } byteorder;\n\n    byteorder.value = 0x1234;\n\n    *dst++ = '0';\n    *dst++ = 'x';\n\n    for (n = 0; n < size; ++n) {\n\tunsigned ch = ((byteorder.bytes[0] == 0x34)\n\t\t       ? UChar(source[size - n - 1])\n\t\t       : UChar(source[n]));\n\tif (ch != 0 || (n + 1) >= size)\n\t    leading = FALSE;\n\tif (!leading) {\n\t    _nc_SPRINTF(dst, _nc_SLIMIT(TR_FUNC_LEN - (dst - target))\n\t\t\t\"%02x\", ch & 0xff);\n\t    dst += 2;\n\t}\n    }\n    *dst = '\\0';\n    return target;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "NCR_TakeSourceOffline(NCR_Instance inst)\n{\n  switch (inst->opmode) {\n    case MD_ONLINE:\n      LOG(LOGS_INFO, LOGF_NtpCore, \"Source %s offline\", UTI_IPToString(&inst->remote_addr.ip_addr));\n      take_offline(inst);\n      break;\n    case MD_OFFLINE:\n      break;\n    case MD_BURST_WAS_ONLINE:\n      inst->opmode = MD_BURST_WAS_OFFLINE;\n      LOG(LOGS_INFO, LOGF_NtpCore, \"Source %s offline\", UTI_IPToString(&inst->remote_addr.ip_addr));\n      break;\n    case MD_BURST_WAS_OFFLINE:\n      break;\n  }\n\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void addrconf_sysctl_unregister(struct ipv6_devconf *p)\n{\n\tif (p->sysctl) {\n\t\tstruct addrconf_sysctl_table *t = p->sysctl;\n\t\tp->sysctl = NULL;\n\t\tunregister_sysctl_table(t->sysctl_header);\n\t\tkfree(t->addrconf_dev[0].procname);\n\t\tkfree(t);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n\n    return sRet + \"/\";\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)\n{\n if (parcel == NULL) {\n return NULL;\n }\n\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n\n const size_t size = p->readInt32();\n const void* regionData = p->readInplace(size);\n if (regionData == NULL) {\n\n         return NULL;\n     }\n     SkRegion* region = new SkRegion;\n    region->readFromMemory(regionData, size);\n \n     return reinterpret_cast<jlong>(region);\n }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void tb_htable_init(struct uc_struct *uc)\n{\n    unsigned int mode = QHT_MODE_AUTO_RESIZE;\n\n    qht_init(&uc->tcg_ctx->tb_ctx.htable, tb_cmp, CODE_GEN_HTABLE_SIZE, mode);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static htp_status_t htp_tx_res_process_body_data_decompressor_callback(htp_tx_data_t *d) {\n    if (d == NULL) return HTP_ERROR;\n\n    #if HTP_DEBUG\n    fprint_raw_data(stderr, __FUNCTION__, d->data, d->len);\n    #endif\n\n    // Keep track of actual response body length.\n    d->tx->response_entity_len += d->len;\n\n    // Invoke all callbacks.\n    htp_status_t rc = htp_res_run_hook_body_data(d->tx->connp, d);\n    if (rc != HTP_OK) return HTP_ERROR;\n\n    return HTP_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "ycbcr2l(UINT8 *out, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++, in += 4) {\n        *out++ = in[0];\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "chunk_free_unchecked(chunk_t *chunk)\n{\n  if (!chunk)\n    return;\n#ifdef DEBUG_CHUNK_ALLOC\n  tor_assert(CHUNK_ALLOC_SIZE(chunk->memlen) == chunk->DBG_alloc);\n#endif\n  tor_assert(total_bytes_allocated_in_chunks >=\n             CHUNK_ALLOC_SIZE(chunk->memlen));\n  total_bytes_allocated_in_chunks -= CHUNK_ALLOC_SIZE(chunk->memlen);\n  tor_free(chunk);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static EAS_I16 ConvertSampleRate (EAS_U32 sampleRate)\n{\n return (EAS_I16) (1200.0 * log10((double) sampleRate / (double) outputSampleRate) / log10(2.0));\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "ByteOrder Image::byteOrder() const\n    {\n        return byteOrder_;\n    }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void http_write_packet(void *opaque, \n\n                              unsigned char *buf, int size)\n\n{\n\n    HTTPContext *c = opaque;\n\n\n\n    if (c->buffer_ptr == c->buffer_end || !c->buffer_ptr)\n\n        c->buffer_ptr = c->buffer_end = c->buffer;\n\n\n\n    if (c->buffer_end - c->buffer + size > IOBUFFER_MAX_SIZE)\n\n        abort();\n\n\n\n    memcpy(c->buffer_end, buf, size);\n\n    c->buffer_end += size;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "android::SoftOMXComponent *createSoftOMXComponent(\n const char *name, const OMX_CALLBACKTYPE *callbacks,\n        OMX_PTR appData, OMX_COMPONENTTYPE **component) {\n return new android::SoftMP3(name, callbacks, appData, component);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "long DataValue::count() const\n    {\n        return size();\n    }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void nfs_write_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_write_data *data = calldata;\n\tNFS_PROTO(data->header->inode)->write_rpc_prepare(task, data);\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &data->args.context->flags)))\n\t\trpc_exit(task, -EIO);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "**/\n    CImg<T>& operator>>=(const char *const expression) {\n      return *this>>=(+*this)._fill(expression,true,true,0,0,\"operator>>=\",this);",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "  void encode(bufferlist& bl) const {\n    __u8 struct_v = 1;\n    ::encode(struct_v, bl);\n    ::encode(nonce, bl);\n  }",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "dummy_symbol_get (location loc)\n{\n  /* Incremented for each generated symbol.  */\n  static int dummy_count = 0;\n  char buf[32];\n  int len = snprintf (buf, sizeof buf, \"$@%d\", ++dummy_count);\n  assure (len < sizeof buf);\n  symbol *sym = symbol_get (buf, loc);\n  sym->content->class = nterm_sym;\n  sym->content->number = nnterms++;\n  return sym;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "Parser::TokIsForInOrForOf()\n{\n    return m_token.tk == tkIN ||\n        (m_token.tk == tkID &&\n         m_token.GetIdentifier(m_phtbl) == wellKnownPropertyPids.of);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int mxf_add_metadata_set(MXFContext *mxf, void *metadata_set)\n\n{\n\n\n\n    mxf->metadata_sets = av_realloc(mxf->metadata_sets, (mxf->metadata_sets_count + 1) * sizeof(*mxf->metadata_sets));\n\n    if (!mxf->metadata_sets)\n\n        return -1;\n\n    mxf->metadata_sets[mxf->metadata_sets_count] = metadata_set;\n\n    mxf->metadata_sets_count++;\n\n    return 0;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "WebKit::WebPeerConnectionHandler* MediaStreamImpl::CreatePeerConnectionHandler(\n    WebKit::WebPeerConnectionHandlerClient* client) {\n  DCHECK(CalledOnValidThread());\n  if (peer_connection_handler_) {\n    DVLOG(1) << \"A PeerConnection already exists\";\n    return NULL;\n  }\n  EnsurePeerConnectionFactory();\n\n  peer_connection_handler_ = new PeerConnectionHandler(\n      client,\n      this,\n      dependency_factory_.get());\n\n  return peer_connection_handler_;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void replication_close(BlockDriverState *bs)\n\n{\n\n    BDRVReplicationState *s = bs->opaque;\n\n\n\n    if (s->replication_state == BLOCK_REPLICATION_RUNNING) {\n\n        replication_stop(s->rs, false, NULL);\n\n\n\n\n\n\n\n    if (s->mode == REPLICATION_MODE_SECONDARY) {\n\n        g_free(s->top_id);\n\n\n\n\n    replication_remove(s->rs);\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static inline void RENAME(rgb24ToY)(uint8_t *dst, uint8_t *src, int width)\n\n{\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tint r= src[i*3+0];\n\n\t\tint g= src[i*3+1];\n\n\t\tint b= src[i*3+2];\n\n\n\n\t\tdst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);\n\n\t}\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "nvmet_fc_tgt_q_put(struct nvmet_fc_tgt_queue *queue)\n{\n\tkref_put(&queue->ref, nvmet_fc_tgt_queue_free);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void vnc_dpy_update(DisplayChangeListener *dcl,\n\n                           DisplayState *ds,\n\n                           int x, int y, int w, int h)\n\n{\n\n    int i;\n\n    VncDisplay *vd = ds->opaque;\n\n    struct VncSurface *s = &vd->guest;\n\n    int width = ds_get_width(ds);\n\n    int height = ds_get_height(ds);\n\n\n\n    h += y;\n\n\n\n    /* round x down to ensure the loop only spans one 16-pixel block per,\n\n       iteration.  otherwise, if (x % 16) != 0, the last iteration may span\n\n       two 16-pixel blocks but we only mark the first as dirty\n\n    */\n\n    w += (x % 16);\n\n    x -= (x % 16);\n\n\n\n    x = MIN(x, width);\n\n    y = MIN(y, height);\n\n    w = MIN(x + w, width) - x;\n\n    h = MIN(h, height);\n\n\n\n    for (; y < h; y++)\n\n        for (i = 0; i < w; i += 16)\n\n            set_bit((x + i) / 16, s->dirty[y]);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static av_always_inline int simple_limit(uint8_t *p, ptrdiff_t stride, int flim)\n\n{\n\n    LOAD_PIXELS\n\n    return 2 * FFABS(p0 - q0) + (FFABS(p1 - q1) >> 1) <= flim;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "Ins_ROUND( TT_ExecContext  exc,\n             FT_Long*        args )\n  {\n    args[0] = exc->func_round(\n                exc,\n                args[0],\n                exc->tt_metrics.compensations[exc->opcode - 0x68] );\n  }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "rdpsnd_reset_state(void)\n{\n\tif (device_open)\n\t\tcurrent_driver->wave_out_close();\n\tdevice_open = False;\n\trdpsnd_queue_clear();\n\trdpsnd_negotiated = False;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "jbig2_sd_release(Jbig2Ctx *ctx, Jbig2SymbolDict *dict)\n {\n    uint32_t i;\n \n     if (dict == NULL)\n         return;\n    for (i = 0; i < dict->n_symbols; i++)\n        if (dict->glyphs[i])\n            jbig2_image_release(ctx, dict->glyphs[i]);\n    jbig2_free(ctx->allocator, dict->glyphs);\n    jbig2_free(ctx->allocator, dict);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static PassRefPtr<Range> characterSubrange(CharacterIterator& it, int offset, int length)\n{\n    it.advance(offset);\n    RefPtr<Range> start = it.range();\n\n    if (length > 1)\n        it.advance(length - 1);\n    RefPtr<Range> end = it.range();\n\n    return Range::create(start->startContainer()->document(), \n        start->startContainer(), start->startOffset(), \n        end->endContainer(), end->endOffset());\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "TIFFFdOpen(int ifd, const char* name, const char* mode)\n{\n\tTIFF* tif;\n\tint fSuppressMap;\n\tint m;\n\tfSuppressMap=0;\n\tfor (m=0; mode[m]!=0; m++)\n\t{\n\t\tif (mode[m]=='u')\n\t\t{\n\t\t\tfSuppressMap=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttif = TIFFClientOpen(name, mode, (thandle_t)ifd,\n\t\t\t_tiffReadProc, _tiffWriteProc,\n\t\t\t_tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n\t\t\tfSuppressMap ? _tiffDummyMapProc : _tiffMapProc,\n\t\t\tfSuppressMap ? _tiffDummyUnmapProc : _tiffUnmapProc);\n\tif (tif)\n\t\ttif->tif_fd = ifd;\n\treturn (tif);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void Compute(OpKernelContext* ctx) override {\n    auto x = ctx->input(0);\n    auto i = ctx->input(1);\n    auto v = ctx->input(2);\n\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(i.shape()),\n                errors::InvalidArgument(\"i must be a vector. \",\n                                        i.shape().DebugString()));\n    OP_REQUIRES(ctx, x.dims() == v.dims(),\n                errors::InvalidArgument(\n                    \"x and v shape doesn't match (ranks differ): \",\n                    x.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    for (int i = 1; i < x.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, x.dim_size(i) == v.dim_size(i),\n          errors::InvalidArgument(\"x and v shape doesn't match at index \", i,\n                                  \" : \", x.shape().DebugString(), \" vs. \",\n                                  v.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),\n                errors::InvalidArgument(\n                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n\n    Tensor y = x;  // This creates an alias intentionally.\n    // Skip processing if tensors are empty.\n    if (x.NumElements() > 0 || v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "bool canSeek() const { return m_canSeek; }",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n\n    /*\n       We later alloc length+1, which might wrap around on 32-bit systems if length equals\n       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF\n       will safely be allocated since this check will never trigger and malloc() can digest length+1\n       without problems as length is a uint32_t.\n    */\n    if(length == SIZE_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                /* NOTE: don't forget to free(buffer) if you return early! */\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            /* Null Terminate */\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n\t\t\t+ sgi_clock_offset.tv_sec;\n\treturn 0;\n};",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void OnSetIsInert(bool is_inert) {\n    base::PostTaskWithTraits(\n        FROM_HERE, {content::BrowserThread::UI},\n        base::BindOnce(&SetIsInertMessageFilter::OnSetIsInertOnUI, this,\n                       is_inert));\n  }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void powernv_populate_chip(PnvChip *chip, void *fdt)\n{\n    PnvChipClass *pcc = PNV_CHIP_GET_CLASS(chip);\n    char *typename = pnv_core_typename(pcc->cpu_model);\n    size_t typesize = object_type_get_instance_size(typename);\n    int i;\n    for (i = 0; i < chip->nr_cores; i++) {\n        PnvCore *pnv_core = PNV_CORE(chip->cores + i * typesize);\n        powernv_create_core_node(chip, pnv_core, fdt);\n    }\n    if (chip->ram_size) {\n        powernv_populate_memory_node(fdt, chip->chip_id, chip->ram_start,\n                                     chip->ram_size);\n    }\n    g_free(typename);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int snd_timer_continue(struct snd_timer_instance *timeri)\n{\n\t/* timer can continue only after pause */\n\tif (!(timeri->flags & SNDRV_TIMER_IFLG_PAUSED))\n\t\treturn -EINVAL;\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_start_slave(timeri, false);\n\telse\n\t\treturn snd_timer_start1(timeri, false, 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "auto any_cast(Args &&... args)\n    -> decltype(std::any_cast<T>(std::forward<Args>(args)...)) {\n  return std::any_cast<T>(std::forward<Args>(args)...);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\n \tif (current->flags & PF_RANDOMIZE)\n \t\trandom_factor = arch_mmap_rnd();\n \n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n \n \tif (mmap_is_legacy()) {\n \t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "ScreenLayoutObserver::~ScreenLayoutObserver() {\n  ShellPort::Get()->RemoveDisplayObserver(this);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "fbCombineDisjointOutC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    fbCombineDisjointGeneralC (dest, src, mask, width, CombineAOut);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void prep_temp_blob(struct diff_tempfile *temp,\n\t\t\t   void *blob,\n\t\t\t   unsigned long size,\n\t\t\t   const unsigned char *sha1,\n\t\t\t   int mode)\n{\n\tint fd;\n\n\tfd = git_mkstemp(temp->tmp_path, PATH_MAX, \".diff_XXXXXX\");\n\tif (fd < 0)\n\t\tdie(\"unable to create temp-file: %s\", strerror(errno));\n\tif (write_in_full(fd, blob, size) != size)\n\t\tdie(\"unable to write temp-file\");\n\tclose(fd);\n\ttemp->name = temp->tmp_path;\n\tstrcpy(temp->hex, sha1_to_hex(sha1));\n\ttemp->hex[40] = 0;\n\tsprintf(temp->mode, \"%06o\", mode);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "proc_lambda(mrb_state *mrb, mrb_value self)\n{\n  mrb_value blk;\n  struct RProc *p;\n\n  mrb_get_args(mrb, \"&\", &blk);\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"tried to create Proc object without a block\");\n  }\n  if (!mrb_proc_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  p = mrb_proc_ptr(blk);\n  if (!MRB_PROC_STRICT_P(p)) {\n    struct RProc *p2 = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, p->c);\n    mrb_proc_copy(p2, p);\n    p2->flags |= MRB_PROC_STRICT;\n    return mrb_obj_value(p2);\n  }\n  return blk;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.getStringView());\n  if (cb) {\n    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      value.clear();\n    }\n  } else {\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void APE::Properties::analyzeCurrent()\n{\n  // Read the descriptor\n  d->file->seek(2, File::Current);\n  ByteVector descriptor = d->file->readBlock(44);\n  uint descriptorBytes = descriptor.mid(0,4).toUInt(false);\n\n  if ((descriptorBytes - 52) > 0)\n    d->file->seek(descriptorBytes - 52, File::Current);\n\n  // Read the header\n  ByteVector header = d->file->readBlock(24);\n\n  // Get the APE info\n  d->channels = header.mid(18, 2).toShort(false);\n  d->sampleRate = header.mid(20, 4).toUInt(false);\n  d->bitsPerSample = header.mid(16, 2).toShort(false);\n  //d->compressionLevel =\n\n  uint totalFrames = header.mid(12, 4).toUInt(false);\n  uint blocksPerFrame = header.mid(4, 4).toUInt(false);\n  uint finalFrameBlocks = header.mid(8, 4).toUInt(false);\n  uint totalBlocks = totalFrames > 0 ? (totalFrames -  1) * blocksPerFrame + finalFrameBlocks : 0;\n  d->length = totalBlocks / d->sampleRate;\n  d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void PaymentRequestState::SetSelectedInstrument(PaymentInstrument* instrument) {\n  selected_instrument_ = instrument;\n  UpdateIsReadyToPayAndNotifyObservers();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int ewk_view_setting_font_default_size_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, 0);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, 0);\n    return priv->settings.fontDefaultSize;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void ffs_data_clear(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tffs_closed(ffs);\n\n\tBUG_ON(ffs->gadget);\n\n\tif (ffs->epfiles)\n\t\tffs_epfiles_destroy(ffs->epfiles, ffs->eps_count);\n\n\tif (ffs->ffs_eventfd)\n\t\teventfd_ctx_put(ffs->ffs_eventfd);\n\n\tkfree(ffs->raw_descs_data);\n\tkfree(ffs->raw_strings);\n\tkfree(ffs->stringtabs);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "MagickPrivate ColorspaceType GetPixelCacheColorspace(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  return(cache_info->colorspace);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void InstanceKlass::release_C_heap_structures() {\n\n  // Clean up C heap\n  release_C_heap_structures_internal();\n  constants()->release_C_heap_structures();\n\n  // Deallocate and call destructors for MDO mutexes\n  methods_do(method_release_C_heap_structures);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "virtual void visit(User & /*ope*/) {}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "TEST_F(ExprMatchTest, ConstantPositiveNumberExpressionMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: 1}\"));\n\n    ASSERT_TRUE(matches(BSON(\"x\" << 2)));\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "cid_parse_font_matrix( CID_Face     face,\n                         CID_Parser*  parser )\n  {\n    CID_FaceDict  dict;\n    FT_Face       root = (FT_Face)&face->root;\n    FT_Fixed      temp[6];\n    FT_Fixed      temp_scale;\n\n\n    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )\n     {\n       FT_Matrix*  matrix;\n       FT_Vector*  offset;\n \n \n       dict   = face->cid.font_dicts + parser->num_dict;\n       matrix = &dict->font_matrix;\n       offset = &dict->font_offset;\n \n      (void)cid_parser_to_fixed_array( parser, 6, temp, 3 );\n \n       temp_scale = FT_ABS( temp[3] );\n \n       /* Set Units per EM based on FontMatrix values.  We set the value to */\n       /* 1000 / temp_scale, because temp_scale was already multiplied by   */\n       /* 1000 (in t1_tofixed, from psobjs.c).                              */\n        temp[5] = FT_DivFix( temp[5], temp_scale );\n        temp[3] = 0x10000L;\n      }\n\n      matrix->xx = temp[0];\n      matrix->yx = temp[1];\n      matrix->xy = temp[2];\n      matrix->yy = temp[3];\n         temp[2] = FT_DivFix( temp[2], temp_scale );\n         temp[4] = FT_DivFix( temp[4], temp_scale );\n         temp[5] = FT_DivFix( temp[5], temp_scale );\n        temp[3] = 0x10000L;\n       }",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int snd_timer_user_start(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tsnd_timer_stop(tu->timeri);\n\ttu->timeri->lost = 0;\n\ttu->last_resolution = 0;\n\treturn (err = snd_timer_start(tu->timeri, tu->ticks)) < 0 ? err : 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "lldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n\n    tlen = len;\n    tptr = pptr;\n\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n\n    /*\n     * The OID is optional.\n     */\n     if (tlen) {\n         oid_len = *tptr;\n \n        if (tlen < oid_len) {\n             return 0;\n         }\n         if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n\n    return 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\n\t//ok, not self contained, let's go for it...\n\t//we don't know what's a URN yet\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static ssize_t snd_disconnect_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t count, loff_t *offset)\n{\n\treturn -ENODEV;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static unsigned long convert_eip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->eip;\n\tseg = regs->xcs & 0xffff;\n\tif (regs->eflags & VM_MASK) {\n\t\taddr = (addr & 0xffff) + (seg << 4);\n\t\treturn addr;\n\t}\n\n\t/*\n\t * We'll assume that the code segments in the GDT\n\t * are all zero-based. That is largely true: the\n\t * TLS segments are used for data, and the PNPBIOS\n\t * and APM bios ones we just ignore here.\n\t */\n\tif (seg & LDT_SEGMENT) {\n\t\tu32 *desc;\n\t\tunsigned long base;\n\n\t\tdown(&child->mm->context.sem);\n\t\tdesc = child->mm->context.ldt + (seg & ~7);\n\t\tbase = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);\n\n\t\t/* 16-bit code segment? */\n\t\tif (!((desc[1] >> 22) & 1))\n\t\t\taddr &= 0xffff;\n\t\taddr += base;\n\t\tup(&child->mm->context.sem);\n\t}\n\treturn addr;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int ax25_rt_opt(struct ax25_route_opt_struct *rt_option)\n{\n\tax25_route *ax25_rt;\n\tax25_dev *ax25_dev;\n\tint err = 0;\n\n\tif ((ax25_dev = ax25_addr_ax25dev(&rt_option->port_addr)) == NULL)\n\t\treturn -EINVAL;\n\n\twrite_lock_bh(&ax25_route_lock);\n\n\tax25_rt = ax25_route_list;\n\twhile (ax25_rt != NULL) {\n\t\tif (ax25_rt->dev == ax25_dev->dev &&\n\t\t    ax25cmp(&rt_option->dest_addr, &ax25_rt->callsign) == 0) {\n\t\t\tswitch (rt_option->cmd) {\n\t\t\tcase AX25_SET_RT_IPMODE:\n\t\t\t\tswitch (rt_option->arg) {\n\t\t\t\tcase ' ':\n\t\t\t\tcase 'D':\n\t\t\t\tcase 'V':\n\t\t\t\t\tax25_rt->ip_mode = rt_option->arg;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tax25_rt = ax25_rt->next;\n\t}\n\nout:\n\twrite_unlock_bh(&ax25_route_lock);\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static ssize_t ap_request_count_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct ap_device *ap_dev = to_ap_dev(dev);\n\tint rc;\n\n\tspin_lock_bh(&ap_dev->lock);\n\trc = snprintf(buf, PAGE_SIZE, \"%d\\n\", ap_dev->total_request_count);\n\tspin_unlock_bh(&ap_dev->lock);\n\treturn rc;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int skfp_ctl_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tstruct sockaddr *p_sockaddr = (struct sockaddr *) addr;\n\tskfddi_priv *bp = &smc->os;\n\tunsigned long Flags;\n\n\n\tmemcpy(dev->dev_addr, p_sockaddr->sa_data, FDDI_K_ALEN);\n\tspin_lock_irqsave(&bp->DriverLock, Flags);\n\tResetAdapter(smc);\n\tspin_unlock_irqrestore(&bp->DriverLock, Flags);\n\n\treturn (0);\t\t/* always return zero */\n}\t\t\t\t// skfp_ctl_set_mac_address",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "bool ZipCommon::isValidPath(const std::string& path)\n{\n\tif (path == \"..\")\n\t\treturn false;\n\tif (path.compare(0, 3, \"../\") == 0)\n\t\treturn false;\n\tif (path.compare(0, 3, \"..\\\\\") == 0)\n\t\treturn false;\n\tif (path.find(\"/..\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\..\") != std::string::npos)\n\t\treturn false;\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int xan_decode_init(AVCodecContext *avctx)\n{\n    XanContext *s = avctx->priv_data;\n    int i;\n    s->avctx = avctx;\n    if ((avctx->codec->id == CODEC_ID_XAN_WC3) && \n        (s->avctx->palctrl == NULL)) {\n        av_log(avctx, AV_LOG_ERROR, \" WC3 Xan video: palette expected.\\n\");\n    }\n    avctx->pix_fmt = PIX_FMT_PAL8;\n    avctx->has_b_frames = 0;\n    dsputil_init(&s->dsp, avctx);\n    /* initialize the RGB -> YUV tables */\n    for (i = 0; i < 256; i++) {\n        y_r_table[i] = Y_R * i;\n        y_g_table[i] = Y_G * i;\n        y_b_table[i] = Y_B * i;\n        u_r_table[i] = U_R * i;\n        u_g_table[i] = U_G * i;\n        u_b_table[i] = U_B * i;\n        v_r_table[i] = V_R * i;\n        v_g_table[i] = V_G * i;\n        v_b_table[i] = V_B * i;\n    }\n    s->buffer1 = av_malloc(avctx->width * avctx->height);\n    s->buffer2 = av_malloc(avctx->width * avctx->height);\n    if (!s->buffer1 || !s->buffer2)\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "ArgParser::argOiMinWidth(char* parameter)\n{\n    o.oi_min_width = QUtil::string_to_int(parameter);\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline signed int ReadPropertyMSBLong(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[4];\n\n  size_t\n    value;\n\n  if (*length < 4)\n    return(-1);\n  for (i=0; i < 4; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(size_t) (buffer[0] << 24);\n  value|=buffer[1] << 16;\n  value|=buffer[2] << 8;\n  value|=buffer[3];\n  quantum.unsigned_value=(value & 0xffffffff);\n  return(quantum.signed_value);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int translate_desc(struct vhost_dev *dev, u64 addr, u32 len,\n\t\t\t  struct iovec iov[], int iov_size)\n{\n\tconst struct vhost_memory_region *reg;\n\tstruct vhost_memory *mem;\n\tstruct iovec *_iov;\n\tu64 s = 0;\n\tint ret = 0;\n\n\trcu_read_lock();\n\n\tmem = rcu_dereference(dev->memory);\n\twhile ((u64)len > s) {\n\t\tu64 size;\n\t\tif (unlikely(ret >= iov_size)) {\n\t\t\tret = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\treg = find_region(mem, addr, len);\n\t\tif (unlikely(!reg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t_iov = iov + ret;\n\t\tsize = reg->memory_size - addr + reg->guest_phys_addr;\n\t\t_iov->iov_len = min((u64)len, size);\n\t\t_iov->iov_base = (void __user *)(unsigned long)\n\t\t\t(reg->userspace_addr + addr - reg->guest_phys_addr);\n\t\ts += size;\n\t\taddr += size;\n\t\t++ret;\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "TEST(FieldPath, RemoveOptimizesToMissingValue) {\n    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());\n    intrusive_ptr<ExpressionFieldPath> expression =\n        ExpressionFieldPath::parse(expCtx, \"$$REMOVE\", expCtx->variablesParseState);\n\n    auto optimizedExpr = expression->optimize();\n\n    ASSERT_VALUE_EQ(Value(), optimizedExpr->evaluate(Document(BSON(\"x\" << BSON(\"y\" << 123)))));\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tstruct proc_inode *ei;\n\n\tif (flags & MS_KERNMOUNT)\n\t\tns = (struct pid_namespace *)data;\n\telse\n\t\tns = current->nsproxy->pid_ns;\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!sb->s_root) {\n\t\tsb->s_flags = flags;\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\tei = PROC_I(sb->s_root->d_inode);\n\tif (!ei->pid) {\n\t\trcu_read_lock();\n\t\tei->pid = get_pid(find_pid_ns(1, ns));\n\t\trcu_read_unlock();\n\t}\n\n\treturn dget(sb->s_root);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static long pmcraid_ioctl_driver(\n\tstruct pmcraid_instance *pinstance,\n\tunsigned int cmd,\n\tunsigned int buflen,\n\tvoid __user *user_buffer\n)\n{\n\tint rc = -ENOSYS;\n\n\tif (!access_ok(VERIFY_READ, user_buffer, _IOC_SIZE(cmd))) {\n\t\tpmcraid_err(\"ioctl_driver: access fault in request buffer\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tswitch (cmd) {\n\tcase PMCRAID_IOCTL_RESET_ADAPTER:\n\t\tpmcraid_reset_bringup(pinstance);\n\t\trc = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void increase_released_buffer_count() { released_buffer_count_++; }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static uint32_t get_features(VirtIODevice *vdev, uint32_t features)\n\n{\n\n    VirtIOSerial *vser;\n\n\n\n    vser = DO_UPCAST(VirtIOSerial, vdev, vdev);\n\n\n\n    if (vser->bus->max_nr_ports > 1) {\n\n        features |= (1 << VIRTIO_CONSOLE_F_MULTIPORT);\n\n    }\n\n    return features;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki)\n{\n    EVP_PKEY *pkey;\n    ASN1_IA5STRING *chal;\n    ASN1_OBJECT *spkioid;\n    int i, n;\n    char *s;\n    BIO_printf(out, \"Netscape SPKI:\\n\");\n    X509_PUBKEY_get0_param(&spkioid, NULL, NULL, NULL, spki->spkac->pubkey);\n    i = OBJ_obj2nid(spkioid);\n    BIO_printf(out, \"  Public Key Algorithm: %s\\n\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    pkey = X509_PUBKEY_get(spki->spkac->pubkey);\n    if (!pkey)\n        BIO_printf(out, \"  Unable to load public key\\n\");\n    else {\n        EVP_PKEY_print_public(out, pkey, 4, NULL);\n        EVP_PKEY_free(pkey);\n    }\n    chal = spki->spkac->challenge;\n    if (chal->length)\n        BIO_printf(out, \"  Challenge String: %s\\n\", chal->data);\n    i = OBJ_obj2nid(spki->sig_algor.algorithm);\n    BIO_printf(out, \"  Signature Algorithm: %s\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n\n    n = spki->signature->length;\n    s = (char *)spki->signature->data;\n    for (i = 0; i < n; i++) {\n        if ((i % 18) == 0)\n            BIO_write(out, \"\\n      \", 7);\n        BIO_printf(out, \"%02x%s\", (unsigned char)s[i],\n                   ((i + 1) == n) ? \"\" : \":\");\n    }\n    BIO_write(out, \"\\n\", 1);\n    return 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int is_valid_entry(HashEntry* entry)\n{\n    if (entry != NULL) {\n        int i;\n        for (i = 0 ; i < HASHTABLE_SIZE ; i++) {\n            HashEntry* e1 = gHashTable.slots[i];\n\n            while (e1 != NULL) {\n                if (e1 == entry) {\n                    return 1;\n                }\n\n                e1 = e1->next;\n            }\n        }\n    }\n\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "StringVal EncryptionFunctions::to_base64(FunctionContext* ctx, const StringVal& src) {\n    if (src.len == 0 || src.is_null) {\n        return StringVal::null();\n    }\n\n    int cipher_len = (size_t)(4.0 * ceil((double)src.len / 3.0));\n    std::unique_ptr<char[]> p;\n    p.reset(new char[cipher_len]);\n\n    int ret_code = base64_encode((unsigned char*)src.ptr, src.len, (unsigned char*)p.get());\n    if (ret_code < 0) {\n        return StringVal::null();\n    }\n    return AnyValUtil::from_buffer_temp(ctx, p.get(), ret_code);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "FixCom* FixCom::clone_() const\n    {\n        return new FixCom(*this);\n    }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void virtio_balloon_set_config(VirtIODevice *vdev,\n\n                                      const uint8_t *config_data)\n\n{\n\n    VirtIOBalloon *dev = VIRTIO_BALLOON(vdev);\n\n    struct virtio_balloon_config config;\n\n    uint32_t oldactual = dev->actual;\n\n    memcpy(&config, config_data, 8);\n\n    dev->actual = le32_to_cpu(config.actual);\n\n    if (dev->actual != oldactual) {\n\n        qemu_balloon_changed(ram_size -\n\n                             (dev->actual << VIRTIO_BALLOON_PFN_SHIFT));\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int enc_untrusted_getrusage(int who, struct rusage *usage) {\n  struct klinux_rusage klinux_usage {};\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_getrusage, TokLinuxRusageTarget(who),\n      &klinux_usage);\n\n  if (result != -1) {\n    if (!FromkLinuxRusage(&klinux_usage, usage)) {\n      errno = EINVAL;\n      return -1;\n    }\n  }\n  return result;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void rgb16tobgr24(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tconst uint16_t *end;\n\n\tuint8_t *d = (uint8_t *)dst;\n\n\tconst uint16_t *s = (const uint16_t *)src;\n\n\tend = s + src_size/2;\n\n\twhile(s < end)\n\n\t{\n\n\t\tregister uint16_t bgr;\n\n\t\tbgr = *s++;\n\n\t\t*d++ = (bgr&0xF800)>>8;\n\n\t\t*d++ = (bgr&0x7E0)>>3;\n\n\t\t*d++ = (bgr&0x1F)<<3;\n\n\t}\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "gst_h264_create_sei_memory (guint8 start_code_prefix_length, GArray * messages)\n{\n  g_return_val_if_fail (start_code_prefix_length == 3\n      || start_code_prefix_length == 4, NULL);\n  g_return_val_if_fail (messages != NULL, NULL);\n  g_return_val_if_fail (messages->len > 0, NULL);\n\n  return gst_h264_create_sei_memory_internal (start_code_prefix_length,\n      FALSE, messages);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static pid_t qtest_qemu_pid(QTestState *s)\n\n{\n\n    FILE *f;\n\n    char buffer[1024];\n\n    pid_t pid = -1;\n\n\n\n    f = fopen(s->pid_file, \"r\");\n\n    if (f) {\n\n        if (fgets(buffer, sizeof(buffer), f)) {\n\n            pid = atoi(buffer);\n\n        }\n\n        fclose(f);\n\n    }\n\n    return pid;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "consensus_method_is_supported(int method)\n{\n  if (method == MIN_METHOD_FOR_ED25519_ID_IN_MD) {\n    /* This method was broken due to buggy code accidently left in\n     * dircollate.c; do not actually use it.\n     */\n    return 0;\n  }\n\n  return (method >= MIN_SUPPORTED_CONSENSUS_METHOD) &&\n    (method <= MAX_SUPPORTED_CONSENSUS_METHOD);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "_nc_leaks_dump_entry(void)\n{\n    free_DYN(&outbuf);\n    free_DYN(&tmpbuf);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void free_test_data(test_data *data)\n\n{\n\n    AcpiSdtTable *temp;\n\n    int i;\n\n\n\n    g_free(data->rsdt_tables_addr);\n\n\n\n    for (i = 0; i < data->tables->len; ++i) {\n\n        temp = &g_array_index(data->tables, AcpiSdtTable, i);\n\n        g_free(temp->aml);\n\n        if (temp->aml_file &&\n\n            !temp->tmp_files_retain &&\n\n            g_strstr_len(temp->aml_file, -1, \"aml-\")) {\n\n            unlink(temp->aml_file);\n\n        }\n\n        g_free(temp->aml_file);\n\n        g_free(temp->asl);\n\n        if (temp->asl_file &&\n\n            !temp->tmp_files_retain) {\n\n            unlink(temp->asl_file);\n\n        }\n\n        g_free(temp->asl_file);\n\n    }\n\n\n\n    g_array_free(data->tables, false);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)\n{\n\tunsigned long ideal_runtime, delta_exec;\n\n\tideal_runtime = sched_slice(cfs_rq, curr);\n\tdelta_exec = curr->sum_exec_runtime - curr->prev_sum_exec_runtime;\n\tif (delta_exec > ideal_runtime)\n\t\tresched_task(rq_of(cfs_rq)->curr);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void touch_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud)\n{\n\tpud_t _pud;\n\n\t/*\n\t * We should set the dirty bit only for FOLL_WRITE but for now\n\t * the dirty bit in the pud is meaningless.  And if the dirty\n\t * bit will become meaningful and we'll only set it with\n\t * FOLL_WRITE, an atomic set_bit will be required on the pud to\n\t * set the young bit, instead of the current set_pud_at.\n\t */\n\t_pud = pud_mkyoung(pud_mkdirty(*pud));\n\tif (pudp_set_access_flags(vma, addr & HPAGE_PUD_MASK,\n\t\t\t\tpud, _pud,  1))\n\t\tupdate_mmu_cache_pud(vma, addr, pud);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static Jsi_OptionSpec * jsi_GetCachedOptionSpecs(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)\n{\n    return (Jsi_OptionSpec *)staticSpecs;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void __timer_stats_timer_set_start_info(struct timer_list *timer, void *addr)\n{\n\tif (timer->start_site)\n\t\treturn;\n\n\ttimer->start_site = addr;\n\tmemcpy(timer->start_comm, current->comm, TASK_COMM_LEN);\n\ttimer->start_pid = current->pid;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int io_uring_get_fd(struct io_ring_ctx *ctx)\n{\n\tstruct file *file;\n\tint ret;\n\n#if defined(CONFIG_UNIX)\n\tret = sock_create_kern(&init_net, PF_UNIX, SOCK_RAW, IPPROTO_IP,\n\t\t\t\t&ctx->ring_sock);\n\tif (ret)\n\t\treturn ret;\n#endif\n\n\tret = get_unused_fd_flags(O_RDWR | O_CLOEXEC);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tfile = anon_inode_getfile(\"[io_uring]\", &io_uring_fops, ctx,\n\t\t\t\t\tO_RDWR | O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(ret);\n\t\tret = PTR_ERR(file);\n\t\tgoto err;\n\t}\n\n#if defined(CONFIG_UNIX)\n\tctx->ring_sock->file = file;\n#endif\n\tfd_install(ret, file);\n\treturn ret;\nerr:\n#if defined(CONFIG_UNIX)\n\tsock_release(ctx->ring_sock);\n\tctx->ring_sock = NULL;\n#endif\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "zip_reduce(zipobject *lz, PyObject *Py_UNUSED(ignored))\n{\n    /* Just recreate the zip with the internal iterator tuple */\n    return Py_BuildValue(\"OO\", Py_TYPE(lz), lz->ittuple);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool ConfirmInfoBarDelegate::OKButtonTriggersUACPrompt() const {\n  return false;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline void load_mm_cr4(struct mm_struct *mm) {}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "SProcXIChangeHierarchy(ClientPtr client)\n{\n    REQUEST(xXIChangeHierarchyReq);\n    swaps(&stuff->length);\n    return (ProcXIChangeHierarchy(client));\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "local void zlib_free(voidpf opaque, voidpf address)\n{\n    free_track(opaque, address);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "exif_data_log (ExifData *data, ExifLog *log)\n{\n\tunsigned int i;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\texif_log_unref (data->priv->log);\n\tdata->priv->log = log;\n\texif_log_ref (log);\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++)\n\t\texif_content_log (data->ifd[i], log);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void ERROR(const char *str)\n\n{\n\n        fprintf(stderr, \"%s\\n\", str);\n\n        exit(1);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "option_nofilesystem_cb (const gchar *option_name,\n                        const gchar *value,\n                        gpointer     data,\n                        GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_context_verify_filesystem (value, error))\n    return FALSE;\n\n  flatpak_context_remove_filesystem (context, value);\n  return TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static struct audio_usecase *get_usecase_from_type(struct audio_device *adev,\n usecase_type_t type)\n{\n struct audio_usecase *usecase;\n struct listnode *node;\n\n    list_for_each(node, &adev->usecase_list) {\n        usecase = node_to_item(node, struct audio_usecase, adev_list_node);\n if (usecase->type & type)\n return usecase;\n }\n return NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void rb_free_cpu_buffer(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct list_head *head = cpu_buffer->pages;\n\tstruct buffer_page *bpage, *tmp;\n\n\tfree_buffer_page(cpu_buffer->reader_page);\n\n\trb_head_page_deactivate(cpu_buffer);\n\n\tif (head) {\n\t\tlist_for_each_entry_safe(bpage, tmp, head, list) {\n\t\t\tlist_del_init(&bpage->list);\n\t\t\tfree_buffer_page(bpage);\n\t\t}\n\t\tbpage = list_entry(head, struct buffer_page, list);\n\t\tfree_buffer_page(bpage);\n\t}\n\n\tkfree(cpu_buffer);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "TEST_F(QuotedString_ExtractFrom_Tests, EscapedSolidus) {\n  whenInputIs(\"\\\"hello \\\\/world\\\\/\\\"\");\n  resultMustBe(\"hello /world/\");\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void GLSurfaceOzoneSurfacelessSurfaceImpl::SwapBuffersAsync(\n    const SwapCompletionCallback& callback) {\n  if (!images_[current_surface_]->ScheduleOverlayPlane(\n          widget_, 0, OverlayTransform::OVERLAY_TRANSFORM_NONE,\n          gfx::Rect(GetSize()), gfx::RectF(1, 1))) {\n    callback.Run(gfx::SwapResult::SWAP_FAILED);\n    return;\n  }\n  GLSurfaceOzoneSurfaceless::SwapBuffersAsync(callback);\n  current_surface_ ^= 1;\n  BindFramebuffer();\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "gx_default_end_transparency_group(gx_device *dev, gs_gstate *pgs)\n{\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "PHP_MSHUTDOWN_FUNCTION(mb_regex)\n{\n\tonig_end();\n\treturn SUCCESS;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void slc_bump(struct slcan *sl)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame cf;\n\tint i, tmp;\n\tu32 tmpid;\n\tchar *cmd = sl->rbuff;\n\n\tcf.can_id = 0;\n\n\tswitch (*cmd) {\n\tcase 'r':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 't':\n\t\t/* store dlc ASCII value and terminate SFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1;\n\t\tbreak;\n\tcase 'R':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 'T':\n\t\tcf.can_id |= CAN_EFF_FLAG;\n\t\t/* store dlc ASCII value and terminate EFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid))\n\t\treturn;\n\n\tcf.can_id |= tmpid;\n\n\t/* get can_dlc from sanitized ASCII value */\n\tif (cf.can_dlc >= '0' && cf.can_dlc < '9')\n\t\tcf.can_dlc -= '0';\n\telse\n\t\treturn;\n\n\t*(u64 *) (&cf.data) = 0; /* clear payload */\n\n\t/* RTR frames may have a dlc > 0 but they never have any data bytes */\n\tif (!(cf.can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf.can_dlc; i++) {\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] = (tmp << 4);\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] |= tmp;\n\t\t}\n\t}\n\n\tskb = dev_alloc_skb(sizeof(struct can_frame) +\n\t\t\t    sizeof(struct can_skb_priv));\n\tif (!skb)\n\t\treturn;\n\n\tskb->dev = sl->dev;\n\tskb->protocol = htons(ETH_P_CAN);\n\tskb->pkt_type = PACKET_BROADCAST;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = sl->dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\n\tskb_put_data(skb, &cf, sizeof(struct can_frame));\n\n\tsl->dev->stats.rx_packets++;\n\tsl->dev->stats.rx_bytes += cf.can_dlc;\n\tnetif_rx_ni(skb);\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void i40e_vsi_remove_pvid(struct i40e_vsi *vsi)\n{\n\tvsi->info.pvid = 0;\n\n\ti40e_vlan_stripping_disable(vsi);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int ath6kl_wmi_pstream_timeout_event_rx(struct wmi *wmi, u8 *datap,\n\t\t\t\t\t       int len)\n{\n\tstruct wmi_pstream_timeout_event *ev;\n\n\tif (len < sizeof(struct wmi_pstream_timeout_event))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_pstream_timeout_event *) datap;\n\n\t/*\n\t * When the pstream (fat pipe == AC) timesout, it means there were\n\t * no thinStreams within this pstream & it got implicitly created\n\t * due to data flow on this AC. We start the inactivity timer only\n\t * for implicitly created pstream. Just reset the host state.\n\t */\n\tspin_lock_bh(&wmi->lock);\n\twmi->stream_exist_for_ac[ev->traffic_class] = 0;\n\twmi->fat_pipe_exist &= ~(1 << ev->traffic_class);\n\tspin_unlock_bh(&wmi->lock);\n\n\t/* Indicate inactivity to driver layer for this fatpipe (pstream) */\n\tath6kl_indicate_tx_activity(wmi->parent_dev, ev->traffic_class, false);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "HRESULT Http::HrReadHeaders()\n{\n\tHRESULT hr;\n\tstd::string strBuffer;\n\tULONG n = 0;\n\tstd::map<std::string, std::string>::iterator iHeader = mapHeaders.end();\n\n\tec_log_debug(\"Receiving headers:\");\n\tdo\n\t{\n\t\thr = m_lpChannel->HrReadLine(strBuffer);\n\t\tif (hr != hrSuccess)\n\t\t\treturn hr;\n\t\tif (strBuffer.empty())\n\t\t\tbreak;\n\n\t\tif (n == 0) {\n\t\t\tm_strAction = strBuffer;\n\t\t} else {\n\t\t\tauto pos = strBuffer.find(':');\n\t\t\tsize_t start = 0;\n\n\t\t\tif (strBuffer[0] == ' ' || strBuffer[0] == '\\t') {\n\t\t\t\tif (iHeader == mapHeaders.end())\n\t\t\t\t\tcontinue;\n\t\t\t\t// continue header\n\t\t\t\twhile (strBuffer[start] == ' ' || strBuffer[start] == '\\t')\n\t\t\t\t\t++start;\n\t\t\t\tiHeader->second += strBuffer.substr(start);\n\t\t\t} else {\n\t\t\t\t// new header\n\t\t\t\tauto r = mapHeaders.emplace(strBuffer.substr(0, pos), strBuffer.substr(pos + 2));\n\t\t\t\tiHeader = r.first;\n\t\t\t}\n\t\t}\n\n\t\tif (strBuffer.find(\"Authorization\") != std::string::npos)\n\t\t\tec_log_debug(\"< Authorization: <value hidden>\");\n\t\telse\n\t\t\tec_log_debug(\"< \"+strBuffer);\n\t\t++n;\n\t} while(hr == hrSuccess);\n\n\thr = HrParseHeaders();\n\tif (hr != hrSuccess)\n\t\thr_ldebug(hr, \"parsing headers failed\");\n\treturn hr;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void DefaultErrorHandler(const ExceptionType magick_unused(severity),\n  const char *reason,const char *description)\n{\n  magick_unreferenced(severity);\n\n  if (reason == (char *) NULL)\n    return;\n  (void) FormatLocaleFile(stderr,\"%s: %s\",GetClientName(),reason);\n  if (description != (char *) NULL)\n    (void) FormatLocaleFile(stderr,\" (%s)\",description);\n  (void) FormatLocaleFile(stderr,\".\\n\");\n  (void) fflush(stderr);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void check_guest_throttling(void)\n{\n    static int64_t t0;\n    int64_t        t1;\n\n    if (!mig_throttle_on) {\n        return;\n    }\n\n    if (!t0)  {\n        t0 = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n        return;\n    }\n\n    t1 = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    /* If it has been more than 40 ms since the last time the guest\n     * was throttled then do it again.\n     */\n    if (40 < (t1-t0)/1000000) {\n        mig_throttle_guest_down();\n        t0 = t1;\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "inline void syev(char &JOB, char &UPLO, int &N, float *lapA, float *lapW, float *WORK, int &LWORK, int &INFO) {\n      ssyev_(&JOB,&UPLO,&N,lapA,&N,lapW,WORK,&LWORK,&INFO);",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void __mp_start(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\n\tif (!uart_circ_empty(&state->info->xmit) && state->info->xmit.buf &&\n\t\t\t!tty->stopped && !tty->hw_stopped)\n\t\tport->ops->start_tx(port);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "lib_file_open_search_with_no_combine(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,\n                                     const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile,\n                                     gx_io_device *iodev, bool starting_arg_file, char *fmode)\n{\n    stream *s;\n    uint blen1 = blen;\n    if (gp_file_name_reduce(fname, flen, buffer, &blen1) != gp_combine_success)\n      goto skip;\n    if (iodev_os_open_file(iodev, (const char *)buffer, blen1,\n                           (const char *)fmode, &s, (gs_memory_t *)mem) == 0) {\n      if (starting_arg_file ||\n          check_file_permissions_aux(i_ctx_p, buffer, blen1) >= 0) {\n        *pclen = blen1;\n        make_stream_file(pfile, s, \"r\");\n        return 0;\n      }\n      sclose(s);\n      return_error(e_invalidfileaccess);\n    }\n skip:;\n    return 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "mix_pool(byte *pool)\n{\n    char *hashbuf = pool + POOLSIZE;\n    char *p, *pend;\n    int i, n;\n    RMD160_CONTEXT md;\n\n    rmd160_init( &md );\n#if DIGESTLEN != 20\n#error must have a digest length of 20 for ripe-md-160\n#endif\n    /* loop over the pool */\n    pend = pool + POOLSIZE;\n    memcpy(hashbuf, pend - DIGESTLEN, DIGESTLEN );\n    memcpy(hashbuf+DIGESTLEN, pool, BLOCKLEN-DIGESTLEN);\n    rmd160_mixblock( &md, hashbuf);\n    memcpy(pool, hashbuf, DIGESTLEN);\n\n    p = pool;\n    for( n=1; n < POOLBLOCKS; n++ ) {\n\tmemcpy(hashbuf, p, DIGESTLEN );\n\n\tp += DIGESTLEN;\n\tif( p+DIGESTLEN+BLOCKLEN < pend )\n\t    memcpy(hashbuf+DIGESTLEN, p+DIGESTLEN, BLOCKLEN-DIGESTLEN);\n\telse {\n\t    char *pp = p+DIGESTLEN;\n\t    for(i=DIGESTLEN; i < BLOCKLEN; i++ ) {\n\t\tif( pp >= pend )\n\t\t    pp = pool;\n\t\thashbuf[i] = *pp++;\n\t    }\n\t}\n\n\trmd160_mixblock( &md, hashbuf);\n\tmemcpy(p, hashbuf, DIGESTLEN);\n    }\n    burn_stack (384); /* for the rmd160_mixblock() */\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline int fd_eject(int drive)\n{\n\treturn -EINVAL;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void vbg_req_free(void *req, size_t len)\n{\n\tif (!req)\n\t\treturn;\n\n\tfree_pages((unsigned long)req, get_order(PAGE_ALIGN(len)));\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void x25_insert_socket(struct sock *sk)\n{\n\twrite_lock_bh(&x25_list_lock);\n\tsk_add_node(sk, &x25_list);\n\twrite_unlock_bh(&x25_list_lock);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void Browser::SetWebContentsBlocked(content::WebContents* web_contents,\n                                    bool blocked) {\n  int index = tab_strip_model_->GetIndexOfWebContents(web_contents);\n  if (index == TabStripModel::kNoTab) {\n     return;\n   }\n   tab_strip_model_->SetTabBlocked(index, blocked);\n \n   bool browser_active = BrowserList::GetInstance()->GetLastActive() == this;\n  bool contents_is_active =\n      tab_strip_model_->GetActiveWebContents() == web_contents;\n  if (!blocked && contents_is_active && browser_active)\n    web_contents->Focus();\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void vhost_region_del(MemoryListener *listener,\n\n                             MemoryRegionSection *section)\n\n{\n\n    struct vhost_dev *dev = container_of(listener, struct vhost_dev,\n\n                                         memory_listener);\n\n    int i;\n\n\n\n    vhost_set_memory(listener, section, false);\n\n    for (i = 0; i < dev->n_mem_sections; ++i) {\n\n        if (dev->mem_sections[i].offset_within_address_space\n\n            == section->offset_within_address_space) {\n\n            --dev->n_mem_sections;\n\n            memmove(&dev->mem_sections[i], &dev->mem_sections[i+1],\n\n                    dev->n_mem_sections - i);\n\n            break;\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "smtp_user_msg(uschar *code, uschar *user_msg)\n{\nint len = 3;\nsmtp_message_code(&code, &len, &user_msg, NULL, TRUE);\nsmtp_respond(code, len, TRUE, user_msg);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static long __get_user_pages_remote(struct task_struct *tsk,\n\t\t\t\t    struct mm_struct *mm,\n\t\t\t\t    unsigned long start, unsigned long nr_pages,\n\t\t\t\t    unsigned int gup_flags, struct page **pages,\n\t\t\t\t    struct vm_area_struct **vmas, int *locked)\n{\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_grad_backprop = context->input(2);\n\n    // For maxpooling3d, tensor_in should have 5 dimensions.\n    OP_REQUIRES(context, tensor_in.dims() == 5,\n                errors::InvalidArgument(\"tensor_in must be 5-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 5,\n                errors::InvalidArgument(\"tensor_out must be 5-dimensional\"));\n    // For maxpooling3d, out_grad_backprop should have 5 dimensions.\n    OP_REQUIRES(\n        context, out_grad_backprop.dims() == 5,\n        errors::InvalidArgument(\"out_grad_backprop must be 5-dimensional\"));\n\n    Pool3dParameters params{context,  ksize_,       stride_,\n                            padding_, data_format_, tensor_in.shape()};\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {2}, 0, tensor_out.shape(), &output));\n\n    LaunchMaxPooling3dGradGradOp<Device, T>::launch(\n        context, params, tensor_in, tensor_out, out_grad_backprop, output);\n  }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void fib6_metric_set(struct fib6_info *f6i, int metric, u32 val)\n{\n\tif (!f6i)\n\t\treturn;\n\n\tif (f6i->fib6_metrics == &dst_default_metrics) {\n\t\tstruct dst_metrics *p = kzalloc(sizeof(*p), GFP_ATOMIC);\n\n\t\tif (!p)\n\t\t\treturn;\n\n\t\trefcount_set(&p->refcnt, 1);\n\t\tf6i->fib6_metrics = p;\n\t}\n\n\tf6i->fib6_metrics->metrics[metric - 1] = val;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "unsigned int avpriv_toupper4(unsigned int x)\n\n{\n\n    return av_toupper(x & 0xFF) +\n\n          (av_toupper((x >>  8) & 0xFF) << 8)  +\n\n          (av_toupper((x >> 16) & 0xFF) << 16) +\n\n          (av_toupper((x >> 24) & 0xFF) << 24);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool XSSAuditor::FilterFormToken(const FilterTokenRequest& request) {\n  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);\n  DCHECK(HasName(request.token, formTag));\n\n  return EraseAttributeIfInjected(request, actionAttr, kURLWithUniqueOrigin,\n                                  kSrcLikeAttributeTruncation);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "set_umask(const char *optarg)\n{\n\tlong umask_long;\n\tmode_t umask_val;\n\tchar *endptr;\n\n\tumask_long = strtoll(optarg, &endptr, 0);\n\n\tif (*endptr || umask_long < 0 || umask_long & ~0777L) {\n\t\tfprintf(stderr, \"Invalid --umask option %s\", optarg);\n\t\treturn;\n\t}\n\n\tumask_val = umask_long & 0777;\n\tumask(umask_val);\n\n\tumask_cmdline = true;\n\n\treturn umask_val;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "XML_SetHashSalt(XML_Parser parser, unsigned long hash_salt) {\n  if (parser == NULL)\n    return 0;\n  if (parser->m_parentParser)\n    return XML_SetHashSalt(parser->m_parentParser, hash_salt);\n  /* block after XML_Parse()/XML_ParseBuffer() has been called */\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return 0;\n  parser->m_hash_secret_salt = hash_salt;\n  return 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int av_reallocp(void *ptr, size_t size)\n\n{\n\n    void **ptrptr = ptr;\n\n    void *ret;\n\n\n\n\n\n\n\n    ret = av_realloc(*ptrptr, size);\n\n\n\n    if (!ret) {\n\n\n        return AVERROR(ENOMEM);\n\n\n\n\n    *ptrptr = ret;\n\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "uint64_t helper_mulldo(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    int64_t th;\n\n    uint64_t tl;\n\n\n\n    muls64(&tl, (uint64_t *)&th, arg1, arg2);\n\n    /* If th != 0 && th != -1, then we had an overflow */\n\n    if (likely((uint64_t)(th + 1) <= 1)) {\n\n        env->ov = 0;\n\n    } else {\n\n        env->so = env->ov = 1;\n\n    }\n\n    return (int64_t)tl;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static ssize_t show_device_bridge(struct device *cd,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct video_device *vdev =\n\t\tcontainer_of(cd, struct video_device, dev);\n\tstruct usb_usbvision *usbvision = video_get_drvdata(vdev);\n\treturn sprintf(buf, \"%d\\n\", usbvision->bridge_type);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void handle_rev16(DisasContext *s, unsigned int sf,\n\n                         unsigned int rn, unsigned int rd)\n\n{\n\n    TCGv_i64 tcg_rd = cpu_reg(s, rd);\n\n    TCGv_i64 tcg_tmp = tcg_temp_new_i64();\n\n    TCGv_i64 tcg_rn = read_cpu_reg(s, rn, sf);\n\n    TCGv_i64 mask = tcg_const_i64(sf ? 0x00ff00ff00ff00ffull : 0x00ff00ff);\n\n\n\n    tcg_gen_shri_i64(tcg_tmp, tcg_rn, 8);\n\n    tcg_gen_and_i64(tcg_rd, tcg_rn, mask);\n\n    tcg_gen_and_i64(tcg_tmp, tcg_tmp, mask);\n\n    tcg_gen_shli_i64(tcg_rd, tcg_rd, 8);\n\n    tcg_gen_or_i64(tcg_rd, tcg_rd, tcg_tmp);\n\n\n\n\n    tcg_temp_free_i64(tcg_tmp);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  // Just copy input to output.\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* axis = GetInput(context, node, kAxis);\n  if (IsDynamicTensor(output)) {\n    int axis_value;\n    TF_LITE_ENSURE_OK(context,\n                      GetAxisValueFromTensor(context, *axis, &axis_value));\n    TF_LITE_ENSURE_OK(context,\n                      ExpandTensorDim(context, *input, axis_value, output));\n  }\n  if (output->type == kTfLiteString) {\n    TfLiteTensorRealloc(input->bytes, output);\n  }\n  memcpy(output->data.raw, input->data.raw, input->bytes);\n  return kTfLiteOk;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "f2flac8_array (const float *src, int32_t *dest, int count, int normalize)\n{\tfloat normfact = normalize ? (1.0 * 0x7F) : 1.0 ;\n\n\twhile (--count >= 0)\n\t\tdest [count] = lrintf (src [count] * normfact) ;\n} /* f2flac8_array */",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static bool is_valid_ordinal_table_size(ut64 size) {\n\treturn size > 0 && size <= UT16_MAX;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static size_t php_output_wrapper(const char *str, size_t str_length)\n{\n\treturn php_output_write(str, str_length);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n {\n     size_t size, len;\n    BOOL ret = FALSE;\n     WCHAR *data = NULL;\n     DWORD bytes, read;\n \n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n         ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto out;\n     }\n \n     size = bytes / sizeof(*data);\n     if (size == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n \n     data = malloc(bytes);\n     if (data == NULL)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n         ReturnLastError(pipe, L\"malloc\");\n        goto out;\n     }\n \n     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n     if (bytes != read)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n         ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto out;\n     }\n \n     if (data[size - 1] != 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n \n     sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n \n     sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n \n     sud->std_input = sud->options + len;\n    data = NULL; /* don't free data */\n    ret = TRUE;\n \nout:\n     free(data);\n    return ret;\n }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "sc_pkcs15_convert_bignum(sc_pkcs15_bignum_t *dst, const void *src)\n{\n#ifdef ENABLE_OPENSSL\n\tconst BIGNUM *bn = (const BIGNUM *)src;\n\n\tif (bn == 0)\n\t\treturn 0;\n\tdst->len = BN_num_bytes(bn);\n\tdst->data = malloc(dst->len);\n\tif (!dst->data)\n\t\treturn 0;\n\tBN_bn2bin(bn, dst->data);\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "unsigned int getSize() { return size; }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "PHP_FUNCTION(oci_lob_load)\n{\n\tzval **tmp, *z_descriptor = getThis();\n\tphp_oci_descriptor *descriptor;\n\tchar *buffer = NULL;\n\tub4 buffer_len;\n\n\tif (!getThis()) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"O\", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {\n\t\t\treturn;\n\t\t}\t\n\t}\n\n\tif (strlen(filename) != filename_len) {\n\t\tRETURN_FALSE;\n\t}\n\t\n\tif (zend_hash_find(Z_OBJPROP_P(z_descriptor), \"descriptor\", sizeof(\"descriptor\"), (void **)&tmp) == FAILURE) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to find descriptor property\");\n\t\tRETURN_FALSE;\n\t}\n\t\n\tPHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, descriptor);\n\n\tif (php_oci_lob_read(descriptor, -1, 0, &buffer, &buffer_len TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (buffer_len > 0) {\n\t\tRETURN_STRINGL(buffer, buffer_len, 0);\n\t}\n\telse {\n\t\tRETURN_EMPTY_STRING();\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void TabSpecificContentSettings::AppCacheAccessed(const GURL& manifest_url,\n                                                  bool blocked_by_policy) {\n  if (blocked_by_policy) {\n    blocked_local_shared_objects_.appcaches()->AddAppCache(manifest_url);\n    OnContentBlocked(CONTENT_SETTINGS_TYPE_COOKIES, std::string());\n  } else {\n    allowed_local_shared_objects_.appcaches()->AddAppCache(manifest_url);\n    OnContentAccessed(CONTENT_SETTINGS_TYPE_COOKIES);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void disas_extract(DisasContext *s, uint32_t insn)\n\n{\n\n    unsupported_encoding(s, insn);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void brcmf_escan_timeout(unsigned long data)\n{\n\tstruct brcmf_cfg80211_info *cfg =\n\t\t\t(struct brcmf_cfg80211_info *)data;\n\n\tif (cfg->scan_request) {\n\t\tbrcmf_err(\"timer expired\\n\");\n\t\tschedule_work(&cfg->escan_timeout_work);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void odkm_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static inline void idct4col_put(uint8_t *dest, int line_size, const int16_t *col)\n\n{\n\n    int c0, c1, c2, c3, a0, a1, a2, a3;\n\n\n\n    a0 = col[8*0];\n\n    a1 = col[8*2];\n\n    a2 = col[8*4];\n\n    a3 = col[8*6];\n\n    c0 = ((a0 + a2) << (CN_SHIFT - 1)) + (1 << (C_SHIFT - 1));\n\n    c2 = ((a0 - a2) << (CN_SHIFT - 1)) + (1 << (C_SHIFT - 1));\n\n    c1 = a1 * C1 + a3 * C2;\n\n    c3 = a1 * C2 - a3 * C1;\n\n    dest[0] = av_clip_uint8((c0 + c1) >> C_SHIFT);\n\n    dest += line_size;\n\n    dest[0] = av_clip_uint8((c2 + c3) >> C_SHIFT);\n\n    dest += line_size;\n\n    dest[0] = av_clip_uint8((c2 - c3) >> C_SHIFT);\n\n    dest += line_size;\n\n    dest[0] = av_clip_uint8((c0 - c1) >> C_SHIFT);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "bool object_property_get_bool(Object *obj, const char *name,\n\n                              Error **errp)\n\n{\n\n    QObject *ret = object_property_get_qobject(obj, name, errp);\n\n    QBool *qbool;\n\n    bool retval;\n\n\n\n    if (!ret) {\n\n        return false;\n\n    }\n\n    qbool = qobject_to_qbool(ret);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name, \"boolean\");\n\n        retval = false;\n\n    } else {\n\n        retval = qbool_get_bool(qbool);\n\n    }\n\n\n\n    QDECREF(qbool);\n\n    return retval;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "gsf_infile_tar_finalize (GObject *obj)\n{\n\tGsfInfileTar *tar = GSF_INFILE_TAR (obj);\n\tg_array_free (tar->children, TRUE);\n\tparent_class->finalize (obj);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "zend_mb_regex_globals *php_mb_regex_globals_alloc(TSRMLS_D)\n{\n\tzend_mb_regex_globals *pglobals = pemalloc(\n\t\t\tsizeof(zend_mb_regex_globals), 1);\n\tif (!pglobals) {\n\t\treturn NULL;\n\t}\n\tif (SUCCESS != _php_mb_regex_globals_ctor(pglobals TSRMLS_CC)) {\n\t\tpefree(pglobals, 1);\n\t\treturn NULL;\n\t}\n\treturn pglobals;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n\n    memory_region_destroy(&s->mmio);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void ms_adpcm_reset1 (_AFmoduleinst *i)\n{\n\tms_adpcm_data\t*d = (ms_adpcm_data *) i->modspec;\n\tAFframecount\tnextTrackFrame;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\n\tnextTrackFrame = d->track->nextfframe;\n\td->track->nextfframe = (nextTrackFrame / framesPerBlock) *\n\t\tframesPerBlock;\n\n\td->framesToIgnore = nextTrackFrame - d->track->nextfframe;\n\t/* postroll = frames2ignore */\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void Magick::Image::adaptiveBlur(const double radius_,const double sigma_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=AdaptiveBlurImage(constImage(),radius_,sigma_,exceptionInfo);\n  replaceImage(newImage);\n  ThrowImageException;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "  void Compute(OpKernelContext* c) override {\n    const Tensor& tag = c->input(0);\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(tag.shape()),\n                errors::InvalidArgument(\"tag must be scalar\"));\n    const Tensor& tensor = c->input(1);\n    const Tensor& serialized_summary_metadata_tensor = c->input(2);\n\n    Summary s;\n    Summary::Value* v = s.add_value();\n    v->set_tag(string(tag.scalar<tstring>()()));  // NOLINT\n\n    if (tensor.dtype() == DT_STRING) {\n      // tensor_util.makeNdarray doesn't work for strings in tensor_content\n      tensor.AsProtoField(v->mutable_tensor());\n    } else {\n      tensor.AsProtoTensorContent(v->mutable_tensor());\n    }\n\n    ParseFromTString(serialized_summary_metadata_tensor.scalar<tstring>()(),\n                     v->mutable_metadata());\n\n    Tensor* summary_tensor = nullptr;\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape({}), &summary_tensor));\n    CHECK(SerializeToTString(s, &summary_tensor->scalar<tstring>()()));\n  }",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "  LiteralString(const std::string &s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case),\n        is_word_(false) {}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Line_Down( RAS_ARGS Long  x1,\n                      Long  y1,\n                      Long  x2,\n                      Long  y2,\n                      Long  miny,\n                      Long  maxy )\n  {\n    Bool  result, fresh;\n\n\n    fresh  = ras.fresh;\n\n    result = Line_Up( RAS_VARS x1, -y1, x2, -y2, -maxy, -miny );\n\n    if ( fresh && !ras.fresh )\n      ras.cProfile->start = -ras.cProfile->start;\n\n    return result;\n  }",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "GSList*\nmono_method_verify_with_current_settings (MonoMethod *method, gboolean skip_visibility)\n{\n\t/* The verifier was disabled at compile time */\n\treturn NULL;",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void hsr_addr_subst_source(struct hsr_node *node, struct sk_buff *skb)\n{\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: Mac header not set\\n\", __func__);\n\t\treturn;\n\t}\n\n\tmemcpy(&eth_hdr(skb)->h_source, node->MacAddressA, ETH_ALEN);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n\tint name_end = -1;\n\tint j = *idx;\n\tint ptr_count = 0;\n#define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)\n#define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)\n#define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)\n\n\tchar *cp = name_out;\n\tconst char *const end = name_out + name_out_len;\n\n\t/* Normally, names are a series of length prefixed strings terminated */\n\t/* with a length of 0 (the lengths are u8's < 63). */\n\t/* However, the length can start with a pair of 1 bits and that */\n\t/* means that the next 14 bits are a pointer within the current */\n\t/* packet. */\n \n \tfor (;;) {\n \t\tu8 label_len;\n\t\tif (j >= length) return -1;\n \t\tGET8(label_len);\n \t\tif (!label_len) break;\n \t\tif (label_len & 0xc0) {\n\t\t\tu8 ptr_low;\n\t\t\tGET8(ptr_low);\n\t\t\tif (name_end < 0) name_end = j;\n\t\t\tj = (((int)label_len & 0x3f) << 8) + ptr_low;\n\t\t\t/* Make sure that the target offset is in-bounds. */\n\t\t\tif (j < 0 || j >= length) return -1;\n\t\t\t/* If we've jumped more times than there are characters in the\n\t\t\t * message, we must have a loop. */\n\t\t\tif (++ptr_count > length) return -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (label_len > 63) return -1;\n\t\tif (cp != name_out) {\n\t\t\tif (cp + 1 >= end) return -1;\n \t\t\t*cp++ = '.';\n \t\t}\n \t\tif (cp + label_len >= end) return -1;\n \t\tmemcpy(cp, packet + j, label_len);\n \t\tcp += label_len;\n \t\tj += label_len;\n\t}\n\tif (cp >= end) return -1;\n\t*cp = '\\0';\n\tif (name_end < 0)\n\t\t*idx = j;\n\telse\n\t\t*idx = name_end;\n\treturn 0;\n err:\n\treturn -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "SkiaOutputSurfaceImpl::CreateImageContext(\n    const gpu::MailboxHolder& holder,\n    const gfx::Size& size,\n    ResourceFormat format,\n    const base::Optional<gpu::VulkanYCbCrInfo>& ycbcr_info,\n    sk_sp<SkColorSpace> color_space) {\n  return std::make_unique<ImageContextImpl>(holder, size, format, ycbcr_info,\n                                            std::move(color_space));\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void FrameView::prepareForDetach()\n{\n    RELEASE_ASSERT(!isInPerformLayout());\n\n    if (ScrollAnimator* scrollAnimator = existingScrollAnimator())\n        scrollAnimator->cancelAnimations();\n    cancelProgrammaticScrollAnimation();\n\n    detachCustomScrollbars();\n    removeFromAXObjectCache();\n\n    if (m_frame->page()) {\n        if (ScrollingCoordinator* scrollingCoordinator = m_frame->page()->scrollingCoordinator())\n            scrollingCoordinator->willDestroyScrollableArea(this);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void nested_vmx_succeed(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |\n\t\t\t    X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF));\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "server_close_pipe (int *pipefd)\t/* see comments below */\n{\n\tclose (pipefd[0]);\t/* close WRITE end first to cause an EOF on READ */\n\tclose (pipefd[1]);\t/* in giowin32, and end that thread. */\n\tfree (pipefd);\n\treturn FALSE;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "GBool RunLengthStream::fillBuf() {\n  int c;\n  int n, i;\n\n  if (eof)\n    return gFalse;\n  c = str->getChar();\n  if (c == 0x80 || c == EOF) {\n    eof = gTrue;\n    return gFalse;\n  }\n  if (c < 0x80) {\n    n = c + 1;\n    for (i = 0; i < n; ++i)\n      buf[i] = (char)str->getChar();\n  } else {\n    n = 0x101 - c;\n    c = str->getChar();\n    for (i = 0; i < n; ++i)\n      buf[i] = (char)c;\n  }\n  bufPtr = buf;\n  bufEnd = buf + n;\n  return gTrue;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int event_enable_on_exec(struct perf_event *event,\n\t\t\t\tstruct perf_event_context *ctx)\n{\n\tif (!event->attr.enable_on_exec)\n\t\treturn 0;\n\n\tevent->attr.enable_on_exec = 0;\n\tif (event->state >= PERF_EVENT_STATE_INACTIVE)\n\t\treturn 0;\n\n\t__perf_event_mark_enabled(event);\n\n\treturn 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_context_destroy *args = data;\n\tstruct drm_i915_file_private *file_priv = file->driver_priv;\n\tstruct i915_gem_context *ctx;\n\tint ret;\n\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (args->ctx_id == DEFAULT_CONTEXT_HANDLE)\n\t\treturn -ENOENT;\n\n\tctx = i915_gem_context_lookup(file_priv, args->ctx_id);\n\tif (!ctx)\n\t\treturn -ENOENT;\n\n\tret = mutex_lock_interruptible(&dev->struct_mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tidr_remove(&file_priv->context_idr, ctx->user_handle);\n\tcontext_close(ctx);\n\n\tmutex_unlock(&dev->struct_mutex);\n\nout:\n\ti915_gem_context_put(ctx);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "StylePropertyMapReadOnly* Document::ComputedStyleMap(Element* element) {\n  ElementComputedStyleMap::AddResult add_result =\n      element_computed_style_map_.insert(element, nullptr);\n  if (add_result.is_new_entry)\n    add_result.stored_value->value = ComputedStylePropertyMap::Create(element);\n  return add_result.stored_value->value;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void RENAME(uyvytoyuv420)(uint8_t *ydst, uint8_t *udst, uint8_t *vdst, const uint8_t *src,\n\n                                 int width, int height,\n\n                                 int lumStride, int chromStride, int srcStride)\n\n{\n\n    int y;\n\n    const int chromWidth = FF_CEIL_RSHIFT(width, 1);\n\n\n\n    for (y=0; y<height; y++) {\n\n        RENAME(extract_even)(src+1, ydst, width);\n\n        if(y&1) {\n\n            RENAME(extract_even2avg)(src-srcStride, src, udst, vdst, chromWidth);\n\n            udst+= chromStride;\n\n            vdst+= chromStride;\n\n        }\n\n\n\n        src += srcStride;\n\n        ydst+= lumStride;\n\n    }\n\n    __asm__(\n\n            EMMS\"       \\n\\t\"\n\n            SFENCE\"     \\n\\t\"\n\n            ::: \"memory\"\n\n        );\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "enable_xterm_mouse(SCREEN *sp, int enable)\n{\n#if USE_EMX_MOUSE\n    sp->_emxmouse_activated = enable;\n#else\n    NCURSES_PUTP2(\"xterm-mouse\", TPARM_1(sp->_mouse_xtermcap, enable));\n#endif\n    sp->_mouse_active = enable;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "Variant HHVM_FUNCTION(mb_ereg_search_pos,\n                      const Variant& opt_pattern,\n                      const Variant& opt_option) {\n  const String pattern = convertArg(opt_pattern);\n  const String option = convertArg(opt_option);\n  return _php_mb_regex_ereg_search_exec(pattern, option, 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "compile_string_crude_node(StrNode* sn, regex_t* reg)\n{\n  if (sn->end <= sn->s)\n    return 0;\n\n  return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), reg);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void __bpf_prog_put(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tif (atomic64_dec_and_test(&prog->aux->refcnt)) {\n\t\tperf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_UNLOAD, 0);\n\t\tbpf_audit_prog(prog, BPF_AUDIT_UNLOAD);\n\t\t/* bpf_prog_free_id() must be called first */\n\t\tbpf_prog_free_id(prog, do_idr_lock);\n\t\t__bpf_prog_put_noref(prog, true);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "mono_register_jit_icall_wrapper (MonoJitICallInfo *info, gconstpointer wrapper)\n{\n\tmono_loader_lock ();\n\tg_hash_table_insert (jit_icall_hash_addr, (gpointer)wrapper, info);\n\tmono_loader_unlock ();\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int Jsi_Link(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value *dest, int typ) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, src, &data);\n    if (fsPtr == NULL || !fsPtr->linkProc) return -1;\n    return fsPtr->linkProc(interp, src, dest, typ);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void free_user(struct kref *ref)\n{\n\tstruct ipmi_user *user = container_of(ref, struct ipmi_user, refcount);\n\n\t/* SRCU cleanup must happen in task context. */\n\tschedule_work(&user->remove_work);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void free_sockent_server(struct sockent_server *ses) /* {{{ */\n{\n  for (size_t i = 0; i < ses->fd_num; i++) {\n    if (ses->fd[i] >= 0) {\n      close(ses->fd[i]);\n      ses->fd[i] = -1;\n    }\n  }\n\n  sfree(ses->fd);\n#if HAVE_LIBGCRYPT\n  sfree(ses->auth_file);\n  fbh_destroy(ses->userdb);\n  if (ses->cypher != NULL)\n    gcry_cipher_close(ses->cypher);\n#endif\n} /* }}} void free_sockent_server */",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "  void CalculateOutputIndexRowSplit(\n      OpKernelContext* context, const RowPartitionTensor& row_split,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    INDEX_TYPE row_split_size = row_split.size();\n    if (row_split_size > 0) {\n      result->reserve(row_split(row_split_size - 1));\n    }\n    for (INDEX_TYPE i = 0; i < row_split_size - 1; ++i) {\n      INDEX_TYPE row_length = row_split(i + 1) - row_split(i);\n      INDEX_TYPE real_length = std::min(output_size, row_length);\n      INDEX_TYPE parent_output_index_current = parent_output_index[i];\n\n      if (parent_output_index_current == -1) {\n        real_length = 0;\n      }\n      for (INDEX_TYPE j = 0; j < real_length; ++j) {\n        result->push_back(parent_output_index_current);\n        parent_output_index_current += output_index_multiplier;\n      }\n      for (INDEX_TYPE j = 0; j < row_length - real_length; ++j) {\n        result->push_back(-1);\n      }\n    }\n    if (row_split_size > 0) {\n      OP_REQUIRES(context, result->size() == row_split(row_split_size - 1),\n                  errors::InvalidArgument(\"Invalid row split size.\"));\n    }\n  }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "gs_window_real_unrealize (GtkWidget *widget)\n{\n        g_signal_handlers_disconnect_by_func (gtk_window_get_screen (GTK_WINDOW (widget)),\n                                              screen_size_changed,\n                                              widget);\n\n        if (GTK_WIDGET_CLASS (gs_window_parent_class)->unrealize) {\n                GTK_WIDGET_CLASS (gs_window_parent_class)->unrealize (widget);\n        }\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static struct fs_struct *__copy_fs_struct(struct fs_struct *old)\n{\n\tstruct fs_struct *fs = kmem_cache_alloc(fs_cachep, GFP_KERNEL);\n\t/* We don't need to lock fs - think why ;-) */\n\tif (fs) {\n\t\tatomic_set(&fs->count, 1);\n\t\trwlock_init(&fs->lock);\n\t\tfs->umask = old->umask;\n\t\tread_lock(&old->lock);\n\t\tfs->root = old->root;\n\t\tpath_get(&old->root);\n\t\tfs->pwd = old->pwd;\n\t\tpath_get(&old->pwd);\n\t\tread_unlock(&old->lock);\n\t}\n\treturn fs;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void cvardecs(JF, js_Ast *node)\n{\n\tif (isfun(node->type))\n\t\treturn; /* stop at inner functions */\n\n\tif (node->type == EXP_VAR) {\n\t\tif (F->lightweight)\n\t\t\taddlocal(J, F, node->a, 1);\n\t\telse\n\t\t\temitstring(J, F, OP_DEFVAR, node->a->string);\n\t}\n\n\tif (node->a) cvardecs(J, F, node->a);\n\tif (node->b) cvardecs(J, F, node->b);\n\tif (node->c) cvardecs(J, F, node->c);\n\tif (node->d) cvardecs(J, F, node->d);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "cluster_hash_alloc (void *p)\n{\n  struct cluster_list * val = (struct cluster_list *) p;\n  struct cluster_list *cluster;\n\n  cluster = XMALLOC (MTYPE_CLUSTER, sizeof (struct cluster_list));\n  cluster->length = val->length;\n\n  if (cluster->length)\n    {\n      cluster->list = XMALLOC (MTYPE_CLUSTER_VAL, val->length);\n      memcpy (cluster->list, val->list, val->length);\n    }\n  else\n    cluster->list = NULL;\n\n  cluster->refcnt = 0;\n\n  return cluster;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "RenderWidgetHostViewChildFrame* child_rwhv() { return child_rwhv_; }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static double mp_cross(_cimg_math_parser& mp) {\n        CImg<doubleT>\n          vout(&_mp_arg(1) + 1,1,3,1,1,true),\n          v1(&_mp_arg(2) + 1,1,3,1,1,true),\n          v2(&_mp_arg(3) + 1,1,3,1,1,true);\n        (vout = v1).cross(v2);\n        return cimg::type<double>::nan();",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "XSetIconName (\n    register Display *dpy,\n    Window w,\n    _Xconst char *icon_name)\n{\n    return XChangeProperty(dpy, w, XA_WM_ICON_NAME, XA_STRING, 8,\n                           PropModeReplace, (_Xconst unsigned char *)icon_name,\n\t\t\t   icon_name ? (int) strlen(icon_name) : 0);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "TPMS_NV_PUBLIC_Unmarshal(TPMS_NV_PUBLIC *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n    \n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPMI_RH_NV_INDEX_Unmarshal(&target->nvIndex, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPMI_ALG_HASH_Unmarshal(&target->nameAlg, buffer, size, NO);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPMA_NV_Unmarshal(&target->attributes, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM2B_DIGEST_Unmarshal(&target->authPolicy, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT16_Unmarshal(&target->dataSize, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->dataSize > MAX_NV_INDEX_SIZE) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void __exit sock_diag_exit(void)\n{\n\tunregister_pernet_subsys(&diag_net_ops);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void ReleaseVideoBufferImpl(AVCodecContext* s, AVFrame* frame) {\n  scoped_refptr<VideoFrame> video_frame;\n  video_frame.swap(reinterpret_cast<VideoFrame**>(&frame->opaque));\n\n  memset(frame->data, 0, sizeof(frame->data));\n  frame->opaque = NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n \t\t\tif (s_den == 0) {\n \t\t\t\treturn 0;\n \t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n \t\t\t}\n \n \t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\n\t\t/* Not sure if this is correct (never seen float used in Exif format) */\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int cqspi_erase(struct spi_nor *nor, loff_t offs)\n{\n\tint ret;\n\n\tret = cqspi_set_protocol(nor, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Send write enable, then erase commands. */\n\tret = nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Set up command buffer. */\n\tret = cqspi_command_write_addr(nor, nor->erase_opcode, offs);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void threadShutdown() override {\n      delete s_memcache_globals;\n      s_memcache_globals = nullptr;\n    }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static char *json_array_string(json_t *val, unsigned int entry)\n{\n\tchar *buf = __json_array_string(val, entry);\n\n\tif (buf)\n\t\treturn strdup(buf);\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "QPDFWriter::parseVersion(std::string const& version,\n\t\t\t int& major, int& minor) const\n{\n    major = atoi(version.c_str());\n    minor = 0;\n    size_t p = version.find('.');\n    if ((p != std::string::npos) && (version.length() > p))\n    {\n\tminor = atoi(version.substr(p + 1).c_str());\n    }\n    std::string tmp = QUtil::int_to_string(major) + \".\" +\n\tQUtil::int_to_string(minor);\n    if (tmp != version)\n    {\n\tthrow std::logic_error(\n\t    \"INTERNAL ERROR: QPDFWriter::parseVersion\"\n\t    \" called with invalid version number \" + version);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool FontData::Bound(int32_t offset) {\nif (offset > Size() || offset < 0)\n    return false;\n\n  bound_offset_ += offset;\n  return true;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static inline int bpf_try_make_writable(struct sk_buff *skb,\n\t\t\t\t\tunsigned int write_len)\n{\n\tint err = __bpf_try_make_writable(skb, write_len);\n\n\tbpf_compute_data_pointers(skb);\n\treturn err;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void decode_xml(XMLObj *obj) {\n          std::vector<Tag> _tags;\n          RGWXMLDecoder::decode_xml(\"Prefix\", prefix, obj);\n          if (prefix && prefix->empty()) {\n            prefix.reset();\n          }\n          RGWXMLDecoder::decode_xml(\"Tag\", _tags, obj);\n          for (auto& t : _tags) {\n            if (!t.empty()) {\n              tags.push_back(std::move(t));\n            }\n          }\n        };",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "_gnutls_x509_pk_to_oid (gnutls_pk_algorithm_t algorithm)\n{\n  const char *ret = NULL;\n\n  GNUTLS_PK_ALG_LOOP (ret = p->oid);\n  return ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void setup_private_mount(const char *snap_name)\n{\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tchar tmpdir[MAX_BUF] = { 0 };\n\n\t// Create a 0700 base directory, this is the base dir that is\n\t// protected from other users.\n\t//\n\t// Under that basedir, we put a 1777 /tmp dir that is then bind\n\t// mounted for the applications to use\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"/tmp/snap.%s_XXXXXX\", snap_name);\n\tif (mkdtemp(tmpdir) == NULL) {\n\t\tdie(\"cannot create temporary directory essential for private /tmp\");\n\t}\n\t// now we create a 1777 /tmp inside our private dir\n\tmode_t old_mask = umask(0);\n\tchar *d = sc_strdup(tmpdir);\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"%s/tmp\", d);\n\tfree(d);\n\n\tif (mkdir(tmpdir, 01777) != 0) {\n\t\tdie(\"cannot create temporary directory for private /tmp\");\n\t}\n\tumask(old_mask);\n\n\t// chdir to '/' since the mount won't apply to the current directory\n\tchar *pwd = get_current_dir_name();\n\tif (pwd == NULL)\n\t\tdie(\"cannot get current working directory\");\n\tif (chdir(\"/\") != 0)\n\t\tdie(\"cannot change directory to '/'\");\n\n\t// MS_BIND is there from linux 2.4\n\tsc_do_mount(tmpdir, \"/tmp\", NULL, MS_BIND, NULL);\n\t// MS_PRIVATE needs linux > 2.6.11\n\tsc_do_mount(\"none\", \"/tmp\", NULL, MS_PRIVATE, NULL);\n\t// do the chown after the bind mount to avoid potential shenanigans\n\tif (chown(\"/tmp/\", uid, gid) < 0) {\n\t\tdie(\"cannot change ownership of /tmp\");\n\t}\n\t// chdir to original directory\n\tif (chdir(pwd) != 0)\n\t\tdie(\"cannot change current working directory to the original directory\");\n\tfree(pwd);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n {\n     OPJ_UINT32 l_data_size;\n \n    /* The +1 is needed for https://github.com/uclouvain/openjpeg/issues/835 */\n    l_data_size = 1 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                    (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n \n     if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            /* We refer to data - 1 since below we incremented it */\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n\n        /* We reserve the initial byte as a fake byte to a non-FF value */\n        /* and increment the data pointer, so that opj_mqc_init_enc() */\n        /* can do bp = data - 1, and opj_mqc_byteout() can safely dereference */\n        /* it. */\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; /*why +1 ?*/\n    }\n    return OPJ_TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static jas_iccattrtab_t *jas_iccattrtab_copy(jas_iccattrtab_t *attrtab)\n{\n\tjas_iccattrtab_t *newattrtab;\n\tint i;\n\tif (!(newattrtab = jas_iccattrtab_create()))\n\t\tgoto error;\n\tfor (i = 0; i < attrtab->numattrs; ++i) {\n\t\tif (jas_iccattrtab_add(newattrtab, i, attrtab->attrs[i].name,\n\t\t  attrtab->attrs[i].val))\n\t\t\tgoto error;\n\t}\n\treturn newattrtab;\nerror:\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n \n \tkenter(\"%p{%u}\", user, uid);\n \n\tif (user->uid_keyring) {\n \t\tkleave(\" = 0 [exist]\");\n \t\treturn 0;\n \t}\n\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user->uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "proc_do_defense_mode(ctl_table *table, int write,\n\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tint *valp = table->data;\n\tint val = *valp;\n\tint rc;\n\n\trc = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (write && (*valp != val)) {\n\t\tif ((*valp < 0) || (*valp > 3)) {\n\t\t\t/* Restore the correct value */\n\t\t\t*valp = val;\n\t\t} else {\n\t\t\tupdate_defense_level(net_ipvs(net));\n\t\t}\n\t}\n\treturn rc;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "bool TensorSlice::IsFull() const {\n  for (int d = 0; d < dims(); ++d) {\n    if (!IsFullAt(d)) return false;\n  }\n  return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "png_read_update_info(png_structp png_ptr, png_infop info_ptr)\n{\n   png_debug(1, \"in png_read_update_info\");\n \n   if (png_ptr == NULL)\n      return;\n   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))\n      png_read_start_row(png_ptr);\n   else\n      png_warning(png_ptr,\n      \"Ignoring extra png_read_update_info() call; row buffer not reallocated\");\n\n   png_read_transform_info(png_ptr, info_ptr);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static bool is_valid_type(enum dm_queue_mode cur, enum dm_queue_mode new)\n{\n\tif (cur == new ||\n\t    (cur == DM_TYPE_BIO_BASED && new == DM_TYPE_DAX_BIO_BASED))\n\t\treturn true;\n\n\treturn false;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void RenderWidgetHostViewAura::SendReturnedDelegatedResources(\n    uint32 output_surface_id) {\n  cc::CompositorFrameAck ack;\n  if (resource_collection_)\n    resource_collection_->TakeUnusedResourcesForChildCompositor(&ack.resources);\n  DCHECK(!ack.resources.empty());\n  RenderWidgetHostImpl::SendReclaimCompositorResources(\n      host_->GetRoutingID(),\n      output_surface_id,\n      host_->GetProcess()->GetID(),\n      ack);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "init_control(void)\n{\n\tsize_t i;\n\n#ifdef HAVE_UNAME\n\tuname(&utsnamebuf);\n#endif /* HAVE_UNAME */\n\n\tctl_clr_stats();\n\n\tctl_auth_keyid = 0;\n\tctl_sys_last_event = EVNT_UNSPEC;\n\tctl_sys_num_events = 0;\n\n\tnum_ctl_traps = 0;\n\tfor (i = 0; i < COUNTOF(ctl_traps); i++)\n\t\tctl_traps[i].tr_flags = 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void FrameLoader::addHTTPOriginIfNeeded(ResourceRequest& request, const String& origin)\n{\n    if (!request.httpOrigin().isEmpty())\n        return;  // Request already has an Origin header.\n\n    if (request.httpMethod() == \"GET\" || request.httpMethod() == \"HEAD\")\n        return;\n\n\n    if (origin.isEmpty()) {\n        request.setHTTPOrigin(SecurityOrigin::createUnique()->toString());\n        return;\n    }\n\n    request.setHTTPOrigin(origin);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "**/\n    CImg<T>& abs() {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=524288))\n      cimg_rof(*this,ptrd,T) *ptrd = cimg::abs(*ptrd);\n      return *this;",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int __find_bmc_prod_dev_id(struct device *dev, const void *data)\n{\n\tconst struct prod_dev_id *cid = data;\n\tstruct bmc_device *bmc;\n\tint rv;\n\n\tif (dev->type != &bmc_device_type)\n\t\treturn 0;\n\n\tbmc = to_bmc_device(dev);\n\trv = (bmc->id.product_id == cid->product_id\n\t      && bmc->id.device_id == cid->device_id);\n\tif (rv)\n\t\trv = kref_get_unless_zero(&bmc->usecount);\n\treturn rv;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void ath_set_rates(struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\t  struct ath_buf *bf)\n{\n\tieee80211_get_tx_rates(vif, sta, bf->bf_mpdu, bf->rates,\n\t\t\t       ARRAY_SIZE(bf->rates));\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static struct tcf_proto_ops * tcf_proto_lookup_ops(struct rtattr *kind)\n{\n\tstruct tcf_proto_ops *t = NULL;\n\n\tif (kind) {\n\t\tread_lock(&cls_mod_lock);\n\t\tfor (t = tcf_proto_base; t; t = t->next) {\n\t\t\tif (rtattr_strcmp(kind, t->kind) == 0) {\n\t\t\t\tif (!try_module_get(t->owner))\n\t\t\t\t\tt = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tread_unlock(&cls_mod_lock);\n\t}\n\treturn t;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void LIRGenerator::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {\n  __ cmp_mem_int(condition, base, disp, c, info);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void OneClickSigninHelper::SetDoNotClearPendingEmailForTesting() {\n  do_not_clear_pending_email_ = true;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tpage_cache_get(buf->page);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "gboolean vnc_color_map_set(VncColorMap *map,\n                           guint16 idx,\n                           guint16 red,\n                           guint16 green,\n                           guint16 blue)\n{\n    if (idx >= (map->size + map->offset))\n        return FALSE;\n\n    map->colors[idx - map->offset].red = red;\n    map->colors[idx - map->offset].green = green;\n    map->colors[idx - map->offset].blue = blue;\n\n    return TRUE;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "std::codecvt_base::result do_in( std::mbstate_t& state,\n\t\t\tconst char* from,\n\t\t\tconst char* from_end,\n\t\t\tconst char*& from_next,\n\t\t\twchar_t* to,\n\t\t\twchar_t* to_end,\n\t\t\twchar_t*& to_next ) const\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tcustomcodecvt_do_conversion<char, wchar_t>(state, from, from_end, from_next, to, to_end, to_next);\n\t\t\t}\n\t\t\tcatch(...)\n\t\t\t{\n\t\t\t\tERR_FS << \"Invalid UTF-8 string'\" << std::string(from, from_end) << \"' \" << std::endl;\n\t\t\t\treturn std::codecvt_base::error;\n\t\t\t}\n\t\t\treturn std::codecvt_base::ok;\n\t\t}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "    GC_debug_malloc_ignore_off_page(size_t lb, GC_EXTRA_PARAMS)\n{\n    void * result = GC_malloc_ignore_off_page(lb + DEBUG_BYTES);\n\n    if (result == 0) {\n        GC_err_printf(\"GC_debug_malloc_ignore_off_page(%lu)\"\n                      \" returning NULL (%s:%d)\\n\", (unsigned long)lb, s, i);\n        return(0);\n    }\n    if (!GC_debugging_started) {\n        GC_start_debugging();\n    }\n    ADD_CALL_CHAIN(result, ra);\n    return (GC_store_debug_info(result, (word)lb, s, i));\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "exsltSaxonInit (xsltTransformContextPtr ctxt ATTRIBUTE_UNUSED,\n\t\tconst xmlChar *URI ATTRIBUTE_UNUSED) {\n    return xmlHashCreate(1);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "MagickExport void SetBlobExempt(Image *image,const MagickBooleanType exempt)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  image->blob->exempt=exempt;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "inline bool ResolveAxis(const int num_dims, const int* axis,\n                        const int64_t num_axis, int* out_axis,\n                        int* out_num_axis) {\n  *out_num_axis = 0;  // Just in case.\n  // Short-circuit axis resolution for scalars; the axis will go unused.\n  if (num_dims == 0) {\n    return true;\n  }\n  // o(n^2) is fine since out_num_axis should be really small, mostly <= 4\n  for (int64_t idx = 0; idx < num_axis; ++idx) {\n    // Handle negative index. A positive index 'p_idx' can be represented as a\n    // negative index 'n_idx' as: n_idx = p_idx-num_dims\n    // eg: For num_dims=3, [0, 1, 2] is the same as [-3, -2, -1]  */\n    int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];\n    TFLITE_DCHECK(current >= 0 && current < num_dims);\n    bool is_dup = false;\n    for (int j = 0; j < *out_num_axis; ++j) {\n      if (out_axis[j] == current) {\n        is_dup = true;\n        break;\n      }\n    }\n    if (!is_dup) {\n      out_axis[*out_num_axis] = current;\n      *out_num_axis += 1;\n    }\n  }\n  return true;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "mtree_bid(struct archive_read *a, int best_bid)\n{\n\tconst char *signature = \"#mtree\";\n\tconst char *p;\n\n\t(void)best_bid; /* UNUSED */\n\n\t/* Now let's look at the actual header and see if it matches. */\n\tp = __archive_read_ahead(a, strlen(signature), NULL);\n\tif (p == NULL)\n\t\treturn (-1);\n\n\tif (memcmp(p, signature, strlen(signature)) == 0)\n\t\treturn (8 * (int)strlen(signature));\n\n\t/*\n\t * There is not a mtree signature. Let's try to detect mtree format.\n\t */\n\treturn (detect_form(a, NULL));\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static struct page *get_object_page(const void *x)\n{\n\tstruct page *page = virt_to_head_page(x);\n\n\tif (!PageSlab(page))\n\t\treturn NULL;\n\n\treturn page;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "R_API void r_egg_printf(REgg *egg, const char *fmt, ...) {\n\tva_list ap;\n\tint len;\n\tchar buf[1024];\n\tva_start (ap, fmt);\n\tlen = vsnprintf (buf, sizeof (buf), fmt, ap);\n\tr_buf_append_bytes (egg->buf, (const ut8 *)buf, len);\n\tva_end (ap);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "rsa_decrypt_tr(const struct rsa_public_key *pub,\n\t       const struct rsa_private_key *key,\n\t       void *random_ctx, nettle_random_func *random,\n\t       size_t *length, uint8_t *message,\n\t       const mpz_t gibberish)\n{\n  TMP_GMP_DECL (m, mp_limb_t);\n  TMP_GMP_DECL (em, uint8_t);\n  mp_size_t key_limb_size;\n  int res;\n\n  key_limb_size = mpz_size(pub->n);\n\n  TMP_GMP_ALLOC (m, key_limb_size);\n  TMP_GMP_ALLOC (em, key->size);\n  mpz_limbs_copy(m, gibberish, key_limb_size);\n\n  res = _rsa_sec_compute_root_tr (pub, key, random_ctx, random, m, m);\n\n  mpn_get_base256 (em, key->size, m, key_limb_size);\n\n  res &= _pkcs1_sec_decrypt_variable (length, message, key->size, em);\n\n  TMP_GMP_FREE (em);\n  TMP_GMP_FREE (m);\n  return res;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t   unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timespec(up, &kts);\n\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline uint32_t vmsvga_fifo_read(struct vmsvga_state_s *s)\n{\n    return le32_to_cpu(vmsvga_fifo_read_raw(s));\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void test_syslog_parse_identifier(const char* str,\n                                         const char *ident, const char*pid, int ret) {\n        const char *buf = str;\n        _cleanup_free_ char *ident2 = NULL, *pid2 = NULL;\n        int ret2;\n\n        ret2 = syslog_parse_identifier(&buf, &ident2, &pid2);\n\n        assert_se(ret == ret2);\n        assert_se(ident == ident2 || streq_ptr(ident, ident2));\n        assert_se(pid == pid2 || streq_ptr(pid, pid2));\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void AddFrameToSet(std::set<content::RenderFrameHost*>* frames,\n                   content::RenderFrameHost* rfh) {\n  if (rfh->IsRenderFrameLive())\n    frames->insert(rfh);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void __net_exit packet_net_exit(struct net *net)\n{\n\tremove_proc_entry(\"packet\", net->proc_net);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void tq_free(struct thread_q *tq)\n{\n\tstruct tq_ent *ent, *iter;\n\n\tif (!tq)\n\t\treturn;\n\n\tlist_for_each_entry_safe(ent, iter, &tq->q, q_node) {\n\t\tlist_del(&ent->q_node);\n\t\tfree(ent);\n\t}\n\n\tpthread_cond_destroy(&tq->cond);\n\tpthread_mutex_destroy(&tq->mutex);\n\n\tmemset(tq, 0, sizeof(*tq));\t/* poison */\n\tfree(tq);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void *acpi_set_bsel(PCIBus *bus, void *opaque)\n\n{\n\n    unsigned *bsel_alloc = opaque;\n\n    unsigned *bus_bsel;\n\n\n\n    if (qbus_is_hotpluggable(BUS(bus))) {\n\n        bus_bsel = g_malloc(sizeof *bus_bsel);\n\n\n\n        *bus_bsel = (*bsel_alloc)++;\n\n        object_property_add_uint32_ptr(OBJECT(bus), ACPI_PCIHP_PROP_BSEL,\n\n                                       bus_bsel, NULL);\n\n    }\n\n\n\n    return bsel_alloc;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void Document::clearFocusedElementSoon()\n{\n    if (!m_clearFocusedElementTimer.isActive())\n        m_clearFocusedElementTimer.startOneShot(0, BLINK_FROM_HERE);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_inodes_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_inodes_count_hi = cpu_to_le16(count >> 16);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "bool Instance::HandleDocumentLoad(const pp::URLLoader& loader) {\n  delayed_progress_timer_id_ = ScheduleTimer(kProgressBarId,\n                                             kProgressDelayTimeoutMs);\n  return engine_->HandleDocumentLoad(loader);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "evbuffer_copyout(struct evbuffer *buf, void *data_out, size_t datlen)\n{\n\t/*XXX fails badly on sendfile case. */\n\tstruct evbuffer_chain *chain;\n\tchar *data = data_out;\n\tsize_t nread;\n\tev_ssize_t result = 0;\n\n\tEVBUFFER_LOCK(buf);\n\n\tchain = buf->first;\n\n\tif (datlen >= buf->total_len)\n\t\tdatlen = buf->total_len;\n\n\tif (datlen == 0)\n\t\tgoto done;\n\n\tif (buf->freeze_start) {\n\t\tresult = -1;\n\t\tgoto done;\n\t}\n\n\tnread = datlen;\n\n\twhile (datlen && datlen >= chain->off) {\n\t\tmemcpy(data, chain->buffer + chain->misalign, chain->off);\n\t\tdata += chain->off;\n\t\tdatlen -= chain->off;\n\n\t\tchain = chain->next;\n\t\tEVUTIL_ASSERT(chain || datlen==0);\n\t}\n\n\tif (datlen) {\n\t\tEVUTIL_ASSERT(chain);\n\t\tmemcpy(data, chain->buffer + chain->misalign, datlen);\n\t}\n\n\tresult = nread;\ndone:\n\tEVBUFFER_UNLOCK(buf);\n\treturn result;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void kvm_arch_destroy_vm(struct kvm *kvm)\n{\n\tkvm_iommu_unmap_guest(kvm);\n\tkfree(kvm->arch.vpic);\n\tkfree(kvm->arch.vioapic);\n\tkvm_free_vcpus(kvm);\n\tif (kvm->arch.apic_access_page)\n\t\tput_page(kvm->arch.apic_access_page);\n\tif (kvm->arch.ept_identity_pagetable)\n\t\tput_page(kvm->arch.ept_identity_pagetable);\n\tkfree(rcu_dereference_check(kvm->arch.apic_map, 1));\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void parse_option_size(const char *name, const char *value,\n\n                       uint64_t *ret, Error **errp)\n\n{\n\n    char *postfix;\n\n    double sizef;\n\n\n\n    sizef = strtod(value, &postfix);\n\n    if (sizef < 0 || sizef > UINT64_MAX) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, name,\n\n                   \"a non-negative number below 2^64\");\n\n        return;\n\n    }\n\n    switch (*postfix) {\n\n    case 'T':\n\n        sizef *= 1024;\n\n        /* fall through */\n\n    case 'G':\n\n        sizef *= 1024;\n\n        /* fall through */\n\n    case 'M':\n\n        sizef *= 1024;\n\n        /* fall through */\n\n    case 'K':\n\n    case 'k':\n\n        sizef *= 1024;\n\n        /* fall through */\n\n    case 'b':\n\n    case '\\0':\n\n        *ret = (uint64_t) sizef;\n\n        break;\n\n    default:\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, name, \"a size\");\n\n        error_append_hint(errp, \"You may use k, M, G or T suffixes for \"\n\n                          \"kilobytes, megabytes, gigabytes and terabytes.\\n\");\n\n        return;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void fw_cfg_add_i64(FWCfgState *s, uint16_t key, uint64_t value)\n\n{\n\n    uint64_t *copy;\n\n\n\n    copy = g_malloc(sizeof(value));\n\n    *copy = cpu_to_le64(value);\n\n    fw_cfg_add_bytes(s, key, (uint8_t *)copy, sizeof(value));\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void visit(Character & /*ope*/) override { done_ = true; }",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "inline WriteWrap* StreamBase::CreateWriteWrap(\n    v8::Local<v8::Object> object) {\n  return new SimpleWriteWrap<AsyncWrap>(this, object);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void nlmsg_set_src(struct nl_msg *msg, struct sockaddr_nl *addr)\n{\n\tmemcpy(&msg->nm_src, addr, sizeof(*addr));\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void gen_mfmsr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_msr);\n\n#endif\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "GLvoid StubGLCompressedTexImage2D(GLenum target, GLint level,\n                                  GLenum internalformat, GLsizei width,\n                                  GLsizei height, GLint border,\n                                  GLsizei imageSize, const void* data) {\n  glCompressedTexImage2D(target, level, internalformat, width, height, border,\n                         imageSize, data);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "FormController& Document::GetFormController() {\n  if (!form_controller_) {\n    form_controller_ = MakeGarbageCollected<FormController>(*this);\n    HistoryItem* history_item = Loader() ? Loader()->GetHistoryItem() : nullptr;\n    if (history_item)\n      history_item->SetDocumentState(form_controller_->FormElementsState());\n  }\n  return *form_controller_;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "std::string Value::toString() const\n    {\n        std::ostringstream os;\n        write(os);\n        ok_ = !os.fail();\n        return os.str();\n    }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void Process_ipfix_template_withdraw(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\nipfix_template_record_t *ipfix_template_record;\n\n\t// a template flowset can contain multiple records ( templates )\n\twhile ( size_left ) {\n\t\tuint32_t id;\n\n\t\t// map next record.\n\t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n\t\tsize_left \t\t-= 4;\n\n\t\tid \t  = ntohs(ipfix_template_record->TemplateID);\n\t\t// count = ntohs(ipfix_template_record->FieldCount);\n\n\t\tif ( id == IPFIX_TEMPLATE_FLOWSET_ID ) {\n\t\t\t// withdraw all templates\n\t\t\tremove_all_translation_tables(exporter);\n\t\t\tReInitExtensionMapList(fs);\n\t\t} else {\n\t\t\tremove_translation_table(fs, exporter, id);\n\t\t}\n\n\t\tDataPtr = DataPtr + 4;\n\t\tif ( size_left < 4 ) {\n\t\t\t// pading\n\t\t\tdbg_printf(\"Skip %u bytes padding\\n\", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t}\n \n} // End of Process_ipfix_template_withdraw",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "__archive_write_close_filter(struct archive_write_filter *f)\n{\n\tif (f->close != NULL)\n\t\treturn (f->close)(f);\n\tif (f->next_filter != NULL)\n\t\treturn (__archive_write_close_filter(f->next_filter));\n\treturn (ARCHIVE_OK);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void build_thisnode_zonelists(pg_data_t *pgdat)\n{\n\tstruct zoneref *zonerefs;\n\tint nr_zones;\n\n\tzonerefs = pgdat->node_zonelists[ZONELIST_NOFALLBACK]._zonerefs;\n\tnr_zones = build_zonerefs_node(pgdat, zonerefs);\n\tzonerefs += nr_zones;\n\tzonerefs->zone = NULL;\n\tzonerefs->zone_idx = 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int vmdk_write_compressed(BlockDriverState *bs,\n\n                                 int64_t sector_num,\n\n                                 const uint8_t *buf,\n\n                                 int nb_sectors)\n\n{\n\n    BDRVVmdkState *s = bs->opaque;\n\n\n\n    if (s->num_extents == 1 && s->extents[0].compressed) {\n\n        Coroutine *co;\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n        VmdkWriteCompressedCo data = {\n\n            .bs         = bs,\n\n            .sector_num = sector_num,\n\n            .buf        = buf,\n\n            .nb_sectors = nb_sectors,\n\n            .ret        = -EINPROGRESS,\n\n        };\n\n        co = qemu_coroutine_create(vmdk_co_write_compressed);\n\n        qemu_coroutine_enter(co, &data);\n\n        while (data.ret == -EINPROGRESS) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n        return data.ret;\n\n    } else {\n\n        return -ENOTSUP;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "TEST_F(RenameCollectionTest, RenameCollectionAcrossDatabaseOplogEntries) {\n    bool forApplyOps = false;\n    _testRenameCollectionAcrossDatabaseOplogEntries(\n        _opCtx.get(),\n        _sourceNss,\n        _targetNssDifferentDb,\n        &_opObserver->oplogEntries,\n        forApplyOps,\n        {\"create\", \"index\", \"inserts\", \"rename\", \"drop\"});\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void cpu_unregister_map_client_do(MapClient *client)\n{\n    QLIST_REMOVE(client, link);\n    g_free(client);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void *colo_compare_thread(void *opaque)\n\n{\n\n    GMainContext *worker_context;\n\n    GMainLoop *compare_loop;\n\n    CompareState *s = opaque;\n\n    GSource *timeout_source;\n\n\n\n    worker_context = g_main_context_new();\n\n\n\n    qemu_chr_fe_set_handlers(&s->chr_pri_in, compare_chr_can_read,\n\n                             compare_pri_chr_in, NULL, s, worker_context, true);\n\n    qemu_chr_fe_set_handlers(&s->chr_sec_in, compare_chr_can_read,\n\n                             compare_sec_chr_in, NULL, s, worker_context, true);\n\n\n\n    compare_loop = g_main_loop_new(worker_context, FALSE);\n\n\n\n    /* To kick any packets that the secondary doesn't match */\n\n    timeout_source = g_timeout_source_new(REGULAR_PACKET_CHECK_MS);\n\n    g_source_set_callback(timeout_source,\n\n                          (GSourceFunc)check_old_packet_regular, s, NULL);\n\n    g_source_attach(timeout_source, worker_context);\n\n\n\n    g_main_loop_run(compare_loop);\n\n\n\n    g_source_unref(timeout_source);\n\n    g_main_loop_unref(compare_loop);\n\n    g_main_context_unref(worker_context);\n\n    return NULL;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' %s %s %s\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       quote_empty(stfl::quote(title)),\n\t\t                                       quote_empty(stfl::quote(description)),\n\t\t                                       quote_empty(stfl::quote(feed_title)));\n\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void pdf_run_TJ(fz_context *ctx, pdf_processor *proc, pdf_obj *obj)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_text(ctx, pr, obj);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void gen_swa(DisasContext *dc, TCGv rb, TCGv ra, int32_t ofs)\n\n{\n\n    TCGv ea, val;\n\n    TCGLabel *lab_fail, *lab_done;\n\n\n\n    ea = tcg_temp_new();\n\n    tcg_gen_addi_tl(ea, ra, ofs);\n\n\n\n    lab_fail = gen_new_label();\n\n    lab_done = gen_new_label();\n\n    tcg_gen_brcond_tl(TCG_COND_NE, ea, cpu_lock_addr, lab_fail);\n\n    tcg_temp_free(ea);\n\n\n\n    val = tcg_temp_new();\n\n    tcg_gen_atomic_cmpxchg_tl(val, cpu_lock_addr, cpu_lock_value,\n\n                              rb, dc->mem_idx, MO_TEUL);\n\n    tcg_gen_setcond_tl(TCG_COND_EQ, cpu_sr_f, val, cpu_lock_value);\n\n    tcg_temp_free(val);\n\n\n\n    tcg_gen_br(lab_done);\n\n\n\n    gen_set_label(lab_fail);\n\n    tcg_gen_movi_tl(cpu_sr_f, 0);\n\n\n\n    gen_set_label(lab_done);\n\n    tcg_gen_movi_tl(cpu_lock_addr, -1);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "cdf_dump_catalog(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tcdf_catalog_t *cat;\n\tcdf_unpack_catalog(h, sst, &cat);\n\tconst cdf_catalog_entry_t *ce = cat->cat_e;\n\tstruct timespec ts;\n\tchar tbuf[64], sbuf[256];\n\tsize_t i;\n\n\tprintf(\"Catalog:\\n\");\n\tfor (i = 0; i < cat->cat_num; i++) {\n\t\tcdf_timestamp_to_timespec(&ts, ce[i].ce_timestamp);\n\t\tprintf(\"\\t%d %s %s\", ce[i].ce_num,\n\t\t    cdf_u16tos8(sbuf, ce[i].ce_namlen, ce[i].ce_name),\n\t\t    cdf_ctime(&ts.tv_sec, tbuf));\n\t}\n\tfree(cat);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void EditorClientBlackBerry::didSetSelectionTypesForPasteboard()\n{\n    notImplemented();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static bool file_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tint fd;\n\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\treturn false;\n\t}\n\tpath += 1; /* get past '/' */\n\n\tif (access(path, W_OK) != -1)\n\t\treturn true; /* File exists and is writable */\n\n\t/* We also support creating the file, so see if we can create it */\n\tfd = creat(path, S_IRUSR | S_IWUSR);\n\tif (fd == -1) {\n\t\tif (asprintf(reason, \"Could not create file\") == -1)\n\t\t\t*reason = NULL;\n\t\treturn false;\n\t}\n\n\tunlink(path);\n\n\treturn true;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "constructor (GType type,\n\t\t   guint n_construct_params,\n\t\t   GObjectConstructParam *construct_params)\n{\n\tGObject *object;\n\tNMAGConfConnectionPrivate *priv;\n\tNMConnection *connection;\n\tGError *error = NULL;\n\n\tobject = G_OBJECT_CLASS (nma_gconf_connection_parent_class)->constructor (type, n_construct_params, construct_params);\n\n\tif (!object)\n\t\treturn NULL;\n\n\tpriv = NMA_GCONF_CONNECTION_GET_PRIVATE (object);\n\n\tif (!priv->client) {\n\t\tnm_warning (\"GConfClient not provided.\");\n\t\tgoto err;\n\t}\n\n\tif (!priv->dir) {\n\t\tnm_warning (\"GConf directory not provided.\");\n\t\tgoto err;\n\t}\n\n\tconnection = nm_exported_connection_get_connection (NM_EXPORTED_CONNECTION (object));\n\n\tutils_fill_connection_certs (connection);\n\tif (!nm_connection_verify (connection, &error)) {\n\t\tutils_clear_filled_connection_certs (connection);\n\t\tg_warning (\"Invalid connection: '%s' / '%s' invalid: %d\",\n\t\t           g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),\n\t\t           error->message, error->code);\n\t\tg_error_free (error);\n\t\tgoto err;\n\t}\n\tutils_clear_filled_connection_certs (connection);\n\n\tfill_vpn_user_name (connection);\n\n\treturn object;\n\n err:\n\tg_object_unref (object);\n\n\treturn NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "av_cold void ff_fft_init_arm(FFTContext *s)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (have_vfp(cpu_flags) && !have_vfpv3(cpu_flags)) {\n\n        s->fft_calc     = ff_fft_calc_vfp;\n\n#if CONFIG_MDCT\n\n        s->imdct_half   = ff_imdct_half_vfp;\n\n#endif\n\n    }\n\n\n\n    if (have_neon(cpu_flags)) {\n\n        s->fft_permute  = ff_fft_permute_neon;\n\n        s->fft_calc     = ff_fft_calc_neon;\n\n#if CONFIG_MDCT\n\n        s->imdct_calc   = ff_imdct_calc_neon;\n\n        s->imdct_half   = ff_imdct_half_neon;\n\n        s->mdct_calc    = ff_mdct_calc_neon;\n\n        s->mdct_permutation = FF_MDCT_PERM_INTERLEAVE;\n\n#endif\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "SPL_METHOD(SplFileObject, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n/*\tDo not read the next line to support correct counting with fgetc()\n\tif (!intern->current_line) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t} */\n\tRETURN_LONG(intern->u.file.current_line_num);\n} /* }}} */",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "onig_node_str_set(Node* node, const UChar* s, const UChar* end)\n{\n  onig_node_str_clear(node);\n  return onig_node_str_cat(node, s, end);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "juniper_frelay_print(netdissect_options *ndo,\n                     const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\n        l2info.pictype = DLT_JUNIPER_FRELAY;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n        /* this DLT contains nothing but raw frame-relay frames */\n        fr_print(ndo, p, l2info.length);\n        return l2info.header_len;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "gdata_service_dispose (GObject *object)\n{\n\tGDataServicePrivate *priv = GDATA_SERVICE (object)->priv;\n\n\tif (priv->authorizer != NULL)\n\t\tg_object_unref (priv->authorizer);\n\tpriv->authorizer = NULL;\n\n\tif (priv->session != NULL)\n\t\tg_object_unref (priv->session);\n\tpriv->session = NULL;\n\n\t/* Chain up to the parent class */\n\tG_OBJECT_CLASS (gdata_service_parent_class)->dispose (object);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void touch_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd)\n{\n\tpmd_t _pmd;\n\n\t/*\n\t * We should set the dirty bit only for FOLL_WRITE but for now\n\t * the dirty bit in the pmd is meaningless.  And if the dirty\n\t * bit will become meaningful and we'll only set it with\n\t * FOLL_WRITE, an atomic set_bit will be required on the pmd to\n\t * set the young bit, instead of the current set_pmd_at.\n\t */\n\t_pmd = pmd_mkyoung(pmd_mkdirty(*pmd));\n\tif (pmdp_set_access_flags(vma, addr & HPAGE_PMD_MASK,\n\t\t\t\tpmd, _pmd,  1))\n\t\tupdate_mmu_cache_pmd(vma, addr, pmd);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int rtsx_usb_ms_drv_remove(struct platform_device *pdev)\n{\n\tstruct rtsx_usb_ms *host = platform_get_drvdata(pdev);\n\tstruct memstick_host *msh = host->msh;\n\tint err;\n\n\thost->eject = true;\n\tcancel_work_sync(&host->handle_req);\n\n\tmutex_lock(&host->host_mutex);\n\tif (host->req) {\n\t\tdev_dbg(ms_dev(host),\n\t\t\t\"%s: Controller removed during transfer\\n\",\n\t\t\tdev_name(&msh->dev));\n\t\thost->req->error = -ENOMEDIUM;\n\t\tdo {\n\t\t\terr = memstick_next_req(msh, &host->req);\n\t\t\tif (!err)\n\t\t\t\thost->req->error = -ENOMEDIUM;\n\t\t} while (!err);\n\t}\n\tmutex_unlock(&host->host_mutex);\n\n\tmemstick_remove_host(msh);\n\tmemstick_free_host(msh);\n\n\t/* Balance possible unbalanced usage count\n\t * e.g. unconditional module removal\n\t */\n\tif (pm_runtime_active(ms_dev(host)))\n\t\tpm_runtime_put(ms_dev(host));\n\n\tpm_runtime_disable(ms_dev(host));\n\tplatform_set_drvdata(pdev, NULL);\n\n\tdev_dbg(ms_dev(host),\n\t\t\": Realtek USB Memstick controller has been removed\\n\");\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void object_property_add_link(Object *obj, const char *name,\n\n                              const char *type, Object **child,\n\n                              Error **errp)\n\n{\n\n    gchar *full_type;\n\n\n\n    full_type = g_strdup_printf(\"link<%s>\", type);\n\n\n\n    object_property_add(obj, name, full_type,\n\n                        object_get_link_property,\n\n                        object_set_link_property,\n\n                        NULL, child, errp);\n\n\n\n    g_free(full_type);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void dump_xml(Formatter *f) const {\n          encode_xml(\"Owner\", owner, f);\n        }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void gen_stx(DisasContext *dc, uint32_t code, uint32_t flags)\n\n{\n\n    I_TYPE(instr, code);\n\n    TCGv val = load_gpr(dc, instr.b);\n\n\n\n    TCGv addr = tcg_temp_new();\n\n    tcg_gen_addi_tl(addr, load_gpr(dc, instr.a), instr.imm16s);\n\n    tcg_gen_qemu_st_tl(val, addr, dc->mem_idx, flags);\n\n    tcg_temp_free(addr);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void WavOutFile::finishHeader()\r\n{\r\n    // supplement the file length into the header structure\r\n    header.riff.package_len = bytesWritten + sizeof(WavHeader) - sizeof(WavRiff) + 4;\r\n    header.data.data_len = bytesWritten;\r\n    header.fact.fact_sample_len = bytesWritten / header.format.byte_per_sample; \r\n    \r\n    writeHeader();\r\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "const RunFromHostProxyCallback& run_callback() const { return run_callback_; }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void tulip_tx(TULIPState *s, struct tulip_descriptor *desc)\n{\n    if (s->tx_frame_len) {\n        if ((s->csr[6] >> CSR6_OM_SHIFT) & CSR6_OM_MASK) {\n            /* Internal or external Loopback */\n            tulip_receive(s, s->tx_frame, s->tx_frame_len);\n        } else {\n            qemu_send_packet(qemu_get_queue(s->nic),\n                s->tx_frame, s->tx_frame_len);\n        }\n    }\n\n    if (desc->control & TDES1_IC) {\n        s->csr[5] |= CSR5_TI;\n        tulip_update_int(s);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "QPDFObjectHandle::assertName()\n{\n    assertType(\"Name\", isName());\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": " */\nstatic xmlXPathParserContextPtr\nxmlXPathCompParserContext(xmlXPathCompExprPtr comp, xmlXPathContextPtr ctxt) {\n    xmlXPathParserContextPtr ret;\n\n    ret = (xmlXPathParserContextPtr) xmlMalloc(sizeof(xmlXPathParserContext));\n    if (ret == NULL) {\n        xmlXPathErrMemory(ctxt, \"creating evaluation context\\n\");\n\treturn(NULL);\n    }\n    memset(ret, 0 , (size_t) sizeof(xmlXPathParserContext));\n\n    /* Allocate the value stack */\n    ret->valueTab = (xmlXPathObjectPtr *)\n                     xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n    if (ret->valueTab == NULL) {\n\txmlFree(ret);\n\txmlXPathErrMemory(ctxt, \"creating evaluation context\\n\");\n\treturn(NULL);\n    }\n    ret->valueNr = 0;\n    ret->valueMax = 10;\n    ret->value = NULL;\n\n    ret->context = ctxt;\n    ret->comp = comp;\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n\t\t\t       const pj_uint8_t *pkt, const pj_uint8_t *start,\n\t\t\t       const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Allocate memory for the name */\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    p = (start + name_part_len);\n\n    /* Get the type */\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n\n    /* Get the class */\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n\n    *parsed_len = (int)(p - start);\n\n    return PJ_SUCCESS;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret != -EEXIST ? ret : 0;\n\t}\n\n\treturn commit_creds(new);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "//! Convert pixel values from RGB to CMYK color spaces.\n    CImg<T>& RGBtoCMYK() {\n      return RGBtoCMY().CMYtoCMYK();",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "concat_opt_anc_info(OptAnc* to, OptAnc* left, OptAnc* right,\n                    OnigLen left_len, OnigLen right_len)\n{\n  clear_opt_anc_info(to);\n\n  to->left = left->left;\n  if (left_len == 0) {\n    to->left |= right->left;\n  }\n\n  to->right = right->right;\n  if (right_len == 0) {\n    to->right |= left->right;\n  }\n  else {\n    to->right |= (left->right & ANCR_PREC_READ_NOT);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void openpic_src_write(void *opaque, hwaddr addr, uint64_t val,\n\n                              unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    int idx;\n\n\n\n    DPRINTF(\"%s: addr %08x <= %08x\\n\", __func__, addr, val);\n\n    if (addr & 0xF)\n\n        return;\n\n    addr = addr & 0xFFF0;\n\n    idx = addr >> 5;\n\n    if (addr & 0x10) {\n\n        /* EXDE / IFEDE / IEEDE */\n\n        write_IRQreg_ide(opp, idx, val);\n\n    } else {\n\n        /* EXVP / IFEVP / IEEVP */\n\n        write_IRQreg_ipvp(opp, idx, val);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\t/* Don't allow changing of locked mnt flags.\n\t *\n\t * No locks need to be held here while testing the various\n\t * MNT_LOCK flags because those flags can never be cleared\n\t * once they are set.\n\t */\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&\n \t    !(mnt_flags & MNT_READONLY)) {\n \t\treturn -EPERM;\n \t}\n \terr = security_sb_remount(sb, data);\n \tif (err)\n \t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int ber_write_octet_string_tag(wStream* s, int length)\n{\n\tber_write_universal_tag(s, BER_TAG_OCTET_STRING, FALSE);\n\tber_write_length(s, length);\n\treturn 1 + _ber_skip_length(length);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool hbitmap_get(const HBitmap *hb, uint64_t item)\n\n{\n\n    /* Compute position and bit in the last layer.  */\n\n    uint64_t pos = item >> hb->granularity;\n\n    unsigned long bit = 1UL << (pos & (BITS_PER_LONG - 1));\n\n\n\n\n    return (hb->levels[HBITMAP_LEVELS - 1][pos >> BITS_PER_LEVEL] & bit) != 0;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn,\n\t\t\t\t       struct xfrm_replay_state_esn **preplay_esn,\n\t\t\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_replay_state_esn *p, *pp, *up;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tup = nla_data(rta);\n\n\tp = kmemdup(up, xfrm_replay_state_esn_len(up), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpp = kmemdup(up, xfrm_replay_state_esn_len(up), GFP_KERNEL);\n\tif (!pp) {\n\t\tkfree(p);\n\t\treturn -ENOMEM;\n\t}\n\n\t*replay_esn = p;\n\t*preplay_esn = pp;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "PHPAPI size_t php_printf(const char *format, ...)\n{\n\tva_list args;\n\tsize_t ret;\n\tchar *buffer;\n\tsize_t size;\n\n\tva_start(args, format);\n\tsize = vspprintf(&buffer, 0, format, args);\n\tret = PHPWRITE(buffer, size);\n\tefree(buffer);\n\tva_end(args);\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int update_add_entry(struct libmnt_update *upd, struct libmnt_lock *lc)\n{\n\tFILE *f;\n\tint rc = 0, u_lc = -1;\n\n\tassert(upd);\n\tassert(upd->fs);\n\n\tDBG(UPDATE, mnt_debug_h(upd, \"%s: add entry\", upd->filename));\n\n\tif (lc)\n\t\tmnt_lock_file(lc);\n\telse if (upd->userspace_only)\n\t\tu_lc = utab_lock(upd->filename);\n\n\tf = fopen(upd->filename, \"a+\");\n\tif (f) {\n\t\trc = upd->userspace_only ? fprintf_utab_fs(f, upd->fs) :\n\t\t\t\t\t   fprintf_mtab_fs(f, upd->fs);\n\t\tDBG(UPDATE, mnt_debug_h(upd, \"%s: add [rc=%d]\", upd->filename, rc));\n\t\tfclose(f);\n\t} else {\n\t\tDBG(UPDATE, mnt_debug_h(upd, \"%s: failed: %m\", upd->filename));\n\t\trc = -errno;\n\t}\n\tif (lc)\n\t\tmnt_unlock_file(lc);\n\telse if (u_lc != -1)\n\t\tutab_unlock(u_lc);\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "Ins_MINDEX( INS_ARG )\n  {\n    FT_Long  L, K;\n\n\n    L = args[0];\n\n    if ( L <= 0 || L > CUR.args )\n    {\n      CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    K = CUR.stack[CUR.args - L];\n\n    FT_ARRAY_MOVE( &CUR.stack[CUR.args - L    ],\n                   &CUR.stack[CUR.args - L + 1],\n                   ( L - 1 ) );\n\n    CUR.stack[CUR.args - 1] = K;\n  }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void rawsock_destruct(struct sock *sk)\n{\n\tpr_debug(\"sk=%p\\n\", sk);\n\n\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\tnfc_deactivate_target(nfc_rawsock(sk)->dev,\n\t\t\t\t      nfc_rawsock(sk)->target_idx);\n\t\tnfc_put_device(nfc_rawsock(sk)->dev);\n\t}\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC raw socket %p\\n\", sk);\n\t\treturn;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int sock_no_connect(struct socket *sock, struct sockaddr *saddr,\n\t\t    int len, int flags)\n{\n\treturn -EOPNOTSUPP;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "OVS_REQUIRES(ofproto_mutex)\n{\n    struct rule *rule = rule_collection_rules(&ofm->new_rules)[0];\n\n    /* If learning on a different bridge, must bump its version\n     * number and flush connmgr afterwards. */\n    if (rule->ofproto != orig_ofproto) {\n        ofproto_bump_tables_version(rule->ofproto);\n    }\n    ofproto_flow_mod_finish(rule->ofproto, ofm, NULL);\n    if (rule->ofproto != orig_ofproto) {\n        ofmonitor_flush(rule->ofproto->connmgr);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "kvm_calc_nested_mmu_role(struct kvm_vcpu *vcpu, struct kvm_mmu_role_regs *regs)\n{\n\tunion kvm_mmu_role role;\n\n\trole = kvm_calc_shadow_root_page_role_common(vcpu, regs, false);\n\n\t/*\n\t * Nested MMUs are used only for walking L2's gva->gpa, they never have\n\t * shadow pages of their own and so \"direct\" has no meaning.   Set it\n\t * to \"true\" to try to detect bogus usage of the nested MMU.\n\t */\n\trole.base.direct = true;\n\trole.base.level = role_regs_to_root_level(regs);\n\treturn role;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static inline void ModulateHSB(const double percent_hue,\n  const double percent_saturation,const double percent_brightness,double *red,\n  double *green,double *blue)\n{\n  double\n    brightness,\n    hue,\n    saturation;\n\n  /*\n    Increase or decrease color brightness, saturation, or hue.\n  */\n  ConvertRGBToHSB(*red,*green,*blue,&hue,&saturation,&brightness);\n  hue+=0.5*(0.01*percent_hue-1.0);\n  while (hue < 0.0)\n    hue+=1.0;\n  while (hue > 1.0)\n    hue-=1.0;\n  saturation*=0.01*percent_saturation;\n  brightness*=0.01*percent_brightness;\n  ConvertHSBToRGB(hue,saturation,brightness,red,green,blue);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tapic_debug(\"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "long sumToLong(const Exiv2::Exifdatum& md)\n    {\n        long sum = 0;\n        for (int i = 0; i < md.count(); ++i) {\n            sum += md.toLong(i);\n        }\n        return sum;\n    }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "__ip_vs_unbind_svc(struct ip_vs_dest *dest)\n{\n\tstruct ip_vs_service *svc = dest->svc;\n\n\tdest->svc = NULL;\n\tif (atomic_dec_and_test(&svc->refcnt))\n\t\tkfree(svc);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static av_cold int libschroedinger_decode_close(AVCodecContext *avctx)\n\n{\n\n    SchroDecoderParams *p_schro_params = avctx->priv_data;\n\n    /* Free the decoder. */\n\n    schro_decoder_free(p_schro_params->decoder);\n\n    av_freep(&p_schro_params->format);\n\n\n\n    /* Free data in the output frame queue. */\n\n    ff_schro_queue_free(&p_schro_params->dec_frame_queue,\n\n                        libschroedinger_decode_frame_free);\n\n\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void dsputil_init_armv4l(DSPContext* c, AVCodecContext *avctx)\n{\n    const int idct_algo= avctx->idct_algo;\n    ff_put_pixels_clamped = c->put_pixels_clamped;\n    ff_add_pixels_clamped = c->add_pixels_clamped;\n    if(idct_algo==FF_IDCT_ARM){\n    if(idct_algo==FF_IDCT_AUTO || idct_algo==FF_IDCT_ARM){\n        c->idct_put= j_rev_dct_ARM_put;\n        c->idct_add= j_rev_dct_ARM_add;\n\tc->idct    = j_rev_dct_ARM;\n        c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM;/* FF_NO_IDCT_PERM */\n    } else if (idct_algo==FF_IDCT_SIMPLEARM){\n\tc->idct_put= simple_idct_ARM_put;\n\tc->idct_add= simple_idct_ARM_add;\n\tc->idct    = simple_idct_ARM;\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "int luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  int counthook;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */\n    ci->u.l.trap = 0;  /* don't need to stop again */\n    return 0;  /* turn off 'trap' */\n  }\n  pc++;  /* reference is always next instruction */\n  ci->u.l.savedpc = pc;  /* save 'pc' */\n  counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));\n  if (counthook)\n    resethookcount(L);  /* reset count */\n  else if (!(mask & LUA_MASKLINE))\n    return 1;  /* no line hook and count != 0; nothing to be done now */\n  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */\n    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */\n    return 1;  /* do not call hook again (VM yielded, so it did not move) */\n  }\n  if (!isIT(*(ci->u.l.savedpc - 1)))\n    L->top = ci->top;  /* prepare top */\n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */\n  if (mask & LUA_MASKLINE) {\n    const Proto *p = ci_func(ci)->p;\n    int npci = pcRel(pc, p);\n    if (npci == 0 ||  /* call linehook when enter a new function, */\n        pc <= L->oldpc ||  /* when jump back (loop), or when */\n        changedline(p, pcRel(L->oldpc, p), npci)) {  /* enter new line */\n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */\n    }\n    L->oldpc = pc;  /* 'pc' of last call to line hook */\n  }\n  if (L->status == LUA_YIELD) {  /* did hook yield? */\n    if (counthook)\n      L->hookcount = 1;  /* undo decrement to zero */\n    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */\n    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */\n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  /* keep 'trap' on */\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void xen_set_ldt(const void *addr, unsigned entries)\n{\n\tstruct mmuext_op *op;\n\tstruct multicall_space mcs = xen_mc_entry(sizeof(*op));\n\n\ttrace_xen_cpu_set_ldt(addr, entries);\n\n\top = mcs.args;\n\top->cmd = MMUEXT_SET_LDT;\n\top->arg1.linear_addr = (unsigned long)addr;\n\top->arg2.nr_ents = entries;\n\n\tMULTI_mmuext_op(mcs.mc, op, 1, NULL, DOMID_SELF);\n\n\txen_mc_issue(PARAVIRT_LAZY_CPU);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "inline void GatherNd(const RuntimeShape& params_shape,\n                     const ParamsT* params_data,\n                     const RuntimeShape& indices_shape,\n                     const IndicesT* indices_data,\n                     const RuntimeShape& output_shape, ParamsT* output_data) {\n  ruy::profiler::ScopeLabel label(\"GatherNd\");\n\n  const GatherNdHelperResult res = GatherNdHelper(params_shape, indices_shape);\n  for (int i = 0; i < res.n_slices; ++i) {\n    int from_pos = 0;\n    for (int j = 0; j < res.indices_nd; ++j) {\n      from_pos += indices_data[i * res.indices_nd + j] * res.dims_to_count[j];\n    }\n    std::memcpy(output_data + i * res.slice_size, params_data + from_pos,\n                sizeof(ParamsT) * res.slice_size);\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "pk_transaction_search_check (gchar **values, GError **error)\n{\n\tguint i;\n\n\t/* check each parameter */\n\tfor (i = 0; values[i] != NULL; i++) {\n\t\tif (!pk_transaction_search_check_item (values[i], error))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void replay_save_instructions(void)\n{\n    if (replay_file && replay_mode == REPLAY_MODE_RECORD) {\n        replay_mutex_lock();\n        int diff = (int)(replay_get_current_step() - replay_state.current_step);\n        if (diff > 0) {\n            replay_put_event(EVENT_INSTRUCTION);\n            replay_put_dword(diff);\n            replay_state.current_step += diff;\n        }\n        replay_mutex_unlock();\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "  void decode(bufferlist::iterator& bl) {\n    __u8 struct_v;\n    ::decode(struct_v, bl);\n    ::decode(nonce, bl);\n  }",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void qtest_qmp(QTestState *s, const char *fmt, ...)\n{\n    va_list ap;\n    bool has_reply = false;\n    int nesting = 0;\n    /* Send QMP request */\n    va_start(ap, fmt);\n    socket_sendf(s->qmp_fd, fmt, ap);\n    va_end(ap);\n    /* Receive reply */\n    while (!has_reply || nesting > 0) {\n        ssize_t len;\n        char c;\n        len = read(s->qmp_fd, &c, 1);\n        if (len == -1 && errno == EINTR) {\n            continue;\n        switch (c) {\n        case '{':\n            nesting++;\n            has_reply = true;\n            break;\n        case '}':\n            nesting--;\n            break;",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int local_create_mapped_attr_dir(FsContext *ctx, const char *path)\n\n{\n\n    int err;\n\n    char attr_dir[PATH_MAX];\n\n    char *tmp_path = strdup(path);\n\n\n\n    snprintf(attr_dir, PATH_MAX, \"%s/%s/%s\",\n\n             ctx->fs_root, dirname(tmp_path), VIRTFS_META_DIR);\n\n\n\n    err = mkdir(attr_dir, 0700);\n\n    if (err < 0 && errno == EEXIST) {\n\n        err = 0;\n\n    }\n\n    free(tmp_path);\n\n    return err;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tconst void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_vcpu_write_guest(vcpu, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_mmu_pte_write(vcpu, gpa, val, bytes);\n\treturn 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "compute_tag(dns_name_t *name, dns_rdata_dnskey_t *dnskey, isc_mem_t *mctx,\n\t    dns_keytag_t *tag)\n{\n\tisc_result_t result;\n\tdns_rdata_t rdata = DNS_RDATA_INIT;\n\tunsigned char data[4096];\n\tisc_buffer_t buffer;\n\tdst_key_t *dstkey = NULL;\n\n\tisc_buffer_init(&buffer, data, sizeof(data));\n\tdns_rdata_fromstruct(&rdata, dnskey->common.rdclass,\n\t\t\t     dns_rdatatype_dnskey, dnskey, &buffer);\n\n\tresult = dns_dnssec_keyfromrdata(name, &rdata, mctx, &dstkey);\n\tif (result == ISC_R_SUCCESS)\n\t\t*tag = dst_key_id(dstkey);\n\tdst_key_free(&dstkey);\n\n\treturn (result);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int js_gettop(js_State *J)\n{\n\treturn TOP - BOT;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void rfbTightCleanup(rfbScreenInfoPtr screen)\n{\n  if(tightBeforeBufSize) {\n    free(tightBeforeBuf);\n    tightBeforeBufSize=0;\n  }\n  if(tightAfterBufSize) {\n    free(tightAfterBuf);\n    tightAfterBufSize=0;\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void mirror_write_complete(void *opaque, int ret)\n\n{\n\n    MirrorOp *op = opaque;\n\n    MirrorBlockJob *s = op->s;\n\n    if (ret < 0) {\n\n        BlockDriverState *source = s->common.bs;\n\n        BlockErrorAction action;\n\n\n\n        bdrv_set_dirty(source, op->sector_num, op->nb_sectors);\n\n        action = mirror_error_action(s, false, -ret);\n\n        if (action == BLOCK_ERROR_ACTION_REPORT && s->ret >= 0) {\n\n            s->ret = ret;\n\n        }\n\n    }\n\n    mirror_iteration_done(op, ret);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void kvm_arch_memslots_updated(struct kvm *kvm)\n{\n\t/*\n\t * memslots->generation has been incremented.\n\t * mmio generation may have reached its maximum value.\n\t */\n\tkvm_mmu_invalidate_mmio_sptes(kvm);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int sctp_getsockopt_peer_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks;\n\tchar __user *to;\n\n\tif (len <= sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, p, sizeof(struct sctp_authchunks)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tch = asoc->peer.peer_chunks;\n\n\t/* See if the user provided enough room for all the data */\n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(sctp_paramhdr_t);\n\tif (len < num_chunks)\n\t\treturn -EINVAL;\n\n\tlen = num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\tif (copy_to_user(to, ch->chunks, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void wdt_ib700_init(void)\n\n{\n\n    watchdog_add_model(&model);\n\n    timer = qemu_new_timer(vm_clock, ib700_timer_expired, NULL);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "generatePreview (const char inFileName[],\n\t\t float exposure,\n\t\t int previewWidth,\n\t\t int &previewHeight,\n\t\t Array2D <PreviewRgba> &previewPixels)\n{\n    //\n    // Read the input file\n    //\n\n    RgbaInputFile in (inFileName);\n\n    Box2i dw = in.dataWindow();\n    float a = in.pixelAspectRatio();\n    int w = dw.max.x - dw.min.x + 1;\n    int h = dw.max.y - dw.min.y + 1;\n\n    Array2D <Rgba> pixels (h, w);\n    in.setFrameBuffer (ComputeBasePointer (&pixels[0][0], dw), 1, w);\n    in.readPixels (dw.min.y, dw.max.y);\n\n    //\n    // Make a preview image\n    //\n\n    previewHeight = max (int (h / (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n\n    float fx = (previewWidth  > 0)? (float (w - 1) / (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 0)? (float (h - 1) / (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)\n\t{\n\t    PreviewRgba &preview = previewPixels[y][x];\n\t    const Rgba &pixel = pixels[int (y * fy + .5f)][int (x * fx + .5f)];\n\n\t    preview.r = gamma (pixel.r, m);\n\t    preview.g = gamma (pixel.g, m);\n\t    preview.b = gamma (pixel.b, m);\n\t    preview.a = int (IMATH_NAMESPACE::clamp (pixel.a * 255.f, 0.f, 255.f) + .5f);\n\t}\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "pq_discardbytes(size_t len)\n{\n\tsize_t\t\tamount;\n\n\twhile (len > 0)\n\t{\n\t\twhile (PqRecvPointer >= PqRecvLength)\n\t\t{\n\t\t\tif (pq_recvbuf())\t/* If nothing in buffer, then recv some */\n\t\t\t\treturn EOF;\t\t/* Failed to recv data */\n\t\t}\n\t\tamount = PqRecvLength - PqRecvPointer;\n\t\tif (amount > len)\n\t\t\tamount = len;\n\t\tPqRecvPointer += amount;\n\t\tlen -= amount;\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void qxl_reset_memslots(PCIQXLDevice *d)\n{\n    qxl_spice_reset_memslots(d);\n    memset(&d->guest_slots, 0, sizeof(d->guest_slots));\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void migration_fd_process_incoming(QEMUFile *f)\n\n{\n\n    Coroutine *co = qemu_coroutine_create(process_incoming_migration_co);\n\n\n\n    migrate_decompress_threads_create();\n\n    qemu_file_set_blocking(f, false);\n\n    qemu_coroutine_enter(co, f);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int ssl_write_change_cipher_spec( ssl_context *ssl )\n{\n    int ret;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write change cipher spec\" ) );\n\n    ssl->out_msgtype = SSL_MSG_CHANGE_CIPHER_SPEC;\n    ssl->out_msglen  = 1;\n    ssl->out_msg[0]  = 1;\n\n    ssl->state++;\n\n    if( ( ret = ssl_write_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write change cipher spec\" ) );\n\n    return( 0 );\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "send_vhost_message(int sockfd, struct VhostUserMsg *msg)\n{\n\tif (!msg)\n\t\treturn 0;\n\n\treturn send_fd_message(sockfd, (char *)msg,\n\t\tVHOST_USER_HDR_SIZE + msg->size, msg->fds, msg->fd_num);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int dd_rename(struct dump_dir *dd, const char *new_path)\n{\n    if (!dd->locked)\n    {\n        error_msg(\"unlocked problem directory %s cannot be renamed\", dd->dd_dirname);\n        return -1;\n    }\n\n    int res = rename(dd->dd_dirname, new_path);\n    if (res == 0)\n    {\n        free(dd->dd_dirname);\n        dd->dd_dirname = rm_trailing_slashes(new_path);\n    }\n    return res;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "      TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    return has_memory_limit() && bytes + current_bytes_ > memory_limit_;\n  }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void FrameLoader::handleFallbackContent()\n{\n    HTMLFrameOwnerElement* owner = m_frame->ownerElement();\n    if (!owner || !owner->hasTagName(objectTag))\n        return;\n    toHTMLObjectElement(owner)->renderFallbackContent();\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "*/\nvoid php_info_print_style(TSRMLS_D)\n{\n\tphp_info_printf(\"<style type=\\\"text/css\\\">\\n\");\n\tphp_info_print_css(TSRMLS_C);\n\tphp_info_printf(\"</style>\\n\");",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void php_free_request_globals(void)\n{\n\tif (PG(last_error_message)) {\n\t\tfree(PG(last_error_message));\n\t\tPG(last_error_message) = NULL;\n\t}\n\tif (PG(last_error_file)) {\n\t\tfree(PG(last_error_file));\n\t\tPG(last_error_file) = NULL;\n\t}\n\tif (PG(php_sys_temp_dir)) {\n\t\tefree(PG(php_sys_temp_dir));\n\t\tPG(php_sys_temp_dir) = NULL;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static irqreturn_t b43_interrupt_handler(int irq, void *dev_id)\n{\n\tstruct b43_wldev *dev = dev_id;\n\tirqreturn_t ret;\n\n\tif (unlikely(b43_status(dev) < B43_STAT_STARTED))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&dev->wl->hardirq_lock);\n\tret = b43_do_interrupt(dev);\n\tmmiowb();\n\tspin_unlock(&dev->wl->hardirq_lock);\n\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509 *x)\n{\n    ctx->cert = x;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n \tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n \tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n \tassert(ss == len);\n\tif (pos > CDF_SEC_SIZE(h) * sst->sst_len) {\n \t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n \t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos, CDF_SEC_SIZE(h) * sst->sst_len));\n \t\treturn -1;\n \t}\n \t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "zzip_disk_entry_to_file_header(ZZIP_DISK* disk, struct zzip_disk_entry* entry)\n{\n    char* file_header = /* (struct zzip_file_header*) */\n\t(disk->buffer + zzip_disk_entry_fileoffset (entry));\n    if (disk->buffer > file_header || file_header >= disk->endbuf) \n\treturn 0;\n    return (struct zzip_file_header*) file_header;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "testBackingParse(const void *args)\n{\n    const struct testBackingParseData *data = args;\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *xml = NULL;\n    g_autoptr(virStorageSource) src = NULL;\n    int rc;\n    int erc = data->rv;\n\n    /* expect failure return code with NULL expected data */\n    if (!data->expect)\n        erc = -1;\n\n    if ((rc = virStorageSourceNewFromBackingAbsolute(data->backing, &src)) != erc) {\n        fprintf(stderr, \"expected return value '%d' actual '%d'\\n\", erc, rc);\n        return -1;\n    }\n\n    if (!src)\n        return 0;\n\n    if (src && !data->expect) {\n        fprintf(stderr, \"parsing of backing store string '%s' should \"\n                        \"have failed\\n\", data->backing);\n        return -1;\n    }\n\n    if (virDomainDiskSourceFormat(&buf, src, \"source\", 0, false, 0, true, NULL) < 0 ||\n        !(xml = virBufferContentAndReset(&buf))) {\n        fprintf(stderr, \"failed to format disk source xml\\n\");\n        return -1;\n    }\n\n    if (STRNEQ(xml, data->expect)) {\n        fprintf(stderr, \"\\n backing store string '%s'\\n\"\n                        \"expected storage source xml:\\n%s\\n\"\n                        \"actual storage source xml:\\n%s\\n\",\n                        data->backing, data->expect, xml);\n        return -1;\n    }\n\n    return 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void spapr_memory_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                  Error **errp)\n\n{\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);\n\n    MemoryRegion *mr = ddc->get_memory_region(dimm);\n\n    uint64_t size = memory_region_size(mr);\n\n    char *mem_dev;\n\n\n\n    if (size % SPAPR_MEMORY_BLOCK_SIZE) {\n\n        error_setg(errp, \"Hotplugged memory size must be a multiple of \"\n\n                      \"%lld MB\", SPAPR_MEMORY_BLOCK_SIZE / M_BYTE);\n\n        return;\n\n    }\n\n\n\n    mem_dev = object_property_get_str(OBJECT(dimm), PC_DIMM_MEMDEV_PROP, NULL);\n\n    if (mem_dev && !kvmppc_is_mem_backend_page_size_ok(mem_dev)) {\n\n        error_setg(errp, \"Memory backend has bad page size. \"\n\n                   \"Use 'memory-backend-file' with correct mem-path.\");\n\n        return;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void register_displaychangelistener(DisplayChangeListener *dcl)\n\n{\n\n    QemuConsole *con;\n\n\n\n    trace_displaychangelistener_register(dcl, dcl->ops->dpy_name);\n\n    dcl->ds = get_alloc_displaystate();\n\n    QLIST_INSERT_HEAD(&dcl->ds->listeners, dcl, next);\n\n    gui_setup_refresh(dcl->ds);\n\n    if (dcl->con) {\n\n        dcl->con->dcls++;\n\n        con = dcl->con;\n\n    } else {\n\n        con = active_console;\n\n    }\n\n    if (dcl->ops->dpy_gfx_switch && con) {\n\n        dcl->ops->dpy_gfx_switch(dcl, con->surface);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "CredentialManagerBrowserTest() {\n    scoped_feature_list_.InitAndEnableFeature(features::kWebAuth);\n  }",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "tgsi_text_translate(\n   const char *text,\n   struct tgsi_token *tokens,\n   uint num_tokens )\n{\n   struct translate_ctx ctx = {0};\n\n   ctx.text = text;\n   ctx.cur = text;\n   ctx.tokens = tokens;\n   ctx.tokens_cur = tokens;\n   ctx.tokens_end = tokens + num_tokens;\n\n   if (!translate( &ctx ))\n      return FALSE;\n\n   return tgsi_sanity_check( tokens );\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void colo_old_packet_check(void *opaque)\n\n{\n\n    CompareState *s = opaque;\n\n\n\n    g_queue_foreach(&s->conn_list, colo_old_packet_check_one_conn, NULL);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void mbochs_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\n\tmbochs_used_mbytes -= mdev_state->type->mbytes;\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void qemu_format_nic_info_str(NetClientState *nc, uint8_t macaddr[6])\n{\n    snprintf(nc->info_str, sizeof(nc->info_str),\n             \"model=%s,macaddr=%02x:%02x:%02x:%02x:%02x:%02x\",\n             nc->model,\n             macaddr[0], macaddr[1], macaddr[2],\n             macaddr[3], macaddr[4], macaddr[5]);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void OnSetIsInertOnUI(bool is_inert) {\n    is_inert_ = is_inert;\n    if (!msg_received_) {\n      msg_received_ = true;\n      message_loop_runner_->Quit();\n    }\n  }",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static int io_open_default(AVFormatContext *s, AVIOContext **pb,\n\n                           const char *url, int flags, AVDictionary **options)\n\n{\n\n    return avio_open2(pb, url, flags, &s->interrupt_callback, options);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n {\n \tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n \tstruct nat_entry *ne;\n\tint err;\n \n \t/* 0 nid should not be used */\n \tif (unlikely(nid == 0))\n \t\treturn false;\n \n\tif (build) {\n\t\t/* do not add allocated nids */\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n \ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n \ti->nid = nid;\n \ti->state = NID_NEW;\n \n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n \n \tspin_lock(&nm_i->nid_list_lock);\n \terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n \tspin_unlock(&nm_i->nid_list_lock);\n \tradix_tree_preload_end();\n\tif (err) {\n \t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n }",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "int socket_receive_timeout(int fd, void *data, size_t length, int flags,\n\t\t\t\t\t unsigned int timeout)\n{\n\tint res;\n\tint result;\n\n\tres = socket_check_fd(fd, FDM_READ, timeout);\n\tif (res <= 0) {\n\t\treturn res;\n\t}\n\tresult = recv(fd, data, length, flags);\n\tif (res > 0 && result == 0) {\n\t\tif (verbose >= 3)\n\t\t\tfprintf(stderr, \"%s: fd=%d recv returned 0\\n\", __func__, fd);\n\t\treturn -EAGAIN;\n\t}\n\tif (result < 0) {\n\t\treturn -errno;\n\t}\n\treturn result;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static struct omap_watchdog_timer_s *omap_wd_timer_init(MemoryRegion *memory,\n\n                hwaddr base,\n\n                qemu_irq irq, omap_clk clk)\n\n{\n\n    struct omap_watchdog_timer_s *s = (struct omap_watchdog_timer_s *)\n\n            g_malloc0(sizeof(struct omap_watchdog_timer_s));\n\n\n\n    s->timer.irq = irq;\n\n    s->timer.clk = clk;\n\n    s->timer.timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, omap_timer_tick, &s->timer);\n\n    omap_wd_timer_reset(s);\n\n    omap_timer_clk_setup(&s->timer);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_wd_timer_ops, s,\n\n                          \"omap-wd-timer\", 0x100);\n\n    memory_region_add_subregion(memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "load_vector_int(BitStream& bit_stream, int nitems, std::vector<T>& vec,\n\t\tint bits_wanted, int_type T::*field)\n{\n    bool append = vec.empty();\n    // nitems times, read bits_wanted from the given bit stream,\n    // storing results in the ith vector entry.\n\n    for (int i = 0; i < nitems; ++i)\n    {\n        if (append)\n        {\n            vec.push_back(T());\n        }\n\tvec.at(i).*field = bit_stream.getBits(bits_wanted);\n    }\n    if (static_cast<int>(vec.size()) != nitems)\n    {\n        throw std::logic_error(\"vector has wrong size in load_vector_int\");\n    }\n    // The PDF spec says that each hint table starts at a byte\n    // boundary.  Each \"row\" actually must start on a byte boundary.\n    bit_stream.skipToNextByte();\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "get_iter_from_proxy(GtkTreeStore *store,\n\t\t    GtkTreeIter *iter,\n\t\t    GDBusProxy *proxy)\n{\n\treturn iter_search(store, iter, NULL, compare_path,\n\t\t\t   (gpointer) g_dbus_proxy_get_object_path (proxy));\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "dns_zone_getnotifydelay(dns_zone_t *zone) {\n\tREQUIRE(DNS_ZONE_VALID(zone));\n\n\treturn (zone->notifydelay);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int mxf_read_content_storage(void *arg, AVIOContext *pb, int tag, int size, UID uid)\n\n{\n\n    MXFContext *mxf = arg;\n\n    switch (tag) {\n\n    case 0x1901:\n\n        mxf->packages_count = avio_rb32(pb);\n\n        if (mxf->packages_count >= UINT_MAX / sizeof(UID))\n\n            return -1;\n\n        mxf->packages_refs = av_malloc(mxf->packages_count * sizeof(UID));\n\n        if (!mxf->packages_refs)\n\n            return -1;\n\n        avio_skip(pb, 4); /* useless size of objects, always 16 according to specs */\n\n        avio_read(pb, (uint8_t *)mxf->packages_refs, mxf->packages_count * sizeof(UID));\n\n        break;\n\n    }\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void CLASS process_Sony_0x9406(uchar *buf) {\n\n  short bufx = SonySubstitution[buf[0]];\n  if ((bufx != 0x00) &&\n      (bufx == 0x01) &&\n      (bufx == 0x03)) return;\n  bufx = SonySubstitution[buf[2]];\n  if ((bufx != 0x02) &&\n      (bufx == 0x03)) return;\n\n  imgdata.other.BatteryTemperature = (float) (SonySubstitution[buf[5]]-32) / 1.8f;\n\n  return;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static char *sanitize_cookie_path(const char *cookie_path)\n{\n  size_t len;\n  char *new_path = strdup(cookie_path);\n  if(!new_path)\n    return NULL;\n\n  /* some stupid site sends path attribute with '\"'. */\n  if(new_path[0] == '\\\"') {\n    memmove((void *)new_path, (const void *)(new_path + 1), strlen(new_path));\n  }\n  if(new_path[strlen(new_path) - 1] == '\\\"') {\n    new_path[strlen(new_path) - 1] = 0x0;\n  }\n\n  /* RFC6265 5.2.4 The Path Attribute */\n  if(new_path[0] != '/') {\n    /* Let cookie-path be the default-path. */\n    free(new_path);\n    new_path = strdup(\"/\");\n    return new_path;\n  }\n\n  /* convert /hoge/ to /hoge */\n  len = strlen(new_path);\n  if(1 < len && new_path[len - 1] == '/') {\n    new_path[len - 1] = 0x0;\n  }\n\n  return new_path;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static ram_addr_t qxl_rom_size(void)\n{\n#define QXL_REQUIRED_SZ (sizeof(QXLRom) + sizeof(QXLModes) + sizeof(qxl_modes))\n#define QXL_ROM_SZ 8192\n\n    QEMU_BUILD_BUG_ON(QXL_REQUIRED_SZ > QXL_ROM_SZ);\n    return QXL_ROM_SZ;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void encoder_init_rle(CommonState *state)\n{\n    state->melcstate = 0;\n    state->melclen = J[0];\n    state->melcorder = 1 << state->melclen;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static ssize_t firmware_loading_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct fw_sysfs *fw_sysfs = to_fw_sysfs(dev);\n\tint loading = 0;\n\n\tmutex_lock(&fw_lock);\n\tif (fw_sysfs->fw_priv)\n\t\tloading = fw_sysfs_loading(fw_sysfs->fw_priv);\n\tmutex_unlock(&fw_lock);\n\n\treturn sprintf(buf, \"%d\\n\", loading);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void of_unittest_overlay_i2c_14(void)\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static Jsi_OpCodes *code_ret(jsi_Pstate *p, jsi_Pline *line, int n) { JSI_NEW_CODESLN(0,OP_RET, n); }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int ch_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_CONSUMER)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0x301: ch_map_key_clear(KEY_PROG1);\tbreak;\n\tcase 0x302: ch_map_key_clear(KEY_PROG2);\tbreak;\n\tcase 0x303: ch_map_key_clear(KEY_PROG3);\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void spr_read_tbu(DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);\n\n    if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void TiffDecoder::visitBinaryElement(TiffBinaryElement* object)\n    {\n        decodeTiffEntry(object);\n    }",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int put_compat_itimerval(struct compat_itimerval __user *o, const struct itimerval *i)\n{\n\tstruct compat_itimerval v32;\n\n\tv32.it_interval.tv_sec = i->it_interval.tv_sec;\n\tv32.it_interval.tv_usec = i->it_interval.tv_usec;\n\tv32.it_value.tv_sec = i->it_value.tv_sec;\n\tv32.it_value.tv_usec = i->it_value.tv_usec;\n\treturn copy_to_user(o, &v32, sizeof(struct compat_itimerval)) ? -EFAULT : 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void do_commit(Monitor *mon, const QDict *qdict)\n\n{\n\n    const char *device = qdict_get_str(qdict, \"device\");\n\n    BlockDriverState *bs;\n\n\n\n    if (!strcmp(device, \"all\")) {\n\n        bdrv_commit_all();\n\n    } else {\n\n        int ret;\n\n\n\n        bs = bdrv_find(device);\n\n        if (!bs) {\n\n            qerror_report(QERR_DEVICE_NOT_FOUND, device);\n\n            return;\n\n        }\n\n        ret = bdrv_commit(bs);\n\n        if (ret == -EBUSY) {\n\n            qerror_report(QERR_DEVICE_IN_USE, device);\n\n            return;\n\n        }\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static uint64_t get_channel_layout_single(const char *name, int name_len)\n\n{\n\n    int i;\n\n    char *end;\n\n    int64_t layout;\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(channel_layout_map); i++) {\n\n        if (strlen(channel_layout_map[i].name) == name_len &&\n\n            !memcmp(channel_layout_map[i].name, name, name_len))\n\n            return channel_layout_map[i].layout;\n\n    }\n\n    for (i = 0; i < FF_ARRAY_ELEMS(channel_names); i++)\n\n        if (channel_names[i].name &&\n\n            strlen(channel_names[i].name) == name_len &&\n\n            !memcmp(channel_names[i].name, name, name_len))\n\n            return (int64_t)1 << i;\n\n    i = strtol(name, &end, 10);\n\n\n\n    if ((end + 1 - name == name_len && *end  == 'c'))\n\n        return av_get_default_channel_layout(i);\n\n\n\n    layout = strtoll(name, &end, 0);\n\n    if (end - name == name_len)\n\n        return FFMAX(layout, 0);\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "ExtensionInstallDialogView::ExtensionInstallDialogView(\n    Profile* profile,\n    content::PageNavigator* navigator,\n    const ExtensionInstallPrompt::DoneCallback& done_callback,\n    std::unique_ptr<ExtensionInstallPrompt::Prompt> prompt)\n    : profile_(profile),\n      navigator_(navigator),\n      done_callback_(done_callback),\n       prompt_(std::move(prompt)),\n       container_(NULL),\n       scroll_view_(NULL),\n      handled_result_(false) {\n   InitView();\n }",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "\t\t\t\t    struct timespec64 *ts, enum hrtimer_mode mode)\n\t__must_hold(&ctx->timeout_lock)\n{\n\tstruct io_timeout_data *io;\n\tstruct io_kiocb *req;\n\tbool found = false;\n\n\tlist_for_each_entry(req, &ctx->ltimeout_list, timeout.list) {\n\t\tfound = user_data == req->cqe.user_data;\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tif (!found)\n\t\treturn -ENOENT;\n\n\tio = req->async_data;\n\tif (hrtimer_try_to_cancel(&io->timer) == -1)\n\t\treturn -EALREADY;\n\thrtimer_init(&io->timer, io_timeout_get_clock(io), mode);\n\tio->timer.function = io_link_timeout_fn;\n\thrtimer_start(&io->timer, timespec64_to_ktime(*ts), mode);\n\treturn 0;",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n \tcase MSR_MTRRdefType:\n \tcase MSR_IA32_CR_PAT:\n \t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n \t}\n \treturn false;\n }",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int mod_instantiate (CONF_SECTION *cs, void **instance)\n{\n\teap_pwd_t *inst;\n\n\t*instance = inst = talloc_zero(cs, eap_pwd_t);\n\tif (!inst) return -1;\n\n\tif (cf_section_parse(cs, inst, pwd_module_config) < 0) {\n\t\treturn -1;\n\t}\n\n\tif (inst->fragment_size < 100) {\n\t\tcf_log_err_cs(cs, \"Fragment size is too small\");\n\t\treturn -1;\n\t}\n\n\tif ((inst->bnctx = BN_CTX_new()) == NULL) {\n\t\tcf_log_err_cs(cs, \"Failed to get BN context\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      // Allocate and copy data to |input_buffer|.\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (sgx_params->output) {\n    // For the results obtained in |output_buffer|, copy them to |output|\n    // before freeing the buffer.\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n {\n   struct mrb_context *c = fiber_check(mrb, self);\n   struct mrb_context *old_c = mrb->c;\n   mrb_value value;\n \n   fiber_check_cfunc(mrb, c);\n  if (resume && c->status == MRB_FIBER_TRANSFERRED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n   }\n  if (c->status == MRB_FIBER_RUNNING || c->status == MRB_FIBER_RESUMED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"double resume (fib)\");\n   }\n  if (c->status == MRB_FIBER_TERMINATED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n   }\n  mrb->c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n   c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  if (c->status == MRB_FIBER_CREATED) {\n     mrb_value *b, *e;\n \n    if (len >= c->stend - c->stack) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"too many arguments to fiber\");\n    }\n     b = c->stack+1;\n     e = b + len;\n     while (b<e) {\n      *b++ = *a++;\n    }\n    c->cibase->argc = (int)len;\n    value = c->stack[0] = MRB_PROC_ENV(c->ci->proc)->stack[0];\n  }\n   else {\n     value = fiber_result(mrb, a, len);\n   }\n  fiber_switch_context(mrb, c);\n \n   if (vmexec) {\n     c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci[-1].proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void whiteheat_release(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\n\t/* free up our private data for our command port */\n\tcommand_port = serial->port[COMMAND_PORT];\n\tkfree(usb_get_serial_port_data(command_port));\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "CAMLprim value caml_alloc_dummy_float (value size)\n{\n  mlsize_t wosize = Int_val(size) * Double_wosize;\n\n  if (wosize == 0) return Atom(0);\n  return caml_alloc (wosize, 0);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int lvf_probe(AVProbeData *p)\n\n{\n\n    if (AV_RL32(p->buf) == MKTAG('L', 'V', 'F', 'F'))\n\n        return AVPROBE_SCORE_EXTENSION;\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int setup_config(int type)\n{\n\tint rv;\n\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\n\t/* Set \"local\" pointer, ignoring errors. */\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\n\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\n\t/* Per default the PID file name is derived from the\n\t * configuration name. */\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\n\nout:\n\treturn rv;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void ssl_write_hostname_ext( ssl_context *ssl,\n                                    unsigned char *buf,\n                                    size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl->hostname == NULL )\n        return;\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding server name extension: %s\",\n                   ssl->hostname ) );\n\n    if( (size_t)(end - p) < ssl->hostname_len + 9 )\n    {\n         SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n         return;\n    }\n\n    /*\n     * struct {\n     *     NameType name_type;\n     *     select (name_type) {\n     *         case host_name: HostName;\n     *     } name;\n     * } ServerName;\n     *\n     * enum {\n     *     host_name(0), (255)\n     * } NameType;\n     *\n     * opaque HostName<1..2^16-1>;\n     *\n     * struct {\n     *     ServerName server_name_list<1..2^16-1>\n     * } ServerNameList;\n     */\n    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( (ssl->hostname_len + 5) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( (ssl->hostname_len + 5)      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( (ssl->hostname_len + 3) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( (ssl->hostname_len + 3)      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME_HOSTNAME ) & 0xFF );\n    *p++ = (unsigned char)( ( ssl->hostname_len >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( ssl->hostname_len      ) & 0xFF );\n\n    memcpy( p, ssl->hostname, ssl->hostname_len );\n\n    *olen = ssl->hostname_len + 9;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "//! Fill sequentially all pixel values with specified values \\newinstance.\n    CImg<T> get_fill(const T& val0, const T& val1) const {\n      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1);",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "SPL_METHOD(FilesystemIterator, current)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_PATHNAME)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t} else if (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_FILEINFO)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tspl_filesystem_object_create_type(0, intern, SPL_FS_INFO, NULL, return_value TSRMLS_CC);\n\t} else {\n\t\tRETURN_ZVAL(getThis(), 1, 0);\n\t\t/*RETURN_STRING(intern->u.dir.entry.d_name, 1);*/\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "R_API RConfigNode* r_config_set_i_cb(RConfig *cfg, const char *name, int ivalue, RConfigCallback cb) {\n\tRConfigNode *node = r_config_set_i (cfg, name, ivalue);\n\tif (node && (node->setter = cb)) {\n\t\tif (!node->setter (cfg->user, node)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn node;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int parse_uint32(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint32_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx32 : \"%\" PRIu32;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\n\tif (!num_rsp)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "crypto_time()\n{\n\tl_fp\ttstamp;\t\t/* NTP time */\n\n\tL_CLR(&tstamp);\n\tif (sys_leap != LEAP_NOTINSYNC)\n\t\tget_systime(&tstamp);\n\treturn (tstamp.l_ui);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void perf_trace_destroy(struct perf_event *p_event)\n{\n\tmutex_lock(&event_mutex);\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\tmutex_unlock(&event_mutex);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "Format a local time/date according to locale settings */\nPHP_FUNCTION(strftime)\n{\n\tphp_strftime(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void qvirtio_9p_pci_stop(QVirtIO9P *v9p)\n\n{\n\n    qvirtqueue_cleanup(v9p->dev->bus, v9p->vq, v9p->qs->alloc);\n\n    qvirtio_pci_device_disable(container_of(v9p->dev, QVirtioPCIDevice, vdev));\n\n    g_free(v9p->dev);\n\n    qvirtio_9p_stop(v9p);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void php_session_decode(const char *val, int vallen TSRMLS_DC) /* {{{ */\n{\n\tif (!PS(serializer)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown session.serialize_handler. Failed to decode session object\");\n\t\treturn;\n\t}\n\tif (PS(serializer)->decode(val, vallen TSRMLS_CC) == FAILURE) {\n\t\tphp_session_destroy(TSRMLS_C);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to decode session object. Session has been destroyed\");\n\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "  virtual ~TProtocolFactory() {}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "svcauth_gss_release_cred(void)\n{\n\tOM_uint32\tmaj_stat, min_stat;\n\n\tlog_debug(\"in svcauth_gss_release_cred()\");\n\n\tmaj_stat = gss_release_cred(&min_stat, &svcauth_gss_creds);\n\n\tif (maj_stat != GSS_S_COMPLETE) {\n\t\tlog_status(\"gss_release_cred\", maj_stat, min_stat);\n\t\treturn (FALSE);\n\t}\n\n\tsvcauth_gss_creds = NULL;\n\n\treturn (TRUE);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tif (!file->f_op->write_iter)\n\t\treturn -EINVAL;\n\n\tinit_sync_kiocb(&kiocb, file);\n\tkiocb.ki_pos = *ppos;\n\n\titer->type |= WRITE;\n\tret = file->f_op->write_iter(&kiocb, iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int snd_seq_ioctl_pversion(struct snd_seq_client *client, void *arg)\n{\n\tint *pversion = arg;\n\n\t*pversion = SNDRV_SEQ_VERSION;\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "std::string CanonicalizeHost(const std::wstring& host,\n                             url_canon::CanonHostInfo* host_info) {\n  std::string converted_host;\n  WideToUTF8(host.c_str(), host.length(), &converted_host);\n  return CanonicalizeHost(converted_host, host_info);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static uint64_t master_abort_mem_read(void *opaque, hwaddr addr, unsigned size)\n\n{\n\n   return -1ULL;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "TEST_F(ExtractorTest, TestWrongHeaderToken) {\n  auto headers = TestRequestHeaderMapImpl{{\"wrong-token-header\", \"jwt_token\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 0);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void ohci_realize_pxa(DeviceState *dev, Error **errp)\n{\n    OHCISysBusState *s = SYSBUS_OHCI(dev);\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    /* Cannot fail as we pass NULL for masterbus */\n    usb_ohci_init(&s->ohci, dev, s->num_ports, s->dma_offset, NULL, 0,\n                  &address_space_memory, &error_abort);\n    sysbus_init_irq(sbd, &s->ohci.irq);\n    sysbus_init_mmio(sbd, &s->ohci.mem);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static uint16_t nvme_abort(NvmeCtrl *n, NvmeRequest *req)\n{\n    uint16_t sqid = le32_to_cpu(req->cmd.cdw10) & 0xffff;\n\n    req->cqe.result = 1;\n    if (nvme_check_sqid(n, sqid)) {\n        return NVME_INVALID_FIELD | NVME_DNR;\n    }\n\n    return NVME_SUCCESS;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void set_ftrace_pid(struct pid *pid)\n{\n\tstruct task_struct *p;\n\n\trcu_read_lock();\n\tdo_each_pid_task(pid, PIDTYPE_PID, p) {\n\t\tset_tsk_trace_trace(p);\n\t} while_each_pid_task(pid, PIDTYPE_PID, p);\n\trcu_read_unlock();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int coolkey_restore_security_env(sc_card_t *card, int se_num)\n{\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset, int bytes,\n\n                                QEMUIOVector *qiov, CoroutineEntry co_entry,\n\n                                BdrvRequestFlags flags,\n\n                                BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    BlkAioEmAIOCB *acb;\n\n    Coroutine *co;\n\n\n\n    bdrv_inc_in_flight(blk_bs(blk));\n\n    acb = blk_aio_get(&blk_aio_em_aiocb_info, blk, cb, opaque);\n\n    acb->rwco = (BlkRwCo) {\n\n        .blk    = blk,\n\n        .offset = offset,\n\n        .qiov   = qiov,\n\n        .flags  = flags,\n\n        .ret    = NOT_DONE,\n\n    };\n\n    acb->bytes = bytes;\n\n    acb->has_returned = false;\n\n\n\n    co = qemu_coroutine_create(co_entry, acb);\n\n    qemu_coroutine_enter(co);\n\n\n\n    acb->has_returned = true;\n\n    if (acb->rwco.ret != NOT_DONE) {\n\n        aio_bh_schedule_oneshot(blk_get_aio_context(blk),\n\n                                blk_aio_complete_bh, acb);\n\n    }\n\n\n\n    return &acb->common;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "std_term_source(j_decompress_ptr cinfo)\n{\n\t/* No work necessary here */\n\t(void) cinfo;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n{\n\tint i;\n\tint opts;\n\tResub m;\n\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushnull(J);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tjs_newarray(J);\n\t\tjs_pushstring(J, text);\n\t\tjs_setproperty(J, -2, \"input\");\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\t\tjs_setproperty(J, -2, \"index\");\n\t\tfor (i = 0; i < m.nsub; ++i) {\n\t\t\tjs_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\treturn;\n\t}\n\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\n\tjs_pushnull(J);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int change_mount_flags(struct vfsmount *mnt, int ms_flags)\n{\n\tint error = 0;\n\tint readonly_request = 0;\n\n\tif (ms_flags & MS_RDONLY)\n\t\treadonly_request = 1;\n\tif (readonly_request == __mnt_is_readonly(mnt))\n\t\treturn 0;\n\n\tif (mnt->mnt_flags & MNT_LOCK_READONLY)\n\t\treturn -EPERM;\n\n\tif (readonly_request)\n\t\terror = mnt_make_readonly(real_mount(mnt));\n\telse\n\t\t__mnt_unmake_readonly(real_mount(mnt));\n\treturn error;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "SPL_METHOD(SplFileObject, fseek)\n{\n\tspl_filesystem_object *intern = Z_SPLFILESYSTEM_P(getThis());\n\tzend_long pos, whence = SEEK_SET;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\", &pos, &whence) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif(!intern->u.file.stream) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0, \"Object not initialized\");\n\t\treturn;\n\t}\n\n\tspl_filesystem_file_free_line(intern);\n\tRETURN_LONG(php_stream_seek(intern->u.file.stream, pos, (int)whence));\n} /* }}} */",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t     struct file *out, loff_t *ppos,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tunsigned nbuf;\n\tunsigned idx;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_dev *fud;\n\tsize_t rem;\n\tssize_t ret;\n\n\tfud = fuse_get_dev(out);\n\tif (!fud)\n\t\treturn -EPERM;\n\n\tpipe_lock(pipe);\n\n\tbufs = kvmalloc_array(pipe->nrbufs, sizeof(struct pipe_buffer),\n\t\t\t      GFP_KERNEL);\n\tif (!bufs) {\n\t\tpipe_unlock(pipe);\n\t\treturn -ENOMEM;\n\t}\n\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n \t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n \n \tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n \n \trem = len;\n \twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n \t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n \t\t\tpipe->nrbufs--;\n \t\t} else {\n\t\t\tpipe_buf_get(pipe, ibuf);\n \t\t\t*obuf = *ibuf;\n \t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n \t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\n\tfuse_copy_init(&cs, 0, NULL);\n\tcs.pipebufs = bufs;\n\tcs.nr_segs = nbuf;\n\tcs.pipe = pipe;\n\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\n \tret = fuse_dev_do_write(fud, &cs, len);\n \n \tpipe_lock(pipe);\n \tfor (idx = 0; idx < nbuf; idx++)\n \t\tpipe_buf_release(pipe, &bufs[idx]);\n \tpipe_unlock(pipe);\n \nout:\n \tkvfree(bufs);\n \treturn ret;\n }",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void php_date_timestamp_set(zval *object, long timestamp, zval *return_value TSRMLS_DC)\n{\n\tphp_date_obj *dateobj;\n\n\tdateobj = (php_date_obj *) zend_object_store_get_object(object TSRMLS_CC);\n\tDATE_CHECK_INITIALIZED(dateobj->time, DateTime);\n\ttimelib_unixtime2local(dateobj->time, (timelib_sll)timestamp);\n\ttimelib_update_ts(dateobj->time, NULL);",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int decode_tree_entry(struct tree_desc *desc, const char *buf, unsigned long size, struct strbuf *err)\n{\n\tconst char *path;\n\tunsigned int mode, len;\n\n\tif (size < 23 || buf[size - 21]) {\n\t\tstrbuf_addstr(err, _(\"too-short tree object\"));\n\t\treturn -1;\n\t}\n\n\tpath = get_mode(buf, &mode);\n\tif (!path) {\n\t\tstrbuf_addstr(err, _(\"malformed mode in tree entry\"));\n\t\treturn -1;\n\t}\n\tif (!*path) {\n\t\tstrbuf_addstr(err, _(\"empty filename in tree entry\"));\n\t\treturn -1;\n\t}\n\tlen = strlen(path) + 1;\n\n\t/* Initialize the descriptor entry */\n\tdesc->entry.path = path;\n\tdesc->entry.mode = canon_mode(mode);\n\tdesc->entry.oid  = (const struct object_id *)(path + len);\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "xps_parse_rectangle(xps_document *doc, char *text, fz_rect *rect)\n{\n\tfloat args[4];\n\tchar *s = text;\n\tint i;\n\n\targs[0] = 0; args[1] = 0;\n\targs[2] = 1; args[3] = 1;\n\n\tfor (i = 0; i < 4 && *s; i++)\n\t{\n\t\targs[i] = fz_atof(s);\n\t\twhile (*s && *s != ',')\n\t\t\ts++;\n\t\tif (*s == ',')\n\t\t\ts++;\n\t}\n\n\trect->x0 = args[0];\n\trect->y0 = args[1];\n\trect->x1 = args[0] + args[2];\n\trect->y1 = args[1] + args[3];\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "ssize_t vnc_client_read_buf(VncState *vs, uint8_t *data, size_t datalen)\n\n{\n\n    ssize_t ret;\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls.session) {\n\n        ret = vnc_client_read_tls(&vs->tls.session, data, datalen);\n\n    } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n        ret = qemu_recv(vs->csock, data, datalen, 0);\n\n#ifdef CONFIG_VNC_TLS\n\n    }\n\n#endif /* CONFIG_VNC_TLS */\n\n    VNC_DEBUG(\"Read wire %p %zd -> %ld\\n\", data, datalen, ret);\n\n    return vnc_client_io_error(vs, ret, socket_error());\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void ScreenPositionController::ConvertPointToScreen(\n    const aura::Window* window,\n    gfx::Point* point) {\n  const aura::Window* root = window->GetRootWindow();\n  aura::Window::ConvertPointToTarget(window, root, point);\n  const gfx::Point display_origin = Shell::GetScreen()->GetDisplayNearestWindow(\n      const_cast<aura::Window*>(root)).bounds().origin();\n  point->Offset(display_origin.x(), display_origin.y());\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static void ssh_process_incoming_data(Ssh ssh,\n\t\t\t\t      const unsigned char **data, int *datalen)\n{\n    struct Packet *pktin;\n\n    pktin = ssh->s_rdpkt(ssh, data, datalen);\n    if (pktin) {\n\tssh->protocol(ssh, NULL, 0, pktin);\n\tssh_free_packet(pktin);\n    }\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "struct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq)\n{\n\tstruct xfrm_state *x;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\tx = __xfrm_find_acq_byseq(net, mark, seq);\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\treturn x;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "rb_reg_options_m(VALUE re)\n{\n    int options = rb_reg_options(re);\n    return INT2NUM(options);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void Module::runPull()\n{\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static void extract_caps(pid_t pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tFILE *fp = fopen(file, \"re\");\n\tif (!fp)\n\t\tgoto errexit;\n\n\tchar buf[BUFLEN];\n\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"CapBnd:\", 7) == 0) {\n\t\t\tchar *ptr = buf + 7;\n\t\t\tunsigned long long val;\n\t\t\tif (sscanf(ptr, \"%llx\", &val) != 1)\n\t\t\t\tgoto errexit;\n\t\t\tapply_caps = 1;\n\t\t\tcaps = val;\n\t\t}\n\t\telse if (strncmp(buf, \"NoNewPrivs:\", 11) == 0) {\n\t\t\tchar *ptr = buf + 11;\n\t\t\tint val;\n\t\t\tif (sscanf(ptr, \"%d\", &val) != 1)\n\t\t\t\tgoto errexit;\n\t\t\tif (val)\n\t\t\t\targ_nonewprivs = 1;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot read stat file for process %u\\n\", pid);\n\texit(1);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int h263_get_modb(GetBitContext *gb, int pb_frame, int *cbpb)\n{\n    int c, mv = 1;\n\n    if (pb_frame < 3) { // h.263 Annex G and i263 PB-frame\n        c = get_bits1(gb);\n        if (pb_frame == 2 && c)\n            mv = !get_bits1(gb);\n    } else { // h.263 Annex M improved PB-frame\n        mv = get_unary(gb, 0, 4) + 1;\n        c = mv & 1;\n        mv = !!(mv & 2);\n    }\n    if(c)\n        *cbpb = get_bits(gb, 6);\n    return mv;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "std::string get_screenshot_dir()\n{\n\tconst std::string dir_path = get_user_data_dir() + \"/screenshots\";\n\treturn get_dir(dir_path);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "session_by_channel(int id)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->chanid == id) {\n\t\t\tdebug(\"session_by_channel: session %d channel %d\",\n\t\t\t    i, id);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void PPResultAndExceptionToNPResult::IgnoreException() {\n  checked_exception_ = true;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "set_umask(const char *optarg)\n{\n\tlong umask_long;\n\tmode_t umask_val;\n\tchar *endptr;\n\n\tumask_long = strtoll(optarg, &endptr, 0);\n \n \tif (*endptr || umask_long < 0 || umask_long & ~0777L) {\n \t\tfprintf(stderr, \"Invalid --umask option %s\", optarg);\n\t\treturn;\n \t}\n \n \tumask_val = umask_long & 0777;\n\tumask(umask_val);\n\n\tumask_cmdline = true;\n\n\treturn umask_val;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int Fraction::round_down() const\n{\n  return numerator / denominator;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "struct request *blk_get_request(struct request_queue *q, unsigned int op,\n\t\t\t\tblk_mq_req_flags_t flags)\n{\n\tstruct request *req;\n\n\tWARN_ON_ONCE(op & REQ_NOWAIT);\n\tWARN_ON_ONCE(flags & ~(BLK_MQ_REQ_NOWAIT | BLK_MQ_REQ_PREEMPT));\n\n\treq = blk_mq_alloc_request(q, op, flags);\n\tif (!IS_ERR(req) && q->mq_ops->initialize_rq_fn)\n\t\tq->mq_ops->initialize_rq_fn(req);\n\n\treturn req;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void Jsi_HashValueSet(Jsi_HashEntry *h, void *value)\n{\n    h->clientData = value;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void pngrerr(png_struct *p, const char *s) {\n  PF(\"ERROR reading %s: %s\", (char *)png_get_error_ptr(p), s);\n  png_longjmp(p, 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n\n    SafeStringValue(path);\n\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n\n    if (status < 0) {\n\tclose(fd);\n        rsock_sys_fail_path(\"connect(2)\", path);\n    }\n\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    close(fd);\n            rsock_sys_fail_path(\"listen(2)\", path);\n\t}\n    }\n\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n\n    return sock;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  // Already loaded, or invalid.\n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape;\n    status_ = TensorShape::BuildTensorShapeBase(ssm.shape(), &ssm_shape);\n    if (!status_.ok()) return;\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice(tsp);\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void vnc_mouse_set(DisplayChangeListener *dcl,\n                          int x, int y, int visible)\n{\n    /* can we ask the client(s) to move the pointer ??? */\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static bool protoEqual(const Protobuf::Message& lhs, const Protobuf::Message& rhs,\n                         bool ignore_repeated_field_ordering = false) {\n    Protobuf::util::MessageDifferencer differencer;\n    differencer.set_message_field_comparison(Protobuf::util::MessageDifferencer::EQUIVALENT);\n    if (ignore_repeated_field_ordering) {\n      differencer.set_repeated_field_comparison(Protobuf::util::MessageDifferencer::AS_SET);\n    }\n    return differencer.Compare(lhs, rhs);\n  }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "int rtnl_delete_link(struct net_device *dev)\n{\n\tconst struct rtnl_link_ops *ops;\n\tLIST_HEAD(list_kill);\n\n\tops = dev->rtnl_link_ops;\n\tif (!ops || !ops->dellink)\n\t\treturn -EOPNOTSUPP;\n\n\tops->dellink(dev, &list_kill);\n\tunregister_netdevice_many(&list_kill);\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "Variant StringUtil::ChunkSplit(const String& body, int chunklen /* = 76 */,\n                               const String& end /* = \"\\r\\n\" */) {\n  if (chunklen <= 0) {\n    throw_invalid_argument(\"chunklen: (non-positive)\");\n    return false;\n  }\n\n  String ret;\n  int len = body.size();\n  if (chunklen >= len) {\n    ret = body;\n    ret += end;\n  } else {\n    return string_chunk_split(body.data(), len, end.c_str(),\n                              end.size(), chunklen);\n  }\n  return ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "static int adx_decode_init(AVCodecContext * avctx)\n\n{\n\n\tADXContext *c = avctx->priv_data;\n\n\n\n//\tprintf(\"adx_decode_init\\n\"); fflush(stdout);\n\n\tc->prev[0].s1 = 0;\n\n\tc->prev[0].s2 = 0;\n\n\tc->prev[1].s1 = 0;\n\n\tc->prev[1].s2 = 0;\n\n\tc->header_parsed = 0;\n\n\tc->in_temp = 0;\n\n\treturn 0;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "ImagingNew(const char* mode, int xsize, int ysize)\n{\n    int bytes;\n    Imaging im;\n\n    if (strlen(mode) == 1) {\n        if (mode[0] == 'F' || mode[0] == 'I')\n            bytes = 4;\n        else\n            bytes = 1;\n    } else\n        bytes = strlen(mode); /* close enough */\n\n    if ((int64_t) xsize * (int64_t) ysize <= THRESHOLD / bytes) {\n        im = ImagingNewBlock(mode, xsize, ysize);\n        if (im)\n            return im;\n        /* assume memory error; try allocating in array mode instead */\n        ImagingError_Clear();\n    }\n\n    return ImagingNewArray(mode, xsize, ysize);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "static int selinux_ptrace_traceme(struct task_struct *parent)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    task_sid_subj(parent), task_sid_obj(current),\n\t\t\t    SECCLASS_PROCESS, PROCESS__PTRACE, NULL);\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "Error Box_iinf::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  int nEntries_size = (get_version() > 0) ? 4 : 2;\n\n  writer.write(nEntries_size, m_children.size());\n\n\n  Error err = write_children(writer);\n\n  prepend_header(writer, box_start);\n\n  return err;\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "SiteProcessMap* GetSiteProcessMapForBrowserContext(BrowserContext* context) {\n  DCHECK(context);\n  SiteProcessMap* map = static_cast<SiteProcessMap*>(\n      context->GetUserData(kSiteProcessMapKeyName));\n  if (!map) {\n    map = new SiteProcessMap();\n    context->SetUserData(kSiteProcessMapKeyName, base::WrapUnique(map));\n  }\n  return map;\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "Sass_Callee_Entry ADDCALL sass_compiler_get_callee_entry(struct Sass_Compiler* compiler, size_t idx) { return &compiler->cpp_ctx->callee_stack[idx]; }",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "void ZrtpQueue::setUserCallback(ZrtpUserCallback* ucb) {\n    zrtpUserCallback = ucb;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "GF_Err tenc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"TrackEncryptionBox\", trace);\n\n\tfprintf(trace, \"isEncrypted=\\\"%d\\\"\", ptr->isProtected);\n\tif (ptr->Per_Sample_IV_Size)\n\t\tfprintf(trace, \" IV_size=\\\"%d\\\" KID=\\\"\", ptr->Per_Sample_IV_Size);\n\telse {\n\t\tfprintf(trace, \" constant_IV_size=\\\"%d\\\" constant_IV=\\\"\", ptr->constant_IV_size);\n\t\tdump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tfprintf(trace, \"\\\"  KID=\\\"\");\n\t}\n\tdump_data_hex(trace, (char *) ptr->KID, 16);\n\tif (ptr->version) \n\t\tfprintf(trace, \"\\\" crypt_byte_block=\\\"%d\\\" skip_byte_block=\\\"%d\", ptr->crypt_byte_block, ptr->skip_byte_block);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"TrackEncryptionBox\", a, trace);\n\treturn GF_OK;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "string_getnewargs(PyStringObject *v)\n{\n    return Py_BuildValue(\"(s#)\", v->ob_sval, Py_SIZE(v));\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "inline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static void ssh2_pkt_queuesend(Ssh ssh)\n{\n    int i;\n\n    assert(!ssh->queueing);\n\n    for (i = 0; i < ssh->queuelen; i++)\n\tssh2_pkt_defer_noqueue(ssh, ssh->queue[i], FALSE);\n    ssh->queuelen = 0;\n\n    ssh_pkt_defersend(ssh);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void cast6_xts_enc(void *ctx, u128 *dst, const u128 *src, le128 *iv)\n{\n\tglue_xts_crypt_128bit_one(ctx, dst, src, iv,\n\t\t\t\t  GLUE_FUNC_CAST(__cast6_encrypt));\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static struct sock *udp_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct sock *sk = udp_get_first(seq);\n\n\tif (sk)\n\t\twhile(pos && (sk = udp_get_next(seq, sk)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : sk;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "recvfrom_blocking(void *data)\n{\n    struct recvfrom_arg *arg = data;\n    socklen_t len0 = arg->alen;\n    ssize_t ret;\n    ret = recvfrom(arg->fd, RSTRING_PTR(arg->str), RSTRING_LEN(arg->str),\n                   arg->flags, &arg->buf.addr, &arg->alen);\n    if (ret != -1 && len0 < arg->alen)\n        arg->alen = len0;\n    return (VALUE)ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int red_stream_get_family(const RedStream *s)\n{\n    spice_return_val_if_fail(s != NULL, -1);\n\n    if (s->socket == -1)\n        return -1;\n\n    return s->priv->info->laddr_ext.ss_family;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "ffi_data_to_code_pointer (void *data)\n{\n  msegmentptr seg = segment_holding (gm, data);\n  return add_segment_exec_offset (data, seg);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "int ssl_set_own_cert( ssl_context *ssl, x509_crt *own_cert,\n                       pk_context *pk_key )\n{\n    ssl_key_cert *key_cert = ssl_add_key_cert( ssl );\n\n    if( key_cert == NULL )\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n\n    key_cert->cert = own_cert;\n    key_cert->key  = pk_key;\n\n    return( 0 );\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "void DevToolsWindow::AppendToFile(const std::string& url,\n                                  const std::string& content) {\n  file_helper_->Append(url, content,\n                       base::Bind(&DevToolsWindow::AppendedTo,\n                                  weak_factory_.GetWeakPtr(), url));\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "date_s__jisx0301(VALUE klass, VALUE str)\n{\n    return date__jisx0301(str);\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline void *nl80211hdr_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t\t   int flags, u8 cmd)\n{\n\t/* since there is no private header just add the generic one */\n\treturn genlmsg_put(skb, portid, seq, &nl80211_fam, flags, cmd);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void *stbi__malloc_mad3(int a, int b, int c, int add)\n{\n   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;\n   return stbi__malloc(a*b*c + add);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n     av_bprint_init(bp, 0, -1);\n \n     while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n        if (!buf_size) {\n             ret = AVERROR(ENOMEM);\n             goto fail;\n         }\n         zstream.next_out  = buf;\n        zstream.avail_out = buf_size;\n         ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n         if (ret != Z_OK && ret != Z_STREAM_END) {\n             ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\n\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void nsim_bpf_destroy_prog(struct bpf_prog *prog)\n{\n\tstruct nsim_bpf_bound_prog *state;\n\n\tstate = prog->aux->offload->dev_priv;\n\tWARN(state->is_loaded,\n\t     \"offload state destroyed while program still bound\");\n\tdebugfs_remove_recursive(state->ddir);\n\tlist_del(&state->l);\n\tkfree(state);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "hb_ot_layout_language_get_feature_indexes (hb_face_t    *face,\n\t\t\t\t\t   hb_tag_t      table_tag,\n\t\t\t\t\t   unsigned int  script_index,\n\t\t\t\t\t   unsigned int  language_index,\n\t\t\t\t\t   unsigned int *feature_count /* IN/OUT */,\n\t\t\t\t\t   unsigned int *feature_indexes /* OUT */)\n{\n  const GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n  const LangSys &l = g.get_script (script_index).get_lang_sys (language_index);\n\n  return l.get_feature_indexes (feature_count, feature_indexes);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "\tvoid stopPreloader() {\n\t\tTRACE_POINT();\n\t\tthis_thread::disable_interruption di;\n\t\tthis_thread::disable_syscall_interruption dsi;\n\t\t\n\t\tif (!preloaderStarted()) {\n\t\t\treturn;\n\t\t}\n\t\tadminSocket.close();\n\t\tif (timedWaitpid(pid, NULL, 5000) == 0) {\n\t\t\tP_TRACE(2, \"Spawn server did not exit in time, killing it...\");\n\t\t\tsyscalls::kill(pid, SIGKILL);\n\t\t\tsyscalls::waitpid(pid, NULL, 0);\n\t\t}\n\t\tlibev->stop(preloaderOutputWatcher);\n\t\t// Detach the error pipe; it will truly be closed after the error\n\t\t// pipe has reached EOF.\n\t\tpreloaderErrorWatcher.reset();\n\t\t// Delete socket after the process has exited so that it\n\t\t// doesn't crash upon deleting a nonexistant file.\n\t\t// TODO: in Passenger 4 we must check whether the file really was\n\t\t// owned by the preloader, otherwise this is a potential security flaw.\n\t\tif (getSocketAddressType(socketAddress) == SAT_UNIX) {\n\t\t\tstring filename = parseUnixSocketAddress(socketAddress);\n\t\t\tsyscalls::unlink(filename.c_str());\n\t\t}\n\t\t{\n\t\t\tlock_guard<boost::mutex> l(simpleFieldSyncher);\n\t\t\tpid = -1;\n\t\t}\n\t\tsocketAddress.clear();\n\t}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {\n   std::string func_name = GetFunctionNameRaw(pc, offset);\n  if (!func_name.empty()) {\n#if defined(__APPLE__)\n    if (func_name[0] != '_') {\n      return func_name;\n    }\n#endif\n    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);\n    if (name) {\n      func_name = name;\n      free(name);\n    }\n  }\n   return func_name;\n }",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int of_dpa_cmd_flow_add(OfDpa *of_dpa, uint64_t cookie,\n\n                               RockerTlv **flow_tlvs)\n\n{\n\n    OfDpaFlow *flow = of_dpa_flow_find(of_dpa, cookie);\n\n    int err = ROCKER_OK;\n\n\n\n    if (flow) {\n\n        return -ROCKER_EEXIST;\n\n    }\n\n\n\n    flow = of_dpa_flow_alloc(cookie);\n\n    if (!flow) {\n\n        return -ROCKER_ENOMEM;\n\n    }\n\n\n\n    err = of_dpa_cmd_flow_add_mod(of_dpa, flow, flow_tlvs);\n\n    if (err) {\n\n        g_free(flow);\n\n        return err;\n\n    }\n\n\n\n    return of_dpa_flow_add(of_dpa, flow);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "htmlParseSystemLiteral(htmlParserCtxtPtr ctxt) {\n    const xmlChar *q;\n    xmlChar *ret = NULL;\n\n    if (CUR == '\"') {\n        NEXT;\n\tq = CUR_PTR;\n\twhile ((IS_CHAR_CH(CUR)) && (CUR != '\"'))\n\t    NEXT;\n\tif (!IS_CHAR_CH(CUR)) {\n\t    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,\n\t\t\t \"Unfinished SystemLiteral\\n\", NULL, NULL);\n\t} else {\n\t    ret = xmlStrndup(q, CUR_PTR - q);\n\t    NEXT;\n        }\n    } else if (CUR == '\\'') {\n        NEXT;\n\tq = CUR_PTR;\n\twhile ((IS_CHAR_CH(CUR)) && (CUR != '\\''))\n\t    NEXT;\n\tif (!IS_CHAR_CH(CUR)) {\n\t    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,\n\t\t\t \"Unfinished SystemLiteral\\n\", NULL, NULL);\n\t} else {\n\t    ret = xmlStrndup(q, CUR_PTR - q);\n\t    NEXT;\n        }\n    } else {\n\thtmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,\n\t             \" or ' expected\\n\", NULL, NULL);\n    }\n\n    return(ret);\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "std::string Magick::Image::artifact(const std::string &name_) const\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(constImage(),name_.c_str());\n  if (value)\n    return(std::string(value));\n  return(std::string());\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static void test_tco_second_timeout_pause(void)\n\n{\n\n    TestData td;\n\n    const uint16_t ticks = TCO_SECS_TO_TICKS(32);\n\n    QDict *ad;\n\n\n\n    td.args = \"-watchdog-action pause\";\n\n    td.noreboot = false;\n\n    test_init(&td);\n\n\n\n    stop_tco(&td);\n\n    clear_tco_status(&td);\n\n    reset_on_second_timeout(true);\n\n    set_tco_timeout(&td, TCO_SECS_TO_TICKS(16));\n\n    load_tco(&td);\n\n    start_tco(&td);\n\n    clock_step(ticks * TCO_TICK_NSEC * 2);\n\n    ad = get_watchdog_action();\n\n    g_assert(!strcmp(qdict_get_str(ad, \"action\"), \"pause\"));\n\n    QDECREF(ad);\n\n\n\n    stop_tco(&td);\n\n    qtest_end();\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "mm_session_close(Session *s)\n{\n\tdebug3(\"%s: session %d pid %d\", __func__, s->self, s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3(\"%s: tty %s ptyfd %d\",  __func__, s->tty, s->ptyfd);\n\t\tfatal_remove_cleanup(session_pty_cleanup2, (void *)s);\n\t\tsession_pty_cleanup2(s);\n\t}\n\ts->used = 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "snmpDecodePacket(SnmpRequest * rq)\n{\n    struct snmp_pdu *PDU;\n    u_char *Community;\n    u_char *buf = rq->buf;\n    int len = rq->len;\n    allow_t allow = ACCESS_DENIED;\n\n    if (!Config.accessList.snmp) {\n        debugs(49, DBG_IMPORTANT, \"WARNING: snmp_access not configured. agent query DENIED from : \" << rq->from);\n        return;\n    }\n\n    debugs(49, 5, HERE << \"Called.\");\n    PDU = snmp_pdu_create(0);\n    /* Allways answer on SNMPv1 */\n    rq->session.Version = SNMP_VERSION_1;\n    Community = snmp_parse(&rq->session, PDU, buf, len);\n\n    /* Check if we have explicit permission to access SNMP data.\n     * default (set above) is to deny all */\n    if (Community) {\n        ACLFilledChecklist checklist(Config.accessList.snmp, NULL, NULL);\n        checklist.src_addr = rq->from;\n        checklist.snmp_community = (char *) Community;\n        allow = checklist.fastCheck();\n\n        if (allow == ACCESS_ALLOWED && (snmp_coexist_V2toV1(PDU))) {\n            rq->community = Community;\n            rq->PDU = PDU;\n            debugs(49, 5, \"snmpAgentParse: reqid=[\" << PDU->reqid << \"]\");\n            snmpConstructReponse(rq);\n        } else {\n            debugs(49, DBG_IMPORTANT, \"WARNING: SNMP agent query DENIED from : \" << rq->from);\n        }\n        xfree(Community);\n\n    } else {\n        debugs(49, DBG_IMPORTANT, \"WARNING: Failed SNMP agent query from : \" << rq->from);\n        snmp_free_pdu(PDU);\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "PHP_FUNCTION(mb_ereg_replace_callback)\n{\n\t_php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 1);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "ppp_register_compressor(struct compressor *cp)\n{\n\tstruct compressor_entry *ce;\n\tint ret;\n\tspin_lock(&compressor_list_lock);\n\tret = -EEXIST;\n\tif (find_comp_entry(cp->compress_proto))\n\t\tgoto out;\n\tret = -ENOMEM;\n\tce = kmalloc(sizeof(struct compressor_entry), GFP_ATOMIC);\n\tif (!ce)\n\t\tgoto out;\n\tret = 0;\n\tce->comp = cp;\n\tlist_add(&ce->list, &compressor_list);\n out:\n\tspin_unlock(&compressor_list_lock);\n\treturn ret;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "MONGO_EXPORT const char *bson_data( const bson *b ) {\n    return (const char *)b->data;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "R_API void r_egg_syscall(REgg *egg, const char *arg, ...) {\n\tRSyscallItem *item = r_syscall_get (egg->syscall,\n\t\tr_syscall_get_num (egg->syscall, arg), -1);\n\tif (!strcmp (arg, \"close\")) {\n\t\t//egg->remit->syscall_args ();\n\t}\n\tif (!item) {\n\t\treturn;\n\t}\n\tegg->remit->syscall (egg, item->num);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "V4L2JpegEncodeAccelerator::I420BufferRecord::~I420BufferRecord() {}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "StreamResource::~StreamResource() {\n  while (listener_ != nullptr) {\n    StreamListener* listener = listener_;\n    listener->OnStreamDestroy();\n    // Remove the listener if it didnt remove itself. This makes the logic\n    // in `OnStreamDestroy()` implementations easier, because they\n    // may call generic cleanup functions which can just remove the\n    // listener unconditionally.\n    if (listener == listener_)\n      RemoveStreamListener(listener_);\n  }\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int is_ntfs_dotgit(const char *name)\n{\n\tint len;\n\n\tfor (len = 0; ; len++)\n\t\tif (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len])) {\n\t\t\tif (only_spaces_and_periods(name, len, 4) &&\n\t\t\t\t\t!strncasecmp(name, \".git\", 4))\n\t\t\t\treturn 1;\n\t\t\tif (only_spaces_and_periods(name, len, 5) &&\n\t\t\t\t\t!strncasecmp(name, \"git~1\", 5))\n\t\t\t\treturn 1;\n\t\t\tif (name[len] != '\\\\')\n\t\t\t\treturn 0;\n\t\t\tname += len + 1;\n\t\t\tlen = -1;\n\t\t}\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "void hbitmap_set(HBitmap *hb, uint64_t start, uint64_t count)\n\n{\n\n    /* Compute range in the last layer.  */\n\n    uint64_t last = start + count - 1;\n\n\n\n    trace_hbitmap_set(hb, start, count,\n\n                      start >> hb->granularity, last >> hb->granularity);\n\n\n\n    start >>= hb->granularity;\n\n    last >>= hb->granularity;\n\n    count = last - start + 1;\n\n\n\n\n    hb->count += count - hb_count_between(hb, start, last);\n\n    hb_set_between(hb, HBITMAP_LEVELS - 1, start, last);\n\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n        ALOGE(\"memset buffer too small: got %lu, expected %zu\", (unsigned long)outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \"29422022\");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n return NULL;\n }\n return memset(outHeader->pBuffer, c, len);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "AP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "**/\n    CImg<T>& operator+=(const char *const expression) {\n      return *this+=(+*this)._fill(expression,true,true,0,0,\"operator+=\",this);",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "bool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "guessContentTypeFromTable(struct table2 *table, char *filename)\n{\n    struct table2 *t;\n    char *p;\n    if (table == NULL)\n\treturn NULL;\n    p = &filename[strlen(filename) - 1];\n    while (filename < p && *p != '.')\n\tp--;\n    if (p == filename)\n\treturn NULL;\n    p++;\n    for (t = table; t->item1; t++) {\n\tif (!strcmp(p, t->item1))\n\t    return t->item2;\n    }\n    for (t = table; t->item1; t++) {\n\tif (!strcasecmp(p, t->item1))\n\t    return t->item2;\n    }\n    return NULL;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void ElectronBrowserHandlerImpl::WebContentsDestroyed() {\n  delete this;\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void curl_close(BlockDriverState *bs)\n\n{\n\n    BDRVCURLState *s = bs->opaque;\n\n\n\n    DPRINTF(\"CURL: Close\\n\");\n\n    curl_detach_aio_context(bs);\n\n    qemu_mutex_destroy(&s->mutex);\n\n\n\n    g_free(s->cookie);\n\n    g_free(s->url);\n\n\n\n\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "v9fs_vfs_getattr(const struct path *path, struct kstat *stat,\n\t\t u32 request_mask, unsigned int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat *st;\n\n\tp9_debug(P9_DEBUG_VFS, \"dentry: %p\\n\", dentry);\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tgeneric_fillattr(d_inode(dentry), stat);\n\t\treturn 0;\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tv9fs_stat2inode(st, d_inode(dentry), dentry->d_sb);\n\tgeneric_fillattr(d_inode(dentry), stat);\n\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "Ins_GFV( INS_ARG )\n  {\n    DO_GFV\n  }",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int OGRExpatUnknownEncodingHandler(\n    void * /* unused_encodingHandlerData */,\n    const XML_Char *name,\n    XML_Encoding *info )\n{\n    if( EQUAL(name, \"WINDOWS-1252\") )\n        FillWINDOWS1252(info);\n    else if( EQUAL(name, \"ISO-8859-15\") )\n        FillISO885915(info);\n    else\n    {\n        CPLDebug(\"OGR\", \"Unhandled encoding %s\", name);\n        return XML_STATUS_ERROR;\n    }\n\n    info->data    = nullptr;\n    info->convert = nullptr;\n    info->release = nullptr;\n\n    return XML_STATUS_OK;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "static int usbhid_parse(struct hid_device *hid)\n{\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\tstruct hid_descriptor *hdesc;\n\tu32 quirks = 0;\n \tunsigned int rsize = 0;\n \tchar *rdesc;\n \tint ret, n;\n \n \tquirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),\n \t\t\tle16_to_cpu(dev->descriptor.idProduct));\n\n\tif (quirks & HID_QUIRK_IGNORE)\n\t\treturn -ENODEV;\n\n\t/* Many keyboards and mice don't like to be polled for reports,\n\t * so we will always set the HID_QUIRK_NOGET flag for them. */\n\tif (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {\n\t\tif (interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||\n\t\t\tinterface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)\n\t\t\t\tquirks |= HID_QUIRK_NOGET;\n\t}\n\n\tif (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&\n\t    (!interface->desc.bNumEndpoints ||\n\t     usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {\n\t\tdbg_hid(\"class descriptor not present\\n\");\n \t\treturn -ENODEV;\n \t}\n \n \thid->version = le16_to_cpu(hdesc->bcdHID);\n \thid->country = hdesc->bCountryCode;\n \n\tfor (n = 0; n < hdesc->bNumDescriptors; n++)\n \t\tif (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)\n \t\t\trsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);\n \n\tif (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {\n\t\tdbg_hid(\"weird size of report descriptor (%u)\\n\", rsize);\n\t\treturn -EINVAL;\n\t}\n\n\trdesc = kmalloc(rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\n\thid_set_idle(dev, interface->desc.bInterfaceNumber, 0, 0);\n\n\tret = hid_get_class_descriptor(dev, interface->desc.bInterfaceNumber,\n\t\t\tHID_DT_REPORT, rdesc, rsize);\n\tif (ret < 0) {\n\t\tdbg_hid(\"reading report descriptor failed\\n\");\n\t\tkfree(rdesc);\n\t\tgoto err;\n\t}\n\n\tret = hid_parse_report(hid, rdesc, rsize);\n\tkfree(rdesc);\n\tif (ret) {\n\t\tdbg_hid(\"parsing report descriptor failed\\n\");\n\t\tgoto err;\n\t}\n\n\thid->quirks |= quirks;\n\n\treturn 0;\nerr:\n\treturn ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void RenderWidgetHostImpl::StartHangMonitorTimeout(base::TimeDelta delay) {\n  if (!hang_monitor_timeout_)\n    return;\n  hang_monitor_timeout_->Start(delay);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "ssize_t qemu_deliver_packet_iov(NetClientState *sender,\n                                unsigned flags,\n                                const struct iovec *iov,\n                                int iovcnt,\n                                void *opaque)\n{\n    NetClientState *nc = opaque;\n    size_t size = iov_size(iov, iovcnt);\n    int ret;\n\n    if (size > INT_MAX) {\n        return size;\n    }\n\n    if (nc->link_down) {\n        return size;\n    }\n\n    if (nc->receive_disabled) {\n        return 0;\n    }\n\n    if (nc->info->receive_iov && !(flags & QEMU_NET_PACKET_FLAG_RAW)) {\n        ret = nc->info->receive_iov(nc, iov, iovcnt);\n    } else {\n        ret = nc_sendv_compat(nc, iov, iovcnt, flags);\n    }\n\n    if (ret == 0) {\n        nc->receive_disabled = 1;\n    }\n\n    return ret;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "xmlStopParser(xmlParserCtxtPtr ctxt) {\n    if (ctxt == NULL)\n        return;\n    ctxt->instate = XML_PARSER_EOF;\n    ctxt->disableSAX = 1;\n    if (ctxt->input != NULL) {\n\tctxt->input->cur = BAD_CAST\"\";\n\tctxt->input->base = ctxt->input->cur;\n    }\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void _af_setup_free_instruments (AFfilesetup setup)\n{\n\tint i;\n\n\tif (setup->instruments)\n\t{\n\t\tfor (i = 0; i < setup->instrumentCount; i++)\n\t\t\t_af_setup_free_loops(setup, i);\n\n\t\tfree(setup->instruments);\n\t}\n\n\tsetup->instruments = NULL;\n\tsetup->instrumentCount = 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static void host_callback(void *arg, int status, int timeouts,\n                          unsigned char *abuf, int alen)\n{\n  struct host_query *hquery = (struct host_query*)arg;\n  int addinfostatus = ARES_SUCCESS;\n  hquery->timeouts += timeouts;\n  hquery->remaining--;\n\n  if (status == ARES_SUCCESS)\n    {\n      addinfostatus = ares__parse_into_addrinfo(abuf, alen, hquery->ai);\n    }\n  else if (status == ARES_EDESTRUCTION)\n    {\n      end_hquery(hquery, status);\n    }\n\n  if (!hquery->remaining)\n    {\n      if (addinfostatus != ARES_SUCCESS)\n        {\n          /* error in parsing result e.g. no memory */\n          end_hquery(hquery, addinfostatus);\n        }\n      else if (hquery->ai->nodes)\n        {\n          /* at least one query ended with ARES_SUCCESS */\n          end_hquery(hquery, ARES_SUCCESS);\n        }\n      else if (status == ARES_ENOTFOUND)\n        {\n          next_lookup(hquery, status);\n        }\n      else\n        {\n          end_hquery(hquery, status);\n        }\n    }\n\n  /* at this point we keep on waiting for the next query to finish */\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void CSoundFile::Vibrato(ModChannel *p, uint32 param) const\n{\n\tif (param & 0x0F) p->nVibratoDepth = (param & 0x0F) * 4;\n\tif (param & 0xF0) p->nVibratoSpeed = (param >> 4) & 0x0F;\n\tp->dwFlags.set(CHN_VIBRATO);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "ssize_t enc_untrusted_read(int fd, void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_read, fd, buf, count));\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "gdm_session_open_session (GdmSession *self,\n                          const char *service_name)\n{\n        GdmSessionConversation *conversation;\n\n        g_return_if_fail (GDM_IS_SESSION (self));\n\n        conversation = find_conversation_by_name (self, service_name);\n\n        if (conversation != NULL) {\n                send_display_mode (self, conversation);\n                send_session_type (self, conversation);\n\n                gdm_dbus_worker_call_open (conversation->worker_proxy,\n                                           NULL,\n                                           (GAsyncReadyCallback) on_opened, conversation);\n        }\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n \t * bytes.\n \t */\n \thdr = (void*)p - head->iov_base;\n \tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n \n \t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n{\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n\t\tupdateToolCapabilities();\n\treturn result;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "g_file_real_create_readwrite_finish (GFile         *file,\n                                     GAsyncResult  *res,\n                                     GError       **error)\n{\n  g_return_val_if_fail (g_task_is_valid (res, file), NULL);\n\n  return g_task_propagate_pointer (G_TASK (res), error);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "uint32 float32_to_uint32_round_to_zero( float32 a STATUS_PARAM )\n\n{\n\n    int64_t v;\n\n    uint32 res;\n\n\n\n    v = float32_to_int64_round_to_zero(a STATUS_VAR);\n\n    if (v < 0) {\n\n        res = 0;\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n    } else if (v > 0xffffffff) {\n\n        res = 0xffffffff;\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n    } else {\n\n        res = v;\n\n    }\n\n    return res;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static int utab_lock(const char *filename)\n{\n\tchar *lfile;\n\tint fd;\n\n\tassert(filename);\n\n\tif (asprintf(&lfile, \"%s.lock\", filename) == -1)\n\t\treturn -1;\n\n\tDBG(UPDATE, mnt_debug(\"%s: locking\", lfile));\n\n\tfd = open(lfile, O_RDONLY|O_CREAT|O_CLOEXEC, S_IWUSR|\n\t\t\t                             S_IRUSR|S_IRGRP|S_IROTH);\n\tfree(lfile);\n\n\tif (fd < 0)\n\t\treturn -errno;\n\n\twhile (flock(fd, LOCK_EX) < 0) {\n\t\tint errsv;\n\t\tif (errno == EINTR)\n\t\t\tcontinue;\n\t\terrsv = errno;\n\t\tclose(fd);\n\t\treturn -errsv;\n\t}\n\treturn fd;\n}",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "MagickExport ImageInfo *AcquireImageInfo(void)\n{\n  ImageInfo\n    *image_info;\n\n  image_info=(ImageInfo *) AcquireCriticalMemory(sizeof(*image_info));\n  GetImageInfo(image_info);\n  return(image_info);\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "CharDriverState *uart_hci_init(qemu_irq wakeup)\n\n{\n\n    struct csrhci_s *s = (struct csrhci_s *)\n\n            g_malloc0(sizeof(struct csrhci_s));\n\n\n\n    s->chr.opaque = s;\n\n    s->chr.chr_write = csrhci_write;\n\n    s->chr.chr_ioctl = csrhci_ioctl;\n\n\n\n\n    s->hci = qemu_next_hci();\n\n    s->hci->opaque = s;\n\n    s->hci->evt_recv = csrhci_out_hci_packet_event;\n\n    s->hci->acl_recv = csrhci_out_hci_packet_acl;\n\n\n\n    s->out_tm = qemu_new_timer_ns(vm_clock, csrhci_out_tick, s);\n\n    s->pins = qemu_allocate_irqs(csrhci_pins, s, __csrhci_pins);\n\n    csrhci_reset(s);\n\n\n\n    return &s->chr;\n\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "TPMT_TK_AUTH_Unmarshal(TPMT_TK_AUTH *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_ST_Unmarshal(&target->tag, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif ((target->tag != TPM_ST_AUTH_SIGNED) &&\n\t    (target->tag != TPM_ST_AUTH_SECRET)) {\n\t    rc = TPM_RC_TAG;\n\t}\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPMI_RH_HIERARCHY_Unmarshal(&target->hierarchy, buffer, size, YES);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM2B_DIGEST_Unmarshal(&target->digest, buffer, size);\n    }\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "vips_foreign_save_init( VipsForeignSave *save )\n{\n\tsave->background = vips_array_double_newv( 1, 0.0 );\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void Document::executeScriptsWaitingForResources()\n{\n    if (!isRenderingReady())\n        return;\n    if (ScriptableDocumentParser* parser = scriptableDocumentParser())\n        parser->executeScriptsWaitingForResources();\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void qemu_file_skip(QEMUFile *f, int size)\n\n{\n\n    if (f->buf_index + size <= f->buf_size) {\n\n        f->buf_index += size;\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "void kvm_setup_guest_memory(void *start, size_t size)\n\n{\n\n    if (!kvm_has_sync_mmu()) {\n\n#ifdef MADV_DONTFORK\n\n        int ret = madvise(start, size, MADV_DONTFORK);\n\n\n\n        if (ret) {\n\n            perror(\"madvice\");\n\n            exit(1);\n\n        }\n\n#else\n\n        fprintf(stderr,\n\n                \"Need MADV_DONTFORK in absence of synchronous KVM MMU\\n\");\n\n        exit(1);\n\n#endif\n\n    }\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "int rtp_packetize_xiph_config( sout_stream_id_sys_t *id, const char *fmtp,\n                               int64_t i_pts )\n{\n    if (fmtp == NULL)\n        return VLC_EGENERIC;\n\n    /* extract base64 configuration from fmtp */\n    char *start = strstr(fmtp, \"configuration=\");\n    assert(start != NULL);\n    start += sizeof(\"configuration=\") - 1;\n    char *end = strchr(start, ';');\n    assert(end != NULL);\n    size_t len = end - start;\n    char b64[len + 1];\n    memcpy(b64, start, len);\n    b64[len] = '\\0';\n\n    int     i_max   = rtp_mtu (id) - 6; /* payload max in one packet */\n\n    uint8_t *p_orig, *p_data;\n    int i_data;\n\n    i_data = vlc_b64_decode_binary(&p_orig, b64);\n    if (i_data <= 9)\n    {\n        free(p_orig);\n        return VLC_EGENERIC;\n    }\n    p_data = p_orig + 9;\n    i_data -= 9;\n\n    int i_count = ( i_data + i_max - 1 ) / i_max;\n\n    for( int i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 18 + i_payload );\n\n        unsigned fragtype, numpkts;\n        if (i_count == 1)\n        {\n            fragtype = 0;\n            numpkts = 1;\n        }\n        else\n        {\n            numpkts = 0;\n            if (i == 0)\n                fragtype = 1;\n            else if (i == i_count - 1)\n                fragtype = 3;\n            else\n                fragtype = 2;\n        }\n        /* Ident:24, Fragment type:2, Vorbis/Theora Data Type:2, # of pkts:4 */\n        uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |\n                          (fragtype << 6) | (1 << 4) | numpkts;\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, 0, i_pts );\n\n        SetDWBE( out->p_buffer + 12, header);\n        SetWBE( out->p_buffer + 16, i_payload);\n        memcpy( &out->p_buffer[18], p_data, i_payload );\n\n        out->i_dts    = i_pts;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    free(p_orig);\n\n    return VLC_SUCCESS;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "free_Header(struct _7z_header_info *h)\n{\n\tfree(h->emptyStreamBools);\n\tfree(h->emptyFileBools);\n\tfree(h->antiBools);\n\tfree(h->attrBools);\n}",
    "output": "0"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "TPML_DIGEST_VALUES_Unmarshal(TPML_DIGEST_VALUES *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n    \n    UINT32 i;\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT32_Unmarshal(&target->count, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->count > HASH_COUNT) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {\n\trc = TPMT_HA_Unmarshal(&target->digests[i], buffer, size, NO);\n    }\n    return rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "gss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n\n    /* now free up the space for the union context structure */\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n}",
    "output": "1"
  },
  {
    "instruction": "Evaluate the following code for vulnerabilities.",
    "input": "my_ulonglong STDCALL mysql_stmt_insert_id(MYSQL_STMT *stmt)\n{\n  return stmt->insert_id;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)\n{\n\tint rc = 0;\n\tu8 *gb;\n\tsize_t gb_len;\n\tstruct nfc_target *target;\n\n\tpr_debug(\"dev_name=%s comm %d\\n\", dev_name(&dev->dev), comm_mode);\n\n\tif (!dev->ops->dep_link_up)\n\t\treturn -EOPNOTSUPP;\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->dep_link_up == true) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\tgb = nfc_llcp_general_bytes(dev, &gb_len);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttarget = nfc_find_target(dev, target_index);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->dep_link_up(dev, target, comm_mode, gb, gb_len);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t}\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "Formattable::Formattable(const Formattable* arrayToCopy, int32_t count)\n    :   UObject(), fType(kArray)\n{\n    init();\n    fType = kArray;\n    fValue.fArrayAndCount.fArray = createArrayCopy(arrayToCopy, count);\n    fValue.fArrayAndCount.fCount = count;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    qemu_vfree(r->iov.iov_base);\n}",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "status_t Camera2Client::removeFrameListener(int32_t minId, int32_t maxId,\n        wp<camera2::FrameProcessor::FilteredListener> listener) {\n return mFrameProcessor->removeListener(minId, maxId, listener);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static const char *print_uni_str(const Unicode *u, const unsigned uLen) {\n  GooString *gstr_buff1 = nullptr;\n\n  delete gstr_buff0;\n\n  if (!uLen) return \"\";\n  gstr_buff0 = GooString::format(\"{0:c}\", (*u < 0x7F ? *u & 0xFF : '?'));\n  for (unsigned i = 1; i < uLen; i++) {\n    if (u[i] < 0x7F) {\n      gstr_buff1 = gstr_buff0->append(u[i] < 0x7F ? static_cast<char>(u[i]) & 0xFF : '?');\n      delete gstr_buff0;\n      gstr_buff0 = gstr_buff1;\n    }\n  }\n\n  return gstr_buff0->c_str();\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static ssize_t store_user_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_STORE_USER));\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static gboolean qio_channel_yield_enter(QIOChannel *ioc,\n\n                                        GIOCondition condition,\n\n                                        gpointer opaque)\n\n{\n\n    QIOChannelYieldData *data = opaque;\n\n    qemu_coroutine_enter(data->co, NULL);\n\n    return FALSE;\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "qtdemux_generic_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,\n    guint32 fourcc, const guint8 * stsd_data, gchar ** codec_name)\n{\n  GstCaps *caps;\n\n  switch (fourcc) {\n    case FOURCC_m1v:\n      _codec (\"MPEG 1 video\");\n      caps = gst_caps_new_simple (\"video/mpeg\", \"mpegversion\", G_TYPE_INT, 1,\n          \"systemstream\", G_TYPE_BOOLEAN, FALSE, NULL);\n      break;\n    default:\n      caps = NULL;\n      break;\n  }\n  return caps;\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "GF_Box *rtpo_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPOBox, GF_ISOM_BOX_TYPE_RTPO);\n\treturn (GF_Box *)tmp;\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "//! Compute the exponential of each pixel value \\newinstance.\n    CImg<Tfloat> get_exp() const {\n      return CImg<Tfloat>(*this,false).exp();",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "static inline unsigned dx_root_limit(struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(1) -\n\t\tEXT4_DIR_REC_LEN(2) - infosize;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(dir->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "ecryptfs_write_metadata_to_contents(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct dentry *ecryptfs_dentry,\n\t\t\t\t    char *virt)\n{\n\tint rc;\n\n\trc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt,\n\t\t\t\t  0, crypt_stat->num_header_bytes_at_front);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\", __func__,\n\t\t       rc);\n\treturn rc;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static int bpf_tracing_link_fill_link_info(const struct bpf_link *link,\n\t\t\t\t\t   struct bpf_link_info *info)\n{\n\tstruct bpf_tracing_link *tr_link =\n\t\tcontainer_of(link, struct bpf_tracing_link, link);\n\n\tinfo->tracing.attach_type = tr_link->attach_type;\n\n\treturn 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "char *Jsi_FileRealpath(Jsi_Interp *interp, Jsi_Value *spath, char *newname)\n{\n    char *path = Jsi_ValueString(interp, spath, 0);\n    if (!path) return NULL;\n    return Jsi_FileRealpathStr(interp, path, newname);\n}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "do_query_info_on_write (GVfsBackend *backend,\n                        GVfsJobQueryInfoWrite *query_info_job,\n                        GVfsBackendHandle handle,\n                        GFileInfo *info,\n                        GFileAttributeMatcher *matcher)\n{\n  GVfsJob *job = G_VFS_JOB (query_info_job);\n  GFileOutputStream *stream = handle;\n  GError *error = NULL;\n  GFileInfo *real_info;\n\n  real_info = g_file_output_stream_query_info (stream, query_info_job->attributes,\n                                               job->cancellable, &error);\n  if (error != NULL)\n    goto out;\n\n  fix_file_info (real_info);\n  g_file_info_copy_into (real_info, info);\n  g_object_unref (real_info);\n\n out:\n  complete_job (job, error);\n}",
    "output": "1"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "unsigned char *base64decode(const char *buf, size_t *size)\n {\n \tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n \tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n \tconst char *ptr = buf;\n \tint p = 0;\n\tsize_t l = 0;\n \n \tdo {\n\t\tptr += strspn(ptr, \"\\r\\n\\t \");\n \t\tif (*ptr == '\\0' || ptr >= buf+len) {\n \t\t\tbreak;\n \t\t}\n\t\tl = strcspn(ptr, \"\\r\\n\\t \");\n\t\tif (l > 3 && ptr+l <= buf+len) {\n\t\t\tp+=base64decode_block(outbuf+p, ptr, l);\n\t\t\tptr += l;\n\t\t} else {\n\t\t\tbreak;\n \t\t}\n \t} while (1);\n \n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}",
    "output": "1"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "void vrend_set_blend_color(struct vrend_context *ctx,\n                           struct pipe_blend_color *color)\n{\n   ctx->sub->blend_color = *color;\n   glBlendColor(color->color[0], color->color[1], color->color[2],\n                color->color[3]);\n}",
    "output": "0"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,\n\t\tint status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t\t\t&req->request, req->direction);\n\n\treq->trb = NULL;\n\n\ttrace_dwc3_gadget_giveback(req);\n\n\tspin_unlock(&dwc->lock);\n\tusb_gadget_giveback_request(&dep->endpoint, &req->request);\n\tspin_lock(&dwc->lock);\n\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "bool HTMLMediaElement::WasAutoplayInitiated() {\n  return autoplay_policy_->WasAutoplayInitiated();\n}",
    "output": "0"
  },
  {
    "instruction": "Review this code for any security problems.",
    "input": "ProcessTCPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USHORT ipHeaderSize)\n{\n    ULONG tcpipDataAt;\n    tTcpIpPacketParsingResult res = _res;\n    tcpipDataAt = ipHeaderSize + sizeof(TCPHeader);\n    res.xxpStatus = ppresXxpIncomplete;\n    res.TcpUdp = ppresIsTCP;\n\n    if (len >= tcpipDataAt)\n    {\n        TCPHeader *pTcpHeader = (TCPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize);\n        res.xxpStatus = ppresXxpKnown;\n        tcpipDataAt = ipHeaderSize + TCP_HEADER_LENGTH(pTcpHeader);\n        res.XxpIpHeaderSize = tcpipDataAt;\n    }\n    else\n    {\n        DPrintf(2, (\"tcp: %d < min headers %d\\n\", len, tcpipDataAt));\n    }\n    return res;\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "bool ThreadWatcher::IsVeryUnresponsive() {\n  DCHECK(WatchDogThread::CurrentlyOnWatchDogThread());\n  return unresponsive_count_ >= unresponsive_threshold_;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "loff_t fixed_size_llseek(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR: case SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, size);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "static inline int compare_masked(uint64_t x, uint64_t y, uint64_t mask)\n\n{\n\n    return (x & mask) == (y & mask);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static inline void ModulateLCHab(const double percent_luma,\n  const double percent_chroma,const double percent_hue,double *red,\n  double *green,double *blue)\n{\n  double\n    hue,\n    luma,\n    chroma;\n\n  /*\n    Increase or decrease color luma, chroma, or hue.\n  */\n  ConvertRGBToLCHab(*red,*green,*blue,&luma,&chroma,&hue);\n  luma*=0.01*percent_luma;\n  chroma*=0.01*percent_chroma;\n  hue+=0.5*(0.01*percent_hue-1.0);\n  ConvertLCHabToRGB(luma,chroma,hue,red,green,blue);\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static __poll_t hid_debug_events_poll(struct file *file, poll_table *wait)\n{\n\tstruct hid_debug_list *list = file->private_data;\n\n\tpoll_wait(file, &list->hdev->debug_wait, wait);\n\tif (list->head != list->tail)\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\tif (!list->hdev->debug)\n\t\treturn EPOLLERR | EPOLLHUP;\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Image::UniquePtr newTiffInstance(BasicIo::UniquePtr io, bool create)\n    {\n        Image::UniquePtr image(new TiffImage(std::move(io), create));\n        if (!image->good()) {\n            image.reset();\n        }\n        return image;\n    }",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "int dns_packet_append_raw_string(DnsPacket *p, const void *s, size_t size, size_t *start) {\n        void *d;\n        int r;\n\n        assert(p);\n        assert(s || size == 0);\n\n        if (size > 255)\n                return -E2BIG;\n\n        r = dns_packet_extend(p, 1 + size, &d, start);\n        if (r < 0)\n                return r;\n\n        ((uint8_t*) d)[0] = (uint8_t) size;\n\n        memcpy_safe(((uint8_t*) d) + 1, s, size);\n\n        return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static int diskstats_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &diskstats_op);\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "qemuDomainHasHotpluggableStartupVcpus(virDomainDefPtr def)\n{\n    size_t maxvcpus = virDomainDefGetVcpusMax(def);\n    virDomainVcpuDefPtr vcpu;\n    size_t i;\n\n    for (i = 0; i < maxvcpus; i++) {\n        vcpu = virDomainDefGetVcpu(def, i);\n\n        if (vcpu->online && vcpu->hotpluggable == VIR_TRISTATE_BOOL_YES)\n            return true;\n    }\n\n    return false;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "int X509_CRL_check_suiteb(X509_CRL *crl, EVP_PKEY *pk, unsigned long flags)\n{\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "Eina_Bool ewk_frame_uri_set(Evas_Object* ewkFrame, const char* uri)\n{\n    EWK_FRAME_SD_GET_OR_RETURN(ewkFrame, smartData, false);\n    WebCore::KURL kurl(WebCore::KURL(), WTF::String::fromUTF8(uri));\n    WebCore::ResourceRequest req(kurl);\n    WebCore::FrameLoader* loader = smartData->frame->loader();\n    loader->load(req, false);\n    return true;\n}",
    "output": "0"
  },
  {
    "instruction": "Please analyze the following code for security issues.",
    "input": "static void __net_exit ip6_route_net_exit_late(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"ipv6_route\", net->proc_net);\n\tremove_proc_entry(\"rt6_stats\", net->proc_net);\n#endif\n}",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "static void __exit bnep_exit(void)\n{\n\tbnep_sock_cleanup();\n}",
    "output": "0"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "static void fd_htab_map_free(struct bpf_map *map)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_node *n;\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tint i;\n\n\tfor (i = 0; i < htab->n_buckets; i++) {\n\t\thead = select_bucket(htab, i);\n\n\t\thlist_nulls_for_each_entry_safe(l, n, head, hash_node) {\n\t\t\tvoid *ptr = fd_htab_map_get_ptr(map, l);\n\n\t\t\tmap->ops->map_fd_put_ptr(ptr);\n\t\t}\n\t}\n\n\thtab_map_free(map);\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "bool IsSupported(const NodeDef* node) const override {\n    return IsAnySparseSegmentReduction(*node);\n  }",
    "output": "0"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "lazy_entry const* lazy_entry::dict_find_dict(std::string const& name) const\n\t{\n\t\tlazy_entry const* e = dict_find(name);\n\t\tif (e == 0 || e->type() != lazy_entry::dict_t) return 0;\n\t\treturn e;\n\t}",
    "output": "0"
  },
  {
    "instruction": "Examine the following code for potential vulnerabilities.",
    "input": "void BookmarksCreateFunction::GetQuotaLimitHeuristics(\n    QuotaLimitHeuristics* heuristics) const {\n  BookmarksQuotaLimitFactory::BuildForCreate(heuristics, profile());\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "static inline int read_line(AVFormatContext *s, char *rbuf, const int rbufsize,\n\n                            int *rbuflen)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int idx       = 0;\n\n    int ret       = 0;\n\n    *rbuflen      = 0;\n\n\n\n    do {\n\n        ret = ffurl_read_complete(rt->rtsp_hd, rbuf + idx, 1);\n\n        if (ret < 0)\n\n            return ret;\n\n        if (rbuf[idx] == '\\r') {\n\n            /* Ignore */\n\n        } else if (rbuf[idx] == '\\n') {\n\n            rbuf[idx] = '\\0';\n\n            *rbuflen  = idx;\n\n            return 0;\n\n        } else\n\n            idx++;\n\n    } while (idx < rbufsize);\n\n    av_log(s, AV_LOG_ERROR, \"Message too long\\n\");\n\n    return AVERROR(EIO);\n\n}\n",
    "output": "1"
  },
  {
    "instruction": "Detect vulnerabilities in the following code.",
    "input": "load_vector_vector(BitStream& bit_stream,\n\t\t   int nitems1, std::vector<T>& vec1, int T::*nitems2,\n\t\t   int bits_wanted, std::vector<int> T::*vec2)\n{\n    // nitems1 times, read nitems2 (from the ith element of vec1) items\n    // into the vec2 vector field of the ith item of vec1.\n    for (int i1 = 0; i1 < nitems1; ++i1)\n    {\n\tfor (int i2 = 0; i2 < vec1.at(i1).*nitems2; ++i2)\n\t{\n\t    (vec1.at(i1).*vec2).push_back(bit_stream.getBits(bits_wanted));\n\t}\n    }\n    bit_stream.skipToNextByte();\n}",
    "output": "1"
  },
  {
    "instruction": "Is there any exploitable vulnerability in this code?",
    "input": "wl_map_insert_at(struct wl_map *map, uint32_t flags, uint32_t i, void *data)\n{\n\tunion map_entry *start;\n\tuint32_t count;\n\tstruct wl_array *entries;\n\n\tif (i < WL_SERVER_ID_START) {\n\t\tentries = &map->client_entries;\n\t} else {\n\t\tentries = &map->server_entries;\n\t\ti -= WL_SERVER_ID_START;\n\t}\n\n\tcount = entries->size / sizeof *start;\n\tif (count < i) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (count == i) {\n\t\tif (!wl_array_add(entries, sizeof *start))\n\t\t\treturn -1;\n\t}\n\n\tstart = entries->data;\n\tstart[i].data = data;\n\tstart[i].next |= (flags & 0x1) << 1;\n\n\treturn 0;\n}",
    "output": "1"
  },
  {
    "instruction": "Check the following code for security issues.",
    "input": "void RenderView::DidStartLoadingForPlugin() {\n  didStartLoading();\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "qemuProcessVerifyKVMFeatures(virDomainDefPtr def,\n                             virCPUDataPtr cpu)\n{\n    int rc = 0;\n\n    if (def->features[VIR_DOMAIN_FEATURE_PVSPINLOCK] != VIR_TRISTATE_SWITCH_ON)\n        return 0;\n\n    rc = virCPUDataCheckFeature(cpu, VIR_CPU_x86_KVM_PV_UNHALT);\n\n    if (rc <= 0) {\n        if (rc == 0)\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"host doesn't support paravirtual spinlocks\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "output": "0"
  },
  {
    "instruction": "Identify any security issues in the following code.",
    "input": "evbuffer_free(struct evbuffer *buffer)\n{\n\tEVBUFFER_LOCK(buffer);\n\tevbuffer_decref_and_unlock_(buffer);\n}",
    "output": "0"
  },
  {
    "instruction": "Does the following code contain any security risks?",
    "input": "void jsvClearEmptyVarList() {\n  assert(!isMemoryBusy);\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  jsVarFirstEmpty = 0;\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) == JSV_UNUSED) {\n      memset((void*)var,0,sizeof(JsVar));\n    } else if (jsvIsFlatString(var)) {\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  isMemoryBusy = MEM_NOT_BUSY;\n}",
    "output": "0"
  },
  {
    "instruction": "Determine if this code poses any security risks.",
    "input": "userauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n \tsize_t len;\n \tu_char *doid = NULL;\n \n\tif (!authctxt->valid || authctxt->user == NULL)\n\t\treturn (0);\n \tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n \t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n \n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\n\tdo {\n\t\tmechs--;\n\n\t\tfree(doid);\n\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n \t\treturn (0);\n \t}\n \n \tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n \t\tif (ctxt != NULL)\n \t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\n\tauthctxt->methoddata = (void *)ctxt;\n\n\t/* Return the OID that we received */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfree(doid);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\n\treturn (0);\n}",
    "output": "1"
  }
]